! function() {
    "use strict";

    function e() {}

    function t(e) {
        return e()
    }

    function n() {
        return Object.create(null)
    }

    function i(e) {
        e.forEach(t)
    }

    function r(e) {
        return "function" == typeof e
    }

    function s(e, t) {
        return e != e ? t == t : e !== t || e && "object" == typeof e || "function" == typeof e
    }

    function o(t, n, i) {
        t.$$.on_destroy.push(function(t, ...n) {
            if (null == t) {
                for (const e of n) e(void 0);
                return e
            }
            const i = t.subscribe(...n);
            return i.unsubscribe ? () => i.unsubscribe() : i
        }(n, i))
    }

    function a(e, t, n, i) {
        if (e) {
            const r = l(e, t, n, i);
            return e[0](r)
        }
    }

    function l(e, t, n, i) {
        return e[1] && i ? function(e, t) {
            for (const n in t) e[n] = t[n];
            return e
        }(n.ctx.slice(), e[1](i(t))) : n.ctx
    }

    function c(e, t, n, i) {
        if (e[2] && i) {
            const r = e[2](i(n));
            if (void 0 === t.dirty) return r;
            if ("object" == typeof r) {
                const e = [],
                    n = Math.max(t.dirty.length, r.length);
                for (let i = 0; i < n; i += 1) e[i] = t.dirty[i] | r[i];
                return e
            }
            return t.dirty | r
        }
        return t.dirty
    }

    function u(e, t, n, i, r, s) {
        if (r) {
            const o = l(t, n, i, s);
            e.p(o, r)
        }
    }

    function h(e) {
        if (e.ctx.length > 32) {
            const t = [],
                n = e.ctx.length / 32;
            for (let e = 0; e < n; e++) t[e] = -1;
            return t
        }
        return -1
    }

    function d(e) {
        return null == e ? "" : e
    }

    function f(e, t, n) {
        return e.set(n), t
    }! function() {
        const e = {
            NODE_ENV: "production",
            MAPBOX_ACCESS_TOKEN: "pk.eyJ1Ijoic2FtYXJhLXdlYm1hc3RlciIsImEiOiJjbDc0bTY3NjMwNmh2M3VudG5sc2hxOGp2In0.DHQc2ZACY-ksnoPFXEP9qg"
        };
        try {
            if (process) return process.env = Object.assign({}, process.env), void Object.assign(process.env, e)
        } catch (e) {}
        globalThis.process = {
            env: e
        }
    }();
    const p = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;

    function m(e, t) {
        e.appendChild(t)
    }

    function g(e, t, n) {
        e.insertBefore(t, n || null)
    }

    function A(e) {
        e.parentNode && e.parentNode.removeChild(e)
    }

    function v(e) {
        return document.createElement(e)
    }

    function y(e) {
        return document.createElementNS("http://www.w3.org/2000/svg", e)
    }

    function _(e) {
        return document.createTextNode(e)
    }

    function x() {
        return _(" ")
    }

    function E(e, t, n, i) {
        return e.addEventListener(t, n, i), () => e.removeEventListener(t, n, i)
    }

    function b(e, t, n) {
        null == n ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n)
    }

    function w(e, t, n) {
        const i = t.toLowerCase();
        i in e ? e[i] = "boolean" == typeof e[i] && "" === n || n : t in e ? e[t] = "boolean" == typeof e[t] && "" === n || n : b(e, t, n)
    }

    function C(e, t, n, i) {
        null == n ? e.style.removeProperty(t) : e.style.setProperty(t, n, "")
    }

    function S(e, t, n) {
        e.classList.toggle(t, !!n)
    }
    let T;

    function M(e) {
        T = e
    }

    function I() {
        if (!T) throw new Error("Function called outside component initialization");
        return T
    }

    function B(e) {
        I().$$.on_mount.push(e)
    }

    function R(e) {
        I().$$.on_destroy.push(e)
    }

    function D() {
        const e = I();
        return (t, n, {
            cancelable: i = !1
        } = {}) => {
            const r = e.$$.callbacks[t];
            if (r) {
                const s = function(e, t, {
                    bubbles: n = !1,
                    cancelable: i = !1
                } = {}) {
                    return new CustomEvent(e, {
                        detail: t,
                        bubbles: n,
                        cancelable: i
                    })
                }(t, n, {
                    cancelable: i
                });
                return r.slice().forEach((t => {
                    t.call(e, s)
                })), !s.defaultPrevented
            }
            return !0
        }
    }
    const P = [],
        L = [];
    let U = [];
    const N = [],
        O = Promise.resolve();
    let F = !1;

    function k(e) {
        U.push(e)
    }
    const Q = new Set;
    let z = 0;

    function H() {
        if (0 !== z) return;
        const e = T;
        do {
            try {
                for (; z < P.length;) {
                    const e = P[z];
                    z++, M(e), G(e.$$)
                }
            } catch (e) {
                throw P.length = 0, z = 0, e
            }
            for (M(null), P.length = 0, z = 0; L.length;) L.pop()();
            for (let e = 0; e < U.length; e += 1) {
                const t = U[e];
                Q.has(t) || (Q.add(t), t())
            }
            U.length = 0
        } while (P.length);
        for (; N.length;) N.pop()();
        F = !1, Q.clear(), M(e)
    }

    function G(e) {
        if (null !== e.fragment) {
            e.update(), i(e.before_update);
            const t = e.dirty;
            e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(k)
        }
    }
    const V = new Set;
    let j;

    function W(e, t) {
        e && e.i && (V.delete(e), e.i(t))
    }

    function X(e, t, n, i) {
        if (e && e.o) {
            if (V.has(e)) return;
            V.add(e), j.c.push((() => {
                V.delete(e), i && (n && e.d(1), i())
            })), e.o(t)
        } else i && i()
    }

    function Y(e) {
        e && e.c()
    }

    function q(e, n, s) {
        const {
            fragment: o,
            after_update: a
        } = e.$$;
        o && o.m(n, s), k((() => {
            const n = e.$$.on_mount.map(t).filter(r);
            e.$$.on_destroy ? e.$$.on_destroy.push(...n) : i(n), e.$$.on_mount = []
        })), a.forEach(k)
    }

    function K(e, t) {
        const n = e.$$;
        null !== n.fragment && (! function(e) {
            const t = [],
                n = [];
            U.forEach((i => -1 === e.indexOf(i) ? t.push(i) : n.push(i))), n.forEach((e => e())), U = t
        }(n.after_update), i(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = [])
    }

    function J(e, t) {
        -1 === e.$$.dirty[0] && (P.push(e), F || (F = !0, O.then(H)), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31
    }

    function Z(t, r, s, o, a, l, c = null, u = [-1]) {
        const h = T;
        M(t);
        const d = t.$$ = {
            fragment: null,
            ctx: [],
            props: l,
            update: e,
            not_equal: a,
            bound: n(),
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(r.context || (h ? h.$$.context : [])),
            callbacks: n(),
            dirty: u,
            skip_bound: !1,
            root: r.target || h.$$.root
        };
        c && c(d.root);
        let f = !1;
        if (d.ctx = s ? s(t, r.props || {}, ((e, n, ...i) => {
                const r = i.length ? i[0] : n;
                return d.ctx && a(d.ctx[e], d.ctx[e] = r) && (!d.skip_bound && d.bound[e] && d.bound[e](r), f && J(t, e)), n
            })) : [], d.update(), f = !0, i(d.before_update), d.fragment = !!o && o(d.ctx), r.target) {
            if (r.hydrate) {
                const e = function(e) {
                    return Array.from(e.childNodes)
                }(r.target);
                d.fragment && d.fragment.l(e), e.forEach(A)
            } else d.fragment && d.fragment.c();
            r.intro && W(t.$$.fragment), q(t, r.target, r.anchor), H()
        }
        M(h)
    }
    class $ {
        $$ = void 0;
        $$set = void 0;
        $destroy() {
            K(this, 1), this.$destroy = e
        }
        $on(t, n) {
            if (!r(n)) return e;
            const i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
            return i.push(n), () => {
                const e = i.indexOf(n); - 1 !== e && i.splice(e, 1)
            }
        }
        $set(e) {
            var t;
            this.$$set && (t = e, 0 !== Object.keys(t).length) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1)
        }
    }
    "undefined" != typeof window && (window.__svelte || (window.__svelte = {
        v: new Set
    })).v.add("4");
    const ee = Symbol("modal");

    function te(e) {
        let t, n, i, r;
        const s = e[2].default,
            o = a(s, e, e[1], null);
        return {
            c() {
                t = v("button"), o && o.c(), b(t, "class", "modal-control type-18 m-type-15 color-text-40 svelte-r0nedy")
            },
            m(s, a) {
                g(s, t, a), o && o.m(t, null), n = !0, i || (r = E(t, "click", e[0]), i = !0)
            },
            p(e, [t]) {
                o && o.p && (!n || 2 & t) && u(o, s, e, e[1], n ? c(s, e[1], t, null) : h(e[1]), null)
            },
            i(e) {
                n || (W(o, e), n = !0)
            },
            o(e) {
                X(o, e), n = !1
            },
            d(e) {
                e && A(t), o && o.d(e), i = !1, r()
            }
        }
    }

    function ne(e, t, n) {
        let {
            $$slots: i = {},
            $$scope: r
        } = t;
        const s = D();
        return e.$$set = e => {
            "$$scope" in e && n(1, r = e.$$scope)
        }, [function() {
            s("click")
        }, r, i]
    }
    class ie extends $ {
        constructor(e) {
            super(), Z(this, e, ne, te, s, {})
        }
    }
    const {
        window: re
    } = p;

    function se(e) {
        let t, n;
        return t = new ie({
            props: {
                $$slots: {
                    default: [oe]
                },
                $$scope: {
                    ctx: e
                }
            }
        }), t.$on("click", e[8]), {
            c() {
                Y(t.$$.fragment)
            },
            m(e, i) {
                q(t, e, i), n = !0
            },
            p(e, n) {
                const i = {};
                4096 & n && (i.$$scope = {
                    dirty: n,
                    ctx: e
                }), t.$set(i)
            },
            i(e) {
                n || (W(t.$$.fragment, e), n = !0)
            },
            o(e) {
                X(t.$$.fragment, e), n = !1
            },
            d(e) {
                K(t, e)
            }
        }
    }

    function oe(t) {
        let n, i, r;
        return {
            c() {
                n = y("svg"), i = y("path"), r = _("\n\t\t\t\t\t\t\tBack"), b(i, "d", "m7.26894 16.6823c.37684.4038 1.00963.4256 1.41338.0488.40375-.3769.42557-1.0097.04874-1.4134zm-6.268941-8.1823-.731055-.68232c-.3585929.38421-.3585929.98043 0 1.36464zm7.731051-6.81768c.37684-.40375.35502-1.03654-.04873-1.413374-.40375-.376835-1.03654-.3550151-1.41338.048736zm.00001 13.63538-7.00001-7.50002-1.462106 1.36464 6.999996 7.49998zm-7.00001-6.13538 7-7.5-1.46211-1.364638-6.999996 7.499998z"), b(i, "fill", "#000"), b(i, "fill-opacity", ".4"), b(n, "fill", "none"), b(n, "height", "17"), b(n, "viewBox", "0 0 9 17"), b(n, "width", "9"), b(n, "xmlns", "http://www.w3.org/2000/svg"), b(n, "class", "svelte-gu11dh")
            },
            m(e, t) {
                g(e, n, t), m(n, i), g(e, r, t)
            },
            p: e,
            d(e) {
                e && (A(n), A(r))
            }
        }
    }

    function ae(t) {
        let n, i;
        return {
            c() {
                n = y("svg"), i = y("path"), b(i, "d", "m13.3007.709971c-.39-.39-1.02-.39-1.41 0l-4.89 4.879999-4.89-4.889999c-.39-.39-1.02-.39-1.409997 0-.39.389999-.39 1.019999 0 1.409999l4.889997 4.89-4.889997 4.89003c-.39.39-.39 1.02 0 1.41.389997.39 1.019997.39 1.409997 0l4.89-4.89003 4.89 4.89003c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41l-4.89-4.89003 4.89-4.89c.38-.38.38-1.02 0-1.399999z"), b(i, "fill", "#000"), b(i, "fill-opacity", ".4"), b(n, "fill", "none"), b(n, "height", "14"), b(n, "viewBox", "0 0 14 14"), b(n, "width", "14"), b(n, "xmlns", "http://www.w3.org/2000/svg"), b(n, "class", "svelte-gu11dh")
            },
            m(e, t) {
                g(e, n, t), m(n, i)
            },
            p: e,
            d(e) {
                e && A(n)
            }
        }
    }

    function le(e) {
        let t, n, r, s, o, l, f, p, y, _, w, C, T, M = e[4] && se(e);
        p = new ie({
            props: {
                $$slots: {
                    default: [ae]
                },
                $$scope: {
                    ctx: e
                }
            }
        }), p.$on("click", e[9]);
        const I = e[10].default,
            B = a(I, e, e[12], null);
        return {
            c() {
                t = v("div"), n = v("div"), r = v("div"), s = v("div"), o = v("div"), M && M.c(), l = x(), f = v("div"), Y(p.$$.fragment), y = x(), B && B.c(), b(o, "class", "common-modal-back-button"), b(f, "class", "common-modal-close-button"), b(s, "class", "common-modal-controls svelte-gu11dh"), b(r, "class", "content svelte-gu11dh"), b(n, "class", "common-modal-scroll svelte-gu11dh"), b(t, "class", _ = d(`common-modal common-modal-variant-${e[0]} ${e[1]}`) + " svelte-gu11dh"), S(t, "common-modal-without-appear-animation", e[2]), S(t, "common-modal-dismissing", e[5])
            },
            m(i, a) {
                g(i, t, a), m(t, n), m(n, r), m(r, s), m(s, o), M && M.m(o, null), m(s, l), m(s, f), q(p, f, null), m(r, y), B && B.m(r, null), e[11](n), w = !0, C || (T = [E(re, "keydown", e[7]), E(r, "click", ce), E(n, "mousedown", e[6]), E(n, "mousemove", ue), E(n, "touchstart", he), E(n, "touchmove", de), E(n, "touchend", fe), E(n, "scroll", pe)], C = !0)
            },
            p(e, [n]) {
                e[4] ? M ? (M.p(e, n), 16 & n && W(M, 1)) : (M = se(e), M.c(), W(M, 1), M.m(o, null)) : M && (j = {
                    r: 0,
                    c: [],
                    p: j
                }, X(M, 1, 1, (() => {
                    M = null
                })), j.r || i(j.c), j = j.p);
                const r = {};
                4096 & n && (r.$$scope = {
                    dirty: n,
                    ctx: e
                }), p.$set(r), B && B.p && (!w || 4096 & n) && u(B, I, e, e[12], w ? c(I, e[12], n, null) : h(e[12]), null), (!w || 3 & n && _ !== (_ = d(`common-modal common-modal-variant-${e[0]} ${e[1]}`) + " svelte-gu11dh")) && b(t, "class", _), (!w || 7 & n) && S(t, "common-modal-without-appear-animation", e[2]), (!w || 35 & n) && S(t, "common-modal-dismissing", e[5])
            },
            i(e) {
                w || (W(M), W(p.$$.fragment, e), W(B, e), w = !0)
            },
            o(e) {
                X(M), X(p.$$.fragment, e), X(B, e), w = !1
            },
            d(n) {
                n && A(t), M && M.d(), K(p), B && B.d(n), e[11](null), C = !1, i(T)
            }
        }
    }

    function ce(e) {
        e.stopPropagation()
    }

    function ue(e) {
        e.stopPropagation()
    }

    function he(e) {
        e.stopPropagation()
    }

    function de(e) {
        e.stopPropagation()
    }

    function fe(e) {
        e.stopPropagation()
    }

    function pe() {}

    function me(e, t, n) {
        let {
            $$slots: i = {},
            $$scope: r
        } = t, {
            variant: s = "default"
        } = t, {
            extraClassNames: o = ""
        } = t, {
            shouldSkipAnimation: a = !1
        } = t;
        ! function(e, t) {
            I().$$.context.set(e, t)
        }(ee, {
            setCanGoBack: function(e) {
                n(4, u = e)
            },
            setBackgroundClickable: function(e) {
                h = e
            }
        });
        const l = D();
        let c, u = !1,
            h = !0,
            d = !1;

        function f(e) {
            n(5, d = !0), l("will-dismiss"), setTimeout(l, 400, "dismiss")
        }

        function p() {
            c.scrollTo(0, 0)
        }
        return B((() => {
            document.body.classList.add("common-modal-presented"), window.addEventListener("router:will-change-url", f), window.addEventListener("modal:did-change-content", p), window.addEventListener("modal:dismiss", f)
        })), R((() => {
            document.body.classList.remove("common-modal-presented"), window.removeEventListener("router:will-change-url", f), window.removeEventListener("modal:did-change-content", p), window.removeEventListener("modal:dismiss", f)
        })), e.$$set = e => {
            "variant" in e && n(0, s = e.variant), "extraClassNames" in e && n(1, o = e.extraClassNames), "shouldSkipAnimation" in e && n(2, a = e.shouldSkipAnimation), "$$scope" in e && n(12, r = e.$$scope)
        }, [s, o, a, c, u, d, function(e) {
            !0 === h && e.target === c && f()
        }, function(e) {
            c.matches(":focus-within") || "Escape" === e.key && f()
        }, function() {
            l("back"), window.dispatchEvent(new Event("modal:did-click-back-button"))
        }, function() {
            f()
        }, i, function(e) {
            L[e ? "unshift" : "push"]((() => {
                c = e, n(3, c)
            }))
        }, r]
    }
    class ge extends $ {
        constructor(e) {
            super(), Z(this, e, me, le, s, {
                variant: 0,
                extraClassNames: 1,
                shouldSkipAnimation: 2
            })
        }
    }
    var Ae = {
        options: [{
            key: "region",
            values: [{
                key: "socal",
                display: {
                    title: "Southern California",
                    alternativeTitle: "Southern<br>California",
                    sf_field: "GEO_c",
                    sf_value: "Southern California"
                }
            }, {
                key: "nocal",
                display: {
                    title: "San&nbsp;Francisco Bay&nbsp;Area",
                    alternativeTitle: "San&nbsp;Francisco<br>Bay&nbsp;Area",
                    sf_field: "GEO_c",
                    sf_value: "San Francisco Bay Area"
                }
            }, {
                key: "rest",
                display: {
                    title: "Somewhere else",
                    subtitle: "Coming soon",
                    sf_field: "GEO_c",
                    sf_value: "Other"
                }
            }],
            display: {
                label: "Region",
                title: "Where is your Backyard going?"
            }
        }, {
            key: "layout",
            sf_field: "Unit_Layout__c",
            values: [{
                key: "studio",
                sf_value: "Studio",
                cost: 152e3,
                display: {
                    title: "Studio",
                    subtitle: "420 gross sq. ft.",
                    primarySubtitle: "1 bath"
                }
            }, {
                key: "onebed",
                sf_value: "One Bedroom",
                cost: 17e4,
                display: {
                    title: "One bedroom",
                    subtitle: "540 gross sq. ft.",
                    primarySubtitle: "1 bedroom, 1 bath"
                }
            }, {
                key: "twobed",
                sf_value: "Two Bedroom",
                cost: 19e4,
                display: {
                    title: "Two bedroom",
                    subtitle: "690 gross sq. ft.",
                    primarySubtitle: "2 bedrooms, 1 bath"
                }
            }, {
                key: "xl8",
                sf_value: "XL 8",
                cost: 249e3,
                display: {
                    title: "Backyard XL 8",
                    subtitle: "800 gross sq. ft.",
                    primarySubtitle: "2 bedrooms, 2 baths"
                }
            }, {
                key: "xl10",
                sf_value: "XL 10",
                cost: 277e3,
                display: {
                    title: "Backyard XL 10",
                    subtitle: "950 gross sq. ft.",
                    primarySubtitle: "2 bedrooms, 2 baths"
                }
            }],
            display: {
                label: "Layout",
                title: "Choose your layout"
            }
        }, {
            key: "cladding",
            sf_field: "Base_Material__c",
            values: [{
                key: "cement",
                sf_value: "Fiber Cement - Vertical",
                display: {
                    title: "Fiber cement",
                    subtitle: "Durable and weather resistant",
                    list: ['Vertical 7" panels with V-groove', "Five standard colors or custom color", "Fire-, moisture-, and rot-resistant"]
                }
            }, {
                key: "metal",
                sf_value: "Insulated Metal Panel",
                cost: ({
                    layout: e
                }) => ({
                    studio: 23500,
                    onebed: 27500,
                    twobed: 32e3,
                    xl8: 45e3,
                    xl10: 5e4
                } [e]),
                display: {
                    title: "Smooth-coated steel",
                    subtitle: "Lustrous and maintenance-free",
                    list: ['Horizontal 24" smooth-coated steel insulated panels', "Three standard colors plus two premium colors", "Easy to clean and never needs to be painted", "Fire-, moisture-, and rot-resistant"]
                }
            }],
            display: {
                label: "Exterior material",
                title: "Choose your cladding material"
            }
        }, {
            key: "color",
            sf_field: "Base_Color_Selection__c",
            values: [{
                key: "base-bonewhite",
                sf_value: "Bone White",
                display: {
                    title: "Bone white",
                    description: "A warm and simple white. Classic."
                }
            }, {
                key: "base-driftwood",
                sf_value: "Driftwood",
                display: {
                    title: "Driftwood",
                    description: "A flexible and serene gray with cool undertones."
                }
            }, {
                key: "base-parchment",
                sf_value: "Parchment",
                display: {
                    title: "Parchment",
                    description: "An inviting, earthy beige. Like stucco."
                }
            }, {
                key: "base-evergreen",
                sf_value: "Evergreen",
                cost: ({
                    cladding: e
                }) => ({
                    cement: 0,
                    metal: 5e3
                } [e]),
                display: {
                    title: "Evergreen",
                    description: "A deep and vibrant green with a hint of earthiness."
                }
            }, {
                key: "base-dark-bronze",
                sf_value: "Dark Bronze",
                cost: ({
                    cladding: e
                }) => ({
                    cement: 0,
                    metal: 5e3
                } [e]),
                display: {
                    title: "Dark bronze",
                    description: "Rich and warm. Most definitely not black."
                }
            }, {
                key: "custom",
                sf_value: "Custom (Fiber Cement Only)",
                cost: ({
                    layout: e
                }) => e?.startsWith("xl") ? 4e3 : 3e3,
                conditions: {
                    cladding: e => "cement" === e
                },
                display: {
                    title: "Custom color",
                    subtitle: "Not shown and specified later"
                }
            }],
            display: {
                label: "Cladding color",
                title: "Choose your cladding color"
            }
        }, {
            key: "roof",
            sf_field: "Roof_Color__c",
            values: [{
                key: "roof-dark-bronze",
                sf_value: "Dark Bronze",
                display: {
                    title: "Dark bronze",
                    description: "Extremely versatile, deep and muted."
                }
            }, {
                key: "roof-metallic-silver",
                sf_value: "Silver",
                cost: 2500,
                display: {
                    title: "Metallic silver",
                    description: "Slightly warm with a subtle fleck."
                }
            }],
            display: {
                label: "Roof",
                title: "Choose your roof color"
            }
        }, {
            key: "floor",
            sf_field: "Floor_Option__c",
            values: [{
                key: "floor-natural-oak",
                sf_value: "Natural oak",
                display: {
                    title: "Natural oak",
                    description: "Waterproof stone composite flooring with a warm, honest character and visible grain."
                }
            }, {
                key: "floor-dark-oak",
                sf_value: "Dark oak",
                cost: 1e3,
                display: {
                    title: "Dark oak",
                    description: "Waterproof stone composite flooring with a rich depth that anchors the space."
                }
            }],
            display: {
                label: "Flooring",
                title: "Choose your floor color"
            }
        }, {
            key: "kitchen-cabinet-finish",
            sf_field: "Kitchen_Cabinet_Finish__c",
            values: [{
                key: "kitchen-cabinet-bone-white",
                sf_value: "Bone white",
                display: {
                    title: "Bone white",
                    description: "Clean and unobtrusive. Emphasizes depth."
                }
            }, {
                key: "kitchen-cabinet-natural-oak",
                sf_value: "Natural oak",
                cost: 5e3,
                display: {
                    title: "Natural oak",
                    description: "Brings tactile warmth. Intentionally unfussy."
                }
            }],
            display: {
                label: "Kitchen cabinet finish",
                title: "Choose your kitchen cabinet finish"
            }
        }, {
            key: "entry",
            sf_field: "Studio_Entry__c",
            conditions: {
                layout: e => "studio" === e
            },
            values: [{
                key: "entry-side",
                sf_value: "Side Entry",
                display: {
                    title: "Side entry",
                    summaryLabel: "Side entry",
                    subtitle: "Enter through the hallway"
                }
            }, {
                key: "entry-front",
                sf_value: "Front Entry",
                cost: 3e3,
                display: {
                    title: "Front entry",
                    summaryLabel: "Front entry",
                    subtitle: "Enter directly into the living area"
                }
            }],
            display: {
                label: "Entry",
                title: "Choose your entrance location",
                camera: "right-angle"
            }
        }, {
            key: "front",
            sf_field: "Front_Option__c",
            conditions: {
                entry: e => void 0 === e || "entry-side" === e
            },
            values: [{
                key: "front-window",
                sf_value: "Casement Window",
                display: {
                    title: "Casement window",
                    summaryLabel: "Front casement window",
                    subtitle: "3'&thinsp;×&thinsp;5'"
                }
            }, {
                key: "front-doors",
                sf_value: "Double Doors",
                cost: 7e3,
                installationCost: 4e3,
                display: {
                    title: "Double doors",
                    summaryLabel: "Front double doors",
                    subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
                }
            }],
            display: {
                label: "Front",
                title: "Choose your front window&nbsp;or&nbsp;doors",
                camera: "right-angle"
            }
        }, {
            key: "left",
            sf_field: "Side_Option__c",
            conditions: {
                layout: e => !1 === e?.startsWith("xl")
            },
            values: [{
                key: "side-window",
                sf_value: "Casement Window",
                display: {
                    title: "Casement Window",
                    summaryLabel: "Left side casement window",
                    subtitle: "3'&thinsp;×&thinsp;5'"
                }
            }, {
                key: "side-doors",
                sf_value: "Double Doors",
                cost: 7e3,
                installationCost: 4e3,
                display: {
                    title: "Double doors",
                    summaryLabel: "Left side double doors",
                    subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
                }
            }],
            display: {
                label: "Left side",
                title: ({
                    layout: e
                }) => "twobed" === e ? "Choose your secondary bedroom window&nbsp;or&nbsp;doors" : "Choose your living room window&nbsp;or&nbsp;doors",
                camera: "left-angle"
            }
        }, {
            key: "xl-living-room-side",
            sf_field: "Side_Option__c",
            conditions: {
                layout: e => !0 === e?.startsWith("xl")
            },
            values: [{
                key: "window",
                sf_value: "Casement Window",
                display: {
                    title: "Casement window",
                    summaryLabel: "Living room casement window",
                    subtitle: "3'&thinsp;×&thinsp;5'"
                }
            }, {
                key: "doors",
                sf_value: "Double Doors",
                cost: 7e3,
                installationCost: 4e3,
                display: {
                    title: "Double doors",
                    summaryLabel: "Living room double doors",
                    subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
                }
            }],
            display: {
                label: "Living room side",
                title: "Choose your living room window&nbsp;or&nbsp;doors",
                camera: "right-angle"
            }
        }, {
            key: "xl-primary-bedroom-side",
            sf_field: "Primary_Bedroom_Option__c",
            conditions: {
                layout: e => !0 === e?.startsWith("xl")
            },
            values: [{
                key: "window",
                sf_value: "Casement Window",
                display: {
                    title: "Casement window",
                    summaryLabel: "Primary bedroom casement window",
                    subtitle: "3'&thinsp;×&thinsp;5'"
                }
            }, {
                key: "doors",
                sf_value: "Double Doors",
                cost: 7e3,
                installationCost: 4e3,
                display: {
                    title: "Double doors",
                    summaryLabel: "Primary bedroom double doors",
                    subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
                }
            }],
            display: {
                label: "Primary bedroom room side",
                title: "Choose your primary bedroom window&nbsp;or&nbsp;doors",
                camera: ({
                    layout: e
                }) => "xl8" === e ? "left-angle" : "right-angle-back"
            }
        }, {
            key: "xl-secondary-bedroom-side",
            sf_field: "Secondary_Bedroom_Option__c",
            conditions: {
                layout: e => e?.startsWith("xl")
            },
            values: [{
                key: "window",
                sf_value: "Casement Window",
                display: {
                    title: "Casement window",
                    summaryLabel: "Secondary bedroom casement window",
                    subtitle: "3'&thinsp;×&thinsp;5'"
                }
            }, {
                key: "doors",
                sf_value: "Double Doors",
                cost: 7e3,
                installationCost: 4e3,
                display: {
                    title: "Double doors",
                    summaryLabel: "Secondary bedroom double doors",
                    subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
                }
            }],
            display: {
                label: "Secondary bedroom room side",
                title: "Choose your secondary bedroom window&nbsp;or&nbsp;doors",
                camera: ({
                    layout: e
                }) => "xl8" === e ? "right-angle" : "right-angle-back"
            }
        }, {
            key: "solar",
            sf_field: "Solar_Option__c",
            values: [{
                key: "solar-no",
                sf_value: "No Solar",
                display: {
                    title: "No solar",
                    summaryLabel: "None",
                    subtitle: "Power with the grid",
                    description: "No solar"
                }
            }, {
                key: "solar-half",
                sf_value: "Half Solar",
                cost: ({
                    layout: e
                }) => ({
                    studio: 8100,
                    onebed: 10200,
                    twobed: 13500,
                    xl8: 11e3,
                    xl10: 13e3
                } [e]),
                display: {
                    title: ({
                        layout: e
                    }) => e?.startsWith("xl") ? "Half solar array" : "Solar array",
                    subtitle: ({
                        layout: e
                    }) => e?.startsWith("xl") ? "Offset your energy usage" : "Go net zero&thinsp;¹",
                    summaryLabel: "Half solar array",
                    description: ({
                        layout: e
                    }) => "studio" === e ? "7-panel, 2.5 kW DC photovoltaic system" : "onebed" === e ? "9-panel, 3.4 kW DC photovoltaic system" : "12-panel, 4.5 kW DC photovoltaic system"
                }
            }, {
                key: "solar-full",
                sf_value: "Full Solar",
                cost: ({
                    layout: e
                }) => ({
                    studio: 16200,
                    onebed: 20400,
                    twobed: 27e3,
                    xl8: 22e3,
                    xl10: 26500
                } [e]),
                conditions: {
                    layout: e => e?.startsWith("xl")
                },
                display: {
                    title: "Full solar array",
                    subtitle: ({
                        layout: e
                    }) => e?.startsWith("xl") ? "Go net zero&thinsp;¹" : "Offset even more energy usage",
                    summaryLabel: "Full solar array",
                    description: ({
                        layout: e
                    }) => "studio" === e ? "14-panel, 5.3 kW DC photovoltaic system" : "onebed" === e ? "18-panel, 6.8 kW DC photovoltaic system" : "24-panel, 9.1 kW DC photovoltaic system"
                }
            }],
            display: {
                label: "Solar",
                title: "Add solar panels",
                camera: "roof"
            }
        }, {
            key: "powerwall",
            sf_field: "Powerwall__c",
            conditions: {
                solar: e => "solar-no" !== e
            },
            values: [{
                key: "standard",
                sf_value: "Standard",
                display: {
                    title: "Standard"
                }
            }, {
                key: "powerwall",
                sf_value: "Tesla Powerwall 3",
                cost: 2e4,
                display: {
                    title: "Tesla Powerwall 3",
                    subtitle: e => "solar-no" === e.solar ? "Available with solar array" : "Use your clean energy 24/7"
                }
            }],
            display: {
                label: "Tesla Powerwall 3",
                title: "Tesla Powerwall 3",
                camera: ({
                    layout: e
                }) => "xl10" === e ? "left-back" : "left-angle-back"
            }
        }, {
            key: "kitchen-layout",
            sf_field: "Kitchen_Layout__c",
            conditions: {
                layout: e => "xl10" === e
            },
            values: [{
                key: "standard",
                sf_value: "Standard",
                display: {
                    title: "Standard kitchen layout",
                    subtitle: "Bring your own dining table"
                }
            }, {
                key: "island",
                sf_value: "Kitchen island",
                cost: 5e3,
                display: {
                    title: "Kitchen with island",
                    subtitle: "Add counter and storage space"
                }
            }],
            display: {
                label: "Kitchen layout",
                title: "Choose your kitchen layout"
            }
        }, {
            key: "kitchen-cooler",
            sf_field: "Kitchen_Cooler__c",
            conditions: {
                layout: e => "xl10" === e,
                "kitchen-layout": e => "island" === e
            },
            values: [{
                key: "standard",
                sf_value: "Standard"
            }, {
                key: "island",
                sf_value: "Wine and beverage cooler",
                cost: 2500,
                display: {
                    title: "Wine and beverage cooler",
                    subtitle: e => "island" === e["kitchen-layout"] ? "Chill your Barolo perfectly" : "Available with kitchen island"
                }
            }],
            display: {
                title: "Wine and beverage cooler",
                label: "Wine and beverage cooler"
            }
        }, {
            key: "primary-bedroom-wardrobe",
            sf_field: "Primary_Bedroom_Wardrobe__c",
            conditions: {
                layout: e => "onebed" === e || "twobed" === e
            },
            values: [{
                key: "standard",
                sf_value: "Standard",
                display: {
                    title: "Standard wardrobe"
                }
            }, {
                key: "full",
                sf_value: "Full Width",
                cost: 1750,
                display: {
                    title: "Full-width wardrobe",
                    summaryLabel: "Primary bedroom full wardrobe",
                    subtitle: "Spans the entire wall"
                }
            }],
            display: {
                title: "Choose storage for this bedroom"
            }
        }, {
            key: "secondary-bedroom-wardrobe",
            sf_field: "Secondary_Bedroom_Wardrobe__c",
            conditions: {
                layout: e => "twobed" === e
            },
            values: [{
                key: "standard",
                sf_value: "Standard",
                display: {
                    title: "Standard wardrobe"
                }
            }, {
                key: "full",
                sf_value: "Full Width",
                cost: 1750,
                display: {
                    title: "Full-width wardrobe",
                    summaryLabel: "Secondary bedroom full wardrobe",
                    subtitle: "Spans the entire wall"
                }
            }],
            display: {
                title: "Choose storage for this bedroom"
            }
        }, {
            key: "bathroom-accessibility-kit",
            sf_field: "Bathroom_Accessibility_Kit__c",
            values: [{
                key: "standard",
                sf_value: "Standard",
                display: {
                    title: "Standard"
                }
            }, {
                key: "bathroom-accessibility-kit",
                sf_value: "Bathroom accessibility kit",
                display: {
                    title: "Bathroom accessibility kit",
                    subtitle: "Enhance safety and ease of use",
                    cost: "Free"
                }
            }],
            display: {
                title: "Bathroom accessibility kit"
            }
        }, {
            key: "interior-blinds",
            sf_field: "Blinds__c",
            values: [{
                key: "standard",
                sf_value: "No blinds",
                display: {
                    title: "Standard"
                }
            }, {
                key: "blinds-roller",
                sf_value: "Rolling blinds",
                installationCost: e => ({
                    studio: 1500,
                    onebed: 1750,
                    twobed: 2e3,
                    xl8: 2250,
                    xl10: 2500
                } [e.layout] + ("side-doors" === e.left ? 300 : 0) + ("entry-front" === e.entry || "front-doors" === e.front ? 300 : 0) + ("doors" === e["xl-living-room-side"] ? 300 : 0) + ("doors" === e["xl-primary-bedroom-side"] ? 300 : 0) + ("doors" === e["xl-secondary-bedroom-side"] ? 300 : 0)),
                display: {
                    title: "Roller blinds",
                    subtitle: "More privacy without losing light"
                }
            }],
            display: {
                title: "Blinds"
            }
        }]
    };
    const ve = ["interior-blinds", "kitchen-pantry", "kitchen-cooler", "bathroom-accessibility-kit"];
    Ae.options.reduce(((e, t) => ve.includes(t.key) ? e : {
        ...e,
        [t.key]: t.values.length > 1 ? t.values[0].key : void 0
    }), {});
    const ye = Ae;
    const _e = [];
    const xe = function(t, n = e) {
        let i;
        const r = new Set;

        function o(e) {
            if (s(t, e) && (t = e, i)) {
                const e = !_e.length;
                for (const e of r) e[1](), _e.push(e, t);
                if (e) {
                    for (let e = 0; e < _e.length; e += 2) _e[e][0](_e[e + 1]);
                    _e.length = 0
                }
            }
        }

        function a(e) {
            o(e(t))
        }
        return {
            set: o,
            update: a,
            subscribe: function(s, l = e) {
                const c = [s, l];
                return r.add(c), 1 === r.size && (i = n(o, a) || e), s(t), () => {
                    r.delete(c), 0 === r.size && i && (i(), i = null)
                }
            }
        }
    }({
        variant: "modal",
        source: null,
        model: "studio",
        nextModel: "studio",
        isModelSelectorVisible: !1,
        isChangingModel: !1,
        isZoomed: !1
    });

    function Ee(t) {
        let n, i, r, s, o, a, l, c, u = (t[1] ? t[1].display.title : "Choose Model") + "";
        return {
            c() {
                n = v("button"), i = v("span"), r = _(u), s = x(), o = y("svg"), a = y("path"), b(i, "class", "type-alt"), b(a, "d", "M6.00195 6.56738C5.77148 6.56738 5.56055 6.47363 5.36914 6.28613L0.957031 1.77441C0.882812 1.69629 0.826172 1.6123 0.787109 1.52246C0.751953 1.43262 0.734375 1.33301 0.734375 1.22363C0.734375 1.0791 0.769531 0.946289 0.839844 0.825195C0.910156 0.704102 1.00391 0.608398 1.12109 0.538086C1.24219 0.467773 1.375 0.432617 1.51953 0.432617C1.73828 0.432617 1.92969 0.512695 2.09375 0.672852L6.27148 4.96191H5.73828L9.9043 0.672852C10.0684 0.512695 10.2598 0.432617 10.4785 0.432617C10.623 0.432617 10.7539 0.467773 10.8711 0.538086C10.9922 0.608398 11.0879 0.704102 11.1582 0.825195C11.2285 0.946289 11.2637 1.0791 11.2637 1.22363C11.2637 1.43848 11.1875 1.62012 11.0352 1.76855L6.63477 6.28613C6.54102 6.37988 6.44141 6.4502 6.33594 6.49707C6.23438 6.54004 6.12305 6.56348 6.00195 6.56738Z"), b(a, "fill", "white"), C(a, "fill", "white"), C(a, "fill-opacity", "1"), b(o, "width", "12"), b(o, "height", "7"), b(o, "viewBox", "0 0 12 7"), b(o, "fill", "none"), b(o, "xmlns", "http://www.w3.org/2000/svg"), b(o, "class", "svelte-q4qxph"), b(n, "class", "tour-controls-selector-button type-15 type-regola-regular svelte-q4qxph"), S(n, "tour-controls-selector-button-visible", !0 === t[0].isModelSelectorVisible), S(n, "tour-controls-selector-button-full-screen", "full-screen" === t[0].variant), S(n, "tour-controls-selector-button-none", null === t[0].model)
            },
            m(e, u) {
                g(e, n, u), m(n, i), m(i, r), m(n, s), m(n, o), m(o, a), l || (c = E(n, "click", t[2]), l = !0)
            },
            p(e, [t]) {
                2 & t && u !== (u = (e[1] ? e[1].display.title : "Choose Model") + "") && function(e, t) {
                    t = "" + t, e.data !== t && (e.data = t)
                }(r, u), 1 & t && S(n, "tour-controls-selector-button-visible", !0 === e[0].isModelSelectorVisible), 1 & t && S(n, "tour-controls-selector-button-full-screen", "full-screen" === e[0].variant), 1 & t && S(n, "tour-controls-selector-button-none", null === e[0].model)
            },
            i: e,
            o: e,
            d(e) {
                e && A(n), l = !1, c()
            }
        }
    }

    function be(e, t, n) {
        let i, r;
        o(e, xe, (e => n(0, r = e)));
        const s = function(e) {
            const t = ye.options.find((t => t.key === e));
            return void 0 === t && "undefined" != typeof Sentry && Sentry.captureException(`can't find option with key "${e}"`), t
        }("layout").values;
        return e.$$.update = () => {
            1 & e.$$.dirty && n(1, i = s[s.findIndex((e => e.key === r.nextModel))])
        }, [r, i, function() {
            f(xe, r.isModelSelectorVisible = !r.isModelSelectorVisible, r), gtag("event", "tour_model_selector_toggled", {
                model: r.model,
                source: r.source,
                action: !0 === r.isModelSelectorVisible ? "opened" : "closed"
            })
        }]
    }
    class we extends $ {
        constructor(e) {
            super(), Z(this, e, be, Ee, s, {})
        }
    }

    function Ce(t) {
        let n, r, s, o, a, l, c, u, h, d, f, p, y, _, w, C, T, M, I, B, R, D, P, L, U;
        return {
            c() {
                n = v("div"), r = v("div"), s = v("div"), o = x(), a = v("div"), l = x(), c = v("h1"), c.textContent = "Choose a model to tour.", u = x(), h = v("h2"), h.textContent = "Backyard comes in five sizes.", d = x(), f = v("div"), p = x(), y = v("button"), y.innerHTML = '<div class="type-15 color-white">Studio</div> <div class="type-14 color-white-60">1 bath · 420 gross sq. ft.</div>', _ = x(), w = v("button"), w.innerHTML = '<div class="type-15 color-white">One bedroom</div> <div class="type-14 color-white-60">1 bedroom, 1 bath · 540 gross sq. ft.</div>', C = x(), T = v("button"), T.innerHTML = '<div class="type-15 color-white">Two bedroom</div> <div class="type-14 color-white-60">2 bedrooms, 1 bath · 690 gross sq. ft.</div>', M = x(), I = v("button"), I.innerHTML = '<div class="type-15 color-white type-alt">Backyard XL 8</div> <div class="type-14 color-white-60">2 bedrooms, 2 baths · 800 gross sq. ft.</div>', B = x(), R = v("button"), R.innerHTML = '<div class="type-15 color-white type-alt">Backyard XL 10</div> <div class="type-14 color-white-60">2 bedrooms, 2 baths · 950 gross sq. ft.</div>', D = x(), P = v("div"), b(s, "class", "spacer-150 m-spacer-50"), b(a, "class", "m-spacer-24"), b(c, "class", "type-30-light m-type-24-light color-white svelte-1elduth"), b(h, "class", "type-30-light m-type-24-light color-white-40 svelte-1elduth"), b(f, "class", "spacer-50 m-spacer-36"), b(y, "class", "svelte-1elduth"), S(y, "tour-model-selector-selected", "studio" === t[1].nextModel), b(w, "class", "svelte-1elduth"), S(w, "tour-model-selector-selected", "onebed" === t[1].nextModel), b(T, "class", "svelte-1elduth"), S(T, "tour-model-selector-selected", "twobed" === t[1].nextModel), b(I, "class", "svelte-1elduth"), S(I, "tour-model-selector-selected", "xl8" === t[1].nextModel), b(R, "class", "svelte-1elduth"), S(R, "tour-model-selector-selected", "xl10" === t[1].nextModel), b(P, "class", "spacer-150 m-spacer-50"), b(r, "class", "tour-model-selector-content svelte-1elduth"), b(n, "class", "tour-model-selector svelte-1elduth"), S(n, "tour-model-selector-visible", !0 === t[1].isModelSelectorVisible), S(n, "tour-model-selector-null", null === t[1].model)
            },
            m(e, i) {
                g(e, n, i), m(n, r), m(r, s), m(r, o), m(r, a), m(r, l), m(r, c), m(r, u), m(r, h), m(r, d), m(r, f), m(r, p), m(r, y), m(r, _), m(r, w), m(r, C), m(r, T), m(r, M), m(r, I), m(r, B), m(r, R), m(r, D), m(r, P), t[4](r), L || (U = [E(y, "click", t[3]("studio")), E(w, "click", t[3]("onebed")), E(T, "click", t[3]("twobed")), E(I, "click", t[3]("xl8")), E(R, "click", t[3]("xl10")), E(r, "click", t[2])], L = !0)
            },
            p(e, [t]) {
                2 & t && S(y, "tour-model-selector-selected", "studio" === e[1].nextModel), 2 & t && S(w, "tour-model-selector-selected", "onebed" === e[1].nextModel), 2 & t && S(T, "tour-model-selector-selected", "twobed" === e[1].nextModel), 2 & t && S(I, "tour-model-selector-selected", "xl8" === e[1].nextModel), 2 & t && S(R, "tour-model-selector-selected", "xl10" === e[1].nextModel), 2 & t && S(n, "tour-model-selector-visible", !0 === e[1].isModelSelectorVisible), 2 & t && S(n, "tour-model-selector-null", null === e[1].model)
            },
            i: e,
            o: e,
            d(e) {
                e && A(n), t[4](null), L = !1, i(U)
            }
        }
    }

    function Se(e, t, n) {
        let i, r;
        return o(e, xe, (e => n(1, i = e))), [r, i, function(e) {
            e.target === r && null !== i.model && f(xe, i.isModelSelectorVisible = !1, i)
        }, function(e) {
            return () => {
                i.model !== e ? (gtag("event", "tour_model_selected", {
                    previous_model: i.model,
                    new_model: e,
                    source: i.source
                }), f(xe, i.isChangingModel = !0, i), f(xe, i.nextModel = e, i), setTimeout((() => {
                    f(xe, i.isZoomed = !1, i), f(xe, i.model = e, i), f(xe, i.nextModel = e, i), f(xe, i.isChangingModel = !1, i)
                }), 1e3), setTimeout((() => {
                    f(xe, i.isModelSelectorVisible = !1, i)
                }), 600)) : f(xe, i.isModelSelectorVisible = !1, i)
            }
        }, function(e) {
            L[e ? "unshift" : "push"]((() => {
                r = e, n(0, r)
            }))
        }]
    }
    class Te extends $ {
        constructor(e) {
            super(), Z(this, e, Se, Ce, s, {})
        }
    }

    function Me(t) {
        let n, i, r;
        return {
            c() {
                n = v("div"), i = v("div"), b(i, "style", r = `width: ${(100*t[0]).toFixed(1)}%`), b(i, "class", "svelte-1vxamij"), b(n, "class", "tour-progress-bar svelte-1vxamij"), S(n, "tour-progress-bar-without-animation", 0 === t[0]), S(n, "tour-progress-bar-hidden", !0 === t[1])
            },
            m(e, t) {
                g(e, n, t), m(n, i)
            },
            p(e, [t]) {
                1 & t && r !== (r = `width: ${(100*e[0]).toFixed(1)}%`) && b(i, "style", r), 1 & t && S(n, "tour-progress-bar-without-animation", 0 === e[0]), 2 & t && S(n, "tour-progress-bar-hidden", !0 === e[1])
            },
            i: e,
            o: e,
            d(e) {
                e && A(n)
            }
        }
    }

    function Ie(e, t, n) {
        let i, r;
        o(e, xe, (e => n(2, r = e)));
        let {
            value: s = 0
        } = t;
        return e.$$set = e => {
            "value" in e && n(0, s = e.value)
        }, e.$$.update = () => {
            5 & e.$$.dirty && n(1, i = 1 === s || !0 === r.isModelSelectorVisible)
        }, [s, i, r]
    }
    class Be extends $ {
        constructor(e) {
            super(), Z(this, e, Ie, Me, s, {
                value: 0
            })
        }
    }
    /*! For license information please see samara_backyard_3d.js.LICENSE.txt */
    function Re(e) {
        let t;
        return {
            c() {
                t = v("div"), b(t, "class", "tour-outline svelte-91gn29")
            },
            m(e, n) {
                g(e, t, n)
            },
            d(e) {
                e && A(t)
            }
        }
    }

    function De(e) {
        let t, n, i;
        return {
            c() {
                t = y("svg"), n = y("path"), i = _("\n\t\t\t\tZoom out"), b(n, "d", "M0 6.11938C0 5.31372 0.151367 4.55933 0.454102 3.8562C0.756836 3.14819 1.17676 2.52563 1.71387 1.98853C2.25098 1.45142 2.87109 1.03149 3.57422 0.72876C4.28223 0.426025 5.03906 0.274658 5.84473 0.274658C6.65039 0.274658 7.40479 0.426025 8.10791 0.72876C8.81592 1.03149 9.43848 1.45142 9.97559 1.98853C10.5127 2.52563 10.9326 3.14819 11.2354 3.8562C11.5381 4.55933 11.6895 5.31372 11.6895 6.11938C11.6895 6.78833 11.582 7.4231 11.3672 8.02368C11.1572 8.62427 10.8643 9.1687 10.4883 9.65698L14.0698 13.2605C14.1479 13.3386 14.2065 13.429 14.2456 13.5315C14.2896 13.634 14.3115 13.7439 14.3115 13.8611C14.3115 14.0222 14.2749 14.1687 14.2017 14.3005C14.1333 14.4324 14.0356 14.5349 13.9087 14.6082C13.7817 14.6863 13.6353 14.7253 13.4692 14.7253C13.3521 14.7253 13.2397 14.7034 13.1323 14.6594C13.0298 14.6204 12.9346 14.5593 12.8467 14.4763L9.24316 10.8655C8.76465 11.2073 8.2373 11.4758 7.66113 11.6711C7.08496 11.8665 6.47949 11.9641 5.84473 11.9641C5.03906 11.9641 4.28223 11.8127 3.57422 11.51C2.87109 11.2073 2.25098 10.7874 1.71387 10.2502C1.17676 9.71313 0.756836 9.09302 0.454102 8.38989C0.151367 7.68188 0 6.92505 0 6.11938ZM1.25244 6.11938C1.25244 6.75415 1.36963 7.34985 1.604 7.90649C1.84326 8.45825 2.17285 8.94409 2.59277 9.36401C3.01758 9.78394 3.50586 10.1135 4.05762 10.3528C4.61426 10.592 5.20996 10.7117 5.84473 10.7117C6.47949 10.7117 7.07275 10.592 7.62451 10.3528C8.18115 10.1135 8.66943 9.78394 9.08936 9.36401C9.50928 8.94409 9.83887 8.45825 10.0781 7.90649C10.3174 7.34985 10.437 6.75415 10.437 6.11938C10.437 5.48462 10.3174 4.89136 10.0781 4.3396C9.83887 3.78296 9.50928 3.29468 9.08936 2.87476C8.66943 2.44995 8.18115 2.12036 7.62451 1.88599C7.07275 1.64673 6.47949 1.5271 5.84473 1.5271C5.20996 1.5271 4.61426 1.64673 4.05762 1.88599C3.50586 2.12036 3.01758 2.44995 2.59277 2.87476C2.17285 3.29468 1.84326 3.78296 1.604 4.3396C1.36963 4.89136 1.25244 5.48462 1.25244 6.11938ZM3.95508 6.65405C3.80859 6.65405 3.68164 6.60278 3.57422 6.50024C3.47168 6.39282 3.42041 6.26587 3.42041 6.11938C3.42041 5.9729 3.47168 5.84595 3.57422 5.73853C3.68164 5.6311 3.80859 5.57739 3.95508 5.57739H7.72705C7.87354 5.57739 7.99805 5.6311 8.10059 5.73853C8.20801 5.84595 8.26172 5.9729 8.26172 6.11938C8.26172 6.26587 8.20801 6.39282 8.10059 6.50024C7.99805 6.60278 7.87354 6.65405 7.72705 6.65405H3.95508Z"), b(n, "fill", "white"), C(n, "fill", "white"), C(n, "fill-opacity", "1"), b(t, "width", "15"), b(t, "height", "15"), b(t, "viewBox", "0 0 15 15"), b(t, "fill", "none"), b(t, "xmlns", "http://www.w3.org/2000/svg")
            },
            m(e, r) {
                g(e, t, r), m(t, n), g(e, i, r)
            },
            d(e) {
                e && (A(t), A(i))
            }
        }
    }

    function Pe(e) {
        let t, n, i;
        return {
            c() {
                t = y("svg"), n = y("path"), i = _("\n\t\t\t\tZoom in"), b(n, "d", "M0 6.11914C0 5.31348 0.151367 4.55908 0.454102 3.85596C0.756836 3.14795 1.17676 2.52539 1.71387 1.98828C2.25098 1.45117 2.87109 1.03125 3.57422 0.728516C4.28223 0.425781 5.03906 0.274414 5.84473 0.274414C6.65039 0.274414 7.40479 0.425781 8.10791 0.728516C8.81592 1.03125 9.43848 1.45117 9.97559 1.98828C10.5127 2.52539 10.9326 3.14795 11.2354 3.85596C11.5381 4.55908 11.6895 5.31348 11.6895 6.11914C11.6895 6.78809 11.582 7.42285 11.3672 8.02344C11.1572 8.62402 10.8643 9.16846 10.4883 9.65674L14.0698 13.2603C14.1479 13.3384 14.2065 13.4287 14.2456 13.5312C14.2896 13.6338 14.3115 13.7437 14.3115 13.8608C14.3115 14.022 14.2749 14.1685 14.2017 14.3003C14.1333 14.4321 14.0356 14.5347 13.9087 14.6079C13.7817 14.686 13.6353 14.7251 13.4692 14.7251C13.3521 14.7251 13.2397 14.7031 13.1323 14.6592C13.0298 14.6201 12.9346 14.5591 12.8467 14.4761L9.24316 10.8652C8.76465 11.207 8.2373 11.4756 7.66113 11.6709C7.08496 11.8662 6.47949 11.9639 5.84473 11.9639C5.03906 11.9639 4.28223 11.8125 3.57422 11.5098C2.87109 11.207 2.25098 10.7871 1.71387 10.25C1.17676 9.71289 0.756836 9.09277 0.454102 8.38965C0.151367 7.68164 0 6.9248 0 6.11914ZM1.25244 6.11914C1.25244 6.75391 1.36963 7.34961 1.604 7.90625C1.84326 8.45801 2.17285 8.94385 2.59277 9.36377C3.01758 9.78369 3.50586 10.1133 4.05762 10.3525C4.61426 10.5918 5.20996 10.7114 5.84473 10.7114C6.47949 10.7114 7.07275 10.5918 7.62451 10.3525C8.18115 10.1133 8.66943 9.78369 9.08936 9.36377C9.50928 8.94385 9.83887 8.45801 10.0781 7.90625C10.3174 7.34961 10.437 6.75391 10.437 6.11914C10.437 5.48438 10.3174 4.89111 10.0781 4.33936C9.83887 3.78271 9.50928 3.29443 9.08936 2.87451C8.66943 2.44971 8.18115 2.12012 7.62451 1.88574C7.07275 1.64648 6.47949 1.52686 5.84473 1.52686C5.20996 1.52686 4.61426 1.64648 4.05762 1.88574C3.50586 2.12012 3.01758 2.44971 2.59277 2.87451C2.17285 3.29443 1.84326 3.78271 1.604 4.33936C1.36963 4.89111 1.25244 5.48438 1.25244 6.11914ZM3.42773 6.11914C3.42773 5.96777 3.479 5.84082 3.58154 5.73828C3.68896 5.63086 3.81592 5.57715 3.9624 5.57715H5.31006V4.23682C5.31006 4.08545 5.36133 3.9585 5.46387 3.85596C5.57129 3.74854 5.69824 3.69482 5.84473 3.69482C5.99609 3.69482 6.12305 3.74854 6.22559 3.85596C6.33301 3.9585 6.38672 4.08545 6.38672 4.23682V5.57715H7.72705C7.87842 5.57715 8.00537 5.63086 8.10791 5.73828C8.21045 5.84082 8.26172 5.96777 8.26172 6.11914C8.26172 6.27051 8.21045 6.39746 8.10791 6.5C8.00537 6.60254 7.87842 6.65381 7.72705 6.65381H6.38672V7.99414C6.38672 8.14551 6.33301 8.2749 6.22559 8.38232C6.12305 8.48486 5.99609 8.53613 5.84473 8.53613C5.69824 8.53613 5.57129 8.48486 5.46387 8.38232C5.36133 8.2749 5.31006 8.14551 5.31006 7.99414V6.65381H3.9624C3.81592 6.65381 3.68896 6.60254 3.58154 6.5C3.479 6.39746 3.42773 6.27051 3.42773 6.11914Z"), b(n, "fill", "white"), C(n, "fill", "white"), C(n, "fill-opacity", "1"), b(t, "width", "15"), b(t, "height", "15"), b(t, "viewBox", "0 0 15 15"), b(t, "fill", "none"), b(t, "xmlns", "http://www.w3.org/2000/svg")
            },
            m(e, r) {
                g(e, t, r), m(t, n), g(e, i, r)
            },
            d(e) {
                e && (A(t), A(i))
            }
        }
    }

    function Le(e) {
        let t;
        return {
            c() {
                t = v("samara-room-tour"), w(t, "activeModel", e[3]), w(t, "class", "svelte-91gn29"), S(t, "samara-scene-loaded", 1 === e[2]), S(t, "samara-scene-changing-model", !0 === e[1].isChangingModel)
            },
            m(n, i) {
                g(n, t, i), e[9](t)
            },
            p(e, n) {
                8 & n && w(t, "activeModel", e[3]), 4 & n && S(t, "samara-scene-loaded", 1 === e[2]), 2 & n && S(t, "samara-scene-changing-model", !0 === e[1].isChangingModel)
            },
            d(n) {
                n && A(t), e[9](null)
            }
        }
    }

    function Ue(e) {
        let t, n, s, o, a, l, c, u, h, f, p, y, _, w, C, T, M, I = "modal" === e[1].variant && Re();

        function B(e, t) {
            return !1 === e[1].isZoomed ? Pe : De
        }
        n = new we({});
        let R = B(e),
            D = R(e);
        f = new Te({}), y = new Be({
            props: {
                value: e[2]
            }
        });
        let P = null !== e[1].model && Le(e);
        return {
            c() {
                I && I.c(), t = x(), Y(n.$$.fragment), s = x(), o = v("div"), a = v("button"), a.innerHTML = 'Specs &amp; pricing\n\t\t\t<svg width="14" height="13" viewBox="0 0 14 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.9995 6.5C13.9995 6.68555 13.9263 6.84912 13.7798 6.99072L8.90918 11.8467C8.76758 11.9834 8.60889 12.0518 8.43311 12.0518C8.25244 12.0518 8.10107 11.9907 7.979 11.8687C7.85693 11.7515 7.7959 11.6025 7.7959 11.4219C7.7959 11.334 7.81055 11.251 7.83984 11.1729C7.86914 11.0898 7.91309 11.019 7.97168 10.9604L9.6123 9.29053L12.52 6.64648L12.6665 7.00537L10.3081 7.15186H1.04297C0.852539 7.15186 0.696289 7.09082 0.574219 6.96875C0.457031 6.84668 0.398438 6.69043 0.398438 6.5C0.398438 6.30957 0.457031 6.15332 0.574219 6.03125C0.696289 5.90918 0.852539 5.84814 1.04297 5.84814H10.3081L12.6665 5.99463L12.52 6.36084L9.6123 3.70947L7.97168 2.03955C7.91309 1.98096 7.86914 1.9126 7.83984 1.83447C7.81055 1.75146 7.7959 1.66602 7.7959 1.57812C7.7959 1.39746 7.85693 1.24854 7.979 1.13135C8.10107 1.00928 8.25244 0.948242 8.43311 0.948242C8.521 0.948242 8.604 0.965332 8.68213 0.999512C8.76514 1.03369 8.8457 1.08984 8.92383 1.16797L13.7798 6.00928C13.9263 6.15088 13.9995 6.31445 13.9995 6.5Z" fill="white" style="fill:white;fill-opacity:1;"></path></svg>', l = x(), c = v("button"), D.c(), u = x(), h = v("div"), Y(f.$$.fragment), p = x(), Y(y.$$.fragment), _ = x(), P && P.c(), b(a, "class", "tour-controls-specs-pricing type-15 type-regola-regular svelte-91gn29"), b(c, "class", "tour-controls-zoom-in type-15 type-regola-regular svelte-91gn29"), b(o, "class", "tour-controls"), b(h, "class", w = d(`tour-content tour-content-variant-${e[1].variant}`) + " svelte-91gn29"), S(h, "tour-content-null", null === e[1].model)
            },
            m(i, d) {
                I && I.m(i, d), g(i, t, d), q(n, i, d), g(i, s, d), g(i, o, d), m(o, a), m(o, l), m(o, c), D.m(c, null), g(i, u, d), g(i, h, d), q(f, h, null), m(h, p), q(y, h, null), m(h, _), P && P.m(h, null), C = !0, T || (M = [E(a, "click", e[6]), E(c, "click", (function() {
                    r(e[4]) && e[4].apply(this, arguments)
                }))], T = !0)
            },
            p(n, i) {
                "modal" === (e = n)[1].variant ? I || (I = Re(), I.c(), I.m(t.parentNode, t)) : I && (I.d(1), I = null), R !== (R = B(e)) && (D.d(1), D = R(e), D && (D.c(), D.m(c, null)));
                const r = {};
                4 & i && (r.value = e[2]), y.$set(r), null !== e[1].model ? P ? P.p(e, i) : (P = Le(e), P.c(), P.m(h, null)) : P && (P.d(1), P = null), (!C || 2 & i && w !== (w = d(`tour-content tour-content-variant-${e[1].variant}`) + " svelte-91gn29")) && b(h, "class", w), (!C || 2 & i) && S(h, "tour-content-null", null === e[1].model)
            },
            i(e) {
                C || (W(n.$$.fragment, e), W(f.$$.fragment, e), W(y.$$.fragment, e), C = !0)
            },
            o(e) {
                X(n.$$.fragment, e), X(f.$$.fragment, e), X(y.$$.fragment, e), C = !1
            },
            d(e) {
                e && (A(t), A(s), A(o), A(u), A(h)), I && I.d(e), K(n, e), D.d(), K(f), K(y), P && P.d(), T = !1, i(M)
            }
        }
    }

    function Ne(e) {
        let t, n;
        return t = new ge({
            props: {
                variant: "tour",
                extraClassNames: `tour-modal-variant-${e[1].variant}`,
                shouldSkipAnimation: "restore" === e[1].source,
                $$slots: {
                    default: [Ue]
                },
                $$scope: {
                    ctx: e
                }
            }
        }), t.$on("dismiss", e[5]), {
            c() {
                Y(t.$$.fragment)
            },
            m(e, i) {
                q(t, e, i), n = !0
            },
            p(e, [n]) {
                const i = {};
                2 & n && (i.extraClassNames = `tour-modal-variant-${e[1].variant}`), 2 & n && (i.shouldSkipAnimation = "restore" === e[1].source), 8388639 & n && (i.$$scope = {
                    dirty: n,
                    ctx: e
                }), t.$set(i)
            },
            i(e) {
                n || (W(t.$$.fragment, e), n = !0)
            },
            o(e) {
                X(t.$$.fragment, e), n = !1
            },
            d(e) {
                K(t, e)
            }
        }
    }(() => {
        var e = {
                543: function(e, t, n) {
                    var i;
                    e = n.nmd(e),
                        function() {
                            var r, s = "Expected a function",
                                o = "__lodash_hash_undefined__",
                                a = "__lodash_placeholder__",
                                l = 32,
                                c = 128,
                                u = 1 / 0,
                                h = 9007199254740991,
                                d = NaN,
                                f = 4294967295,
                                p = [
                                    ["ary", c],
                                    ["bind", 1],
                                    ["bindKey", 2],
                                    ["curry", 8],
                                    ["curryRight", 16],
                                    ["flip", 512],
                                    ["partial", l],
                                    ["partialRight", 64],
                                    ["rearg", 256]
                                ],
                                m = "[object Arguments]",
                                g = "[object Array]",
                                A = "[object Boolean]",
                                v = "[object Date]",
                                y = "[object Error]",
                                _ = "[object Function]",
                                x = "[object GeneratorFunction]",
                                E = "[object Map]",
                                b = "[object Number]",
                                w = "[object Object]",
                                C = "[object Promise]",
                                S = "[object RegExp]",
                                T = "[object Set]",
                                M = "[object String]",
                                I = "[object Symbol]",
                                B = "[object WeakMap]",
                                R = "[object ArrayBuffer]",
                                D = "[object DataView]",
                                P = "[object Float32Array]",
                                L = "[object Float64Array]",
                                U = "[object Int8Array]",
                                N = "[object Int16Array]",
                                O = "[object Int32Array]",
                                F = "[object Uint8Array]",
                                k = "[object Uint8ClampedArray]",
                                Q = "[object Uint16Array]",
                                z = "[object Uint32Array]",
                                H = /\b__p \+= '';/g,
                                G = /\b(__p \+=) '' \+/g,
                                V = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                                j = /&(?:amp|lt|gt|quot|#39);/g,
                                W = /[&<>"']/g,
                                X = RegExp(j.source),
                                Y = RegExp(W.source),
                                q = /<%-([\s\S]+?)%>/g,
                                K = /<%([\s\S]+?)%>/g,
                                J = /<%=([\s\S]+?)%>/g,
                                Z = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                                $ = /^\w*$/,
                                ee = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                                te = /[\\^$.*+?()[\]{}|]/g,
                                ne = RegExp(te.source),
                                ie = /^\s+/,
                                re = /\s/,
                                se = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                                oe = /\{\n\/\* \[wrapped with (.+)\] \*/,
                                ae = /,? & /,
                                le = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                                ce = /[()=,{}\[\]\/\s]/,
                                ue = /\\(\\)?/g,
                                he = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                                de = /\w*$/,
                                fe = /^[-+]0x[0-9a-f]+$/i,
                                pe = /^0b[01]+$/i,
                                me = /^\[object .+?Constructor\]$/,
                                ge = /^0o[0-7]+$/i,
                                Ae = /^(?:0|[1-9]\d*)$/,
                                ve = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                                ye = /($^)/,
                                _e = /['\n\r\u2028\u2029\\]/g,
                                xe = "\\ud800-\\udfff",
                                Ee = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
                                be = "\\u2700-\\u27bf",
                                we = "a-z\\xdf-\\xf6\\xf8-\\xff",
                                Ce = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                                Se = "\\ufe0e\\ufe0f",
                                Te = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                                Me = "[" + xe + "]",
                                Ie = "[" + Te + "]",
                                Be = "[" + Ee + "]",
                                Re = "\\d+",
                                De = "[" + be + "]",
                                Pe = "[" + we + "]",
                                Le = "[^" + xe + Te + Re + be + we + Ce + "]",
                                Ue = "\\ud83c[\\udffb-\\udfff]",
                                Ne = "[^" + xe + "]",
                                Oe = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                                Fe = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                                ke = "[" + Ce + "]",
                                Qe = "\\u200d",
                                ze = "(?:" + Pe + "|" + Le + ")",
                                He = "(?:" + ke + "|" + Le + ")",
                                Ge = "(?:['’](?:d|ll|m|re|s|t|ve))?",
                                Ve = "(?:['’](?:D|LL|M|RE|S|T|VE))?",
                                je = "(?:" + Be + "|" + Ue + ")?",
                                We = "[" + Se + "]?",
                                Xe = We + je + "(?:" + Qe + "(?:" + [Ne, Oe, Fe].join("|") + ")" + We + je + ")*",
                                Ye = "(?:" + [De, Oe, Fe].join("|") + ")" + Xe,
                                qe = "(?:" + [Ne + Be + "?", Be, Oe, Fe, Me].join("|") + ")",
                                Ke = RegExp("['’]", "g"),
                                Je = RegExp(Be, "g"),
                                Ze = RegExp(Ue + "(?=" + Ue + ")|" + qe + Xe, "g"),
                                $e = RegExp([ke + "?" + Pe + "+" + Ge + "(?=" + [Ie, ke, "$"].join("|") + ")", He + "+" + Ve + "(?=" + [Ie, ke + ze, "$"].join("|") + ")", ke + "?" + ze + "+" + Ge, ke + "+" + Ve, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Re, Ye].join("|"), "g"),
                                et = RegExp("[" + Qe + xe + Ee + Se + "]"),
                                tt = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                                nt = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                                it = -1,
                                rt = {};
                            rt[P] = rt[L] = rt[U] = rt[N] = rt[O] = rt[F] = rt[k] = rt[Q] = rt[z] = !0, rt[m] = rt[g] = rt[R] = rt[A] = rt[D] = rt[v] = rt[y] = rt[_] = rt[E] = rt[b] = rt[w] = rt[S] = rt[T] = rt[M] = rt[B] = !1;
                            var st = {};
                            st[m] = st[g] = st[R] = st[D] = st[A] = st[v] = st[P] = st[L] = st[U] = st[N] = st[O] = st[E] = st[b] = st[w] = st[S] = st[T] = st[M] = st[I] = st[F] = st[k] = st[Q] = st[z] = !0, st[y] = st[_] = st[B] = !1;
                            var ot = {
                                    "\\": "\\",
                                    "'": "'",
                                    "\n": "n",
                                    "\r": "r",
                                    "\u2028": "u2028",
                                    "\u2029": "u2029"
                                },
                                at = parseFloat,
                                lt = parseInt,
                                ct = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                                ut = "object" == typeof self && self && self.Object === Object && self,
                                ht = ct || ut || Function("return this")(),
                                dt = t && !t.nodeType && t,
                                ft = dt && e && !e.nodeType && e,
                                pt = ft && ft.exports === dt,
                                mt = pt && ct.process,
                                gt = function() {
                                    try {
                                        return ft && ft.require && ft.require("util").types || mt && mt.binding && mt.binding("util")
                                    } catch (e) {}
                                }(),
                                At = gt && gt.isArrayBuffer,
                                vt = gt && gt.isDate,
                                yt = gt && gt.isMap,
                                _t = gt && gt.isRegExp,
                                xt = gt && gt.isSet,
                                Et = gt && gt.isTypedArray;

                            function bt(e, t, n) {
                                switch (n.length) {
                                    case 0:
                                        return e.call(t);
                                    case 1:
                                        return e.call(t, n[0]);
                                    case 2:
                                        return e.call(t, n[0], n[1]);
                                    case 3:
                                        return e.call(t, n[0], n[1], n[2])
                                }
                                return e.apply(t, n)
                            }

                            function wt(e, t, n, i) {
                                for (var r = -1, s = null == e ? 0 : e.length; ++r < s;) {
                                    var o = e[r];
                                    t(i, o, n(o), e)
                                }
                                return i
                            }

                            function Ct(e, t) {
                                for (var n = -1, i = null == e ? 0 : e.length; ++n < i && !1 !== t(e[n], n, e););
                                return e
                            }

                            function St(e, t) {
                                for (var n = null == e ? 0 : e.length; n-- && !1 !== t(e[n], n, e););
                                return e
                            }

                            function Tt(e, t) {
                                for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
                                    if (!t(e[n], n, e)) return !1;
                                return !0
                            }

                            function Mt(e, t) {
                                for (var n = -1, i = null == e ? 0 : e.length, r = 0, s = []; ++n < i;) {
                                    var o = e[n];
                                    t(o, n, e) && (s[r++] = o)
                                }
                                return s
                            }

                            function It(e, t) {
                                return !(null == e || !e.length) && kt(e, t, 0) > -1
                            }

                            function Bt(e, t, n) {
                                for (var i = -1, r = null == e ? 0 : e.length; ++i < r;)
                                    if (n(t, e[i])) return !0;
                                return !1
                            }

                            function Rt(e, t) {
                                for (var n = -1, i = null == e ? 0 : e.length, r = Array(i); ++n < i;) r[n] = t(e[n], n, e);
                                return r
                            }

                            function Dt(e, t) {
                                for (var n = -1, i = t.length, r = e.length; ++n < i;) e[r + n] = t[n];
                                return e
                            }

                            function Pt(e, t, n, i) {
                                var r = -1,
                                    s = null == e ? 0 : e.length;
                                for (i && s && (n = e[++r]); ++r < s;) n = t(n, e[r], r, e);
                                return n
                            }

                            function Lt(e, t, n, i) {
                                var r = null == e ? 0 : e.length;
                                for (i && r && (n = e[--r]); r--;) n = t(n, e[r], r, e);
                                return n
                            }

                            function Ut(e, t) {
                                for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
                                    if (t(e[n], n, e)) return !0;
                                return !1
                            }
                            var Nt = Gt("length");

                            function Ot(e, t, n) {
                                var i;
                                return n(e, (function(e, n, r) {
                                    if (t(e, n, r)) return i = n, !1
                                })), i
                            }

                            function Ft(e, t, n, i) {
                                for (var r = e.length, s = n + (i ? 1 : -1); i ? s-- : ++s < r;)
                                    if (t(e[s], s, e)) return s;
                                return -1
                            }

                            function kt(e, t, n) {
                                return t == t ? function(e, t, n) {
                                    for (var i = n - 1, r = e.length; ++i < r;)
                                        if (e[i] === t) return i;
                                    return -1
                                }(e, t, n) : Ft(e, zt, n)
                            }

                            function Qt(e, t, n, i) {
                                for (var r = n - 1, s = e.length; ++r < s;)
                                    if (i(e[r], t)) return r;
                                return -1
                            }

                            function zt(e) {
                                return e != e
                            }

                            function Ht(e, t) {
                                var n = null == e ? 0 : e.length;
                                return n ? Wt(e, t) / n : d
                            }

                            function Gt(e) {
                                return function(t) {
                                    return null == t ? r : t[e]
                                }
                            }

                            function Vt(e) {
                                return function(t) {
                                    return null == e ? r : e[t]
                                }
                            }

                            function jt(e, t, n, i, r) {
                                return r(e, (function(e, r, s) {
                                    n = i ? (i = !1, e) : t(n, e, r, s)
                                })), n
                            }

                            function Wt(e, t) {
                                for (var n, i = -1, s = e.length; ++i < s;) {
                                    var o = t(e[i]);
                                    o !== r && (n = n === r ? o : n + o)
                                }
                                return n
                            }

                            function Xt(e, t) {
                                for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                                return i
                            }

                            function Yt(e) {
                                return e ? e.slice(0, hn(e) + 1).replace(ie, "") : e
                            }

                            function qt(e) {
                                return function(t) {
                                    return e(t)
                                }
                            }

                            function Kt(e, t) {
                                return Rt(t, (function(t) {
                                    return e[t]
                                }))
                            }

                            function Jt(e, t) {
                                return e.has(t)
                            }

                            function Zt(e, t) {
                                for (var n = -1, i = e.length; ++n < i && kt(t, e[n], 0) > -1;);
                                return n
                            }

                            function $t(e, t) {
                                for (var n = e.length; n-- && kt(t, e[n], 0) > -1;);
                                return n
                            }
                            var en = Vt({
                                    "À": "A",
                                    "Á": "A",
                                    "Â": "A",
                                    "Ã": "A",
                                    "Ä": "A",
                                    "Å": "A",
                                    "à": "a",
                                    "á": "a",
                                    "â": "a",
                                    "ã": "a",
                                    "ä": "a",
                                    "å": "a",
                                    "Ç": "C",
                                    "ç": "c",
                                    "Ð": "D",
                                    "ð": "d",
                                    "È": "E",
                                    "É": "E",
                                    "Ê": "E",
                                    "Ë": "E",
                                    "è": "e",
                                    "é": "e",
                                    "ê": "e",
                                    "ë": "e",
                                    "Ì": "I",
                                    "Í": "I",
                                    "Î": "I",
                                    "Ï": "I",
                                    "ì": "i",
                                    "í": "i",
                                    "î": "i",
                                    "ï": "i",
                                    "Ñ": "N",
                                    "ñ": "n",
                                    "Ò": "O",
                                    "Ó": "O",
                                    "Ô": "O",
                                    "Õ": "O",
                                    "Ö": "O",
                                    "Ø": "O",
                                    "ò": "o",
                                    "ó": "o",
                                    "ô": "o",
                                    "õ": "o",
                                    "ö": "o",
                                    "ø": "o",
                                    "Ù": "U",
                                    "Ú": "U",
                                    "Û": "U",
                                    "Ü": "U",
                                    "ù": "u",
                                    "ú": "u",
                                    "û": "u",
                                    "ü": "u",
                                    "Ý": "Y",
                                    "ý": "y",
                                    "ÿ": "y",
                                    "Æ": "Ae",
                                    "æ": "ae",
                                    "Þ": "Th",
                                    "þ": "th",
                                    "ß": "ss",
                                    "Ā": "A",
                                    "Ă": "A",
                                    "Ą": "A",
                                    "ā": "a",
                                    "ă": "a",
                                    "ą": "a",
                                    "Ć": "C",
                                    "Ĉ": "C",
                                    "Ċ": "C",
                                    "Č": "C",
                                    "ć": "c",
                                    "ĉ": "c",
                                    "ċ": "c",
                                    "č": "c",
                                    "Ď": "D",
                                    "Đ": "D",
                                    "ď": "d",
                                    "đ": "d",
                                    "Ē": "E",
                                    "Ĕ": "E",
                                    "Ė": "E",
                                    "Ę": "E",
                                    "Ě": "E",
                                    "ē": "e",
                                    "ĕ": "e",
                                    "ė": "e",
                                    "ę": "e",
                                    "ě": "e",
                                    "Ĝ": "G",
                                    "Ğ": "G",
                                    "Ġ": "G",
                                    "Ģ": "G",
                                    "ĝ": "g",
                                    "ğ": "g",
                                    "ġ": "g",
                                    "ģ": "g",
                                    "Ĥ": "H",
                                    "Ħ": "H",
                                    "ĥ": "h",
                                    "ħ": "h",
                                    "Ĩ": "I",
                                    "Ī": "I",
                                    "Ĭ": "I",
                                    "Į": "I",
                                    "İ": "I",
                                    "ĩ": "i",
                                    "ī": "i",
                                    "ĭ": "i",
                                    "į": "i",
                                    "ı": "i",
                                    "Ĵ": "J",
                                    "ĵ": "j",
                                    "Ķ": "K",
                                    "ķ": "k",
                                    "ĸ": "k",
                                    "Ĺ": "L",
                                    "Ļ": "L",
                                    "Ľ": "L",
                                    "Ŀ": "L",
                                    "Ł": "L",
                                    "ĺ": "l",
                                    "ļ": "l",
                                    "ľ": "l",
                                    "ŀ": "l",
                                    "ł": "l",
                                    "Ń": "N",
                                    "Ņ": "N",
                                    "Ň": "N",
                                    "Ŋ": "N",
                                    "ń": "n",
                                    "ņ": "n",
                                    "ň": "n",
                                    "ŋ": "n",
                                    "Ō": "O",
                                    "Ŏ": "O",
                                    "Ő": "O",
                                    "ō": "o",
                                    "ŏ": "o",
                                    "ő": "o",
                                    "Ŕ": "R",
                                    "Ŗ": "R",
                                    "Ř": "R",
                                    "ŕ": "r",
                                    "ŗ": "r",
                                    "ř": "r",
                                    "Ś": "S",
                                    "Ŝ": "S",
                                    "Ş": "S",
                                    "Š": "S",
                                    "ś": "s",
                                    "ŝ": "s",
                                    "ş": "s",
                                    "š": "s",
                                    "Ţ": "T",
                                    "Ť": "T",
                                    "Ŧ": "T",
                                    "ţ": "t",
                                    "ť": "t",
                                    "ŧ": "t",
                                    "Ũ": "U",
                                    "Ū": "U",
                                    "Ŭ": "U",
                                    "Ů": "U",
                                    "Ű": "U",
                                    "Ų": "U",
                                    "ũ": "u",
                                    "ū": "u",
                                    "ŭ": "u",
                                    "ů": "u",
                                    "ű": "u",
                                    "ų": "u",
                                    "Ŵ": "W",
                                    "ŵ": "w",
                                    "Ŷ": "Y",
                                    "ŷ": "y",
                                    "Ÿ": "Y",
                                    "Ź": "Z",
                                    "Ż": "Z",
                                    "Ž": "Z",
                                    "ź": "z",
                                    "ż": "z",
                                    "ž": "z",
                                    "Ĳ": "IJ",
                                    "ĳ": "ij",
                                    "Œ": "Oe",
                                    "œ": "oe",
                                    "ŉ": "'n",
                                    "ſ": "s"
                                }),
                                tn = Vt({
                                    "&": "&amp;",
                                    "<": "&lt;",
                                    ">": "&gt;",
                                    '"': "&quot;",
                                    "'": "&#39;"
                                });

                            function nn(e) {
                                return "\\" + ot[e]
                            }

                            function rn(e) {
                                return et.test(e)
                            }

                            function sn(e) {
                                var t = -1,
                                    n = Array(e.size);
                                return e.forEach((function(e, i) {
                                    n[++t] = [i, e]
                                })), n
                            }

                            function on(e, t) {
                                return function(n) {
                                    return e(t(n))
                                }
                            }

                            function an(e, t) {
                                for (var n = -1, i = e.length, r = 0, s = []; ++n < i;) {
                                    var o = e[n];
                                    o !== t && o !== a || (e[n] = a, s[r++] = n)
                                }
                                return s
                            }

                            function ln(e) {
                                var t = -1,
                                    n = Array(e.size);
                                return e.forEach((function(e) {
                                    n[++t] = e
                                })), n
                            }

                            function cn(e) {
                                return rn(e) ? function(e) {
                                    for (var t = Ze.lastIndex = 0; Ze.test(e);) ++t;
                                    return t
                                }(e) : Nt(e)
                            }

                            function un(e) {
                                return rn(e) ? function(e) {
                                    return e.match(Ze) || []
                                }(e) : function(e) {
                                    return e.split("")
                                }(e)
                            }

                            function hn(e) {
                                for (var t = e.length; t-- && re.test(e.charAt(t)););
                                return t
                            }
                            var dn = Vt({
                                    "&amp;": "&",
                                    "&lt;": "<",
                                    "&gt;": ">",
                                    "&quot;": '"',
                                    "&#39;": "'"
                                }),
                                fn = function e(t) {
                                    var n, i = (t = null == t ? ht : fn.defaults(ht.Object(), t, fn.pick(ht, nt))).Array,
                                        re = t.Date,
                                        xe = t.Error,
                                        Ee = t.Function,
                                        be = t.Math,
                                        we = t.Object,
                                        Ce = t.RegExp,
                                        Se = t.String,
                                        Te = t.TypeError,
                                        Me = i.prototype,
                                        Ie = Ee.prototype,
                                        Be = we.prototype,
                                        Re = t["__core-js_shared__"],
                                        De = Ie.toString,
                                        Pe = Be.hasOwnProperty,
                                        Le = 0,
                                        Ue = (n = /[^.]+$/.exec(Re && Re.keys && Re.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "",
                                        Ne = Be.toString,
                                        Oe = De.call(we),
                                        Fe = ht._,
                                        ke = Ce("^" + De.call(Pe).replace(te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                                        Qe = pt ? t.Buffer : r,
                                        ze = t.Symbol,
                                        He = t.Uint8Array,
                                        Ge = Qe ? Qe.allocUnsafe : r,
                                        Ve = on(we.getPrototypeOf, we),
                                        je = we.create,
                                        We = Be.propertyIsEnumerable,
                                        Xe = Me.splice,
                                        Ye = ze ? ze.isConcatSpreadable : r,
                                        qe = ze ? ze.iterator : r,
                                        Ze = ze ? ze.toStringTag : r,
                                        et = function() {
                                            try {
                                                var e = as(we, "defineProperty");
                                                return e({}, "", {}), e
                                            } catch (e) {}
                                        }(),
                                        ot = t.clearTimeout !== ht.clearTimeout && t.clearTimeout,
                                        ct = re && re.now !== ht.Date.now && re.now,
                                        ut = t.setTimeout !== ht.setTimeout && t.setTimeout,
                                        dt = be.ceil,
                                        ft = be.floor,
                                        mt = we.getOwnPropertySymbols,
                                        gt = Qe ? Qe.isBuffer : r,
                                        Nt = t.isFinite,
                                        Vt = Me.join,
                                        pn = on(we.keys, we),
                                        mn = be.max,
                                        gn = be.min,
                                        An = re.now,
                                        vn = t.parseInt,
                                        yn = be.random,
                                        _n = Me.reverse,
                                        xn = as(t, "DataView"),
                                        En = as(t, "Map"),
                                        bn = as(t, "Promise"),
                                        wn = as(t, "Set"),
                                        Cn = as(t, "WeakMap"),
                                        Sn = as(we, "create"),
                                        Tn = Cn && new Cn,
                                        Mn = {},
                                        In = Ps(xn),
                                        Bn = Ps(En),
                                        Rn = Ps(bn),
                                        Dn = Ps(wn),
                                        Pn = Ps(Cn),
                                        Ln = ze ? ze.prototype : r,
                                        Un = Ln ? Ln.valueOf : r,
                                        Nn = Ln ? Ln.toString : r;

                                    function On(e) {
                                        if (Jo(e) && !Qo(e) && !(e instanceof zn)) {
                                            if (e instanceof Qn) return e;
                                            if (Pe.call(e, "__wrapped__")) return Ls(e)
                                        }
                                        return new Qn(e)
                                    }
                                    var Fn = function() {
                                        function e() {}
                                        return function(t) {
                                            if (!Ko(t)) return {};
                                            if (je) return je(t);
                                            e.prototype = t;
                                            var n = new e;
                                            return e.prototype = r, n
                                        }
                                    }();

                                    function kn() {}

                                    function Qn(e, t) {
                                        this.__wrapped__ = e, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, this.__values__ = r
                                    }

                                    function zn(e) {
                                        this.__wrapped__ = e, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = f, this.__views__ = []
                                    }

                                    function Hn(e) {
                                        var t = -1,
                                            n = null == e ? 0 : e.length;
                                        for (this.clear(); ++t < n;) {
                                            var i = e[t];
                                            this.set(i[0], i[1])
                                        }
                                    }

                                    function Gn(e) {
                                        var t = -1,
                                            n = null == e ? 0 : e.length;
                                        for (this.clear(); ++t < n;) {
                                            var i = e[t];
                                            this.set(i[0], i[1])
                                        }
                                    }

                                    function Vn(e) {
                                        var t = -1,
                                            n = null == e ? 0 : e.length;
                                        for (this.clear(); ++t < n;) {
                                            var i = e[t];
                                            this.set(i[0], i[1])
                                        }
                                    }

                                    function jn(e) {
                                        var t = -1,
                                            n = null == e ? 0 : e.length;
                                        for (this.__data__ = new Vn; ++t < n;) this.add(e[t])
                                    }

                                    function Wn(e) {
                                        var t = this.__data__ = new Gn(e);
                                        this.size = t.size
                                    }

                                    function Xn(e, t) {
                                        var n = Qo(e),
                                            i = !n && ko(e),
                                            r = !n && !i && Vo(e),
                                            s = !n && !i && !r && sa(e),
                                            o = n || i || r || s,
                                            a = o ? Xt(e.length, Se) : [],
                                            l = a.length;
                                        for (var c in e) !t && !Pe.call(e, c) || o && ("length" == c || r && ("offset" == c || "parent" == c) || s && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || ps(c, l)) || a.push(c);
                                        return a
                                    }

                                    function Yn(e) {
                                        var t = e.length;
                                        return t ? e[Vi(0, t - 1)] : r
                                    }

                                    function qn(e, t) {
                                        return Bs(Cr(e), ri(t, 0, e.length))
                                    }

                                    function Kn(e) {
                                        return Bs(Cr(e))
                                    }

                                    function Jn(e, t, n) {
                                        (n !== r && !No(e[t], n) || n === r && !(t in e)) && ni(e, t, n)
                                    }

                                    function Zn(e, t, n) {
                                        var i = e[t];
                                        Pe.call(e, t) && No(i, n) && (n !== r || t in e) || ni(e, t, n)
                                    }

                                    function $n(e, t) {
                                        for (var n = e.length; n--;)
                                            if (No(e[n][0], t)) return n;
                                        return -1
                                    }

                                    function ei(e, t, n, i) {
                                        return ci(e, (function(e, r, s) {
                                            t(i, e, n(e), s)
                                        })), i
                                    }

                                    function ti(e, t) {
                                        return e && Sr(t, Ta(t), e)
                                    }

                                    function ni(e, t, n) {
                                        "__proto__" == t && et ? et(e, t, {
                                            configurable: !0,
                                            enumerable: !0,
                                            value: n,
                                            writable: !0
                                        }) : e[t] = n
                                    }

                                    function ii(e, t) {
                                        for (var n = -1, s = t.length, o = i(s), a = null == e; ++n < s;) o[n] = a ? r : Ea(e, t[n]);
                                        return o
                                    }

                                    function ri(e, t, n) {
                                        return e == e && (n !== r && (e = e <= n ? e : n), t !== r && (e = e >= t ? e : t)), e
                                    }

                                    function si(e, t, n, i, s, o) {
                                        var a, l = 1 & t,
                                            c = 2 & t,
                                            u = 4 & t;
                                        if (n && (a = s ? n(e, i, s, o) : n(e)), a !== r) return a;
                                        if (!Ko(e)) return e;
                                        var h = Qo(e);
                                        if (h) {
                                            if (a = function(e) {
                                                    var t = e.length,
                                                        n = new e.constructor(t);
                                                    return t && "string" == typeof e[0] && Pe.call(e, "index") && (n.index = e.index, n.input = e.input), n
                                                }(e), !l) return Cr(e, a)
                                        } else {
                                            var d = us(e),
                                                f = d == _ || d == x;
                                            if (Vo(e)) return yr(e, l);
                                            if (d == w || d == m || f && !s) {
                                                if (a = c || f ? {} : ds(e), !l) return c ? function(e, t) {
                                                    return Sr(e, cs(e), t)
                                                }(e, function(e, t) {
                                                    return e && Sr(t, Ma(t), e)
                                                }(a, e)) : function(e, t) {
                                                    return Sr(e, ls(e), t)
                                                }(e, ti(a, e))
                                            } else {
                                                if (!st[d]) return s ? e : {};
                                                a = function(e, t, n) {
                                                    var i, r = e.constructor;
                                                    switch (t) {
                                                        case R:
                                                            return _r(e);
                                                        case A:
                                                        case v:
                                                            return new r(+e);
                                                        case D:
                                                            return function(e, t) {
                                                                var n = t ? _r(e.buffer) : e.buffer;
                                                                return new e.constructor(n, e.byteOffset, e.byteLength)
                                                            }(e, n);
                                                        case P:
                                                        case L:
                                                        case U:
                                                        case N:
                                                        case O:
                                                        case F:
                                                        case k:
                                                        case Q:
                                                        case z:
                                                            return xr(e, n);
                                                        case E:
                                                            return new r;
                                                        case b:
                                                        case M:
                                                            return new r(e);
                                                        case S:
                                                            return function(e) {
                                                                var t = new e.constructor(e.source, de.exec(e));
                                                                return t.lastIndex = e.lastIndex, t
                                                            }(e);
                                                        case T:
                                                            return new r;
                                                        case I:
                                                            return i = e, Un ? we(Un.call(i)) : {}
                                                    }
                                                }(e, d, l)
                                            }
                                        }
                                        o || (o = new Wn);
                                        var p = o.get(e);
                                        if (p) return p;
                                        o.set(e, a), na(e) ? e.forEach((function(i) {
                                            a.add(si(i, t, n, i, e, o))
                                        })) : Zo(e) && e.forEach((function(i, r) {
                                            a.set(r, si(i, t, n, r, e, o))
                                        }));
                                        var g = h ? r : (u ? c ? es : $r : c ? Ma : Ta)(e);
                                        return Ct(g || e, (function(i, r) {
                                            g && (i = e[r = i]), Zn(a, r, si(i, t, n, r, e, o))
                                        })), a
                                    }

                                    function oi(e, t, n) {
                                        var i = n.length;
                                        if (null == e) return !i;
                                        for (e = we(e); i--;) {
                                            var s = n[i],
                                                o = t[s],
                                                a = e[s];
                                            if (a === r && !(s in e) || !o(a)) return !1
                                        }
                                        return !0
                                    }

                                    function ai(e, t, n) {
                                        if ("function" != typeof e) throw new Te(s);
                                        return Ss((function() {
                                            e.apply(r, n)
                                        }), t)
                                    }

                                    function li(e, t, n, i) {
                                        var r = -1,
                                            s = It,
                                            o = !0,
                                            a = e.length,
                                            l = [],
                                            c = t.length;
                                        if (!a) return l;
                                        n && (t = Rt(t, qt(n))), i ? (s = Bt, o = !1) : t.length >= 200 && (s = Jt, o = !1, t = new jn(t));
                                        e: for (; ++r < a;) {
                                            var u = e[r],
                                                h = null == n ? u : n(u);
                                            if (u = i || 0 !== u ? u : 0, o && h == h) {
                                                for (var d = c; d--;)
                                                    if (t[d] === h) continue e;
                                                l.push(u)
                                            } else s(t, h, i) || l.push(u)
                                        }
                                        return l
                                    }
                                    On.templateSettings = {
                                        escape: q,
                                        evaluate: K,
                                        interpolate: J,
                                        variable: "",
                                        imports: {
                                            _: On
                                        }
                                    }, On.prototype = kn.prototype, On.prototype.constructor = On, Qn.prototype = Fn(kn.prototype), Qn.prototype.constructor = Qn, zn.prototype = Fn(kn.prototype), zn.prototype.constructor = zn, Hn.prototype.clear = function() {
                                        this.__data__ = Sn ? Sn(null) : {}, this.size = 0
                                    }, Hn.prototype.delete = function(e) {
                                        var t = this.has(e) && delete this.__data__[e];
                                        return this.size -= t ? 1 : 0, t
                                    }, Hn.prototype.get = function(e) {
                                        var t = this.__data__;
                                        if (Sn) {
                                            var n = t[e];
                                            return n === o ? r : n
                                        }
                                        return Pe.call(t, e) ? t[e] : r
                                    }, Hn.prototype.has = function(e) {
                                        var t = this.__data__;
                                        return Sn ? t[e] !== r : Pe.call(t, e)
                                    }, Hn.prototype.set = function(e, t) {
                                        var n = this.__data__;
                                        return this.size += this.has(e) ? 0 : 1, n[e] = Sn && t === r ? o : t, this
                                    }, Gn.prototype.clear = function() {
                                        this.__data__ = [], this.size = 0
                                    }, Gn.prototype.delete = function(e) {
                                        var t = this.__data__,
                                            n = $n(t, e);
                                        return !(n < 0 || (n == t.length - 1 ? t.pop() : Xe.call(t, n, 1), --this.size, 0))
                                    }, Gn.prototype.get = function(e) {
                                        var t = this.__data__,
                                            n = $n(t, e);
                                        return n < 0 ? r : t[n][1]
                                    }, Gn.prototype.has = function(e) {
                                        return $n(this.__data__, e) > -1
                                    }, Gn.prototype.set = function(e, t) {
                                        var n = this.__data__,
                                            i = $n(n, e);
                                        return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
                                    }, Vn.prototype.clear = function() {
                                        this.size = 0, this.__data__ = {
                                            hash: new Hn,
                                            map: new(En || Gn),
                                            string: new Hn
                                        }
                                    }, Vn.prototype.delete = function(e) {
                                        var t = ss(this, e).delete(e);
                                        return this.size -= t ? 1 : 0, t
                                    }, Vn.prototype.get = function(e) {
                                        return ss(this, e).get(e)
                                    }, Vn.prototype.has = function(e) {
                                        return ss(this, e).has(e)
                                    }, Vn.prototype.set = function(e, t) {
                                        var n = ss(this, e),
                                            i = n.size;
                                        return n.set(e, t), this.size += n.size == i ? 0 : 1, this
                                    }, jn.prototype.add = jn.prototype.push = function(e) {
                                        return this.__data__.set(e, o), this
                                    }, jn.prototype.has = function(e) {
                                        return this.__data__.has(e)
                                    }, Wn.prototype.clear = function() {
                                        this.__data__ = new Gn, this.size = 0
                                    }, Wn.prototype.delete = function(e) {
                                        var t = this.__data__,
                                            n = t.delete(e);
                                        return this.size = t.size, n
                                    }, Wn.prototype.get = function(e) {
                                        return this.__data__.get(e)
                                    }, Wn.prototype.has = function(e) {
                                        return this.__data__.has(e)
                                    }, Wn.prototype.set = function(e, t) {
                                        var n = this.__data__;
                                        if (n instanceof Gn) {
                                            var i = n.__data__;
                                            if (!En || i.length < 199) return i.push([e, t]), this.size = ++n.size, this;
                                            n = this.__data__ = new Vn(i)
                                        }
                                        return n.set(e, t), this.size = n.size, this
                                    };
                                    var ci = Ir(Ai),
                                        ui = Ir(vi, !0);

                                    function hi(e, t) {
                                        var n = !0;
                                        return ci(e, (function(e, i, r) {
                                            return n = !!t(e, i, r)
                                        })), n
                                    }

                                    function di(e, t, n) {
                                        for (var i = -1, s = e.length; ++i < s;) {
                                            var o = e[i],
                                                a = t(o);
                                            if (null != a && (l === r ? a == a && !ra(a) : n(a, l))) var l = a,
                                                c = o
                                        }
                                        return c
                                    }

                                    function fi(e, t) {
                                        var n = [];
                                        return ci(e, (function(e, i, r) {
                                            t(e, i, r) && n.push(e)
                                        })), n
                                    }

                                    function pi(e, t, n, i, r) {
                                        var s = -1,
                                            o = e.length;
                                        for (n || (n = fs), r || (r = []); ++s < o;) {
                                            var a = e[s];
                                            t > 0 && n(a) ? t > 1 ? pi(a, t - 1, n, i, r) : Dt(r, a) : i || (r[r.length] = a)
                                        }
                                        return r
                                    }
                                    var mi = Br(),
                                        gi = Br(!0);

                                    function Ai(e, t) {
                                        return e && mi(e, t, Ta)
                                    }

                                    function vi(e, t) {
                                        return e && gi(e, t, Ta)
                                    }

                                    function yi(e, t) {
                                        return Mt(t, (function(t) {
                                            return Xo(e[t])
                                        }))
                                    }

                                    function _i(e, t) {
                                        for (var n = 0, i = (t = mr(t, e)).length; null != e && n < i;) e = e[Ds(t[n++])];
                                        return n && n == i ? e : r
                                    }

                                    function xi(e, t, n) {
                                        var i = t(e);
                                        return Qo(e) ? i : Dt(i, n(e))
                                    }

                                    function Ei(e) {
                                        return null == e ? e === r ? "[object Undefined]" : "[object Null]" : Ze && Ze in we(e) ? function(e) {
                                            var t = Pe.call(e, Ze),
                                                n = e[Ze];
                                            try {
                                                e[Ze] = r;
                                                var i = !0
                                            } catch (e) {}
                                            var s = Ne.call(e);
                                            return i && (t ? e[Ze] = n : delete e[Ze]), s
                                        }(e) : function(e) {
                                            return Ne.call(e)
                                        }(e)
                                    }

                                    function bi(e, t) {
                                        return e > t
                                    }

                                    function wi(e, t) {
                                        return null != e && Pe.call(e, t)
                                    }

                                    function Ci(e, t) {
                                        return null != e && t in we(e)
                                    }

                                    function Si(e, t, n) {
                                        for (var s = n ? Bt : It, o = e[0].length, a = e.length, l = a, c = i(a), u = 1 / 0, h = []; l--;) {
                                            var d = e[l];
                                            l && t && (d = Rt(d, qt(t))), u = gn(d.length, u), c[l] = !n && (t || o >= 120 && d.length >= 120) ? new jn(l && d) : r
                                        }
                                        d = e[0];
                                        var f = -1,
                                            p = c[0];
                                        e: for (; ++f < o && h.length < u;) {
                                            var m = d[f],
                                                g = t ? t(m) : m;
                                            if (m = n || 0 !== m ? m : 0, !(p ? Jt(p, g) : s(h, g, n))) {
                                                for (l = a; --l;) {
                                                    var A = c[l];
                                                    if (!(A ? Jt(A, g) : s(e[l], g, n))) continue e
                                                }
                                                p && p.push(g), h.push(m)
                                            }
                                        }
                                        return h
                                    }

                                    function Ti(e, t, n) {
                                        var i = null == (e = bs(e, t = mr(t, e))) ? e : e[Ds(js(t))];
                                        return null == i ? r : bt(i, e, n)
                                    }

                                    function Mi(e) {
                                        return Jo(e) && Ei(e) == m
                                    }

                                    function Ii(e, t, n, i, s) {
                                        return e === t || (null == e || null == t || !Jo(e) && !Jo(t) ? e != e && t != t : function(e, t, n, i, s, o) {
                                            var a = Qo(e),
                                                l = Qo(t),
                                                c = a ? g : us(e),
                                                u = l ? g : us(t),
                                                h = (c = c == m ? w : c) == w,
                                                d = (u = u == m ? w : u) == w,
                                                f = c == u;
                                            if (f && Vo(e)) {
                                                if (!Vo(t)) return !1;
                                                a = !0, h = !1
                                            }
                                            if (f && !h) return o || (o = new Wn), a || sa(e) ? Jr(e, t, n, i, s, o) : function(e, t, n, i, r, s, o) {
                                                switch (n) {
                                                    case D:
                                                        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                                                        e = e.buffer, t = t.buffer;
                                                    case R:
                                                        return !(e.byteLength != t.byteLength || !s(new He(e), new He(t)));
                                                    case A:
                                                    case v:
                                                    case b:
                                                        return No(+e, +t);
                                                    case y:
                                                        return e.name == t.name && e.message == t.message;
                                                    case S:
                                                    case M:
                                                        return e == t + "";
                                                    case E:
                                                        var a = sn;
                                                    case T:
                                                        var l = 1 & i;
                                                        if (a || (a = ln), e.size != t.size && !l) return !1;
                                                        var c = o.get(e);
                                                        if (c) return c == t;
                                                        i |= 2, o.set(e, t);
                                                        var u = Jr(a(e), a(t), i, r, s, o);
                                                        return o.delete(e), u;
                                                    case I:
                                                        if (Un) return Un.call(e) == Un.call(t)
                                                }
                                                return !1
                                            }(e, t, c, n, i, s, o);
                                            if (!(1 & n)) {
                                                var p = h && Pe.call(e, "__wrapped__"),
                                                    _ = d && Pe.call(t, "__wrapped__");
                                                if (p || _) {
                                                    var x = p ? e.value() : e,
                                                        C = _ ? t.value() : t;
                                                    return o || (o = new Wn), s(x, C, n, i, o)
                                                }
                                            }
                                            return !!f && (o || (o = new Wn), function(e, t, n, i, s, o) {
                                                var a = 1 & n,
                                                    l = $r(e),
                                                    c = l.length;
                                                if (c != $r(t).length && !a) return !1;
                                                for (var u = c; u--;) {
                                                    var h = l[u];
                                                    if (!(a ? h in t : Pe.call(t, h))) return !1
                                                }
                                                var d = o.get(e),
                                                    f = o.get(t);
                                                if (d && f) return d == t && f == e;
                                                var p = !0;
                                                o.set(e, t), o.set(t, e);
                                                for (var m = a; ++u < c;) {
                                                    var g = e[h = l[u]],
                                                        A = t[h];
                                                    if (i) var v = a ? i(A, g, h, t, e, o) : i(g, A, h, e, t, o);
                                                    if (!(v === r ? g === A || s(g, A, n, i, o) : v)) {
                                                        p = !1;
                                                        break
                                                    }
                                                    m || (m = "constructor" == h)
                                                }
                                                if (p && !m) {
                                                    var y = e.constructor,
                                                        _ = t.constructor;
                                                    y == _ || !("constructor" in e) || !("constructor" in t) || "function" == typeof y && y instanceof y && "function" == typeof _ && _ instanceof _ || (p = !1)
                                                }
                                                return o.delete(e), o.delete(t), p
                                            }(e, t, n, i, s, o))
                                        }(e, t, n, i, Ii, s))
                                    }

                                    function Bi(e, t, n, i) {
                                        var s = n.length,
                                            o = s,
                                            a = !i;
                                        if (null == e) return !o;
                                        for (e = we(e); s--;) {
                                            var l = n[s];
                                            if (a && l[2] ? l[1] !== e[l[0]] : !(l[0] in e)) return !1
                                        }
                                        for (; ++s < o;) {
                                            var c = (l = n[s])[0],
                                                u = e[c],
                                                h = l[1];
                                            if (a && l[2]) {
                                                if (u === r && !(c in e)) return !1
                                            } else {
                                                var d = new Wn;
                                                if (i) var f = i(u, h, c, e, t, d);
                                                if (!(f === r ? Ii(h, u, 3, i, d) : f)) return !1
                                            }
                                        }
                                        return !0
                                    }

                                    function Ri(e) {
                                        return !(!Ko(e) || (t = e, Ue && Ue in t)) && (Xo(e) ? ke : me).test(Ps(e));
                                        var t
                                    }

                                    function Di(e) {
                                        return "function" == typeof e ? e : null == e ? $a : "object" == typeof e ? Qo(e) ? Oi(e[0], e[1]) : Ni(e) : ll(e)
                                    }

                                    function Pi(e) {
                                        if (!ys(e)) return pn(e);
                                        var t = [];
                                        for (var n in we(e)) Pe.call(e, n) && "constructor" != n && t.push(n);
                                        return t
                                    }

                                    function Li(e, t) {
                                        return e < t
                                    }

                                    function Ui(e, t) {
                                        var n = -1,
                                            r = Ho(e) ? i(e.length) : [];
                                        return ci(e, (function(e, i, s) {
                                            r[++n] = t(e, i, s)
                                        })), r
                                    }

                                    function Ni(e) {
                                        var t = os(e);
                                        return 1 == t.length && t[0][2] ? xs(t[0][0], t[0][1]) : function(n) {
                                            return n === e || Bi(n, e, t)
                                        }
                                    }

                                    function Oi(e, t) {
                                        return gs(e) && _s(t) ? xs(Ds(e), t) : function(n) {
                                            var i = Ea(n, e);
                                            return i === r && i === t ? ba(n, e) : Ii(t, i, 3)
                                        }
                                    }

                                    function Fi(e, t, n, i, s) {
                                        e !== t && mi(t, (function(o, a) {
                                            if (s || (s = new Wn), Ko(o)) ! function(e, t, n, i, s, o, a) {
                                                var l = ws(e, n),
                                                    c = ws(t, n),
                                                    u = a.get(c);
                                                if (u) Jn(e, n, u);
                                                else {
                                                    var h = o ? o(l, c, n + "", e, t, a) : r,
                                                        d = h === r;
                                                    if (d) {
                                                        var f = Qo(c),
                                                            p = !f && Vo(c),
                                                            m = !f && !p && sa(c);
                                                        h = c, f || p || m ? Qo(l) ? h = l : Go(l) ? h = Cr(l) : p ? (d = !1, h = yr(c, !0)) : m ? (d = !1, h = xr(c, !0)) : h = [] : ea(c) || ko(c) ? (h = l, ko(l) ? h = fa(l) : Ko(l) && !Xo(l) || (h = ds(c))) : d = !1
                                                    }
                                                    d && (a.set(c, h), s(h, c, i, o, a), a.delete(c)), Jn(e, n, h)
                                                }
                                            }(e, t, a, n, Fi, i, s);
                                            else {
                                                var l = i ? i(ws(e, a), o, a + "", e, t, s) : r;
                                                l === r && (l = o), Jn(e, a, l)
                                            }
                                        }), Ma)
                                    }

                                    function ki(e, t) {
                                        var n = e.length;
                                        if (n) return ps(t += t < 0 ? n : 0, n) ? e[t] : r
                                    }

                                    function Qi(e, t, n) {
                                        t = t.length ? Rt(t, (function(e) {
                                            return Qo(e) ? function(t) {
                                                return _i(t, 1 === e.length ? e[0] : e)
                                            } : e
                                        })) : [$a];
                                        var i = -1;
                                        t = Rt(t, qt(rs()));
                                        var r = Ui(e, (function(e, n, r) {
                                            var s = Rt(t, (function(t) {
                                                return t(e)
                                            }));
                                            return {
                                                criteria: s,
                                                index: ++i,
                                                value: e
                                            }
                                        }));
                                        return function(e, t) {
                                            var n = e.length;
                                            for (e.sort(t); n--;) e[n] = e[n].value;
                                            return e
                                        }(r, (function(e, t) {
                                            return function(e, t, n) {
                                                for (var i = -1, r = e.criteria, s = t.criteria, o = r.length, a = n.length; ++i < o;) {
                                                    var l = Er(r[i], s[i]);
                                                    if (l) return i >= a ? l : l * ("desc" == n[i] ? -1 : 1)
                                                }
                                                return e.index - t.index
                                            }(e, t, n)
                                        }))
                                    }

                                    function zi(e, t, n) {
                                        for (var i = -1, r = t.length, s = {}; ++i < r;) {
                                            var o = t[i],
                                                a = _i(e, o);
                                            n(a, o) && qi(s, mr(o, e), a)
                                        }
                                        return s
                                    }

                                    function Hi(e, t, n, i) {
                                        var r = i ? Qt : kt,
                                            s = -1,
                                            o = t.length,
                                            a = e;
                                        for (e === t && (t = Cr(t)), n && (a = Rt(e, qt(n))); ++s < o;)
                                            for (var l = 0, c = t[s], u = n ? n(c) : c;
                                                (l = r(a, u, l, i)) > -1;) a !== e && Xe.call(a, l, 1), Xe.call(e, l, 1);
                                        return e
                                    }

                                    function Gi(e, t) {
                                        for (var n = e ? t.length : 0, i = n - 1; n--;) {
                                            var r = t[n];
                                            if (n == i || r !== s) {
                                                var s = r;
                                                ps(r) ? Xe.call(e, r, 1) : ar(e, r)
                                            }
                                        }
                                        return e
                                    }

                                    function Vi(e, t) {
                                        return e + ft(yn() * (t - e + 1))
                                    }

                                    function ji(e, t) {
                                        var n = "";
                                        if (!e || t < 1 || t > h) return n;
                                        do {
                                            t % 2 && (n += e), (t = ft(t / 2)) && (e += e)
                                        } while (t);
                                        return n
                                    }

                                    function Wi(e, t) {
                                        return Ts(Es(e, t, $a), e + "")
                                    }

                                    function Xi(e) {
                                        return Yn(Na(e))
                                    }

                                    function Yi(e, t) {
                                        var n = Na(e);
                                        return Bs(n, ri(t, 0, n.length))
                                    }

                                    function qi(e, t, n, i) {
                                        if (!Ko(e)) return e;
                                        for (var s = -1, o = (t = mr(t, e)).length, a = o - 1, l = e; null != l && ++s < o;) {
                                            var c = Ds(t[s]),
                                                u = n;
                                            if ("__proto__" === c || "constructor" === c || "prototype" === c) return e;
                                            if (s != a) {
                                                var h = l[c];
                                                (u = i ? i(h, c, l) : r) === r && (u = Ko(h) ? h : ps(t[s + 1]) ? [] : {})
                                            }
                                            Zn(l, c, u), l = l[c]
                                        }
                                        return e
                                    }
                                    var Ki = Tn ? function(e, t) {
                                            return Tn.set(e, t), e
                                        } : $a,
                                        Ji = et ? function(e, t) {
                                            return et(e, "toString", {
                                                configurable: !0,
                                                enumerable: !1,
                                                value: Ka(t),
                                                writable: !0
                                            })
                                        } : $a;

                                    function Zi(e) {
                                        return Bs(Na(e))
                                    }

                                    function $i(e, t, n) {
                                        var r = -1,
                                            s = e.length;
                                        t < 0 && (t = -t > s ? 0 : s + t), (n = n > s ? s : n) < 0 && (n += s), s = t > n ? 0 : n - t >>> 0, t >>>= 0;
                                        for (var o = i(s); ++r < s;) o[r] = e[r + t];
                                        return o
                                    }

                                    function er(e, t) {
                                        var n;
                                        return ci(e, (function(e, i, r) {
                                            return !(n = t(e, i, r))
                                        })), !!n
                                    }

                                    function tr(e, t, n) {
                                        var i = 0,
                                            r = null == e ? i : e.length;
                                        if ("number" == typeof t && t == t && r <= 2147483647) {
                                            for (; i < r;) {
                                                var s = i + r >>> 1,
                                                    o = e[s];
                                                null !== o && !ra(o) && (n ? o <= t : o < t) ? i = s + 1 : r = s
                                            }
                                            return r
                                        }
                                        return nr(e, t, $a, n)
                                    }

                                    function nr(e, t, n, i) {
                                        var s = 0,
                                            o = null == e ? 0 : e.length;
                                        if (0 === o) return 0;
                                        for (var a = (t = n(t)) != t, l = null === t, c = ra(t), u = t === r; s < o;) {
                                            var h = ft((s + o) / 2),
                                                d = n(e[h]),
                                                f = d !== r,
                                                p = null === d,
                                                m = d == d,
                                                g = ra(d);
                                            if (a) var A = i || m;
                                            else A = u ? m && (i || f) : l ? m && f && (i || !p) : c ? m && f && !p && (i || !g) : !p && !g && (i ? d <= t : d < t);
                                            A ? s = h + 1 : o = h
                                        }
                                        return gn(o, 4294967294)
                                    }

                                    function ir(e, t) {
                                        for (var n = -1, i = e.length, r = 0, s = []; ++n < i;) {
                                            var o = e[n],
                                                a = t ? t(o) : o;
                                            if (!n || !No(a, l)) {
                                                var l = a;
                                                s[r++] = 0 === o ? 0 : o
                                            }
                                        }
                                        return s
                                    }

                                    function rr(e) {
                                        return "number" == typeof e ? e : ra(e) ? d : +e
                                    }

                                    function sr(e) {
                                        if ("string" == typeof e) return e;
                                        if (Qo(e)) return Rt(e, sr) + "";
                                        if (ra(e)) return Nn ? Nn.call(e) : "";
                                        var t = e + "";
                                        return "0" == t && 1 / e == -1 / 0 ? "-0" : t
                                    }

                                    function or(e, t, n) {
                                        var i = -1,
                                            r = It,
                                            s = e.length,
                                            o = !0,
                                            a = [],
                                            l = a;
                                        if (n) o = !1, r = Bt;
                                        else if (s >= 200) {
                                            var c = t ? null : jr(e);
                                            if (c) return ln(c);
                                            o = !1, r = Jt, l = new jn
                                        } else l = t ? [] : a;
                                        e: for (; ++i < s;) {
                                            var u = e[i],
                                                h = t ? t(u) : u;
                                            if (u = n || 0 !== u ? u : 0, o && h == h) {
                                                for (var d = l.length; d--;)
                                                    if (l[d] === h) continue e;
                                                t && l.push(h), a.push(u)
                                            } else r(l, h, n) || (l !== a && l.push(h), a.push(u))
                                        }
                                        return a
                                    }

                                    function ar(e, t) {
                                        return null == (e = bs(e, t = mr(t, e))) || delete e[Ds(js(t))]
                                    }

                                    function lr(e, t, n, i) {
                                        return qi(e, t, n(_i(e, t)), i)
                                    }

                                    function cr(e, t, n, i) {
                                        for (var r = e.length, s = i ? r : -1;
                                            (i ? s-- : ++s < r) && t(e[s], s, e););
                                        return n ? $i(e, i ? 0 : s, i ? s + 1 : r) : $i(e, i ? s + 1 : 0, i ? r : s)
                                    }

                                    function ur(e, t) {
                                        var n = e;
                                        return n instanceof zn && (n = n.value()), Pt(t, (function(e, t) {
                                            return t.func.apply(t.thisArg, Dt([e], t.args))
                                        }), n)
                                    }

                                    function hr(e, t, n) {
                                        var r = e.length;
                                        if (r < 2) return r ? or(e[0]) : [];
                                        for (var s = -1, o = i(r); ++s < r;)
                                            for (var a = e[s], l = -1; ++l < r;) l != s && (o[s] = li(o[s] || a, e[l], t, n));
                                        return or(pi(o, 1), t, n)
                                    }

                                    function dr(e, t, n) {
                                        for (var i = -1, s = e.length, o = t.length, a = {}; ++i < s;) {
                                            var l = i < o ? t[i] : r;
                                            n(a, e[i], l)
                                        }
                                        return a
                                    }

                                    function fr(e) {
                                        return Go(e) ? e : []
                                    }

                                    function pr(e) {
                                        return "function" == typeof e ? e : $a
                                    }

                                    function mr(e, t) {
                                        return Qo(e) ? e : gs(e, t) ? [e] : Rs(pa(e))
                                    }
                                    var gr = Wi;

                                    function Ar(e, t, n) {
                                        var i = e.length;
                                        return n = n === r ? i : n, !t && n >= i ? e : $i(e, t, n)
                                    }
                                    var vr = ot || function(e) {
                                        return ht.clearTimeout(e)
                                    };

                                    function yr(e, t) {
                                        if (t) return e.slice();
                                        var n = e.length,
                                            i = Ge ? Ge(n) : new e.constructor(n);
                                        return e.copy(i), i
                                    }

                                    function _r(e) {
                                        var t = new e.constructor(e.byteLength);
                                        return new He(t).set(new He(e)), t
                                    }

                                    function xr(e, t) {
                                        var n = t ? _r(e.buffer) : e.buffer;
                                        return new e.constructor(n, e.byteOffset, e.length)
                                    }

                                    function Er(e, t) {
                                        if (e !== t) {
                                            var n = e !== r,
                                                i = null === e,
                                                s = e == e,
                                                o = ra(e),
                                                a = t !== r,
                                                l = null === t,
                                                c = t == t,
                                                u = ra(t);
                                            if (!l && !u && !o && e > t || o && a && c && !l && !u || i && a && c || !n && c || !s) return 1;
                                            if (!i && !o && !u && e < t || u && n && s && !i && !o || l && n && s || !a && s || !c) return -1
                                        }
                                        return 0
                                    }

                                    function br(e, t, n, r) {
                                        for (var s = -1, o = e.length, a = n.length, l = -1, c = t.length, u = mn(o - a, 0), h = i(c + u), d = !r; ++l < c;) h[l] = t[l];
                                        for (; ++s < a;)(d || s < o) && (h[n[s]] = e[s]);
                                        for (; u--;) h[l++] = e[s++];
                                        return h
                                    }

                                    function wr(e, t, n, r) {
                                        for (var s = -1, o = e.length, a = -1, l = n.length, c = -1, u = t.length, h = mn(o - l, 0), d = i(h + u), f = !r; ++s < h;) d[s] = e[s];
                                        for (var p = s; ++c < u;) d[p + c] = t[c];
                                        for (; ++a < l;)(f || s < o) && (d[p + n[a]] = e[s++]);
                                        return d
                                    }

                                    function Cr(e, t) {
                                        var n = -1,
                                            r = e.length;
                                        for (t || (t = i(r)); ++n < r;) t[n] = e[n];
                                        return t
                                    }

                                    function Sr(e, t, n, i) {
                                        var s = !n;
                                        n || (n = {});
                                        for (var o = -1, a = t.length; ++o < a;) {
                                            var l = t[o],
                                                c = i ? i(n[l], e[l], l, n, e) : r;
                                            c === r && (c = e[l]), s ? ni(n, l, c) : Zn(n, l, c)
                                        }
                                        return n
                                    }

                                    function Tr(e, t) {
                                        return function(n, i) {
                                            var r = Qo(n) ? wt : ei,
                                                s = t ? t() : {};
                                            return r(n, e, rs(i, 2), s)
                                        }
                                    }

                                    function Mr(e) {
                                        return Wi((function(t, n) {
                                            var i = -1,
                                                s = n.length,
                                                o = s > 1 ? n[s - 1] : r,
                                                a = s > 2 ? n[2] : r;
                                            for (o = e.length > 3 && "function" == typeof o ? (s--, o) : r, a && ms(n[0], n[1], a) && (o = s < 3 ? r : o, s = 1), t = we(t); ++i < s;) {
                                                var l = n[i];
                                                l && e(t, l, i, o)
                                            }
                                            return t
                                        }))
                                    }

                                    function Ir(e, t) {
                                        return function(n, i) {
                                            if (null == n) return n;
                                            if (!Ho(n)) return e(n, i);
                                            for (var r = n.length, s = t ? r : -1, o = we(n);
                                                (t ? s-- : ++s < r) && !1 !== i(o[s], s, o););
                                            return n
                                        }
                                    }

                                    function Br(e) {
                                        return function(t, n, i) {
                                            for (var r = -1, s = we(t), o = i(t), a = o.length; a--;) {
                                                var l = o[e ? a : ++r];
                                                if (!1 === n(s[l], l, s)) break
                                            }
                                            return t
                                        }
                                    }

                                    function Rr(e) {
                                        return function(t) {
                                            var n = rn(t = pa(t)) ? un(t) : r,
                                                i = n ? n[0] : t.charAt(0),
                                                s = n ? Ar(n, 1).join("") : t.slice(1);
                                            return i[e]() + s
                                        }
                                    }

                                    function Dr(e) {
                                        return function(t) {
                                            return Pt(Xa(ka(t).replace(Ke, "")), e, "")
                                        }
                                    }

                                    function Pr(e) {
                                        return function() {
                                            var t = arguments;
                                            switch (t.length) {
                                                case 0:
                                                    return new e;
                                                case 1:
                                                    return new e(t[0]);
                                                case 2:
                                                    return new e(t[0], t[1]);
                                                case 3:
                                                    return new e(t[0], t[1], t[2]);
                                                case 4:
                                                    return new e(t[0], t[1], t[2], t[3]);
                                                case 5:
                                                    return new e(t[0], t[1], t[2], t[3], t[4]);
                                                case 6:
                                                    return new e(t[0], t[1], t[2], t[3], t[4], t[5]);
                                                case 7:
                                                    return new e(t[0], t[1], t[2], t[3], t[4], t[5], t[6])
                                            }
                                            var n = Fn(e.prototype),
                                                i = e.apply(n, t);
                                            return Ko(i) ? i : n
                                        }
                                    }

                                    function Lr(e) {
                                        return function(t, n, i) {
                                            var s = we(t);
                                            if (!Ho(t)) {
                                                var o = rs(n, 3);
                                                t = Ta(t), n = function(e) {
                                                    return o(s[e], e, s)
                                                }
                                            }
                                            var a = e(t, n, i);
                                            return a > -1 ? s[o ? t[a] : a] : r
                                        }
                                    }

                                    function Ur(e) {
                                        return Zr((function(t) {
                                            var n = t.length,
                                                i = n,
                                                o = Qn.prototype.thru;
                                            for (e && t.reverse(); i--;) {
                                                var a = t[i];
                                                if ("function" != typeof a) throw new Te(s);
                                                if (o && !l && "wrapper" == ns(a)) var l = new Qn([], !0)
                                            }
                                            for (i = l ? i : n; ++i < n;) {
                                                var c = ns(a = t[i]),
                                                    u = "wrapper" == c ? ts(a) : r;
                                                l = u && As(u[0]) && 424 == u[1] && !u[4].length && 1 == u[9] ? l[ns(u[0])].apply(l, u[3]) : 1 == a.length && As(a) ? l[c]() : l.thru(a)
                                            }
                                            return function() {
                                                var e = arguments,
                                                    i = e[0];
                                                if (l && 1 == e.length && Qo(i)) return l.plant(i).value();
                                                for (var r = 0, s = n ? t[r].apply(this, e) : i; ++r < n;) s = t[r].call(this, s);
                                                return s
                                            }
                                        }))
                                    }

                                    function Nr(e, t, n, s, o, a, l, u, h, d) {
                                        var f = t & c,
                                            p = 1 & t,
                                            m = 2 & t,
                                            g = 24 & t,
                                            A = 512 & t,
                                            v = m ? r : Pr(e);
                                        return function c() {
                                            for (var y = arguments.length, _ = i(y), x = y; x--;) _[x] = arguments[x];
                                            if (g) var E = is(c),
                                                b = function(e, t) {
                                                    for (var n = e.length, i = 0; n--;) e[n] === t && ++i;
                                                    return i
                                                }(_, E);
                                            if (s && (_ = br(_, s, o, g)), a && (_ = wr(_, a, l, g)), y -= b, g && y < d) {
                                                var w = an(_, E);
                                                return Gr(e, t, Nr, c.placeholder, n, _, w, u, h, d - y)
                                            }
                                            var C = p ? n : this,
                                                S = m ? C[e] : e;
                                            return y = _.length, u ? _ = function(e, t) {
                                                for (var n = e.length, i = gn(t.length, n), s = Cr(e); i--;) {
                                                    var o = t[i];
                                                    e[i] = ps(o, n) ? s[o] : r
                                                }
                                                return e
                                            }(_, u) : A && y > 1 && _.reverse(), f && h < y && (_.length = h), this && this !== ht && this instanceof c && (S = v || Pr(S)), S.apply(C, _)
                                        }
                                    }

                                    function Or(e, t) {
                                        return function(n, i) {
                                            return function(e, t, n, i) {
                                                return Ai(e, (function(e, r, s) {
                                                    t(i, n(e), r, s)
                                                })), i
                                            }(n, e, t(i), {})
                                        }
                                    }

                                    function Fr(e, t) {
                                        return function(n, i) {
                                            var s;
                                            if (n === r && i === r) return t;
                                            if (n !== r && (s = n), i !== r) {
                                                if (s === r) return i;
                                                "string" == typeof n || "string" == typeof i ? (n = sr(n), i = sr(i)) : (n = rr(n), i = rr(i)), s = e(n, i)
                                            }
                                            return s
                                        }
                                    }

                                    function kr(e) {
                                        return Zr((function(t) {
                                            return t = Rt(t, qt(rs())), Wi((function(n) {
                                                var i = this;
                                                return e(t, (function(e) {
                                                    return bt(e, i, n)
                                                }))
                                            }))
                                        }))
                                    }

                                    function Qr(e, t) {
                                        var n = (t = t === r ? " " : sr(t)).length;
                                        if (n < 2) return n ? ji(t, e) : t;
                                        var i = ji(t, dt(e / cn(t)));
                                        return rn(t) ? Ar(un(i), 0, e).join("") : i.slice(0, e)
                                    }

                                    function zr(e) {
                                        return function(t, n, s) {
                                            return s && "number" != typeof s && ms(t, n, s) && (n = s = r), t = ca(t), n === r ? (n = t, t = 0) : n = ca(n),
                                                function(e, t, n, r) {
                                                    for (var s = -1, o = mn(dt((t - e) / (n || 1)), 0), a = i(o); o--;) a[r ? o : ++s] = e, e += n;
                                                    return a
                                                }(t, n, s = s === r ? t < n ? 1 : -1 : ca(s), e)
                                        }
                                    }

                                    function Hr(e) {
                                        return function(t, n) {
                                            return "string" == typeof t && "string" == typeof n || (t = da(t), n = da(n)), e(t, n)
                                        }
                                    }

                                    function Gr(e, t, n, i, s, o, a, c, u, h) {
                                        var d = 8 & t;
                                        t |= d ? l : 64, 4 & (t &= ~(d ? 64 : l)) || (t &= -4);
                                        var f = [e, t, s, d ? o : r, d ? a : r, d ? r : o, d ? r : a, c, u, h],
                                            p = n.apply(r, f);
                                        return As(e) && Cs(p, f), p.placeholder = i, Ms(p, e, t)
                                    }

                                    function Vr(e) {
                                        var t = be[e];
                                        return function(e, n) {
                                            if (e = da(e), (n = null == n ? 0 : gn(ua(n), 292)) && Nt(e)) {
                                                var i = (pa(e) + "e").split("e");
                                                return +((i = (pa(t(i[0] + "e" + (+i[1] + n))) + "e").split("e"))[0] + "e" + (+i[1] - n))
                                            }
                                            return t(e)
                                        }
                                    }
                                    var jr = wn && 1 / ln(new wn([, -0]))[1] == u ? function(e) {
                                        return new wn(e)
                                    } : rl;

                                    function Wr(e) {
                                        return function(t) {
                                            var n = us(t);
                                            return n == E ? sn(t) : n == T ? function(e) {
                                                var t = -1,
                                                    n = Array(e.size);
                                                return e.forEach((function(e) {
                                                    n[++t] = [e, e]
                                                })), n
                                            }(t) : function(e, t) {
                                                return Rt(t, (function(t) {
                                                    return [t, e[t]]
                                                }))
                                            }(t, e(t))
                                        }
                                    }

                                    function Xr(e, t, n, o, u, h, d, f) {
                                        var p = 2 & t;
                                        if (!p && "function" != typeof e) throw new Te(s);
                                        var m = o ? o.length : 0;
                                        if (m || (t &= -97, o = u = r), d = d === r ? d : mn(ua(d), 0), f = f === r ? f : ua(f), m -= u ? u.length : 0, 64 & t) {
                                            var g = o,
                                                A = u;
                                            o = u = r
                                        }
                                        var v = p ? r : ts(e),
                                            y = [e, t, n, o, u, g, A, h, d, f];
                                        if (v && function(e, t) {
                                                var n = e[1],
                                                    i = t[1],
                                                    r = n | i,
                                                    s = r < 131,
                                                    o = i == c && 8 == n || i == c && 256 == n && e[7].length <= t[8] || 384 == i && t[7].length <= t[8] && 8 == n;
                                                if (!s && !o) return e;
                                                1 & i && (e[2] = t[2], r |= 1 & n ? 0 : 4);
                                                var l = t[3];
                                                if (l) {
                                                    var u = e[3];
                                                    e[3] = u ? br(u, l, t[4]) : l, e[4] = u ? an(e[3], a) : t[4]
                                                }(l = t[5]) && (u = e[5], e[5] = u ? wr(u, l, t[6]) : l, e[6] = u ? an(e[5], a) : t[6]), (l = t[7]) && (e[7] = l), i & c && (e[8] = null == e[8] ? t[8] : gn(e[8], t[8])), null == e[9] && (e[9] = t[9]), e[0] = t[0], e[1] = r
                                            }(y, v), e = y[0], t = y[1], n = y[2], o = y[3], u = y[4], !(f = y[9] = y[9] === r ? p ? 0 : e.length : mn(y[9] - m, 0)) && 24 & t && (t &= -25), t && 1 != t) _ = 8 == t || 16 == t ? function(e, t, n) {
                                            var s = Pr(e);
                                            return function o() {
                                                for (var a = arguments.length, l = i(a), c = a, u = is(o); c--;) l[c] = arguments[c];
                                                var h = a < 3 && l[0] !== u && l[a - 1] !== u ? [] : an(l, u);
                                                return (a -= h.length) < n ? Gr(e, t, Nr, o.placeholder, r, l, h, r, r, n - a) : bt(this && this !== ht && this instanceof o ? s : e, this, l)
                                            }
                                        }(e, t, f) : t != l && 33 != t || u.length ? Nr.apply(r, y) : function(e, t, n, r) {
                                            var s = 1 & t,
                                                o = Pr(e);
                                            return function t() {
                                                for (var a = -1, l = arguments.length, c = -1, u = r.length, h = i(u + l), d = this && this !== ht && this instanceof t ? o : e; ++c < u;) h[c] = r[c];
                                                for (; l--;) h[c++] = arguments[++a];
                                                return bt(d, s ? n : this, h)
                                            }
                                        }(e, t, n, o);
                                        else var _ = function(e, t, n) {
                                            var i = 1 & t,
                                                r = Pr(e);
                                            return function t() {
                                                return (this && this !== ht && this instanceof t ? r : e).apply(i ? n : this, arguments)
                                            }
                                        }(e, t, n);
                                        return Ms((v ? Ki : Cs)(_, y), e, t)
                                    }

                                    function Yr(e, t, n, i) {
                                        return e === r || No(e, Be[n]) && !Pe.call(i, n) ? t : e
                                    }

                                    function qr(e, t, n, i, s, o) {
                                        return Ko(e) && Ko(t) && (o.set(t, e), Fi(e, t, r, qr, o), o.delete(t)), e
                                    }

                                    function Kr(e) {
                                        return ea(e) ? r : e
                                    }

                                    function Jr(e, t, n, i, s, o) {
                                        var a = 1 & n,
                                            l = e.length,
                                            c = t.length;
                                        if (l != c && !(a && c > l)) return !1;
                                        var u = o.get(e),
                                            h = o.get(t);
                                        if (u && h) return u == t && h == e;
                                        var d = -1,
                                            f = !0,
                                            p = 2 & n ? new jn : r;
                                        for (o.set(e, t), o.set(t, e); ++d < l;) {
                                            var m = e[d],
                                                g = t[d];
                                            if (i) var A = a ? i(g, m, d, t, e, o) : i(m, g, d, e, t, o);
                                            if (A !== r) {
                                                if (A) continue;
                                                f = !1;
                                                break
                                            }
                                            if (p) {
                                                if (!Ut(t, (function(e, t) {
                                                        if (!Jt(p, t) && (m === e || s(m, e, n, i, o))) return p.push(t)
                                                    }))) {
                                                    f = !1;
                                                    break
                                                }
                                            } else if (m !== g && !s(m, g, n, i, o)) {
                                                f = !1;
                                                break
                                            }
                                        }
                                        return o.delete(e), o.delete(t), f
                                    }

                                    function Zr(e) {
                                        return Ts(Es(e, r, Qs), e + "")
                                    }

                                    function $r(e) {
                                        return xi(e, Ta, ls)
                                    }

                                    function es(e) {
                                        return xi(e, Ma, cs)
                                    }
                                    var ts = Tn ? function(e) {
                                        return Tn.get(e)
                                    } : rl;

                                    function ns(e) {
                                        for (var t = e.name + "", n = Mn[t], i = Pe.call(Mn, t) ? n.length : 0; i--;) {
                                            var r = n[i],
                                                s = r.func;
                                            if (null == s || s == e) return r.name
                                        }
                                        return t
                                    }

                                    function is(e) {
                                        return (Pe.call(On, "placeholder") ? On : e).placeholder
                                    }

                                    function rs() {
                                        var e = On.iteratee || el;
                                        return e = e === el ? Di : e, arguments.length ? e(arguments[0], arguments[1]) : e
                                    }

                                    function ss(e, t) {
                                        var n, i, r = e.__data__;
                                        return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? r["string" == typeof t ? "string" : "hash"] : r.map
                                    }

                                    function os(e) {
                                        for (var t = Ta(e), n = t.length; n--;) {
                                            var i = t[n],
                                                r = e[i];
                                            t[n] = [i, r, _s(r)]
                                        }
                                        return t
                                    }

                                    function as(e, t) {
                                        var n = function(e, t) {
                                            return null == e ? r : e[t]
                                        }(e, t);
                                        return Ri(n) ? n : r
                                    }
                                    var ls = mt ? function(e) {
                                            return null == e ? [] : (e = we(e), Mt(mt(e), (function(t) {
                                                return We.call(e, t)
                                            })))
                                        } : hl,
                                        cs = mt ? function(e) {
                                            for (var t = []; e;) Dt(t, ls(e)), e = Ve(e);
                                            return t
                                        } : hl,
                                        us = Ei;

                                    function hs(e, t, n) {
                                        for (var i = -1, r = (t = mr(t, e)).length, s = !1; ++i < r;) {
                                            var o = Ds(t[i]);
                                            if (!(s = null != e && n(e, o))) break;
                                            e = e[o]
                                        }
                                        return s || ++i != r ? s : !!(r = null == e ? 0 : e.length) && qo(r) && ps(o, r) && (Qo(e) || ko(e))
                                    }

                                    function ds(e) {
                                        return "function" != typeof e.constructor || ys(e) ? {} : Fn(Ve(e))
                                    }

                                    function fs(e) {
                                        return Qo(e) || ko(e) || !!(Ye && e && e[Ye])
                                    }

                                    function ps(e, t) {
                                        var n = typeof e;
                                        return !!(t = null == t ? h : t) && ("number" == n || "symbol" != n && Ae.test(e)) && e > -1 && e % 1 == 0 && e < t
                                    }

                                    function ms(e, t, n) {
                                        if (!Ko(n)) return !1;
                                        var i = typeof t;
                                        return !!("number" == i ? Ho(n) && ps(t, n.length) : "string" == i && t in n) && No(n[t], e)
                                    }

                                    function gs(e, t) {
                                        if (Qo(e)) return !1;
                                        var n = typeof e;
                                        return !("number" != n && "symbol" != n && "boolean" != n && null != e && !ra(e)) || $.test(e) || !Z.test(e) || null != t && e in we(t)
                                    }

                                    function As(e) {
                                        var t = ns(e),
                                            n = On[t];
                                        if ("function" != typeof n || !(t in zn.prototype)) return !1;
                                        if (e === n) return !0;
                                        var i = ts(n);
                                        return !!i && e === i[0]
                                    }(xn && us(new xn(new ArrayBuffer(1))) != D || En && us(new En) != E || bn && us(bn.resolve()) != C || wn && us(new wn) != T || Cn && us(new Cn) != B) && (us = function(e) {
                                        var t = Ei(e),
                                            n = t == w ? e.constructor : r,
                                            i = n ? Ps(n) : "";
                                        if (i) switch (i) {
                                            case In:
                                                return D;
                                            case Bn:
                                                return E;
                                            case Rn:
                                                return C;
                                            case Dn:
                                                return T;
                                            case Pn:
                                                return B
                                        }
                                        return t
                                    });
                                    var vs = Re ? Xo : dl;

                                    function ys(e) {
                                        var t = e && e.constructor;
                                        return e === ("function" == typeof t && t.prototype || Be)
                                    }

                                    function _s(e) {
                                        return e == e && !Ko(e)
                                    }

                                    function xs(e, t) {
                                        return function(n) {
                                            return null != n && n[e] === t && (t !== r || e in we(n))
                                        }
                                    }

                                    function Es(e, t, n) {
                                        return t = mn(t === r ? e.length - 1 : t, 0),
                                            function() {
                                                for (var r = arguments, s = -1, o = mn(r.length - t, 0), a = i(o); ++s < o;) a[s] = r[t + s];
                                                s = -1;
                                                for (var l = i(t + 1); ++s < t;) l[s] = r[s];
                                                return l[t] = n(a), bt(e, this, l)
                                            }
                                    }

                                    function bs(e, t) {
                                        return t.length < 2 ? e : _i(e, $i(t, 0, -1))
                                    }

                                    function ws(e, t) {
                                        if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t) return e[t]
                                    }
                                    var Cs = Is(Ki),
                                        Ss = ut || function(e, t) {
                                            return ht.setTimeout(e, t)
                                        },
                                        Ts = Is(Ji);

                                    function Ms(e, t, n) {
                                        var i = t + "";
                                        return Ts(e, function(e, t) {
                                            var n = t.length;
                                            if (!n) return e;
                                            var i = n - 1;
                                            return t[i] = (n > 1 ? "& " : "") + t[i], t = t.join(n > 2 ? ", " : " "), e.replace(se, "{\n/* [wrapped with " + t + "] */\n")
                                        }(i, function(e, t) {
                                            return Ct(p, (function(n) {
                                                var i = "_." + n[0];
                                                t & n[1] && !It(e, i) && e.push(i)
                                            })), e.sort()
                                        }(function(e) {
                                            var t = e.match(oe);
                                            return t ? t[1].split(ae) : []
                                        }(i), n)))
                                    }

                                    function Is(e) {
                                        var t = 0,
                                            n = 0;
                                        return function() {
                                            var i = An(),
                                                s = 16 - (i - n);
                                            if (n = i, s > 0) {
                                                if (++t >= 800) return arguments[0]
                                            } else t = 0;
                                            return e.apply(r, arguments)
                                        }
                                    }

                                    function Bs(e, t) {
                                        var n = -1,
                                            i = e.length,
                                            s = i - 1;
                                        for (t = t === r ? i : t; ++n < t;) {
                                            var o = Vi(n, s),
                                                a = e[o];
                                            e[o] = e[n], e[n] = a
                                        }
                                        return e.length = t, e
                                    }
                                    var Rs = function(e) {
                                        var t = Bo((function(e) {
                                                var t = [];
                                                return 46 === e.charCodeAt(0) && t.push(""), e.replace(ee, (function(e, n, i, r) {
                                                    t.push(i ? r.replace(ue, "$1") : n || e)
                                                })), t
                                            }), (function(e) {
                                                return 500 === n.size && n.clear(), e
                                            })),
                                            n = t.cache;
                                        return t
                                    }();

                                    function Ds(e) {
                                        if ("string" == typeof e || ra(e)) return e;
                                        var t = e + "";
                                        return "0" == t && 1 / e == -1 / 0 ? "-0" : t
                                    }

                                    function Ps(e) {
                                        if (null != e) {
                                            try {
                                                return De.call(e)
                                            } catch (e) {}
                                            try {
                                                return e + ""
                                            } catch (e) {}
                                        }
                                        return ""
                                    }

                                    function Ls(e) {
                                        if (e instanceof zn) return e.clone();
                                        var t = new Qn(e.__wrapped__, e.__chain__);
                                        return t.__actions__ = Cr(e.__actions__), t.__index__ = e.__index__, t.__values__ = e.__values__, t
                                    }
                                    var Us = Wi((function(e, t) {
                                            return Go(e) ? li(e, pi(t, 1, Go, !0)) : []
                                        })),
                                        Ns = Wi((function(e, t) {
                                            var n = js(t);
                                            return Go(n) && (n = r), Go(e) ? li(e, pi(t, 1, Go, !0), rs(n, 2)) : []
                                        })),
                                        Os = Wi((function(e, t) {
                                            var n = js(t);
                                            return Go(n) && (n = r), Go(e) ? li(e, pi(t, 1, Go, !0), r, n) : []
                                        }));

                                    function Fs(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        if (!i) return -1;
                                        var r = null == n ? 0 : ua(n);
                                        return r < 0 && (r = mn(i + r, 0)), Ft(e, rs(t, 3), r)
                                    }

                                    function ks(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        if (!i) return -1;
                                        var s = i - 1;
                                        return n !== r && (s = ua(n), s = n < 0 ? mn(i + s, 0) : gn(s, i - 1)), Ft(e, rs(t, 3), s, !0)
                                    }

                                    function Qs(e) {
                                        return null != e && e.length ? pi(e, 1) : []
                                    }

                                    function zs(e) {
                                        return e && e.length ? e[0] : r
                                    }
                                    var Hs = Wi((function(e) {
                                            var t = Rt(e, fr);
                                            return t.length && t[0] === e[0] ? Si(t) : []
                                        })),
                                        Gs = Wi((function(e) {
                                            var t = js(e),
                                                n = Rt(e, fr);
                                            return t === js(n) ? t = r : n.pop(), n.length && n[0] === e[0] ? Si(n, rs(t, 2)) : []
                                        })),
                                        Vs = Wi((function(e) {
                                            var t = js(e),
                                                n = Rt(e, fr);
                                            return (t = "function" == typeof t ? t : r) && n.pop(), n.length && n[0] === e[0] ? Si(n, r, t) : []
                                        }));

                                    function js(e) {
                                        var t = null == e ? 0 : e.length;
                                        return t ? e[t - 1] : r
                                    }
                                    var Ws = Wi(Xs);

                                    function Xs(e, t) {
                                        return e && e.length && t && t.length ? Hi(e, t) : e
                                    }
                                    var Ys = Zr((function(e, t) {
                                        var n = null == e ? 0 : e.length,
                                            i = ii(e, t);
                                        return Gi(e, Rt(t, (function(e) {
                                            return ps(e, n) ? +e : e
                                        })).sort(Er)), i
                                    }));

                                    function qs(e) {
                                        return null == e ? e : _n.call(e)
                                    }
                                    var Ks = Wi((function(e) {
                                            return or(pi(e, 1, Go, !0))
                                        })),
                                        Js = Wi((function(e) {
                                            var t = js(e);
                                            return Go(t) && (t = r), or(pi(e, 1, Go, !0), rs(t, 2))
                                        })),
                                        Zs = Wi((function(e) {
                                            var t = js(e);
                                            return t = "function" == typeof t ? t : r, or(pi(e, 1, Go, !0), r, t)
                                        }));

                                    function $s(e) {
                                        if (!e || !e.length) return [];
                                        var t = 0;
                                        return e = Mt(e, (function(e) {
                                            if (Go(e)) return t = mn(e.length, t), !0
                                        })), Xt(t, (function(t) {
                                            return Rt(e, Gt(t))
                                        }))
                                    }

                                    function eo(e, t) {
                                        if (!e || !e.length) return [];
                                        var n = $s(e);
                                        return null == t ? n : Rt(n, (function(e) {
                                            return bt(t, r, e)
                                        }))
                                    }
                                    var to = Wi((function(e, t) {
                                            return Go(e) ? li(e, t) : []
                                        })),
                                        no = Wi((function(e) {
                                            return hr(Mt(e, Go))
                                        })),
                                        io = Wi((function(e) {
                                            var t = js(e);
                                            return Go(t) && (t = r), hr(Mt(e, Go), rs(t, 2))
                                        })),
                                        ro = Wi((function(e) {
                                            var t = js(e);
                                            return t = "function" == typeof t ? t : r, hr(Mt(e, Go), r, t)
                                        })),
                                        so = Wi($s),
                                        oo = Wi((function(e) {
                                            var t = e.length,
                                                n = t > 1 ? e[t - 1] : r;
                                            return n = "function" == typeof n ? (e.pop(), n) : r, eo(e, n)
                                        }));

                                    function ao(e) {
                                        var t = On(e);
                                        return t.__chain__ = !0, t
                                    }

                                    function lo(e, t) {
                                        return t(e)
                                    }
                                    var co = Zr((function(e) {
                                            var t = e.length,
                                                n = t ? e[0] : 0,
                                                i = this.__wrapped__,
                                                s = function(t) {
                                                    return ii(t, e)
                                                };
                                            return !(t > 1 || this.__actions__.length) && i instanceof zn && ps(n) ? ((i = i.slice(n, +n + (t ? 1 : 0))).__actions__.push({
                                                func: lo,
                                                args: [s],
                                                thisArg: r
                                            }), new Qn(i, this.__chain__).thru((function(e) {
                                                return t && !e.length && e.push(r), e
                                            }))) : this.thru(s)
                                        })),
                                        uo = Tr((function(e, t, n) {
                                            Pe.call(e, n) ? ++e[n] : ni(e, n, 1)
                                        })),
                                        ho = Lr(Fs),
                                        fo = Lr(ks);

                                    function po(e, t) {
                                        return (Qo(e) ? Ct : ci)(e, rs(t, 3))
                                    }

                                    function mo(e, t) {
                                        return (Qo(e) ? St : ui)(e, rs(t, 3))
                                    }
                                    var go = Tr((function(e, t, n) {
                                            Pe.call(e, n) ? e[n].push(t) : ni(e, n, [t])
                                        })),
                                        Ao = Wi((function(e, t, n) {
                                            var r = -1,
                                                s = "function" == typeof t,
                                                o = Ho(e) ? i(e.length) : [];
                                            return ci(e, (function(e) {
                                                o[++r] = s ? bt(t, e, n) : Ti(e, t, n)
                                            })), o
                                        })),
                                        vo = Tr((function(e, t, n) {
                                            ni(e, n, t)
                                        }));

                                    function yo(e, t) {
                                        return (Qo(e) ? Rt : Ui)(e, rs(t, 3))
                                    }
                                    var _o = Tr((function(e, t, n) {
                                            e[n ? 0 : 1].push(t)
                                        }), (function() {
                                            return [
                                                [],
                                                []
                                            ]
                                        })),
                                        xo = Wi((function(e, t) {
                                            if (null == e) return [];
                                            var n = t.length;
                                            return n > 1 && ms(e, t[0], t[1]) ? t = [] : n > 2 && ms(t[0], t[1], t[2]) && (t = [t[0]]), Qi(e, pi(t, 1), [])
                                        })),
                                        Eo = ct || function() {
                                            return ht.Date.now()
                                        };

                                    function bo(e, t, n) {
                                        return t = n ? r : t, t = e && null == t ? e.length : t, Xr(e, c, r, r, r, r, t)
                                    }

                                    function wo(e, t) {
                                        var n;
                                        if ("function" != typeof t) throw new Te(s);
                                        return e = ua(e),
                                            function() {
                                                return --e > 0 && (n = t.apply(this, arguments)), e <= 1 && (t = r), n
                                            }
                                    }
                                    var Co = Wi((function(e, t, n) {
                                            var i = 1;
                                            if (n.length) {
                                                var r = an(n, is(Co));
                                                i |= l
                                            }
                                            return Xr(e, i, t, n, r)
                                        })),
                                        So = Wi((function(e, t, n) {
                                            var i = 3;
                                            if (n.length) {
                                                var r = an(n, is(So));
                                                i |= l
                                            }
                                            return Xr(t, i, e, n, r)
                                        }));

                                    function To(e, t, n) {
                                        var i, o, a, l, c, u, h = 0,
                                            d = !1,
                                            f = !1,
                                            p = !0;
                                        if ("function" != typeof e) throw new Te(s);

                                        function m(t) {
                                            var n = i,
                                                s = o;
                                            return i = o = r, h = t, l = e.apply(s, n)
                                        }

                                        function g(e) {
                                            var n = e - u;
                                            return u === r || n >= t || n < 0 || f && e - h >= a
                                        }

                                        function A() {
                                            var e = Eo();
                                            if (g(e)) return v(e);
                                            c = Ss(A, function(e) {
                                                var n = t - (e - u);
                                                return f ? gn(n, a - (e - h)) : n
                                            }(e))
                                        }

                                        function v(e) {
                                            return c = r, p && i ? m(e) : (i = o = r, l)
                                        }

                                        function y() {
                                            var e = Eo(),
                                                n = g(e);
                                            if (i = arguments, o = this, u = e, n) {
                                                if (c === r) return function(e) {
                                                    return h = e, c = Ss(A, t), d ? m(e) : l
                                                }(u);
                                                if (f) return vr(c), c = Ss(A, t), m(u)
                                            }
                                            return c === r && (c = Ss(A, t)), l
                                        }
                                        return t = da(t) || 0, Ko(n) && (d = !!n.leading, a = (f = "maxWait" in n) ? mn(da(n.maxWait) || 0, t) : a, p = "trailing" in n ? !!n.trailing : p), y.cancel = function() {
                                            c !== r && vr(c), h = 0, i = u = o = c = r
                                        }, y.flush = function() {
                                            return c === r ? l : v(Eo())
                                        }, y
                                    }
                                    var Mo = Wi((function(e, t) {
                                            return ai(e, 1, t)
                                        })),
                                        Io = Wi((function(e, t, n) {
                                            return ai(e, da(t) || 0, n)
                                        }));

                                    function Bo(e, t) {
                                        if ("function" != typeof e || null != t && "function" != typeof t) throw new Te(s);
                                        var n = function() {
                                            var i = arguments,
                                                r = t ? t.apply(this, i) : i[0],
                                                s = n.cache;
                                            if (s.has(r)) return s.get(r);
                                            var o = e.apply(this, i);
                                            return n.cache = s.set(r, o) || s, o
                                        };
                                        return n.cache = new(Bo.Cache || Vn), n
                                    }

                                    function Ro(e) {
                                        if ("function" != typeof e) throw new Te(s);
                                        return function() {
                                            var t = arguments;
                                            switch (t.length) {
                                                case 0:
                                                    return !e.call(this);
                                                case 1:
                                                    return !e.call(this, t[0]);
                                                case 2:
                                                    return !e.call(this, t[0], t[1]);
                                                case 3:
                                                    return !e.call(this, t[0], t[1], t[2])
                                            }
                                            return !e.apply(this, t)
                                        }
                                    }
                                    Bo.Cache = Vn;
                                    var Do = gr((function(e, t) {
                                            var n = (t = 1 == t.length && Qo(t[0]) ? Rt(t[0], qt(rs())) : Rt(pi(t, 1), qt(rs()))).length;
                                            return Wi((function(i) {
                                                for (var r = -1, s = gn(i.length, n); ++r < s;) i[r] = t[r].call(this, i[r]);
                                                return bt(e, this, i)
                                            }))
                                        })),
                                        Po = Wi((function(e, t) {
                                            var n = an(t, is(Po));
                                            return Xr(e, l, r, t, n)
                                        })),
                                        Lo = Wi((function(e, t) {
                                            var n = an(t, is(Lo));
                                            return Xr(e, 64, r, t, n)
                                        })),
                                        Uo = Zr((function(e, t) {
                                            return Xr(e, 256, r, r, r, t)
                                        }));

                                    function No(e, t) {
                                        return e === t || e != e && t != t
                                    }
                                    var Oo = Hr(bi),
                                        Fo = Hr((function(e, t) {
                                            return e >= t
                                        })),
                                        ko = Mi(function() {
                                            return arguments
                                        }()) ? Mi : function(e) {
                                            return Jo(e) && Pe.call(e, "callee") && !We.call(e, "callee")
                                        },
                                        Qo = i.isArray,
                                        zo = At ? qt(At) : function(e) {
                                            return Jo(e) && Ei(e) == R
                                        };

                                    function Ho(e) {
                                        return null != e && qo(e.length) && !Xo(e)
                                    }

                                    function Go(e) {
                                        return Jo(e) && Ho(e)
                                    }
                                    var Vo = gt || dl,
                                        jo = vt ? qt(vt) : function(e) {
                                            return Jo(e) && Ei(e) == v
                                        };

                                    function Wo(e) {
                                        if (!Jo(e)) return !1;
                                        var t = Ei(e);
                                        return t == y || "[object DOMException]" == t || "string" == typeof e.message && "string" == typeof e.name && !ea(e)
                                    }

                                    function Xo(e) {
                                        if (!Ko(e)) return !1;
                                        var t = Ei(e);
                                        return t == _ || t == x || "[object AsyncFunction]" == t || "[object Proxy]" == t
                                    }

                                    function Yo(e) {
                                        return "number" == typeof e && e == ua(e)
                                    }

                                    function qo(e) {
                                        return "number" == typeof e && e > -1 && e % 1 == 0 && e <= h
                                    }

                                    function Ko(e) {
                                        var t = typeof e;
                                        return null != e && ("object" == t || "function" == t)
                                    }

                                    function Jo(e) {
                                        return null != e && "object" == typeof e
                                    }
                                    var Zo = yt ? qt(yt) : function(e) {
                                        return Jo(e) && us(e) == E
                                    };

                                    function $o(e) {
                                        return "number" == typeof e || Jo(e) && Ei(e) == b
                                    }

                                    function ea(e) {
                                        if (!Jo(e) || Ei(e) != w) return !1;
                                        var t = Ve(e);
                                        if (null === t) return !0;
                                        var n = Pe.call(t, "constructor") && t.constructor;
                                        return "function" == typeof n && n instanceof n && De.call(n) == Oe
                                    }
                                    var ta = _t ? qt(_t) : function(e) {
                                            return Jo(e) && Ei(e) == S
                                        },
                                        na = xt ? qt(xt) : function(e) {
                                            return Jo(e) && us(e) == T
                                        };

                                    function ia(e) {
                                        return "string" == typeof e || !Qo(e) && Jo(e) && Ei(e) == M
                                    }

                                    function ra(e) {
                                        return "symbol" == typeof e || Jo(e) && Ei(e) == I
                                    }
                                    var sa = Et ? qt(Et) : function(e) {
                                            return Jo(e) && qo(e.length) && !!rt[Ei(e)]
                                        },
                                        oa = Hr(Li),
                                        aa = Hr((function(e, t) {
                                            return e <= t
                                        }));

                                    function la(e) {
                                        if (!e) return [];
                                        if (Ho(e)) return ia(e) ? un(e) : Cr(e);
                                        if (qe && e[qe]) return function(e) {
                                            for (var t, n = []; !(t = e.next()).done;) n.push(t.value);
                                            return n
                                        }(e[qe]());
                                        var t = us(e);
                                        return (t == E ? sn : t == T ? ln : Na)(e)
                                    }

                                    function ca(e) {
                                        return e ? (e = da(e)) === u || e === -1 / 0 ? 17976931348623157e292 * (e < 0 ? -1 : 1) : e == e ? e : 0 : 0 === e ? e : 0
                                    }

                                    function ua(e) {
                                        var t = ca(e),
                                            n = t % 1;
                                        return t == t ? n ? t - n : t : 0
                                    }

                                    function ha(e) {
                                        return e ? ri(ua(e), 0, f) : 0
                                    }

                                    function da(e) {
                                        if ("number" == typeof e) return e;
                                        if (ra(e)) return d;
                                        if (Ko(e)) {
                                            var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                                            e = Ko(t) ? t + "" : t
                                        }
                                        if ("string" != typeof e) return 0 === e ? e : +e;
                                        e = Yt(e);
                                        var n = pe.test(e);
                                        return n || ge.test(e) ? lt(e.slice(2), n ? 2 : 8) : fe.test(e) ? d : +e
                                    }

                                    function fa(e) {
                                        return Sr(e, Ma(e))
                                    }

                                    function pa(e) {
                                        return null == e ? "" : sr(e)
                                    }
                                    var ma = Mr((function(e, t) {
                                            if (ys(t) || Ho(t)) Sr(t, Ta(t), e);
                                            else
                                                for (var n in t) Pe.call(t, n) && Zn(e, n, t[n])
                                        })),
                                        ga = Mr((function(e, t) {
                                            Sr(t, Ma(t), e)
                                        })),
                                        Aa = Mr((function(e, t, n, i) {
                                            Sr(t, Ma(t), e, i)
                                        })),
                                        va = Mr((function(e, t, n, i) {
                                            Sr(t, Ta(t), e, i)
                                        })),
                                        ya = Zr(ii),
                                        _a = Wi((function(e, t) {
                                            e = we(e);
                                            var n = -1,
                                                i = t.length,
                                                s = i > 2 ? t[2] : r;
                                            for (s && ms(t[0], t[1], s) && (i = 1); ++n < i;)
                                                for (var o = t[n], a = Ma(o), l = -1, c = a.length; ++l < c;) {
                                                    var u = a[l],
                                                        h = e[u];
                                                    (h === r || No(h, Be[u]) && !Pe.call(e, u)) && (e[u] = o[u])
                                                }
                                            return e
                                        })),
                                        xa = Wi((function(e) {
                                            return e.push(r, qr), bt(Ba, r, e)
                                        }));

                                    function Ea(e, t, n) {
                                        var i = null == e ? r : _i(e, t);
                                        return i === r ? n : i
                                    }

                                    function ba(e, t) {
                                        return null != e && hs(e, t, Ci)
                                    }
                                    var wa = Or((function(e, t, n) {
                                            null != t && "function" != typeof t.toString && (t = Ne.call(t)), e[t] = n
                                        }), Ka($a)),
                                        Ca = Or((function(e, t, n) {
                                            null != t && "function" != typeof t.toString && (t = Ne.call(t)), Pe.call(e, t) ? e[t].push(n) : e[t] = [n]
                                        }), rs),
                                        Sa = Wi(Ti);

                                    function Ta(e) {
                                        return Ho(e) ? Xn(e) : Pi(e)
                                    }

                                    function Ma(e) {
                                        return Ho(e) ? Xn(e, !0) : function(e) {
                                            if (!Ko(e)) return function(e) {
                                                var t = [];
                                                if (null != e)
                                                    for (var n in we(e)) t.push(n);
                                                return t
                                            }(e);
                                            var t = ys(e),
                                                n = [];
                                            for (var i in e)("constructor" != i || !t && Pe.call(e, i)) && n.push(i);
                                            return n
                                        }(e)
                                    }
                                    var Ia = Mr((function(e, t, n) {
                                            Fi(e, t, n)
                                        })),
                                        Ba = Mr((function(e, t, n, i) {
                                            Fi(e, t, n, i)
                                        })),
                                        Ra = Zr((function(e, t) {
                                            var n = {};
                                            if (null == e) return n;
                                            var i = !1;
                                            t = Rt(t, (function(t) {
                                                return t = mr(t, e), i || (i = t.length > 1), t
                                            })), Sr(e, es(e), n), i && (n = si(n, 7, Kr));
                                            for (var r = t.length; r--;) ar(n, t[r]);
                                            return n
                                        })),
                                        Da = Zr((function(e, t) {
                                            return null == e ? {} : function(e, t) {
                                                return zi(e, t, (function(t, n) {
                                                    return ba(e, n)
                                                }))
                                            }(e, t)
                                        }));

                                    function Pa(e, t) {
                                        if (null == e) return {};
                                        var n = Rt(es(e), (function(e) {
                                            return [e]
                                        }));
                                        return t = rs(t), zi(e, n, (function(e, n) {
                                            return t(e, n[0])
                                        }))
                                    }
                                    var La = Wr(Ta),
                                        Ua = Wr(Ma);

                                    function Na(e) {
                                        return null == e ? [] : Kt(e, Ta(e))
                                    }
                                    var Oa = Dr((function(e, t, n) {
                                        return t = t.toLowerCase(), e + (n ? Fa(t) : t)
                                    }));

                                    function Fa(e) {
                                        return Wa(pa(e).toLowerCase())
                                    }

                                    function ka(e) {
                                        return (e = pa(e)) && e.replace(ve, en).replace(Je, "")
                                    }
                                    var Qa = Dr((function(e, t, n) {
                                            return e + (n ? "-" : "") + t.toLowerCase()
                                        })),
                                        za = Dr((function(e, t, n) {
                                            return e + (n ? " " : "") + t.toLowerCase()
                                        })),
                                        Ha = Rr("toLowerCase"),
                                        Ga = Dr((function(e, t, n) {
                                            return e + (n ? "_" : "") + t.toLowerCase()
                                        })),
                                        Va = Dr((function(e, t, n) {
                                            return e + (n ? " " : "") + Wa(t)
                                        })),
                                        ja = Dr((function(e, t, n) {
                                            return e + (n ? " " : "") + t.toUpperCase()
                                        })),
                                        Wa = Rr("toUpperCase");

                                    function Xa(e, t, n) {
                                        return e = pa(e), (t = n ? r : t) === r ? function(e) {
                                            return tt.test(e)
                                        }(e) ? function(e) {
                                            return e.match($e) || []
                                        }(e) : function(e) {
                                            return e.match(le) || []
                                        }(e) : e.match(t) || []
                                    }
                                    var Ya = Wi((function(e, t) {
                                            try {
                                                return bt(e, r, t)
                                            } catch (e) {
                                                return Wo(e) ? e : new xe(e)
                                            }
                                        })),
                                        qa = Zr((function(e, t) {
                                            return Ct(t, (function(t) {
                                                t = Ds(t), ni(e, t, Co(e[t], e))
                                            })), e
                                        }));

                                    function Ka(e) {
                                        return function() {
                                            return e
                                        }
                                    }
                                    var Ja = Ur(),
                                        Za = Ur(!0);

                                    function $a(e) {
                                        return e
                                    }

                                    function el(e) {
                                        return Di("function" == typeof e ? e : si(e, 1))
                                    }
                                    var tl = Wi((function(e, t) {
                                            return function(n) {
                                                return Ti(n, e, t)
                                            }
                                        })),
                                        nl = Wi((function(e, t) {
                                            return function(n) {
                                                return Ti(e, n, t)
                                            }
                                        }));

                                    function il(e, t, n) {
                                        var i = Ta(t),
                                            r = yi(t, i);
                                        null != n || Ko(t) && (r.length || !i.length) || (n = t, t = e, e = this, r = yi(t, Ta(t)));
                                        var s = !(Ko(n) && "chain" in n && !n.chain),
                                            o = Xo(e);
                                        return Ct(r, (function(n) {
                                            var i = t[n];
                                            e[n] = i, o && (e.prototype[n] = function() {
                                                var t = this.__chain__;
                                                if (s || t) {
                                                    var n = e(this.__wrapped__);
                                                    return (n.__actions__ = Cr(this.__actions__)).push({
                                                        func: i,
                                                        args: arguments,
                                                        thisArg: e
                                                    }), n.__chain__ = t, n
                                                }
                                                return i.apply(e, Dt([this.value()], arguments))
                                            })
                                        })), e
                                    }

                                    function rl() {}
                                    var sl = kr(Rt),
                                        ol = kr(Tt),
                                        al = kr(Ut);

                                    function ll(e) {
                                        return gs(e) ? Gt(Ds(e)) : function(e) {
                                            return function(t) {
                                                return _i(t, e)
                                            }
                                        }(e)
                                    }
                                    var cl = zr(),
                                        ul = zr(!0);

                                    function hl() {
                                        return []
                                    }

                                    function dl() {
                                        return !1
                                    }
                                    var fl, pl = Fr((function(e, t) {
                                            return e + t
                                        }), 0),
                                        ml = Vr("ceil"),
                                        gl = Fr((function(e, t) {
                                            return e / t
                                        }), 1),
                                        Al = Vr("floor"),
                                        vl = Fr((function(e, t) {
                                            return e * t
                                        }), 1),
                                        yl = Vr("round"),
                                        _l = Fr((function(e, t) {
                                            return e - t
                                        }), 0);
                                    return On.after = function(e, t) {
                                        if ("function" != typeof t) throw new Te(s);
                                        return e = ua(e),
                                            function() {
                                                if (--e < 1) return t.apply(this, arguments)
                                            }
                                    }, On.ary = bo, On.assign = ma, On.assignIn = ga, On.assignInWith = Aa, On.assignWith = va, On.at = ya, On.before = wo, On.bind = Co, On.bindAll = qa, On.bindKey = So, On.castArray = function() {
                                        if (!arguments.length) return [];
                                        var e = arguments[0];
                                        return Qo(e) ? e : [e]
                                    }, On.chain = ao, On.chunk = function(e, t, n) {
                                        t = (n ? ms(e, t, n) : t === r) ? 1 : mn(ua(t), 0);
                                        var s = null == e ? 0 : e.length;
                                        if (!s || t < 1) return [];
                                        for (var o = 0, a = 0, l = i(dt(s / t)); o < s;) l[a++] = $i(e, o, o += t);
                                        return l
                                    }, On.compact = function(e) {
                                        for (var t = -1, n = null == e ? 0 : e.length, i = 0, r = []; ++t < n;) {
                                            var s = e[t];
                                            s && (r[i++] = s)
                                        }
                                        return r
                                    }, On.concat = function() {
                                        var e = arguments.length;
                                        if (!e) return [];
                                        for (var t = i(e - 1), n = arguments[0], r = e; r--;) t[r - 1] = arguments[r];
                                        return Dt(Qo(n) ? Cr(n) : [n], pi(t, 1))
                                    }, On.cond = function(e) {
                                        var t = null == e ? 0 : e.length,
                                            n = rs();
                                        return e = t ? Rt(e, (function(e) {
                                            if ("function" != typeof e[1]) throw new Te(s);
                                            return [n(e[0]), e[1]]
                                        })) : [], Wi((function(n) {
                                            for (var i = -1; ++i < t;) {
                                                var r = e[i];
                                                if (bt(r[0], this, n)) return bt(r[1], this, n)
                                            }
                                        }))
                                    }, On.conforms = function(e) {
                                        return function(e) {
                                            var t = Ta(e);
                                            return function(n) {
                                                return oi(n, e, t)
                                            }
                                        }(si(e, 1))
                                    }, On.constant = Ka, On.countBy = uo, On.create = function(e, t) {
                                        var n = Fn(e);
                                        return null == t ? n : ti(n, t)
                                    }, On.curry = function e(t, n, i) {
                                        var s = Xr(t, 8, r, r, r, r, r, n = i ? r : n);
                                        return s.placeholder = e.placeholder, s
                                    }, On.curryRight = function e(t, n, i) {
                                        var s = Xr(t, 16, r, r, r, r, r, n = i ? r : n);
                                        return s.placeholder = e.placeholder, s
                                    }, On.debounce = To, On.defaults = _a, On.defaultsDeep = xa, On.defer = Mo, On.delay = Io, On.difference = Us, On.differenceBy = Ns, On.differenceWith = Os, On.drop = function(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        return i ? $i(e, (t = n || t === r ? 1 : ua(t)) < 0 ? 0 : t, i) : []
                                    }, On.dropRight = function(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        return i ? $i(e, 0, (t = i - (t = n || t === r ? 1 : ua(t))) < 0 ? 0 : t) : []
                                    }, On.dropRightWhile = function(e, t) {
                                        return e && e.length ? cr(e, rs(t, 3), !0, !0) : []
                                    }, On.dropWhile = function(e, t) {
                                        return e && e.length ? cr(e, rs(t, 3), !0) : []
                                    }, On.fill = function(e, t, n, i) {
                                        var s = null == e ? 0 : e.length;
                                        return s ? (n && "number" != typeof n && ms(e, t, n) && (n = 0, i = s), function(e, t, n, i) {
                                            var s = e.length;
                                            for ((n = ua(n)) < 0 && (n = -n > s ? 0 : s + n), (i = i === r || i > s ? s : ua(i)) < 0 && (i += s), i = n > i ? 0 : ha(i); n < i;) e[n++] = t;
                                            return e
                                        }(e, t, n, i)) : []
                                    }, On.filter = function(e, t) {
                                        return (Qo(e) ? Mt : fi)(e, rs(t, 3))
                                    }, On.flatMap = function(e, t) {
                                        return pi(yo(e, t), 1)
                                    }, On.flatMapDeep = function(e, t) {
                                        return pi(yo(e, t), u)
                                    }, On.flatMapDepth = function(e, t, n) {
                                        return n = n === r ? 1 : ua(n), pi(yo(e, t), n)
                                    }, On.flatten = Qs, On.flattenDeep = function(e) {
                                        return null != e && e.length ? pi(e, u) : []
                                    }, On.flattenDepth = function(e, t) {
                                        return null != e && e.length ? pi(e, t = t === r ? 1 : ua(t)) : []
                                    }, On.flip = function(e) {
                                        return Xr(e, 512)
                                    }, On.flow = Ja, On.flowRight = Za, On.fromPairs = function(e) {
                                        for (var t = -1, n = null == e ? 0 : e.length, i = {}; ++t < n;) {
                                            var r = e[t];
                                            i[r[0]] = r[1]
                                        }
                                        return i
                                    }, On.functions = function(e) {
                                        return null == e ? [] : yi(e, Ta(e))
                                    }, On.functionsIn = function(e) {
                                        return null == e ? [] : yi(e, Ma(e))
                                    }, On.groupBy = go, On.initial = function(e) {
                                        return null != e && e.length ? $i(e, 0, -1) : []
                                    }, On.intersection = Hs, On.intersectionBy = Gs, On.intersectionWith = Vs, On.invert = wa, On.invertBy = Ca, On.invokeMap = Ao, On.iteratee = el, On.keyBy = vo, On.keys = Ta, On.keysIn = Ma, On.map = yo, On.mapKeys = function(e, t) {
                                        var n = {};
                                        return t = rs(t, 3), Ai(e, (function(e, i, r) {
                                            ni(n, t(e, i, r), e)
                                        })), n
                                    }, On.mapValues = function(e, t) {
                                        var n = {};
                                        return t = rs(t, 3), Ai(e, (function(e, i, r) {
                                            ni(n, i, t(e, i, r))
                                        })), n
                                    }, On.matches = function(e) {
                                        return Ni(si(e, 1))
                                    }, On.matchesProperty = function(e, t) {
                                        return Oi(e, si(t, 1))
                                    }, On.memoize = Bo, On.merge = Ia, On.mergeWith = Ba, On.method = tl, On.methodOf = nl, On.mixin = il, On.negate = Ro, On.nthArg = function(e) {
                                        return e = ua(e), Wi((function(t) {
                                            return ki(t, e)
                                        }))
                                    }, On.omit = Ra, On.omitBy = function(e, t) {
                                        return Pa(e, Ro(rs(t)))
                                    }, On.once = function(e) {
                                        return wo(2, e)
                                    }, On.orderBy = function(e, t, n, i) {
                                        return null == e ? [] : (Qo(t) || (t = null == t ? [] : [t]), Qo(n = i ? r : n) || (n = null == n ? [] : [n]), Qi(e, t, n))
                                    }, On.over = sl, On.overArgs = Do, On.overEvery = ol, On.overSome = al, On.partial = Po, On.partialRight = Lo, On.partition = _o, On.pick = Da, On.pickBy = Pa, On.property = ll, On.propertyOf = function(e) {
                                        return function(t) {
                                            return null == e ? r : _i(e, t)
                                        }
                                    }, On.pull = Ws, On.pullAll = Xs, On.pullAllBy = function(e, t, n) {
                                        return e && e.length && t && t.length ? Hi(e, t, rs(n, 2)) : e
                                    }, On.pullAllWith = function(e, t, n) {
                                        return e && e.length && t && t.length ? Hi(e, t, r, n) : e
                                    }, On.pullAt = Ys, On.range = cl, On.rangeRight = ul, On.rearg = Uo, On.reject = function(e, t) {
                                        return (Qo(e) ? Mt : fi)(e, Ro(rs(t, 3)))
                                    }, On.remove = function(e, t) {
                                        var n = [];
                                        if (!e || !e.length) return n;
                                        var i = -1,
                                            r = [],
                                            s = e.length;
                                        for (t = rs(t, 3); ++i < s;) {
                                            var o = e[i];
                                            t(o, i, e) && (n.push(o), r.push(i))
                                        }
                                        return Gi(e, r), n
                                    }, On.rest = function(e, t) {
                                        if ("function" != typeof e) throw new Te(s);
                                        return Wi(e, t = t === r ? t : ua(t))
                                    }, On.reverse = qs, On.sampleSize = function(e, t, n) {
                                        return t = (n ? ms(e, t, n) : t === r) ? 1 : ua(t), (Qo(e) ? qn : Yi)(e, t)
                                    }, On.set = function(e, t, n) {
                                        return null == e ? e : qi(e, t, n)
                                    }, On.setWith = function(e, t, n, i) {
                                        return i = "function" == typeof i ? i : r, null == e ? e : qi(e, t, n, i)
                                    }, On.shuffle = function(e) {
                                        return (Qo(e) ? Kn : Zi)(e)
                                    }, On.slice = function(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        return i ? (n && "number" != typeof n && ms(e, t, n) ? (t = 0, n = i) : (t = null == t ? 0 : ua(t), n = n === r ? i : ua(n)), $i(e, t, n)) : []
                                    }, On.sortBy = xo, On.sortedUniq = function(e) {
                                        return e && e.length ? ir(e) : []
                                    }, On.sortedUniqBy = function(e, t) {
                                        return e && e.length ? ir(e, rs(t, 2)) : []
                                    }, On.split = function(e, t, n) {
                                        return n && "number" != typeof n && ms(e, t, n) && (t = n = r), (n = n === r ? f : n >>> 0) ? (e = pa(e)) && ("string" == typeof t || null != t && !ta(t)) && !(t = sr(t)) && rn(e) ? Ar(un(e), 0, n) : e.split(t, n) : []
                                    }, On.spread = function(e, t) {
                                        if ("function" != typeof e) throw new Te(s);
                                        return t = null == t ? 0 : mn(ua(t), 0), Wi((function(n) {
                                            var i = n[t],
                                                r = Ar(n, 0, t);
                                            return i && Dt(r, i), bt(e, this, r)
                                        }))
                                    }, On.tail = function(e) {
                                        var t = null == e ? 0 : e.length;
                                        return t ? $i(e, 1, t) : []
                                    }, On.take = function(e, t, n) {
                                        return e && e.length ? $i(e, 0, (t = n || t === r ? 1 : ua(t)) < 0 ? 0 : t) : []
                                    }, On.takeRight = function(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        return i ? $i(e, (t = i - (t = n || t === r ? 1 : ua(t))) < 0 ? 0 : t, i) : []
                                    }, On.takeRightWhile = function(e, t) {
                                        return e && e.length ? cr(e, rs(t, 3), !1, !0) : []
                                    }, On.takeWhile = function(e, t) {
                                        return e && e.length ? cr(e, rs(t, 3)) : []
                                    }, On.tap = function(e, t) {
                                        return t(e), e
                                    }, On.throttle = function(e, t, n) {
                                        var i = !0,
                                            r = !0;
                                        if ("function" != typeof e) throw new Te(s);
                                        return Ko(n) && (i = "leading" in n ? !!n.leading : i, r = "trailing" in n ? !!n.trailing : r), To(e, t, {
                                            leading: i,
                                            maxWait: t,
                                            trailing: r
                                        })
                                    }, On.thru = lo, On.toArray = la, On.toPairs = La, On.toPairsIn = Ua, On.toPath = function(e) {
                                        return Qo(e) ? Rt(e, Ds) : ra(e) ? [e] : Cr(Rs(pa(e)))
                                    }, On.toPlainObject = fa, On.transform = function(e, t, n) {
                                        var i = Qo(e),
                                            r = i || Vo(e) || sa(e);
                                        if (t = rs(t, 4), null == n) {
                                            var s = e && e.constructor;
                                            n = r ? i ? new s : [] : Ko(e) && Xo(s) ? Fn(Ve(e)) : {}
                                        }
                                        return (r ? Ct : Ai)(e, (function(e, i, r) {
                                            return t(n, e, i, r)
                                        })), n
                                    }, On.unary = function(e) {
                                        return bo(e, 1)
                                    }, On.union = Ks, On.unionBy = Js, On.unionWith = Zs, On.uniq = function(e) {
                                        return e && e.length ? or(e) : []
                                    }, On.uniqBy = function(e, t) {
                                        return e && e.length ? or(e, rs(t, 2)) : []
                                    }, On.uniqWith = function(e, t) {
                                        return t = "function" == typeof t ? t : r, e && e.length ? or(e, r, t) : []
                                    }, On.unset = function(e, t) {
                                        return null == e || ar(e, t)
                                    }, On.unzip = $s, On.unzipWith = eo, On.update = function(e, t, n) {
                                        return null == e ? e : lr(e, t, pr(n))
                                    }, On.updateWith = function(e, t, n, i) {
                                        return i = "function" == typeof i ? i : r, null == e ? e : lr(e, t, pr(n), i)
                                    }, On.values = Na, On.valuesIn = function(e) {
                                        return null == e ? [] : Kt(e, Ma(e))
                                    }, On.without = to, On.words = Xa, On.wrap = function(e, t) {
                                        return Po(pr(t), e)
                                    }, On.xor = no, On.xorBy = io, On.xorWith = ro, On.zip = so, On.zipObject = function(e, t) {
                                        return dr(e || [], t || [], Zn)
                                    }, On.zipObjectDeep = function(e, t) {
                                        return dr(e || [], t || [], qi)
                                    }, On.zipWith = oo, On.entries = La, On.entriesIn = Ua, On.extend = ga, On.extendWith = Aa, il(On, On), On.add = pl, On.attempt = Ya, On.camelCase = Oa, On.capitalize = Fa, On.ceil = ml, On.clamp = function(e, t, n) {
                                        return n === r && (n = t, t = r), n !== r && (n = (n = da(n)) == n ? n : 0), t !== r && (t = (t = da(t)) == t ? t : 0), ri(da(e), t, n)
                                    }, On.clone = function(e) {
                                        return si(e, 4)
                                    }, On.cloneDeep = function(e) {
                                        return si(e, 5)
                                    }, On.cloneDeepWith = function(e, t) {
                                        return si(e, 5, t = "function" == typeof t ? t : r)
                                    }, On.cloneWith = function(e, t) {
                                        return si(e, 4, t = "function" == typeof t ? t : r)
                                    }, On.conformsTo = function(e, t) {
                                        return null == t || oi(e, t, Ta(t))
                                    }, On.deburr = ka, On.defaultTo = function(e, t) {
                                        return null == e || e != e ? t : e
                                    }, On.divide = gl, On.endsWith = function(e, t, n) {
                                        e = pa(e), t = sr(t);
                                        var i = e.length,
                                            s = n = n === r ? i : ri(ua(n), 0, i);
                                        return (n -= t.length) >= 0 && e.slice(n, s) == t
                                    }, On.eq = No, On.escape = function(e) {
                                        return (e = pa(e)) && Y.test(e) ? e.replace(W, tn) : e
                                    }, On.escapeRegExp = function(e) {
                                        return (e = pa(e)) && ne.test(e) ? e.replace(te, "\\$&") : e
                                    }, On.every = function(e, t, n) {
                                        var i = Qo(e) ? Tt : hi;
                                        return n && ms(e, t, n) && (t = r), i(e, rs(t, 3))
                                    }, On.find = ho, On.findIndex = Fs, On.findKey = function(e, t) {
                                        return Ot(e, rs(t, 3), Ai)
                                    }, On.findLast = fo, On.findLastIndex = ks, On.findLastKey = function(e, t) {
                                        return Ot(e, rs(t, 3), vi)
                                    }, On.floor = Al, On.forEach = po, On.forEachRight = mo, On.forIn = function(e, t) {
                                        return null == e ? e : mi(e, rs(t, 3), Ma)
                                    }, On.forInRight = function(e, t) {
                                        return null == e ? e : gi(e, rs(t, 3), Ma)
                                    }, On.forOwn = function(e, t) {
                                        return e && Ai(e, rs(t, 3))
                                    }, On.forOwnRight = function(e, t) {
                                        return e && vi(e, rs(t, 3))
                                    }, On.get = Ea, On.gt = Oo, On.gte = Fo, On.has = function(e, t) {
                                        return null != e && hs(e, t, wi)
                                    }, On.hasIn = ba, On.head = zs, On.identity = $a, On.includes = function(e, t, n, i) {
                                        e = Ho(e) ? e : Na(e), n = n && !i ? ua(n) : 0;
                                        var r = e.length;
                                        return n < 0 && (n = mn(r + n, 0)), ia(e) ? n <= r && e.indexOf(t, n) > -1 : !!r && kt(e, t, n) > -1
                                    }, On.indexOf = function(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        if (!i) return -1;
                                        var r = null == n ? 0 : ua(n);
                                        return r < 0 && (r = mn(i + r, 0)), kt(e, t, r)
                                    }, On.inRange = function(e, t, n) {
                                        return t = ca(t), n === r ? (n = t, t = 0) : n = ca(n),
                                            function(e, t, n) {
                                                return e >= gn(t, n) && e < mn(t, n)
                                            }(e = da(e), t, n)
                                    }, On.invoke = Sa, On.isArguments = ko, On.isArray = Qo, On.isArrayBuffer = zo, On.isArrayLike = Ho, On.isArrayLikeObject = Go, On.isBoolean = function(e) {
                                        return !0 === e || !1 === e || Jo(e) && Ei(e) == A
                                    }, On.isBuffer = Vo, On.isDate = jo, On.isElement = function(e) {
                                        return Jo(e) && 1 === e.nodeType && !ea(e)
                                    }, On.isEmpty = function(e) {
                                        if (null == e) return !0;
                                        if (Ho(e) && (Qo(e) || "string" == typeof e || "function" == typeof e.splice || Vo(e) || sa(e) || ko(e))) return !e.length;
                                        var t = us(e);
                                        if (t == E || t == T) return !e.size;
                                        if (ys(e)) return !Pi(e).length;
                                        for (var n in e)
                                            if (Pe.call(e, n)) return !1;
                                        return !0
                                    }, On.isEqual = function(e, t) {
                                        return Ii(e, t)
                                    }, On.isEqualWith = function(e, t, n) {
                                        var i = (n = "function" == typeof n ? n : r) ? n(e, t) : r;
                                        return i === r ? Ii(e, t, r, n) : !!i
                                    }, On.isError = Wo, On.isFinite = function(e) {
                                        return "number" == typeof e && Nt(e)
                                    }, On.isFunction = Xo, On.isInteger = Yo, On.isLength = qo, On.isMap = Zo, On.isMatch = function(e, t) {
                                        return e === t || Bi(e, t, os(t))
                                    }, On.isMatchWith = function(e, t, n) {
                                        return n = "function" == typeof n ? n : r, Bi(e, t, os(t), n)
                                    }, On.isNaN = function(e) {
                                        return $o(e) && e != +e
                                    }, On.isNative = function(e) {
                                        if (vs(e)) throw new xe("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
                                        return Ri(e)
                                    }, On.isNil = function(e) {
                                        return null == e
                                    }, On.isNull = function(e) {
                                        return null === e
                                    }, On.isNumber = $o, On.isObject = Ko, On.isObjectLike = Jo, On.isPlainObject = ea, On.isRegExp = ta, On.isSafeInteger = function(e) {
                                        return Yo(e) && e >= -9007199254740991 && e <= h
                                    }, On.isSet = na, On.isString = ia, On.isSymbol = ra, On.isTypedArray = sa, On.isUndefined = function(e) {
                                        return e === r
                                    }, On.isWeakMap = function(e) {
                                        return Jo(e) && us(e) == B
                                    }, On.isWeakSet = function(e) {
                                        return Jo(e) && "[object WeakSet]" == Ei(e)
                                    }, On.join = function(e, t) {
                                        return null == e ? "" : Vt.call(e, t)
                                    }, On.kebabCase = Qa, On.last = js, On.lastIndexOf = function(e, t, n) {
                                        var i = null == e ? 0 : e.length;
                                        if (!i) return -1;
                                        var s = i;
                                        return n !== r && (s = (s = ua(n)) < 0 ? mn(i + s, 0) : gn(s, i - 1)), t == t ? function(e, t, n) {
                                            for (var i = n + 1; i--;)
                                                if (e[i] === t) return i;
                                            return i
                                        }(e, t, s) : Ft(e, zt, s, !0)
                                    }, On.lowerCase = za, On.lowerFirst = Ha, On.lt = oa, On.lte = aa, On.max = function(e) {
                                        return e && e.length ? di(e, $a, bi) : r
                                    }, On.maxBy = function(e, t) {
                                        return e && e.length ? di(e, rs(t, 2), bi) : r
                                    }, On.mean = function(e) {
                                        return Ht(e, $a)
                                    }, On.meanBy = function(e, t) {
                                        return Ht(e, rs(t, 2))
                                    }, On.min = function(e) {
                                        return e && e.length ? di(e, $a, Li) : r
                                    }, On.minBy = function(e, t) {
                                        return e && e.length ? di(e, rs(t, 2), Li) : r
                                    }, On.stubArray = hl, On.stubFalse = dl, On.stubObject = function() {
                                        return {}
                                    }, On.stubString = function() {
                                        return ""
                                    }, On.stubTrue = function() {
                                        return !0
                                    }, On.multiply = vl, On.nth = function(e, t) {
                                        return e && e.length ? ki(e, ua(t)) : r
                                    }, On.noConflict = function() {
                                        return ht._ === this && (ht._ = Fe), this
                                    }, On.noop = rl, On.now = Eo, On.pad = function(e, t, n) {
                                        e = pa(e);
                                        var i = (t = ua(t)) ? cn(e) : 0;
                                        if (!t || i >= t) return e;
                                        var r = (t - i) / 2;
                                        return Qr(ft(r), n) + e + Qr(dt(r), n)
                                    }, On.padEnd = function(e, t, n) {
                                        e = pa(e);
                                        var i = (t = ua(t)) ? cn(e) : 0;
                                        return t && i < t ? e + Qr(t - i, n) : e
                                    }, On.padStart = function(e, t, n) {
                                        e = pa(e);
                                        var i = (t = ua(t)) ? cn(e) : 0;
                                        return t && i < t ? Qr(t - i, n) + e : e
                                    }, On.parseInt = function(e, t, n) {
                                        return n || null == t ? t = 0 : t && (t = +t), vn(pa(e).replace(ie, ""), t || 0)
                                    }, On.random = function(e, t, n) {
                                        if (n && "boolean" != typeof n && ms(e, t, n) && (t = n = r), n === r && ("boolean" == typeof t ? (n = t, t = r) : "boolean" == typeof e && (n = e, e = r)), e === r && t === r ? (e = 0, t = 1) : (e = ca(e), t === r ? (t = e, e = 0) : t = ca(t)), e > t) {
                                            var i = e;
                                            e = t, t = i
                                        }
                                        if (n || e % 1 || t % 1) {
                                            var s = yn();
                                            return gn(e + s * (t - e + at("1e-" + ((s + "").length - 1))), t)
                                        }
                                        return Vi(e, t)
                                    }, On.reduce = function(e, t, n) {
                                        var i = Qo(e) ? Pt : jt,
                                            r = arguments.length < 3;
                                        return i(e, rs(t, 4), n, r, ci)
                                    }, On.reduceRight = function(e, t, n) {
                                        var i = Qo(e) ? Lt : jt,
                                            r = arguments.length < 3;
                                        return i(e, rs(t, 4), n, r, ui)
                                    }, On.repeat = function(e, t, n) {
                                        return t = (n ? ms(e, t, n) : t === r) ? 1 : ua(t), ji(pa(e), t)
                                    }, On.replace = function() {
                                        var e = arguments,
                                            t = pa(e[0]);
                                        return e.length < 3 ? t : t.replace(e[1], e[2])
                                    }, On.result = function(e, t, n) {
                                        var i = -1,
                                            s = (t = mr(t, e)).length;
                                        for (s || (s = 1, e = r); ++i < s;) {
                                            var o = null == e ? r : e[Ds(t[i])];
                                            o === r && (i = s, o = n), e = Xo(o) ? o.call(e) : o
                                        }
                                        return e
                                    }, On.round = yl, On.runInContext = e, On.sample = function(e) {
                                        return (Qo(e) ? Yn : Xi)(e)
                                    }, On.size = function(e) {
                                        if (null == e) return 0;
                                        if (Ho(e)) return ia(e) ? cn(e) : e.length;
                                        var t = us(e);
                                        return t == E || t == T ? e.size : Pi(e).length
                                    }, On.snakeCase = Ga, On.some = function(e, t, n) {
                                        var i = Qo(e) ? Ut : er;
                                        return n && ms(e, t, n) && (t = r), i(e, rs(t, 3))
                                    }, On.sortedIndex = function(e, t) {
                                        return tr(e, t)
                                    }, On.sortedIndexBy = function(e, t, n) {
                                        return nr(e, t, rs(n, 2))
                                    }, On.sortedIndexOf = function(e, t) {
                                        var n = null == e ? 0 : e.length;
                                        if (n) {
                                            var i = tr(e, t);
                                            if (i < n && No(e[i], t)) return i
                                        }
                                        return -1
                                    }, On.sortedLastIndex = function(e, t) {
                                        return tr(e, t, !0)
                                    }, On.sortedLastIndexBy = function(e, t, n) {
                                        return nr(e, t, rs(n, 2), !0)
                                    }, On.sortedLastIndexOf = function(e, t) {
                                        if (null != e && e.length) {
                                            var n = tr(e, t, !0) - 1;
                                            if (No(e[n], t)) return n
                                        }
                                        return -1
                                    }, On.startCase = Va, On.startsWith = function(e, t, n) {
                                        return e = pa(e), n = null == n ? 0 : ri(ua(n), 0, e.length), t = sr(t), e.slice(n, n + t.length) == t
                                    }, On.subtract = _l, On.sum = function(e) {
                                        return e && e.length ? Wt(e, $a) : 0
                                    }, On.sumBy = function(e, t) {
                                        return e && e.length ? Wt(e, rs(t, 2)) : 0
                                    }, On.template = function(e, t, n) {
                                        var i = On.templateSettings;
                                        n && ms(e, t, n) && (t = r), e = pa(e), t = Aa({}, t, i, Yr);
                                        var s, o, a = Aa({}, t.imports, i.imports, Yr),
                                            l = Ta(a),
                                            c = Kt(a, l),
                                            u = 0,
                                            h = t.interpolate || ye,
                                            d = "__p += '",
                                            f = Ce((t.escape || ye).source + "|" + h.source + "|" + (h === J ? he : ye).source + "|" + (t.evaluate || ye).source + "|$", "g"),
                                            p = "//# sourceURL=" + (Pe.call(t, "sourceURL") ? (t.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++it + "]") + "\n";
                                        e.replace(f, (function(t, n, i, r, a, l) {
                                            return i || (i = r), d += e.slice(u, l).replace(_e, nn), n && (s = !0, d += "' +\n__e(" + n + ") +\n'"), a && (o = !0, d += "';\n" + a + ";\n__p += '"), i && (d += "' +\n((__t = (" + i + ")) == null ? '' : __t) +\n'"), u = l + t.length, t
                                        })), d += "';\n";
                                        var m = Pe.call(t, "variable") && t.variable;
                                        if (m) {
                                            if (ce.test(m)) throw new xe("Invalid `variable` option passed into `_.template`")
                                        } else d = "with (obj) {\n" + d + "\n}\n";
                                        d = (o ? d.replace(H, "") : d).replace(G, "$1").replace(V, "$1;"), d = "function(" + (m || "obj") + ") {\n" + (m ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (s ? ", __e = _.escape" : "") + (o ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + d + "return __p\n}";
                                        var g = Ya((function() {
                                            return Ee(l, p + "return " + d).apply(r, c)
                                        }));
                                        if (g.source = d, Wo(g)) throw g;
                                        return g
                                    }, On.times = function(e, t) {
                                        if ((e = ua(e)) < 1 || e > h) return [];
                                        var n = f,
                                            i = gn(e, f);
                                        t = rs(t), e -= f;
                                        for (var r = Xt(i, t); ++n < e;) t(n);
                                        return r
                                    }, On.toFinite = ca, On.toInteger = ua, On.toLength = ha, On.toLower = function(e) {
                                        return pa(e).toLowerCase()
                                    }, On.toNumber = da, On.toSafeInteger = function(e) {
                                        return e ? ri(ua(e), -9007199254740991, h) : 0 === e ? e : 0
                                    }, On.toString = pa, On.toUpper = function(e) {
                                        return pa(e).toUpperCase()
                                    }, On.trim = function(e, t, n) {
                                        if ((e = pa(e)) && (n || t === r)) return Yt(e);
                                        if (!e || !(t = sr(t))) return e;
                                        var i = un(e),
                                            s = un(t);
                                        return Ar(i, Zt(i, s), $t(i, s) + 1).join("")
                                    }, On.trimEnd = function(e, t, n) {
                                        if ((e = pa(e)) && (n || t === r)) return e.slice(0, hn(e) + 1);
                                        if (!e || !(t = sr(t))) return e;
                                        var i = un(e);
                                        return Ar(i, 0, $t(i, un(t)) + 1).join("")
                                    }, On.trimStart = function(e, t, n) {
                                        if ((e = pa(e)) && (n || t === r)) return e.replace(ie, "");
                                        if (!e || !(t = sr(t))) return e;
                                        var i = un(e);
                                        return Ar(i, Zt(i, un(t))).join("")
                                    }, On.truncate = function(e, t) {
                                        var n = 30,
                                            i = "...";
                                        if (Ko(t)) {
                                            var s = "separator" in t ? t.separator : s;
                                            n = "length" in t ? ua(t.length) : n, i = "omission" in t ? sr(t.omission) : i
                                        }
                                        var o = (e = pa(e)).length;
                                        if (rn(e)) {
                                            var a = un(e);
                                            o = a.length
                                        }
                                        if (n >= o) return e;
                                        var l = n - cn(i);
                                        if (l < 1) return i;
                                        var c = a ? Ar(a, 0, l).join("") : e.slice(0, l);
                                        if (s === r) return c + i;
                                        if (a && (l += c.length - l), ta(s)) {
                                            if (e.slice(l).search(s)) {
                                                var u, h = c;
                                                for (s.global || (s = Ce(s.source, pa(de.exec(s)) + "g")), s.lastIndex = 0; u = s.exec(h);) var d = u.index;
                                                c = c.slice(0, d === r ? l : d)
                                            }
                                        } else if (e.indexOf(sr(s), l) != l) {
                                            var f = c.lastIndexOf(s);
                                            f > -1 && (c = c.slice(0, f))
                                        }
                                        return c + i
                                    }, On.unescape = function(e) {
                                        return (e = pa(e)) && X.test(e) ? e.replace(j, dn) : e
                                    }, On.uniqueId = function(e) {
                                        var t = ++Le;
                                        return pa(e) + t
                                    }, On.upperCase = ja, On.upperFirst = Wa, On.each = po, On.eachRight = mo, On.first = zs, il(On, (fl = {}, Ai(On, (function(e, t) {
                                        Pe.call(On.prototype, t) || (fl[t] = e)
                                    })), fl), {
                                        chain: !1
                                    }), On.VERSION = "4.17.21", Ct(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], (function(e) {
                                        On[e].placeholder = On
                                    })), Ct(["drop", "take"], (function(e, t) {
                                        zn.prototype[e] = function(n) {
                                            n = n === r ? 1 : mn(ua(n), 0);
                                            var i = this.__filtered__ && !t ? new zn(this) : this.clone();
                                            return i.__filtered__ ? i.__takeCount__ = gn(n, i.__takeCount__) : i.__views__.push({
                                                size: gn(n, f),
                                                type: e + (i.__dir__ < 0 ? "Right" : "")
                                            }), i
                                        }, zn.prototype[e + "Right"] = function(t) {
                                            return this.reverse()[e](t).reverse()
                                        }
                                    })), Ct(["filter", "map", "takeWhile"], (function(e, t) {
                                        var n = t + 1,
                                            i = 1 == n || 3 == n;
                                        zn.prototype[e] = function(e) {
                                            var t = this.clone();
                                            return t.__iteratees__.push({
                                                iteratee: rs(e, 3),
                                                type: n
                                            }), t.__filtered__ = t.__filtered__ || i, t
                                        }
                                    })), Ct(["head", "last"], (function(e, t) {
                                        var n = "take" + (t ? "Right" : "");
                                        zn.prototype[e] = function() {
                                            return this[n](1).value()[0]
                                        }
                                    })), Ct(["initial", "tail"], (function(e, t) {
                                        var n = "drop" + (t ? "" : "Right");
                                        zn.prototype[e] = function() {
                                            return this.__filtered__ ? new zn(this) : this[n](1)
                                        }
                                    })), zn.prototype.compact = function() {
                                        return this.filter($a)
                                    }, zn.prototype.find = function(e) {
                                        return this.filter(e).head()
                                    }, zn.prototype.findLast = function(e) {
                                        return this.reverse().find(e)
                                    }, zn.prototype.invokeMap = Wi((function(e, t) {
                                        return "function" == typeof e ? new zn(this) : this.map((function(n) {
                                            return Ti(n, e, t)
                                        }))
                                    })), zn.prototype.reject = function(e) {
                                        return this.filter(Ro(rs(e)))
                                    }, zn.prototype.slice = function(e, t) {
                                        e = ua(e);
                                        var n = this;
                                        return n.__filtered__ && (e > 0 || t < 0) ? new zn(n) : (e < 0 ? n = n.takeRight(-e) : e && (n = n.drop(e)), t !== r && (n = (t = ua(t)) < 0 ? n.dropRight(-t) : n.take(t - e)), n)
                                    }, zn.prototype.takeRightWhile = function(e) {
                                        return this.reverse().takeWhile(e).reverse()
                                    }, zn.prototype.toArray = function() {
                                        return this.take(f)
                                    }, Ai(zn.prototype, (function(e, t) {
                                        var n = /^(?:filter|find|map|reject)|While$/.test(t),
                                            i = /^(?:head|last)$/.test(t),
                                            s = On[i ? "take" + ("last" == t ? "Right" : "") : t],
                                            o = i || /^find/.test(t);
                                        s && (On.prototype[t] = function() {
                                            var t = this.__wrapped__,
                                                a = i ? [1] : arguments,
                                                l = t instanceof zn,
                                                c = a[0],
                                                u = l || Qo(t),
                                                h = function(e) {
                                                    var t = s.apply(On, Dt([e], a));
                                                    return i && d ? t[0] : t
                                                };
                                            u && n && "function" == typeof c && 1 != c.length && (l = u = !1);
                                            var d = this.__chain__,
                                                f = !!this.__actions__.length,
                                                p = o && !d,
                                                m = l && !f;
                                            if (!o && u) {
                                                t = m ? t : new zn(this);
                                                var g = e.apply(t, a);
                                                return g.__actions__.push({
                                                    func: lo,
                                                    args: [h],
                                                    thisArg: r
                                                }), new Qn(g, d)
                                            }
                                            return p && m ? e.apply(this, a) : (g = this.thru(h), p ? i ? g.value()[0] : g.value() : g)
                                        })
                                    })), Ct(["pop", "push", "shift", "sort", "splice", "unshift"], (function(e) {
                                        var t = Me[e],
                                            n = /^(?:push|sort|unshift)$/.test(e) ? "tap" : "thru",
                                            i = /^(?:pop|shift)$/.test(e);
                                        On.prototype[e] = function() {
                                            var e = arguments;
                                            if (i && !this.__chain__) {
                                                var r = this.value();
                                                return t.apply(Qo(r) ? r : [], e)
                                            }
                                            return this[n]((function(n) {
                                                return t.apply(Qo(n) ? n : [], e)
                                            }))
                                        }
                                    })), Ai(zn.prototype, (function(e, t) {
                                        var n = On[t];
                                        if (n) {
                                            var i = n.name + "";
                                            Pe.call(Mn, i) || (Mn[i] = []), Mn[i].push({
                                                name: t,
                                                func: n
                                            })
                                        }
                                    })), Mn[Nr(r, 2).name] = [{
                                        name: "wrapper",
                                        func: r
                                    }], zn.prototype.clone = function() {
                                        var e = new zn(this.__wrapped__);
                                        return e.__actions__ = Cr(this.__actions__), e.__dir__ = this.__dir__, e.__filtered__ = this.__filtered__, e.__iteratees__ = Cr(this.__iteratees__), e.__takeCount__ = this.__takeCount__, e.__views__ = Cr(this.__views__), e
                                    }, zn.prototype.reverse = function() {
                                        if (this.__filtered__) {
                                            var e = new zn(this);
                                            e.__dir__ = -1, e.__filtered__ = !0
                                        } else(e = this.clone()).__dir__ *= -1;
                                        return e
                                    }, zn.prototype.value = function() {
                                        var e = this.__wrapped__.value(),
                                            t = this.__dir__,
                                            n = Qo(e),
                                            i = t < 0,
                                            r = n ? e.length : 0,
                                            s = function(e, t, n) {
                                                for (var i = -1, r = n.length; ++i < r;) {
                                                    var s = n[i],
                                                        o = s.size;
                                                    switch (s.type) {
                                                        case "drop":
                                                            e += o;
                                                            break;
                                                        case "dropRight":
                                                            t -= o;
                                                            break;
                                                        case "take":
                                                            t = gn(t, e + o);
                                                            break;
                                                        case "takeRight":
                                                            e = mn(e, t - o)
                                                    }
                                                }
                                                return {
                                                    start: e,
                                                    end: t
                                                }
                                            }(0, r, this.__views__),
                                            o = s.start,
                                            a = s.end,
                                            l = a - o,
                                            c = i ? a : o - 1,
                                            u = this.__iteratees__,
                                            h = u.length,
                                            d = 0,
                                            f = gn(l, this.__takeCount__);
                                        if (!n || !i && r == l && f == l) return ur(e, this.__actions__);
                                        var p = [];
                                        e: for (; l-- && d < f;) {
                                            for (var m = -1, g = e[c += t]; ++m < h;) {
                                                var A = u[m],
                                                    v = A.iteratee,
                                                    y = A.type,
                                                    _ = v(g);
                                                if (2 == y) g = _;
                                                else if (!_) {
                                                    if (1 == y) continue e;
                                                    break e
                                                }
                                            }
                                            p[d++] = g
                                        }
                                        return p
                                    }, On.prototype.at = co, On.prototype.chain = function() {
                                        return ao(this)
                                    }, On.prototype.commit = function() {
                                        return new Qn(this.value(), this.__chain__)
                                    }, On.prototype.next = function() {
                                        this.__values__ === r && (this.__values__ = la(this.value()));
                                        var e = this.__index__ >= this.__values__.length;
                                        return {
                                            done: e,
                                            value: e ? r : this.__values__[this.__index__++]
                                        }
                                    }, On.prototype.plant = function(e) {
                                        for (var t, n = this; n instanceof kn;) {
                                            var i = Ls(n);
                                            i.__index__ = 0, i.__values__ = r, t ? s.__wrapped__ = i : t = i;
                                            var s = i;
                                            n = n.__wrapped__
                                        }
                                        return s.__wrapped__ = e, t
                                    }, On.prototype.reverse = function() {
                                        var e = this.__wrapped__;
                                        if (e instanceof zn) {
                                            var t = e;
                                            return this.__actions__.length && (t = new zn(this)), (t = t.reverse()).__actions__.push({
                                                func: lo,
                                                args: [qs],
                                                thisArg: r
                                            }), new Qn(t, this.__chain__)
                                        }
                                        return this.thru(qs)
                                    }, On.prototype.toJSON = On.prototype.valueOf = On.prototype.value = function() {
                                        return ur(this.__wrapped__, this.__actions__)
                                    }, On.prototype.first = On.prototype.head, qe && (On.prototype[qe] = function() {
                                        return this
                                    }), On
                                }();
                            ht._ = fn, (i = function() {
                                return fn
                            }.call(t, n, t, e)) === r || (e.exports = i)
                        }.call(this)
                }
            },
            t = {};

        function n(i) {
            var r = t[i];
            if (void 0 !== r) return r.exports;
            var s = t[i] = {
                id: i,
                loaded: !1,
                exports: {}
            };
            return e[i].call(s.exports, s, s.exports, n), s.loaded = !0, s.exports
        }
        n.n = e => {
            var t = e && e.__esModule ? () => e.default : () => e;
            return n.d(t, {
                a: t
            }), t
        }, n.d = (e, t) => {
            for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, {
                enumerable: !0,
                get: t[i]
            })
        }, n.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")()
            } catch (e) {
                if ("object" == typeof window) return window
            }
        }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.nmd = e => (e.paths = [], e.children || (e.children = []), e), (() => {
            const e = "170",
                t = 100,
                i = "attached",
                r = 301,
                s = 302,
                o = 303,
                a = 306,
                l = 1e3,
                c = 1001,
                u = 1002,
                h = 1003,
                d = 1005,
                f = 1006,
                p = 1007,
                m = 1008,
                g = 1008,
                A = 1009,
                v = 1010,
                y = 1011,
                _ = 1012,
                x = 1013,
                E = 1014,
                b = 1015,
                w = 1016,
                C = 1017,
                S = 1018,
                T = 1020,
                M = 35902,
                I = 1023,
                B = 1024,
                R = 1026,
                D = 1027,
                P = 1028,
                L = 1029,
                U = 1030,
                N = 1031,
                O = 1033,
                F = 33776,
                k = 33777,
                Q = 33778,
                z = 33779,
                H = 35840,
                G = 35841,
                V = 35842,
                j = 35843,
                W = 36196,
                X = 37492,
                Y = 37496,
                q = 37808,
                K = 37809,
                J = 37810,
                Z = 37811,
                $ = 37812,
                ee = 37813,
                te = 37814,
                ne = 37815,
                ie = 37816,
                re = 37817,
                se = 37818,
                oe = 37819,
                ae = 37820,
                le = 37821,
                ce = 36492,
                ue = 36494,
                he = 36495,
                de = 36284,
                fe = 36285,
                pe = 36286,
                me = 2300,
                ge = 2301,
                Ae = 2302,
                ve = 3201,
                ye = "",
                _e = "srgb",
                xe = "srgb-linear",
                Ee = "linear",
                be = "srgb",
                we = 7680,
                Ce = 35044,
                Se = "300 es",
                Te = 2e3,
                Me = 2001;
            class Ie {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners[e];
                    if (void 0 !== n) {
                        const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return;
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const n = t.slice(0);
                        for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
                        e.target = null
                    }
                }
            }
            const Be = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
            let Re = 1234567;
            const De = Math.PI / 180,
                Pe = 180 / Math.PI;

            function Le() {
                const e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0;
                return (Be[255 & e] + Be[e >> 8 & 255] + Be[e >> 16 & 255] + Be[e >> 24 & 255] + "-" + Be[255 & t] + Be[t >> 8 & 255] + "-" + Be[t >> 16 & 15 | 64] + Be[t >> 24 & 255] + "-" + Be[63 & n | 128] + Be[n >> 8 & 255] + "-" + Be[n >> 16 & 255] + Be[n >> 24 & 255] + Be[255 & i] + Be[i >> 8 & 255] + Be[i >> 16 & 255] + Be[i >> 24 & 255]).toLowerCase()
            }

            function Ue(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }

            function Ne(e, t) {
                return (e % t + t) % t
            }

            function Oe(e, t, n) {
                return (1 - n) * e + n * t
            }

            function Fe(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return e / 4294967295;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int32Array:
                        return Math.max(e / 2147483647, -1);
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                }
            }

            function ke(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return Math.round(4294967295 * e);
                    case Uint16Array:
                        return Math.round(65535 * e);
                    case Uint8Array:
                        return Math.round(255 * e);
                    case Int32Array:
                        return Math.round(2147483647 * e);
                    case Int16Array:
                        return Math.round(32767 * e);
                    case Int8Array:
                        return Math.round(127 * e);
                    default:
                        throw new Error("Invalid component type.")
                }
            }
            const Qe = {
                DEG2RAD: De,
                RAD2DEG: Pe,
                generateUUID: Le,
                clamp: Ue,
                euclideanModulo: Ne,
                mapLinear: function(e, t, n, i, r) {
                    return i + (e - t) * (r - i) / (n - t)
                },
                inverseLerp: function(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                },
                lerp: Oe,
                damp: function(e, t, n, i) {
                    return Oe(e, t, 1 - Math.exp(-n * i))
                },
                pingpong: function(e, t = 1) {
                    return t - Math.abs(Ne(e, 2 * t) - t)
                },
                smoothstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    void 0 !== e && (Re = e);
                    let t = Re += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296
                },
                degToRad: function(e) {
                    return e * De
                },
                radToDeg: function(e) {
                    return e * Pe
                },
                isPowerOfTwo: function(e) {
                    return !(e & e - 1) && 0 !== e
                },
                ceilPowerOfTwo: function(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                },
                floorPowerOfTwo: function(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(e, t, n, i, r) {
                    const s = Math.cos,
                        o = Math.sin,
                        a = s(n / 2),
                        l = o(n / 2),
                        c = s((t + i) / 2),
                        u = o((t + i) / 2),
                        h = s((t - i) / 2),
                        d = o((t - i) / 2),
                        f = s((i - t) / 2),
                        p = o((i - t) / 2);
                    switch (r) {
                        case "XYX":
                            e.set(a * u, l * h, l * d, a * c);
                            break;
                        case "YZY":
                            e.set(l * d, a * u, l * h, a * c);
                            break;
                        case "ZXZ":
                            e.set(l * h, l * d, a * u, a * c);
                            break;
                        case "XZX":
                            e.set(a * u, l * p, l * f, a * c);
                            break;
                        case "YXY":
                            e.set(l * f, a * u, l * p, a * c);
                            break;
                        case "ZYZ":
                            e.set(l * p, l * f, a * u, a * c)
                    }
                },
                normalize: ke,
                denormalize: Fe
            };
            class ze {
                constructor(e = 0, t = 0) {
                    ze.prototype.isVector2 = !0, this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(Ue(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    const n = Math.cos(t),
                        i = Math.sin(t),
                        r = this.x - e.x,
                        s = this.y - e.y;
                    return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            class He {
                constructor(e, t, n, i, r, s, o, a, l) {
                    He.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, s, o, a, l)
                }
                set(e, t, n, i, r, s, o, a, l) {
                    const c = this.elements;
                    return c[0] = e, c[1] = i, c[2] = o, c[3] = t, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    const t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        s = n[0],
                        o = n[3],
                        a = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        f = n[8],
                        p = i[0],
                        m = i[3],
                        g = i[6],
                        A = i[1],
                        v = i[4],
                        y = i[7],
                        _ = i[2],
                        x = i[5],
                        E = i[8];
                    return r[0] = s * p + o * A + a * _, r[3] = s * m + o * v + a * x, r[6] = s * g + o * y + a * E, r[1] = l * p + c * A + u * _, r[4] = l * m + c * v + u * x, r[7] = l * g + c * y + u * E, r[2] = h * p + d * A + f * _, r[5] = h * m + d * v + f * x, r[8] = h * g + d * y + f * E, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        s = e[4],
                        o = e[5],
                        a = e[6],
                        l = e[7],
                        c = e[8];
                    return t * s * c - t * o * l - n * r * c + n * o * a + i * r * l - i * s * a
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        s = e[4],
                        o = e[5],
                        a = e[6],
                        l = e[7],
                        c = e[8],
                        u = c * s - o * l,
                        h = o * a - c * r,
                        d = l * r - s * a,
                        f = t * u + n * h + i * d;
                    if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const p = 1 / f;
                    return e[0] = u * p, e[1] = (i * l - c * n) * p, e[2] = (o * n - i * s) * p, e[3] = h * p, e[4] = (c * t - i * a) * p, e[5] = (i * r - o * t) * p, e[6] = d * p, e[7] = (n * a - l * t) * p, e[8] = (s * t - n * r) * p, this
                }
                transpose() {
                    let e;
                    const t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    const t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, n, i, r, s, o) {
                    const a = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(n * a, n * l, -n * (a * s + l * o) + s + e, -i * l, i * a, -i * (-l * s + a * o) + o + t, 0, 0, 1), this
                }
                scale(e, t) {
                    return this.premultiply(Ge.makeScale(e, t)), this
                }
                rotate(e) {
                    return this.premultiply(Ge.makeRotation(-e)), this
                }
                translate(e, t) {
                    return this.premultiply(Ge.makeTranslation(e, t)), this
                }
                makeTranslation(e, t) {
                    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
                }
                makeRotation(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
                }
                makeScale(e, t) {
                    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }
            const Ge = new He;

            function Ve(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] >= 65535) return !0;
                return !1
            }

            function je(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }

            function We() {
                const e = je("canvas");
                return e.style.display = "block", e
            }
            const Xe = {};

            function Ye(e) {
                e in Xe || (Xe[e] = !0)
            }
            const qe = {
                enabled: !0,
                workingColorSpace: xe,
                spaces: {},
                convert: function(e, t, n) {
                    return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === be && (e.r = Ke(e.r), e.g = Ke(e.g), e.b = Ke(e.b)), this.spaces[t].primaries !== this.spaces[n].primaries && (e.applyMatrix3(this.spaces[t].toXYZ), e.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === be && (e.r = Je(e.r), e.g = Je(e.g), e.b = Je(e.b)), e) : e
                },
                fromWorkingColorSpace: function(e, t) {
                    return this.convert(e, this.workingColorSpace, t)
                },
                toWorkingColorSpace: function(e, t) {
                    return this.convert(e, t, this.workingColorSpace)
                },
                getPrimaries: function(e) {
                    return this.spaces[e].primaries
                },
                getTransfer: function(e) {
                    return e === ye ? Ee : this.spaces[e].transfer
                },
                getLuminanceCoefficients: function(e, t = this.workingColorSpace) {
                    return e.fromArray(this.spaces[t].luminanceCoefficients)
                },
                define: function(e) {
                    Object.assign(this.spaces, e)
                },
                _getMatrix: function(e, t, n) {
                    return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)
                },
                _getDrawingBufferColorSpace: function(e) {
                    return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace
                },
                _getUnpackColorSpace: function(e = this.workingColorSpace) {
                    return this.spaces[e].workingColorSpaceConfig.unpackColorSpace
                }
            };

            function Ke(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function Je(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            const Ze = [.64, .33, .3, .6, .15, .06],
                $e = [.2126, .7152, .0722],
                et = [.3127, .329],
                tt = (new He).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
                nt = (new He).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
            let it;
            qe.define({
                [xe]: {
                    primaries: Ze,
                    whitePoint: et,
                    transfer: Ee,
                    toXYZ: tt,
                    fromXYZ: nt,
                    luminanceCoefficients: $e,
                    workingColorSpaceConfig: {
                        unpackColorSpace: _e
                    },
                    outputColorSpaceConfig: {
                        drawingBufferColorSpace: _e
                    }
                },
                [_e]: {
                    primaries: Ze,
                    whitePoint: et,
                    transfer: be,
                    toXYZ: tt,
                    fromXYZ: nt,
                    luminanceCoefficients: $e,
                    outputColorSpaceConfig: {
                        drawingBufferColorSpace: _e
                    }
                }
            });
            class rt {
                static getDataURL(e) {
                    if (/^data:/i.test(e.src)) return e.src;
                    if ("undefined" == typeof HTMLCanvasElement) return e.src;
                    let t;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === it && (it = je("canvas")), it.width = e.width, it.height = e.height;
                        const n = it.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = it
                    }
                    return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        const t = je("canvas");
                        t.width = e.width, t.height = e.height;
                        const n = t.getContext("2d");
                        n.drawImage(e, 0, 0, e.width, e.height);
                        const i = n.getImageData(0, 0, e.width, e.height),
                            r = i.data;
                        for (let e = 0; e < r.length; e++) r[e] = 255 * Ke(r[e] / 255);
                        return n.putImageData(i, 0, 0), t
                    }
                    if (e.data) {
                        const t = e.data.slice(0);
                        for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Ke(t[e] / 255)) : t[e] = Ke(t[e]);
                        return {
                            data: t,
                            width: e.width,
                            height: e.height
                        }
                    }
                    return e
                }
            }
            let st = 0;
            class ot {
                constructor(e = null) {
                    this.isSource = !0, Object.defineProperty(this, "id", {
                        value: st++
                    }), this.uuid = Le(), this.data = e, this.dataReady = !0, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                    const n = {
                            uuid: this.uuid,
                            url: ""
                        },
                        i = this.data;
                    if (null !== i) {
                        let e;
                        if (Array.isArray(i)) {
                            e = [];
                            for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(at(i[t].image)) : e.push(at(i[t]))
                        } else e = at(i);
                        n.url = e
                    }
                    return t || (e.images[this.uuid] = n), n
                }
            }

            function at(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? rt.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : {}
            }
            let lt = 0;
            class ct extends Ie {
                constructor(e = ct.DEFAULT_IMAGE, t = ct.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, o = 1023, a = 1009, l = ct.DEFAULT_ANISOTROPY, c = "") {
                    super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                        value: lt++
                    }), this.uuid = Le(), this.name = "", this.source = new ot(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new ze(0, 0), this.repeat = new ze(1, 1), this.center = new ze(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new He, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
                }
                get image() {
                    return this.source.data
                }
                set image(e = null) {
                    this.source.data = e
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.6,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(e).uuid,
                        mapping: this.mapping,
                        channel: this.channel,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        internalFormat: this.internalFormat,
                        type: this.type,
                        colorSpace: this.colorSpace,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        generateMipmaps: this.generateMipmaps,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (300 !== this.mapping) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case l:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case c:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case u:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case l:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case c:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case u:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
                set needsUpdate(e) {
                    !0 === e && (this.version++, this.source.needsUpdate = !0)
                }
                set needsPMREMUpdate(e) {
                    !0 === e && this.pmremVersion++
                }
            }
            ct.DEFAULT_IMAGE = null, ct.DEFAULT_MAPPING = 300, ct.DEFAULT_ANISOTROPY = 1;
            class ut {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                    ut.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, i) {
                    return this.x = e, this.y = t, this.z = n, this.w = i, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        s = e.elements;
                    return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    const t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, i, r;
                    const s = .01,
                        o = .1,
                        a = e.elements,
                        l = a[0],
                        c = a[4],
                        u = a[8],
                        h = a[1],
                        d = a[5],
                        f = a[9],
                        p = a[2],
                        m = a[6],
                        g = a[10];
                    if (Math.abs(c - h) < s && Math.abs(u - p) < s && Math.abs(f - m) < s) {
                        if (Math.abs(c + h) < o && Math.abs(u + p) < o && Math.abs(f + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        const e = (l + 1) / 2,
                            a = (d + 1) / 2,
                            A = (g + 1) / 2,
                            v = (c + h) / 4,
                            y = (u + p) / 4,
                            _ = (f + m) / 4;
                        return e > a && e > A ? e < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = v / n, r = y / n) : a > A ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = v / i, r = _ / i) : A < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(A), n = y / r, i = _ / r), this.set(n, i, r, t), this
                    }
                    let A = Math.sqrt((m - f) * (m - f) + (u - p) * (u - p) + (h - c) * (h - c));
                    return Math.abs(A) < .001 && (A = 1), this.x = (m - f) / A, this.y = (u - p) / A, this.z = (h - c) / A, this.w = Math.acos((l + d + g - 1) / 2), this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            class ht extends Ie {
                constructor(e = 1, t = 1, n = {}) {
                    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new ut(0, 0, e, t), this.scissorTest = !1, this.viewport = new ut(0, 0, e, t);
                    const i = {
                        width: e,
                        height: t,
                        depth: 1
                    };
                    n = Object.assign({
                        generateMipmaps: !1,
                        internalFormat: null,
                        minFilter: f,
                        depthBuffer: !0,
                        stencilBuffer: !1,
                        resolveDepthBuffer: !0,
                        resolveStencilBuffer: !0,
                        depthTexture: null,
                        samples: 0,
                        count: 1
                    }, n);
                    const r = new ct(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
                    r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
                    const s = n.count;
                    for (let e = 0; e < s; e++) this.textures[e] = r.clone(), this.textures[e].isRenderTargetTexture = !0;
                    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
                }
                get texture() {
                    return this.textures[0]
                }
                set texture(e) {
                    this.textures[0] = e
                }
                setSize(e, t, n = 1) {
                    if (this.width !== e || this.height !== t || this.depth !== n) {
                        this.width = e, this.height = t, this.depth = n;
                        for (let i = 0, r = this.textures.length; i < r; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
                        this.dispose()
                    }
                    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
                    for (let t = 0, n = e.textures.length; t < n; t++) this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0;
                    const t = Object.assign({}, e.texture.image);
                    return this.texture.source = new ot(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class dt extends ht {
                constructor(e = 1, t = 1, n = {}) {
                    super(e, t, n), this.isWebGLRenderTarget = !0
                }
            }
            class ft extends ct {
                constructor(e = null, t = 1, n = 1, i = 1) {
                    super(null), this.isDataArrayTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: i
                    }, this.magFilter = h, this.minFilter = h, this.wrapR = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
                }
                addLayerUpdate(e) {
                    this.layerUpdates.add(e)
                }
                clearLayerUpdates() {
                    this.layerUpdates.clear()
                }
            }
            class pt extends ct {
                constructor(e = null, t = 1, n = 1, i = 1) {
                    super(null), this.isData3DTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: i
                    }, this.magFilter = h, this.minFilter = h, this.wrapR = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class mt {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
                }
                static slerpFlat(e, t, n, i, r, s, o) {
                    let a = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        u = n[i + 3];
                    const h = r[s + 0],
                        d = r[s + 1],
                        f = r[s + 2],
                        p = r[s + 3];
                    if (0 === o) return e[t + 0] = a, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = u);
                    if (1 === o) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = f, void(e[t + 3] = p);
                    if (u !== p || a !== h || l !== d || c !== f) {
                        let e = 1 - o;
                        const t = a * h + l * d + c * f + u * p,
                            n = t >= 0 ? 1 : -1,
                            i = 1 - t * t;
                        if (i > Number.EPSILON) {
                            const r = Math.sqrt(i),
                                s = Math.atan2(r, t * n);
                            e = Math.sin(e * s) / r, o = Math.sin(o * s) / r
                        }
                        const r = o * n;
                        if (a = a * e + h * r, l = l * e + d * r, c = c * e + f * r, u = u * e + p * r, e === 1 - o) {
                            const e = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                            a *= e, l *= e, c *= e, u *= e
                        }
                    }
                    e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
                static multiplyQuaternionsFlat(e, t, n, i, r, s) {
                    const o = n[i],
                        a = n[i + 1],
                        l = n[i + 2],
                        c = n[i + 3],
                        u = r[s],
                        h = r[s + 1],
                        d = r[s + 2],
                        f = r[s + 3];
                    return e[t] = o * f + c * u + a * d - l * h, e[t + 1] = a * f + c * h + l * u - o * d, e[t + 2] = l * f + c * d + o * h - a * u, e[t + 3] = c * f - o * u - a * h - l * d, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t = !0) {
                    const n = e._x,
                        i = e._y,
                        r = e._z,
                        s = e._order,
                        o = Math.cos,
                        a = Math.sin,
                        l = o(n / 2),
                        c = o(i / 2),
                        u = o(r / 2),
                        h = a(n / 2),
                        d = a(i / 2),
                        f = a(r / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = h * c * u + l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u - h * d * f;
                            break;
                        case "YXZ":
                            this._x = h * c * u + l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u + h * d * f;
                            break;
                        case "ZXY":
                            this._x = h * c * u - l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u - h * d * f;
                            break;
                        case "ZYX":
                            this._x = h * c * u - l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u + h * d * f;
                            break;
                        case "YZX":
                            this._x = h * c * u + l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u - h * d * f;
                            break;
                        case "XZY":
                            this._x = h * c * u - l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u + h * d * f
                    }
                    return !0 === t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    const n = t / 2,
                        i = Math.sin(n);
                    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    const t = e.elements,
                        n = t[0],
                        i = t[4],
                        r = t[8],
                        s = t[1],
                        o = t[5],
                        a = t[9],
                        l = t[2],
                        c = t[6],
                        u = t[10],
                        h = n + o + u;
                    if (h > 0) {
                        const e = .5 / Math.sqrt(h + 1);
                        this._w = .25 / e, this._x = (c - a) * e, this._y = (r - l) * e, this._z = (s - i) * e
                    } else if (n > o && n > u) {
                        const e = 2 * Math.sqrt(1 + n - o - u);
                        this._w = (c - a) / e, this._x = .25 * e, this._y = (i + s) / e, this._z = (r + l) / e
                    } else if (o > u) {
                        const e = 2 * Math.sqrt(1 + o - n - u);
                        this._w = (r - l) / e, this._x = (i + s) / e, this._y = .25 * e, this._z = (a + c) / e
                    } else {
                        const e = 2 * Math.sqrt(1 + u - n - o);
                        this._w = (s - i) / e, this._x = (r + l) / e, this._y = (a + c) / e, this._z = .25 * e
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(Ue(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    const n = this.angleTo(e);
                    if (0 === n) return this;
                    const i = Math.min(1, t / n);
                    return this.slerp(e, i), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e) {
                    return this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    const n = e._x,
                        i = e._y,
                        r = e._z,
                        s = e._w,
                        o = t._x,
                        a = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    const n = this._x,
                        i = this._y,
                        r = this._z,
                        s = this._w;
                    let o = s * e._w + n * e._x + i * e._y + r * e._z;
                    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                    const a = 1 - o * o;
                    if (a <= Number.EPSILON) {
                        const e = 1 - t;
                        return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this
                    }
                    const l = Math.sqrt(a),
                        c = Math.atan2(l, o),
                        u = Math.sin((1 - t) * c) / l,
                        h = Math.sin(t * c) / l;
                    return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
                }
                slerpQuaternions(e, t, n) {
                    return this.copy(e).slerp(t, n)
                }
                random() {
                    const e = 2 * Math.PI * Math.random(),
                        t = 2 * Math.PI * Math.random(),
                        n = Math.random(),
                        i = Math.sqrt(1 - n),
                        r = Math.sqrt(n);
                    return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
                }
                toJSON() {
                    return this.toArray()
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._w
                }
            }
            class gt {
                constructor(e = 0, t = 0, n = 0) {
                    gt.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return this.applyQuaternion(vt.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(vt.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements,
                        s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this
                }
                applyQuaternion(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        s = e.y,
                        o = e.z,
                        a = e.w,
                        l = 2 * (s * i - o * n),
                        c = 2 * (o * t - r * i),
                        u = 2 * (r * n - s * t);
                    return this.x = t + a * l + s * u - o * c, this.y = n + a * c + o * l - r * u, this.z = i + a * u + r * c - s * l, this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                }
                cross(e) {
                    return this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        s = t.x,
                        o = t.y,
                        a = t.z;
                    return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
                }
                projectOnVector(e) {
                    const t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    const n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return At.copy(this).projectOnVector(e), this.sub(At)
                }
                reflect(e) {
                    return this.sub(At.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(Ue(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y,
                        i = this.z - e.z;
                    return t * t + n * n + i * i
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    const i = Math.sin(t) * e;
                    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    const t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        i = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = i, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                setFromEuler(e) {
                    return this.x = e._x, this.y = e._y, this.z = e._z, this
                }
                setFromColor(e) {
                    return this.x = e.r, this.y = e.g, this.z = e.b, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    const e = Math.random() * Math.PI * 2,
                        t = 2 * Math.random() - 1,
                        n = Math.sqrt(1 - t * t);
                    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            const At = new gt,
                vt = new mt;
            class yt {
                constructor(e = new gt(1 / 0, 1 / 0, 1 / 0), t = new gt(-1 / 0, -1 / 0, -1 / 0)) {
                    this.isBox3 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(xt.fromArray(e, t));
                    return this
                }
                setFromBufferAttribute(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(xt.fromBufferAttribute(e, t));
                    return this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = xt.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                setFromObject(e, t = !1) {
                    return this.makeEmpty(), this.expandByObject(e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e, t = !1) {
                    e.updateWorldMatrix(!1, !1);
                    const n = e.geometry;
                    if (void 0 !== n) {
                        const i = n.getAttribute("position");
                        if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                            for (let t = 0, n = i.count; t < n; t++) !0 === e.isMesh ? e.getVertexPosition(t, xt) : xt.fromBufferAttribute(i, t), xt.applyMatrix4(e.matrixWorld), this.expandByPoint(xt);
                        else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), Et.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), Et.copy(n.boundingBox)), Et.applyMatrix4(e.matrixWorld), this.union(Et)
                    }
                    const i = e.children;
                    for (let e = 0, n = i.length; e < n; e++) this.expandByObject(i[e], t);
                    return this
                }
                containsPoint(e) {
                    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, xt), xt.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(It), Bt.subVectors(this.max, It), bt.subVectors(e.a, It), wt.subVectors(e.b, It), Ct.subVectors(e.c, It), St.subVectors(wt, bt), Tt.subVectors(Ct, wt), Mt.subVectors(bt, Ct);
                    let t = [0, -St.z, St.y, 0, -Tt.z, Tt.y, 0, -Mt.z, Mt.y, St.z, 0, -St.x, Tt.z, 0, -Tt.x, Mt.z, 0, -Mt.x, -St.y, St.x, 0, -Tt.y, Tt.x, 0, -Mt.y, Mt.x, 0];
                    return !!Pt(t, bt, wt, Ct, Bt) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Pt(t, bt, wt, Ct, Bt) && (Rt.crossVectors(St, Tt), t = [Rt.x, Rt.y, Rt.z], Pt(t, bt, wt, Ct, Bt)))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return this.clampPoint(e, xt).distanceTo(e)
                }
                getBoundingSphere(e) {
                    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(xt).length()), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (_t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), _t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), _t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), _t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), _t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), _t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), _t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), _t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(_t)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            const _t = [new gt, new gt, new gt, new gt, new gt, new gt, new gt, new gt],
                xt = new gt,
                Et = new yt,
                bt = new gt,
                wt = new gt,
                Ct = new gt,
                St = new gt,
                Tt = new gt,
                Mt = new gt,
                It = new gt,
                Bt = new gt,
                Rt = new gt,
                Dt = new gt;

            function Pt(e, t, n, i, r) {
                for (let s = 0, o = e.length - 3; s <= o; s += 3) {
                    Dt.fromArray(e, s);
                    const o = r.x * Math.abs(Dt.x) + r.y * Math.abs(Dt.y) + r.z * Math.abs(Dt.z),
                        a = t.dot(Dt),
                        l = n.dot(Dt),
                        c = i.dot(Dt);
                    if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
                }
                return !0
            }
            const Lt = new yt,
                Ut = new gt,
                Nt = new gt;
            class Ot {
                constructor(e = new gt, t = -1) {
                    this.isSphere = !0, this.center = e, this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    const n = this.center;
                    void 0 !== t ? n.copy(t) : Lt.setFromPoints(e).getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(i), this
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    const t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    const n = this.center.distanceToSquared(e);
                    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                expandByPoint(e) {
                    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                    Ut.subVectors(e, this.center);
                    const t = Ut.lengthSq();
                    if (t > this.radius * this.radius) {
                        const e = Math.sqrt(t),
                            n = .5 * (e - this.radius);
                        this.center.addScaledVector(Ut, n / e), this.radius += n
                    }
                    return this
                }
                union(e) {
                    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Nt.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Ut.copy(e.center).add(Nt)), this.expandByPoint(Ut.copy(e.center).sub(Nt))), this)
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Ft = new gt,
                kt = new gt,
                Qt = new gt,
                zt = new gt,
                Ht = new gt,
                Gt = new gt,
                Vt = new gt;
            class jt {
                constructor(e = new gt, t = new gt(0, 0, -1)) {
                    this.origin = e, this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return t.copy(this.origin).addScaledVector(this.direction, e)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, Ft)), this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    const n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    const t = Ft.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (Ft.copy(this.origin).addScaledVector(this.direction, t), Ft.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, i) {
                    kt.copy(e).add(t).multiplyScalar(.5), Qt.copy(t).sub(e).normalize(), zt.copy(this.origin).sub(kt);
                    const r = .5 * e.distanceTo(t),
                        s = -this.direction.dot(Qt),
                        o = zt.dot(this.direction),
                        a = -zt.dot(Qt),
                        l = zt.lengthSq(),
                        c = Math.abs(1 - s * s);
                    let u, h, d, f;
                    if (c > 0)
                        if (u = s * a - o, h = s * o - a, f = r * c, u >= 0)
                            if (h >= -f)
                                if (h <= f) {
                                    const e = 1 / c;
                                    u *= e, h *= e, d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l
                                } else h = r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                    else h = -r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                    else h <= -f ? (u = Math.max(0, -(-s * r + o)), h = u > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l) : h <= f ? (u = 0, h = Math.min(Math.max(-r, -a), r), d = h * (h + 2 * a) + l) : (u = Math.max(0, -(s * r + o)), h = u > 0 ? r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l);
                    else h = s > 0 ? -r : r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                    return n && n.copy(this.origin).addScaledVector(this.direction, u), i && i.copy(kt).addScaledVector(Qt, h), d
                }
                intersectSphere(e, t) {
                    Ft.subVectors(e.center, this.origin);
                    const n = Ft.dot(this.direction),
                        i = Ft.dot(Ft) - n * n,
                        r = e.radius * e.radius;
                    if (i > r) return null;
                    const s = Math.sqrt(r - i),
                        o = n - s,
                        a = n + s;
                    return a < 0 ? null : o < 0 ? this.at(a, t) : this.at(o, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    const t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    const n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    const t = e.distanceToPoint(this.origin);
                    return 0 === t || e.normal.dot(this.direction) * t < 0
                }
                intersectBox(e, t) {
                    let n, i, r, s, o, a;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, s = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, s = (e.min.y - h.y) * c), n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r), (s < i || isNaN(i)) && (i = s), u >= 0 ? (o = (e.min.z - h.z) * u, a = (e.max.z - h.z) * u) : (o = (e.max.z - h.z) * u, a = (e.min.z - h.z) * u), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, Ft)
                }
                intersectTriangle(e, t, n, i, r) {
                    Ht.subVectors(t, e), Gt.subVectors(n, e), Vt.crossVectors(Ht, Gt);
                    let s, o = this.direction.dot(Vt);
                    if (o > 0) {
                        if (i) return null;
                        s = 1
                    } else {
                        if (!(o < 0)) return null;
                        s = -1, o = -o
                    }
                    zt.subVectors(this.origin, e);
                    const a = s * this.direction.dot(Gt.crossVectors(zt, Gt));
                    if (a < 0) return null;
                    const l = s * this.direction.dot(Ht.cross(zt));
                    if (l < 0) return null;
                    if (a + l > o) return null;
                    const c = -s * zt.dot(Vt);
                    return c < 0 ? null : this.at(c / o, r)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Wt {
                constructor(e, t, n, i, r, s, o, a, l, c, u, h, d, f, p, m) {
                    Wt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, s, o, a, l, c, u, h, d, f, p, m)
                }
                set(e, t, n, i, r, s, o, a, l, c, u, h, d, f, p, m) {
                    const g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = f, g[11] = p, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new Wt).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                }
                copyPosition(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                }
                setFromMatrix3(e) {
                    const t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    const t = this.elements,
                        n = e.elements,
                        i = 1 / Xt.setFromMatrixColumn(e, 0).length(),
                        r = 1 / Xt.setFromMatrixColumn(e, 1).length(),
                        s = 1 / Xt.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    const t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z,
                        s = Math.cos(n),
                        o = Math.sin(n),
                        a = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === e.order) {
                        const e = s * c,
                            n = s * u,
                            i = o * c,
                            r = o * u;
                        t[0] = a * c, t[4] = -a * u, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -o * a, t[2] = r - e * l, t[6] = i + n * l, t[10] = s * a
                    } else if ("YXZ" === e.order) {
                        const e = a * c,
                            n = a * u,
                            i = l * c,
                            r = l * u;
                        t[0] = e + r * o, t[4] = i * o - n, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -o, t[2] = n * o - i, t[6] = r + e * o, t[10] = s * a
                    } else if ("ZXY" === e.order) {
                        const e = a * c,
                            n = a * u,
                            i = l * c,
                            r = l * u;
                        t[0] = e - r * o, t[4] = -s * u, t[8] = i + n * o, t[1] = n + i * o, t[5] = s * c, t[9] = r - e * o, t[2] = -s * l, t[6] = o, t[10] = s * a
                    } else if ("ZYX" === e.order) {
                        const e = s * c,
                            n = s * u,
                            i = o * c,
                            r = o * u;
                        t[0] = a * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = a * u, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = o * a, t[10] = s * a
                    } else if ("YZX" === e.order) {
                        const e = s * a,
                            n = s * l,
                            i = o * a,
                            r = o * l;
                        t[0] = a * c, t[4] = r - e * u, t[8] = i * u + n, t[1] = u, t[5] = s * c, t[9] = -o * c, t[2] = -l * c, t[6] = n * u + i, t[10] = e - r * u
                    } else if ("XZY" === e.order) {
                        const e = s * a,
                            n = s * l,
                            i = o * a,
                            r = o * l;
                        t[0] = a * c, t[4] = -u, t[8] = l * c, t[1] = e * u + r, t[5] = s * c, t[9] = n * u - i, t[2] = i * u - n, t[6] = o * c, t[10] = r * u + e
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(qt, e, Kt)
                }
                lookAt(e, t, n) {
                    const i = this.elements;
                    return $t.subVectors(e, t), 0 === $t.lengthSq() && ($t.z = 1), $t.normalize(), Jt.crossVectors(n, $t), 0 === Jt.lengthSq() && (1 === Math.abs(n.z) ? $t.x += 1e-4 : $t.z += 1e-4, $t.normalize(), Jt.crossVectors(n, $t)), Jt.normalize(), Zt.crossVectors($t, Jt), i[0] = Jt.x, i[4] = Zt.x, i[8] = $t.x, i[1] = Jt.y, i[5] = Zt.y, i[9] = $t.y, i[2] = Jt.z, i[6] = Zt.z, i[10] = $t.z, this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        s = n[0],
                        o = n[4],
                        a = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        f = n[2],
                        p = n[6],
                        m = n[10],
                        g = n[14],
                        A = n[3],
                        v = n[7],
                        y = n[11],
                        _ = n[15],
                        x = i[0],
                        E = i[4],
                        b = i[8],
                        w = i[12],
                        C = i[1],
                        S = i[5],
                        T = i[9],
                        M = i[13],
                        I = i[2],
                        B = i[6],
                        R = i[10],
                        D = i[14],
                        P = i[3],
                        L = i[7],
                        U = i[11],
                        N = i[15];
                    return r[0] = s * x + o * C + a * I + l * P, r[4] = s * E + o * S + a * B + l * L, r[8] = s * b + o * T + a * R + l * U, r[12] = s * w + o * M + a * D + l * N, r[1] = c * x + u * C + h * I + d * P, r[5] = c * E + u * S + h * B + d * L, r[9] = c * b + u * T + h * R + d * U, r[13] = c * w + u * M + h * D + d * N, r[2] = f * x + p * C + m * I + g * P, r[6] = f * E + p * S + m * B + g * L, r[10] = f * b + p * T + m * R + g * U, r[14] = f * w + p * M + m * D + g * N, r[3] = A * x + v * C + y * I + _ * P, r[7] = A * E + v * S + y * B + _ * L, r[11] = A * b + v * T + y * R + _ * U, r[15] = A * w + v * M + y * D + _ * N, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[4],
                        i = e[8],
                        r = e[12],
                        s = e[1],
                        o = e[5],
                        a = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        h = e[10],
                        d = e[14];
                    return e[3] * (+r * a * u - i * l * u - r * o * h + n * l * h + i * o * d - n * a * d) + e[7] * (+t * a * d - t * l * h + r * s * h - i * s * d + i * l * c - r * a * c) + e[11] * (+t * l * u - t * o * d - r * s * u + n * s * d + r * o * c - n * l * c) + e[15] * (-i * o * c - t * a * u + t * o * h + i * s * u - n * s * h + n * a * c)
                }
                transpose() {
                    const e = this.elements;
                    let t;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                }
                setPosition(e, t, n) {
                    const i = this.elements;
                    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        s = e[4],
                        o = e[5],
                        a = e[6],
                        l = e[7],
                        c = e[8],
                        u = e[9],
                        h = e[10],
                        d = e[11],
                        f = e[12],
                        p = e[13],
                        m = e[14],
                        g = e[15],
                        A = u * m * l - p * h * l + p * a * d - o * m * d - u * a * g + o * h * g,
                        v = f * h * l - c * m * l - f * a * d + s * m * d + c * a * g - s * h * g,
                        y = c * p * l - f * u * l + f * o * d - s * p * d - c * o * g + s * u * g,
                        _ = f * u * a - c * p * a - f * o * h + s * p * h + c * o * m - s * u * m,
                        x = t * A + n * v + i * y + r * _;
                    if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const E = 1 / x;
                    return e[0] = A * E, e[1] = (p * h * r - u * m * r - p * i * d + n * m * d + u * i * g - n * h * g) * E, e[2] = (o * m * r - p * a * r + p * i * l - n * m * l - o * i * g + n * a * g) * E, e[3] = (u * a * r - o * h * r - u * i * l + n * h * l + o * i * d - n * a * d) * E, e[4] = v * E, e[5] = (c * m * r - f * h * r + f * i * d - t * m * d - c * i * g + t * h * g) * E, e[6] = (f * a * r - s * m * r - f * i * l + t * m * l + s * i * g - t * a * g) * E, e[7] = (s * h * r - c * a * r + c * i * l - t * h * l - s * i * d + t * a * d) * E, e[8] = y * E, e[9] = (f * u * r - c * p * r - f * n * d + t * p * d + c * n * g - t * u * g) * E, e[10] = (s * p * r - f * o * r + f * n * l - t * p * l - s * n * g + t * o * g) * E, e[11] = (c * o * r - s * u * r - c * n * l + t * u * l + s * n * d - t * o * d) * E, e[12] = _ * E, e[13] = (c * p * i - f * u * i + f * n * h - t * p * h - c * n * m + t * u * m) * E, e[14] = (f * o * i - s * p * i - f * n * a + t * p * a + s * n * m - t * o * m) * E, e[15] = (s * u * i - c * o * i + c * n * a - t * u * a - s * n * h + t * o * h) * E, this
                }
                scale(e) {
                    const t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z;
                    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, i))
                }
                makeTranslation(e, t, n) {
                    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    const n = Math.cos(t),
                        i = Math.sin(t),
                        r = 1 - n,
                        s = e.x,
                        o = e.y,
                        a = e.z,
                        l = r * s,
                        c = r * o;
                    return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, n, i, r, s) {
                    return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, n) {
                    const i = this.elements,
                        r = t._x,
                        s = t._y,
                        o = t._z,
                        a = t._w,
                        l = r + r,
                        c = s + s,
                        u = o + o,
                        h = r * l,
                        d = r * c,
                        f = r * u,
                        p = s * c,
                        m = s * u,
                        g = o * u,
                        A = a * l,
                        v = a * c,
                        y = a * u,
                        _ = n.x,
                        x = n.y,
                        E = n.z;
                    return i[0] = (1 - (p + g)) * _, i[1] = (d + y) * _, i[2] = (f - v) * _, i[3] = 0, i[4] = (d - y) * x, i[5] = (1 - (h + g)) * x, i[6] = (m + A) * x, i[7] = 0, i[8] = (f + v) * E, i[9] = (m - A) * E, i[10] = (1 - (h + p)) * E, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
                }
                decompose(e, t, n) {
                    const i = this.elements;
                    let r = Xt.set(i[0], i[1], i[2]).length();
                    const s = Xt.set(i[4], i[5], i[6]).length(),
                        o = Xt.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Yt.copy(this);
                    const a = 1 / r,
                        l = 1 / s,
                        c = 1 / o;
                    return Yt.elements[0] *= a, Yt.elements[1] *= a, Yt.elements[2] *= a, Yt.elements[4] *= l, Yt.elements[5] *= l, Yt.elements[6] *= l, Yt.elements[8] *= c, Yt.elements[9] *= c, Yt.elements[10] *= c, t.setFromRotationMatrix(Yt), n.x = r, n.y = s, n.z = o, this
                }
                makePerspective(e, t, n, i, r, s, o = 2e3) {
                    const a = this.elements,
                        l = 2 * r / (t - e),
                        c = 2 * r / (n - i),
                        u = (t + e) / (t - e),
                        h = (n + i) / (n - i);
                    let d, f;
                    if (o === Te) d = -(s + r) / (s - r), f = -2 * s * r / (s - r);
                    else {
                        if (o !== Me) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
                        d = -s / (s - r), f = -s * r / (s - r)
                    }
                    return a[0] = l, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                }
                makeOrthographic(e, t, n, i, r, s, o = 2e3) {
                    const a = this.elements,
                        l = 1 / (t - e),
                        c = 1 / (n - i),
                        u = 1 / (s - r),
                        h = (t + e) * l,
                        d = (n + i) * c;
                    let f, p;
                    if (o === Te) f = (s + r) * u, p = -2 * u;
                    else {
                        if (o !== Me) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
                        f = r * u, p = -1 * u
                    }
                    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = p, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }
            const Xt = new gt,
                Yt = new Wt,
                qt = new gt(0, 0, 0),
                Kt = new gt(1, 1, 1),
                Jt = new gt,
                Zt = new gt,
                $t = new gt,
                en = new Wt,
                tn = new mt;
            class nn {
                constructor(e = 0, t = 0, n = 0, i = nn.DEFAULT_ORDER) {
                    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, n, i = this._order) {
                    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t = this._order, n = !0) {
                    const i = e.elements,
                        r = i[0],
                        s = i[4],
                        o = i[8],
                        a = i[1],
                        l = i[5],
                        c = i[9],
                        u = i[2],
                        h = i[6],
                        d = i[10];
                    switch (t) {
                        case "XYZ":
                            this._y = Math.asin(Ue(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-Ue(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(Ue(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-Ue(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(Ue(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(o, d));
                            break;
                        case "XZY":
                            this._z = Math.asin(-Ue(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d), this._y = 0)
                    }
                    return this._order = t, !0 === n && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, n) {
                    return en.makeRotationFromQuaternion(e), this.setFromRotationMatrix(en, t, n)
                }
                setFromVector3(e, t = this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return tn.setFromEuler(this), this.setFromQuaternion(tn, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._order
                }
            }
            nn.DEFAULT_ORDER = "XYZ";
            class rn {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = 1 << e >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e
                }
                disable(e) {
                    this.mask &= ~(1 << e)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return !!(this.mask & e.mask)
                }
                isEnabled(e) {
                    return !!(this.mask & 1 << e)
                }
            }
            let sn = 0;
            const on = new gt,
                an = new mt,
                ln = new Wt,
                cn = new gt,
                un = new gt,
                hn = new gt,
                dn = new mt,
                fn = new gt(1, 0, 0),
                pn = new gt(0, 1, 0),
                mn = new gt(0, 0, 1),
                gn = {
                    type: "added"
                },
                An = {
                    type: "removed"
                },
                vn = {
                    type: "childadded",
                    child: null
                },
                yn = {
                    type: "childremoved",
                    child: null
                };
            class _n extends Ie {
                constructor() {
                    super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                        value: sn++
                    }), this.uuid = Le(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _n.DEFAULT_UP.clone();
                    const e = new gt,
                        t = new nn,
                        n = new mt,
                        i = new gt(1, 1, 1);
                    t._onChange((function() {
                        n.setFromEuler(t, !1)
                    })), n._onChange((function() {
                        t.setFromQuaternion(n, void 0, !1)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: i
                        },
                        modelViewMatrix: {
                            value: new Wt
                        },
                        normalMatrix: {
                            value: new He
                        }
                    }), this.matrix = new Wt, this.matrixWorld = new Wt, this.matrixAutoUpdate = _n.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = _n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new rn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeShadow() {}
                onAfterShadow() {}
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e), this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return an.setFromAxisAngle(e, t), this.quaternion.multiply(an), this
                }
                rotateOnWorldAxis(e, t) {
                    return an.setFromAxisAngle(e, t), this.quaternion.premultiply(an), this
                }
                rotateX(e) {
                    return this.rotateOnAxis(fn, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(pn, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(mn, e)
                }
                translateOnAxis(e, t) {
                    return on.copy(e).applyQuaternion(this.quaternion), this.position.add(on.multiplyScalar(t)), this
                }
                translateX(e) {
                    return this.translateOnAxis(fn, e)
                }
                translateY(e) {
                    return this.translateOnAxis(pn, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(mn, e)
                }
                localToWorld(e) {
                    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ln.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, n) {
                    e.isVector3 ? cn.copy(e) : cn.set(e, t, n);
                    const i = this.parent;
                    this.updateWorldMatrix(!0, !1), un.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ln.lookAt(un, cn, this.up) : ln.lookAt(cn, un, this.up), this.quaternion.setFromRotationMatrix(ln), i && (ln.extractRotation(i.matrixWorld), an.setFromRotationMatrix(ln), this.quaternion.premultiply(an.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return e === this || e && e.isObject3D && (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(gn), vn.child = e, this.dispatchEvent(vn), vn.child = null), this
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    const t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(An), yn.child = e, this.dispatchEvent(yn), yn.child = null), this
                }
                removeFromParent() {
                    const e = this.parent;
                    return null !== e && e.remove(this), this
                }
                clear() {
                    return this.remove(...this.children)
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1), ln.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), ln.multiply(e.parent.matrixWorld)), e.applyMatrix4(ln), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(gn), vn.child = e, this.dispatchEvent(vn), vn.child = null, this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t) return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== i) return i
                    }
                }
                getObjectsByProperty(e, t, n = []) {
                    this[e] === t && n.push(this);
                    const i = this.children;
                    for (let r = 0, s = i.length; r < s; r++) i[r].getObjectsByProperty(e, t, n);
                    return n
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(un, e, hn), e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(un, dn, e), e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
                }
                traverseAncestors(e) {
                    const t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
                }
                updateWorldMatrix(e, t) {
                    const n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) {
                        const e = this.children;
                        for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, n.metadata = {
                        version: 4.6,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const i = {};

                    function r(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((e => ({
                            boxInitialized: e.boxInitialized,
                            boxMin: e.box.min.toArray(),
                            boxMax: e.box.max.toArray(),
                            sphereInitialized: e.sphereInitialized,
                            sphereRadius: e.sphere.radius,
                            sphereCenter: e.sphere.center.toArray()
                        }))), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), null !== this._colorsTexture && (i.colorsTexture = this._colorsTexture.toJSON(e)), null !== this.boundingSphere && (i.boundingSphere = {
                            center: i.boundingSphere.center.toArray(),
                            radius: i.boundingSphere.radius
                        }), null !== this.boundingBox && (i.boundingBox = {
                            min: i.boundingBox.min.toArray(),
                            max: i.boundingBox.max.toArray()
                        })), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(e.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const n = t.shapes;
                            if (Array.isArray(n))
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    r(e.shapes, i)
                                } else r(e.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
                            i.material = t
                        } else i.material = r(e.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        i.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            const n = this.animations[t];
                            i.animations.push(r(e.animations, n))
                        }
                    }
                    if (t) {
                        const t = s(e.geometries),
                            i = s(e.materials),
                            r = s(e.textures),
                            o = s(e.images),
                            a = s(e.shapes),
                            l = s(e.skeletons),
                            c = s(e.animations),
                            u = s(e.nodes);
                        t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u)
                    }
                    return n.object = i, n;

                    function s(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                }
                clone(e) {
                    return (new this.constructor).copy(this, e)
                }
                copy(e, t = !0) {
                    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            const n = e.children[t];
                            this.add(n.clone())
                        }
                    return this
                }
            }
            _n.DEFAULT_UP = new gt(0, 1, 0), _n.DEFAULT_MATRIX_AUTO_UPDATE = !0, _n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
            const xn = new gt,
                En = new gt,
                bn = new gt,
                wn = new gt,
                Cn = new gt,
                Sn = new gt,
                Tn = new gt,
                Mn = new gt,
                In = new gt,
                Bn = new gt,
                Rn = new ut,
                Dn = new ut,
                Pn = new ut;
            class Ln {
                constructor(e = new gt, t = new gt, n = new gt) {
                    this.a = e, this.b = t, this.c = n
                }
                static getNormal(e, t, n, i) {
                    i.subVectors(n, t), xn.subVectors(e, t), i.cross(xn);
                    const r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, i, r) {
                    xn.subVectors(i, t), En.subVectors(n, t), bn.subVectors(e, t);
                    const s = xn.dot(xn),
                        o = xn.dot(En),
                        a = xn.dot(bn),
                        l = En.dot(En),
                        c = En.dot(bn),
                        u = s * l - o * o;
                    if (0 === u) return r.set(0, 0, 0), null;
                    const h = 1 / u,
                        d = (l * a - o * c) * h,
                        f = (s * c - o * a) * h;
                    return r.set(1 - d - f, f, d)
                }
                static containsPoint(e, t, n, i) {
                    return null !== this.getBarycoord(e, t, n, i, wn) && wn.x >= 0 && wn.y >= 0 && wn.x + wn.y <= 1
                }
                static getInterpolation(e, t, n, i, r, s, o, a) {
                    return null === this.getBarycoord(e, t, n, i, wn) ? (a.x = 0, a.y = 0, "z" in a && (a.z = 0), "w" in a && (a.w = 0), null) : (a.setScalar(0), a.addScaledVector(r, wn.x), a.addScaledVector(s, wn.y), a.addScaledVector(o, wn.z), a)
                }
                static getInterpolatedAttribute(e, t, n, i, r, s) {
                    return Rn.setScalar(0), Dn.setScalar(0), Pn.setScalar(0), Rn.fromBufferAttribute(e, t), Dn.fromBufferAttribute(e, n), Pn.fromBufferAttribute(e, i), s.setScalar(0), s.addScaledVector(Rn, r.x), s.addScaledVector(Dn, r.y), s.addScaledVector(Pn, r.z), s
                }
                static isFrontFacing(e, t, n, i) {
                    return xn.subVectors(n, t), En.subVectors(e, t), xn.cross(En).dot(i) < 0
                }
                set(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                }
                setFromPointsAndIndices(e, t, n, i) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
                }
                setFromAttributeAndIndices(e, t, n, i) {
                    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return xn.subVectors(this.c, this.b), En.subVectors(this.a, this.b), .5 * xn.cross(En).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return Ln.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return Ln.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getInterpolation(e, t, n, i, r) {
                    return Ln.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
                }
                containsPoint(e) {
                    return Ln.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return Ln.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    const n = this.a,
                        i = this.b,
                        r = this.c;
                    let s, o;
                    Cn.subVectors(i, n), Sn.subVectors(r, n), Mn.subVectors(e, n);
                    const a = Cn.dot(Mn),
                        l = Sn.dot(Mn);
                    if (a <= 0 && l <= 0) return t.copy(n);
                    In.subVectors(e, i);
                    const c = Cn.dot(In),
                        u = Sn.dot(In);
                    if (c >= 0 && u <= c) return t.copy(i);
                    const h = a * u - c * l;
                    if (h <= 0 && a >= 0 && c <= 0) return s = a / (a - c), t.copy(n).addScaledVector(Cn, s);
                    Bn.subVectors(e, r);
                    const d = Cn.dot(Bn),
                        f = Sn.dot(Bn);
                    if (f >= 0 && d <= f) return t.copy(r);
                    const p = d * l - a * f;
                    if (p <= 0 && l >= 0 && f <= 0) return o = l / (l - f), t.copy(n).addScaledVector(Sn, o);
                    const m = c * f - d * u;
                    if (m <= 0 && u - c >= 0 && d - f >= 0) return Tn.subVectors(r, i), o = (u - c) / (u - c + (d - f)), t.copy(i).addScaledVector(Tn, o);
                    const g = 1 / (m + p + h);
                    return s = p * g, o = h * g, t.copy(n).addScaledVector(Cn, s).addScaledVector(Sn, o)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            const Un = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                Nn = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                On = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function Fn(e, t, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }
            class kn {
                constructor(e, t, n) {
                    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
                }
                set(e, t, n) {
                    if (void 0 === t && void 0 === n) {
                        const t = e;
                        t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                    } else this.setRGB(e, t, n);
                    return this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e, t = _e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, qe.toWorkingColorSpace(this, t), this
                }
                setRGB(e, t, n, i = qe.workingColorSpace) {
                    return this.r = e, this.g = t, this.b = n, qe.toWorkingColorSpace(this, i), this
                }
                setHSL(e, t, n, i = qe.workingColorSpace) {
                    if (e = Ne(e, 1), t = Ue(t, 0, 1), n = Ue(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                    else {
                        const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                            r = 2 * n - i;
                        this.r = Fn(r, i, e + 1 / 3), this.g = Fn(r, i, e), this.b = Fn(r, i, e - 1 / 3)
                    }
                    return qe.toWorkingColorSpace(this, i), this
                }
                setStyle(e, t = _e) {
                    let n;
                    if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                        let e;
                        const i = n[1],
                            r = n[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return e[4], this.setRGB(Math.min(255, parseInt(e[1], 10)) / 255, Math.min(255, parseInt(e[2], 10)) / 255, Math.min(255, parseInt(e[3], 10)) / 255, t);
                                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return e[4], this.setRGB(Math.min(100, parseInt(e[1], 10)) / 100, Math.min(100, parseInt(e[2], 10)) / 100, Math.min(100, parseInt(e[3], 10)) / 100, t);
                                break;
                            case "hsl":
                            case "hsla":
                                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return e[4], this.setHSL(parseFloat(e[1]) / 360, parseFloat(e[2]) / 100, parseFloat(e[3]) / 100, t)
                        }
                    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        const e = n[1],
                            i = e.length;
                        if (3 === i) return this.setRGB(parseInt(e.charAt(0), 16) / 15, parseInt(e.charAt(1), 16) / 15, parseInt(e.charAt(2), 16) / 15, t);
                        if (6 === i) return this.setHex(parseInt(e, 16), t)
                    } else if (e && e.length > 0) return this.setColorName(e, t);
                    return this
                }
                setColorName(e, t = _e) {
                    const n = Un[e.toLowerCase()];
                    return void 0 !== n && this.setHex(n, t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copySRGBToLinear(e) {
                    return this.r = Ke(e.r), this.g = Ke(e.g), this.b = Ke(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = Je(e.r), this.g = Je(e.g), this.b = Je(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(e = _e) {
                    return qe.fromWorkingColorSpace(Qn.copy(this), e), 65536 * Math.round(Ue(255 * Qn.r, 0, 255)) + 256 * Math.round(Ue(255 * Qn.g, 0, 255)) + Math.round(Ue(255 * Qn.b, 0, 255))
                }
                getHexString(e = _e) {
                    return ("000000" + this.getHex(e).toString(16)).slice(-6)
                }
                getHSL(e, t = qe.workingColorSpace) {
                    qe.fromWorkingColorSpace(Qn.copy(this), t);
                    const n = Qn.r,
                        i = Qn.g,
                        r = Qn.b,
                        s = Math.max(n, i, r),
                        o = Math.min(n, i, r);
                    let a, l;
                    const c = (o + s) / 2;
                    if (o === s) a = 0, l = 0;
                    else {
                        const e = s - o;
                        switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
                            case n:
                                a = (i - r) / e + (i < r ? 6 : 0);
                                break;
                            case i:
                                a = (r - n) / e + 2;
                                break;
                            case r:
                                a = (n - i) / e + 4
                        }
                        a /= 6
                    }
                    return e.h = a, e.s = l, e.l = c, e
                }
                getRGB(e, t = qe.workingColorSpace) {
                    return qe.fromWorkingColorSpace(Qn.copy(this), t), e.r = Qn.r, e.g = Qn.g, e.b = Qn.b, e
                }
                getStyle(e = _e) {
                    qe.fromWorkingColorSpace(Qn.copy(this), e);
                    const t = Qn.r,
                        n = Qn.g,
                        i = Qn.b;
                    return e !== _e ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255*t)},${Math.round(255*n)},${Math.round(255*i)})`
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(Nn), this.setHSL(Nn.h + e, Nn.s + t, Nn.l + n)
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpColors(e, t, n) {
                    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
                }
                lerpHSL(e, t) {
                    this.getHSL(Nn), e.getHSL(On);
                    const n = Oe(Nn.h, On.h, t),
                        i = Oe(Nn.s, On.s, t),
                        r = Oe(Nn.l, On.l, t);
                    return this.setHSL(n, i, r), this
                }
                setFromVector3(e) {
                    return this.r = e.x, this.g = e.y, this.b = e.z, this
                }
                applyMatrix3(e) {
                    const t = this.r,
                        n = this.g,
                        i = this.b,
                        r = e.elements;
                    return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
                }
                toJSON() {
                    return this.getHex()
                }*[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b
                }
            }
            const Qn = new kn;
            kn.NAMES = Un;
            let zn = 0;
            class Hn extends Ie {
                static get type() {
                    return "Material"
                }
                get type() {
                    return this.constructor.type
                }
                set type(e) {}
                constructor() {
                    super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                        value: zn++
                    }), this.uuid = Le(), this.name = "", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = t, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new kn(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = we, this.stencilZFail = we, this.stencilZPass = we, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                }
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (const t in e) {
                            const n = e[t];
                            if (void 0 === n) continue;
                            const i = this[t];
                            void 0 !== i && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n)
                        }
                }
                toJSON(e) {
                    const n = void 0 === e || "string" == typeof e;
                    n && (e = {
                        textures: {},
                        images: {}
                    });
                    const i = {
                        metadata: {
                            version: 4.6,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (i.dispersion = this.dispersion), void 0 !== this.iridescence && (i.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapRotation && (i.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), !0 === this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = !0), 204 !== this.blendSrc && (i.blendSrc = this.blendSrc), 205 !== this.blendDst && (i.blendDst = this.blendDst), this.blendEquation !== t && (i.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (i.depthFunc = this.depthFunc), !1 === this.depthTest && (i.depthTest = this.depthTest), !1 === this.depthWrite && (i.depthWrite = this.depthWrite), !1 === this.colorWrite && (i.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (i.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (i.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== we && (i.stencilFail = this.stencilFail), this.stencilZFail !== we && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== we && (i.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaHash && (i.alphaHash = !0), !0 === this.alphaToCoverage && (i.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0), !0 === this.forceSinglePass && (i.forceSinglePass = !0), !0 === this.wireframe && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = !0), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), !1 === this.fog && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), n) {
                        const t = r(e.textures),
                            n = r(e.images);
                        t.length > 0 && (i.textures = t), n.length > 0 && (i.images = n)
                    }
                    return i
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    const t = e.clippingPlanes;
                    let n = null;
                    if (null !== t) {
                        const e = t.length;
                        n = new Array(e);
                        for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                onBuild() {}
            }
            class Gn extends Hn {
                static get type() {
                    return "MeshBasicMaterial"
                }
                constructor(e) {
                    super(), this.isMeshBasicMaterial = !0, this.color = new kn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new nn, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            const Vn = function() {
                const e = new ArrayBuffer(4),
                    t = new Float32Array(e),
                    n = new Uint32Array(e),
                    i = new Uint32Array(512),
                    r = new Uint32Array(512);
                for (let e = 0; e < 256; ++e) {
                    const t = e - 127;
                    t < -27 ? (i[e] = 0, i[256 | e] = 32768, r[e] = 24, r[256 | e] = 24) : t < -14 ? (i[e] = 1024 >> -t - 14, i[256 | e] = 1024 >> -t - 14 | 32768, r[e] = -t - 1, r[256 | e] = -t - 1) : t <= 15 ? (i[e] = t + 15 << 10, i[256 | e] = t + 15 << 10 | 32768, r[e] = 13, r[256 | e] = 13) : t < 128 ? (i[e] = 31744, i[256 | e] = 64512, r[e] = 24, r[256 | e] = 24) : (i[e] = 31744, i[256 | e] = 64512, r[e] = 13, r[256 | e] = 13)
                }
                const s = new Uint32Array(2048),
                    o = new Uint32Array(64),
                    a = new Uint32Array(64);
                for (let e = 1; e < 1024; ++e) {
                    let t = e << 13,
                        n = 0;
                    for (; !(8388608 & t);) t <<= 1, n -= 8388608;
                    t &= -8388609, n += 947912704, s[e] = t | n
                }
                for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + (e - 1024 << 13);
                for (let e = 1; e < 31; ++e) o[e] = e << 23;
                o[31] = 1199570944, o[32] = 2147483648;
                for (let e = 33; e < 63; ++e) o[e] = 2147483648 + (e - 32 << 23);
                o[63] = 3347054592;
                for (let e = 1; e < 64; ++e) 32 !== e && (a[e] = 1024);
                return {
                    floatView: t,
                    uint32View: n,
                    baseTable: i,
                    shiftTable: r,
                    mantissaTable: s,
                    exponentTable: o,
                    offsetTable: a
                }
            }();
            const jn = {
                    toHalfFloat: function(e) {
                        e = Ue(e, -65504, 65504), Vn.floatView[0] = e;
                        const t = Vn.uint32View[0],
                            n = t >> 23 & 511;
                        return Vn.baseTable[n] + ((8388607 & t) >> Vn.shiftTable[n])
                    },
                    fromHalfFloat: function(e) {
                        const t = e >> 10;
                        return Vn.uint32View[0] = Vn.mantissaTable[Vn.offsetTable[t] + (1023 & e)] + Vn.exponentTable[t], Vn.floatView[0]
                    }
                },
                Wn = new gt,
                Xn = new ze;
            class Yn {
                constructor(e, t, n = !1) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = Ce, this.updateRanges = [], this.gpuType = b, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
                }
                copyAt(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e), this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) Xn.fromBufferAttribute(this, t), Xn.applyMatrix3(e), this.setXY(t, Xn.x, Xn.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) Wn.fromBufferAttribute(this, t), Wn.applyMatrix3(e), this.setXYZ(t, Wn.x, Wn.y, Wn.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.count; t < n; t++) Wn.fromBufferAttribute(this, t), Wn.applyMatrix4(e), this.setXYZ(t, Wn.x, Wn.y, Wn.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) Wn.fromBufferAttribute(this, t), Wn.applyNormalMatrix(e), this.setXYZ(t, Wn.x, Wn.y, Wn.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) Wn.fromBufferAttribute(this, t), Wn.transformDirection(e), this.setXYZ(t, Wn.x, Wn.y, Wn.z);
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                getComponent(e, t) {
                    let n = this.array[e * this.itemSize + t];
                    return this.normalized && (n = Fe(n, this.array)), n
                }
                setComponent(e, t, n) {
                    return this.normalized && (n = ke(n, this.array)), this.array[e * this.itemSize + t] = n, this
                }
                getX(e) {
                    let t = this.array[e * this.itemSize];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                setX(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize] = t, this
                }
                getY(e) {
                    let t = this.array[e * this.itemSize + 1];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                setY(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize + 1] = t, this
                }
                getZ(e) {
                    let t = this.array[e * this.itemSize + 2];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                setZ(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize + 2] = t, this
                }
                getW(e) {
                    let t = this.array[e * this.itemSize + 3];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                setW(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize + 3] = t, this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize, this.normalized && (t = ke(t, this.array), n = ke(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
                }
                setXYZ(e, t, n, i) {
                    return e *= this.itemSize, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), i = ke(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
                }
                setXYZW(e, t, n, i, r) {
                    return e *= this.itemSize, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), i = ke(i, this.array), r = ke(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    const e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name), this.usage !== Ce && (e.usage = this.usage), e
                }
            }
            class qn extends Yn {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            class Kn extends Yn {
                constructor(e, t, n) {
                    super(new Uint32Array(e), t, n)
                }
            }
            class Jn extends Yn {
                constructor(e, t, n) {
                    super(new Float32Array(e), t, n)
                }
            }
            let Zn = 0;
            const $n = new Wt,
                ei = new _n,
                ti = new gt,
                ni = new yt,
                ii = new yt,
                ri = new gt;
            class si extends Ie {
                constructor() {
                    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                        value: Zn++
                    }), this.uuid = Le(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new(Ve(e) ? Kn : qn)(e, 1) : this.index = e, this
                }
                setIndirect(e) {
                    return this.indirect = e, this
                }
                getIndirect() {
                    return this.indirect
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t, this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e], this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, n = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                }
                applyMatrix4(e) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const t = (new He).getNormalMatrix(e);
                        n.applyNormalMatrix(t), n.needsUpdate = !0
                    }
                    const i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(e) {
                    return $n.makeRotationFromQuaternion(e), this.applyMatrix4($n), this
                }
                rotateX(e) {
                    return $n.makeRotationX(e), this.applyMatrix4($n), this
                }
                rotateY(e) {
                    return $n.makeRotationY(e), this.applyMatrix4($n), this
                }
                rotateZ(e) {
                    return $n.makeRotationZ(e), this.applyMatrix4($n), this
                }
                translate(e, t, n) {
                    return $n.makeTranslation(e, t, n), this.applyMatrix4($n), this
                }
                scale(e, t, n) {
                    return $n.makeScale(e, t, n), this.applyMatrix4($n), this
                }
                lookAt(e) {
                    return ei.lookAt(e), ei.updateMatrix(), this.applyMatrix4(ei.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(ti).negate(), this.translate(ti.x, ti.y, ti.z), this
                }
                setFromPoints(e) {
                    const t = this.getAttribute("position");
                    if (void 0 === t) {
                        const t = [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            t.push(i.x, i.y, i.z || 0)
                        }
                        this.setAttribute("position", new Jn(t, 3))
                    } else {
                        for (let n = 0, i = t.count; n < i; n++) {
                            const i = e[n];
                            t.setXYZ(n, i.x, i.y, i.z || 0)
                        }
                        e.length, t.count, t.needsUpdate = !0
                    }
                    return this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new yt);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) this.boundingBox.set(new gt(-1 / 0, -1 / 0, -1 / 0), new gt(1 / 0, 1 / 0, 1 / 0));
                    else {
                        if (void 0 !== e) {
                            if (this.boundingBox.setFromBufferAttribute(e), t)
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e];
                                    ni.setFromBufferAttribute(n), this.morphTargetsRelative ? (ri.addVectors(this.boundingBox.min, ni.min), this.boundingBox.expandByPoint(ri), ri.addVectors(this.boundingBox.max, ni.max), this.boundingBox.expandByPoint(ri)) : (this.boundingBox.expandByPoint(ni.min), this.boundingBox.expandByPoint(ni.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
                    }
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new Ot);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) this.boundingSphere.set(new gt, 1 / 0);
                    else if (e) {
                        const n = this.boundingSphere.center;
                        if (ni.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                ii.setFromBufferAttribute(n), this.morphTargetsRelative ? (ri.addVectors(ni.min, ii.min), ni.expandByPoint(ri), ri.addVectors(ni.max, ii.max), ni.expandByPoint(ri)) : (ni.expandByPoint(ii.min), ni.expandByPoint(ii.max))
                            }
                        ni.getCenter(n);
                        let i = 0;
                        for (let t = 0, r = e.count; t < r; t++) ri.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(ri));
                        if (t)
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r],
                                    o = this.morphTargetsRelative;
                                for (let t = 0, r = s.count; t < r; t++) ri.fromBufferAttribute(s, t), o && (ti.fromBufferAttribute(e, t), ri.add(ti)), i = Math.max(i, n.distanceToSquared(ri))
                            }
                        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius)
                    }
                }
                computeTangents() {
                    const e = this.index,
                        t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return;
                    const n = t.position,
                        i = t.normal,
                        r = t.uv;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Yn(new Float32Array(4 * n.count), 4));
                    const s = this.getAttribute("tangent"),
                        o = [],
                        a = [];
                    for (let e = 0; e < n.count; e++) o[e] = new gt, a[e] = new gt;
                    const l = new gt,
                        c = new gt,
                        u = new gt,
                        h = new ze,
                        d = new ze,
                        f = new ze,
                        p = new gt,
                        m = new gt;

                    function g(e, t, i) {
                        l.fromBufferAttribute(n, e), c.fromBufferAttribute(n, t), u.fromBufferAttribute(n, i), h.fromBufferAttribute(r, e), d.fromBufferAttribute(r, t), f.fromBufferAttribute(r, i), c.sub(l), u.sub(l), d.sub(h), f.sub(h);
                        const s = 1 / (d.x * f.y - f.x * d.y);
                        isFinite(s) && (p.copy(c).multiplyScalar(f.y).addScaledVector(u, -d.y).multiplyScalar(s), m.copy(u).multiplyScalar(d.x).addScaledVector(c, -f.x).multiplyScalar(s), o[e].add(p), o[t].add(p), o[i].add(p), a[e].add(m), a[t].add(m), a[i].add(m))
                    }
                    let A = this.groups;
                    0 === A.length && (A = [{
                        start: 0,
                        count: e.count
                    }]);
                    for (let t = 0, n = A.length; t < n; ++t) {
                        const n = A[t],
                            i = n.start;
                        for (let t = i, r = i + n.count; t < r; t += 3) g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                    }
                    const v = new gt,
                        y = new gt,
                        _ = new gt,
                        x = new gt;

                    function E(e) {
                        _.fromBufferAttribute(i, e), x.copy(_);
                        const t = o[e];
                        v.copy(t), v.sub(_.multiplyScalar(_.dot(t))).normalize(), y.crossVectors(x, t);
                        const n = y.dot(a[e]) < 0 ? -1 : 1;
                        s.setXYZW(e, v.x, v.y, v.z, n)
                    }
                    for (let t = 0, n = A.length; t < n; ++t) {
                        const n = A[t],
                            i = n.start;
                        for (let t = i, r = i + n.count; t < r; t += 3) E(e.getX(t + 0)), E(e.getX(t + 1)), E(e.getX(t + 2))
                    }
                }
                computeVertexNormals() {
                    const e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new Yn(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                        else
                            for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                        const i = new gt,
                            r = new gt,
                            s = new gt,
                            o = new gt,
                            a = new gt,
                            l = new gt,
                            c = new gt,
                            u = new gt;
                        if (e)
                            for (let h = 0, d = e.count; h < d; h += 3) {
                                const d = e.getX(h + 0),
                                    f = e.getX(h + 1),
                                    p = e.getX(h + 2);
                                i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, f), s.fromBufferAttribute(t, p), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, f), l.fromBufferAttribute(n, p), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(p, l.x, l.y, l.z)
                            } else
                                for (let e = 0, o = t.count; e < o; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                }
                normalizeNormals() {
                    const e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++) ri.fromBufferAttribute(e, t), ri.normalize(), e.setXYZ(t, ri.x, ri.y, ri.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        const n = e.array,
                            i = e.itemSize,
                            r = e.normalized,
                            s = new n.constructor(t.length * i);
                        let o = 0,
                            a = 0;
                        for (let r = 0, l = t.length; r < l; r++) {
                            o = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                            for (let e = 0; e < i; e++) s[a++] = n[o++]
                        }
                        return new Yn(s, i, r)
                    }
                    if (null === this.index) return this;
                    const t = new si,
                        n = this.index.array,
                        i = this.attributes;
                    for (const r in i) {
                        const s = e(i[r], n);
                        t.setAttribute(r, s)
                    }
                    const r = this.morphAttributes;
                    for (const i in r) {
                        const s = [],
                            o = r[i];
                        for (let t = 0, i = o.length; t < i; t++) {
                            const i = e(o[t], n);
                            s.push(i)
                        }
                        t.morphAttributes[i] = s
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let e = 0, n = s.length; e < n; e++) {
                        const n = s[e];
                        t.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.6,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const n = this.attributes;
                    for (const t in n) {
                        const i = n[t];
                        e.data.attributes[t] = i.toJSON(e.data)
                    }
                    const i = {};
                    let r = !1;
                    for (const t in this.morphAttributes) {
                        const n = this.morphAttributes[t],
                            s = [];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            s.push(i.toJSON(e.data))
                        }
                        s.length > 0 && (i[t] = s, r = !0)
                    }
                    r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    const s = this.groups;
                    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    const o = this.boundingSphere;
                    return null !== o && (e.data.boundingSphere = {
                        center: o.center.toArray(),
                        radius: o.radius
                    }), e
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const t = {};
                    this.name = e.name;
                    const n = e.index;
                    null !== n && this.setIndex(n.clone(t));
                    const i = e.attributes;
                    for (const e in i) {
                        const n = i[e];
                        this.setAttribute(e, n.clone(t))
                    }
                    const r = e.morphAttributes;
                    for (const e in r) {
                        const n = [],
                            i = r[e];
                        for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                        this.morphAttributes[e] = n
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    const s = e.groups;
                    for (let e = 0, t = s.length; e < t; e++) {
                        const t = s[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const o = e.boundingBox;
                    null !== o && (this.boundingBox = o.clone());
                    const a = e.boundingSphere;
                    return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            const oi = new Wt,
                ai = new jt,
                li = new Ot,
                ci = new gt,
                ui = new gt,
                hi = new gt,
                di = new gt,
                fi = new gt,
                pi = new gt,
                mi = new gt,
                gi = new gt;
            class Ai extends _n {
                constructor(e = new si, t = new Gn) {
                    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
                getVertexPosition(e, t) {
                    const n = this.geometry,
                        i = n.attributes.position,
                        r = n.morphAttributes.position,
                        s = n.morphTargetsRelative;
                    t.fromBufferAttribute(i, e);
                    const o = this.morphTargetInfluences;
                    if (r && o) {
                        pi.set(0, 0, 0);
                        for (let n = 0, i = r.length; n < i; n++) {
                            const i = o[n],
                                a = r[n];
                            0 !== i && (fi.fromBufferAttribute(a, e), s ? pi.addScaledVector(fi, i) : pi.addScaledVector(fi.sub(t), i))
                        }
                        t.add(pi)
                    }
                    return t
                }
                raycast(e, t) {
                    const n = this.geometry,
                        i = this.material,
                        r = this.matrixWorld;
                    if (void 0 !== i) {
                        if (null === n.boundingSphere && n.computeBoundingSphere(), li.copy(n.boundingSphere), li.applyMatrix4(r), ai.copy(e.ray).recast(e.near), !1 === li.containsPoint(ai.origin)) {
                            if (null === ai.intersectSphere(li, ci)) return;
                            if (ai.origin.distanceToSquared(ci) > (e.far - e.near) ** 2) return
                        }
                        oi.copy(r).invert(), ai.copy(e.ray).applyMatrix4(oi), null !== n.boundingBox && !1 === ai.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, ai)
                    }
                }
                _computeIntersections(e, t, n) {
                    let i;
                    const r = this.geometry,
                        s = this.material,
                        o = r.index,
                        a = r.attributes.position,
                        l = r.attributes.uv,
                        c = r.attributes.uv1,
                        u = r.attributes.normal,
                        h = r.groups,
                        d = r.drawRange;
                    if (null !== o)
                        if (Array.isArray(s))
                            for (let r = 0, a = h.length; r < a; r++) {
                                const a = h[r],
                                    f = s[a.materialIndex];
                                for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3) i = vi(this, f, e, n, l, c, u, o.getX(r), o.getX(r + 1), o.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = a.materialIndex, t.push(i))
                            } else
                                for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3) i = vi(this, s, e, n, l, c, u, o.getX(r), o.getX(r + 1), o.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), t.push(i));
                        else if (void 0 !== a)
                        if (Array.isArray(s))
                            for (let r = 0, o = h.length; r < o; r++) {
                                const o = h[r],
                                    f = s[o.materialIndex];
                                for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3) i = vi(this, f, e, n, l, c, u, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = o.materialIndex, t.push(i))
                            } else
                                for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3) i = vi(this, s, e, n, l, c, u, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), t.push(i))
                }
            }

            function vi(e, t, n, i, r, s, o, a, l, c) {
                e.getVertexPosition(a, ui), e.getVertexPosition(l, hi), e.getVertexPosition(c, di);
                const u = function(e, t, n, i, r, s, o, a) {
                    let l;
                    if (l = 1 === t.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 0 === t.side, a), null === l) return null;
                    gi.copy(a), gi.applyMatrix4(e.matrixWorld);
                    const c = n.ray.origin.distanceTo(gi);
                    return c < n.near || c > n.far ? null : {
                        distance: c,
                        point: gi.clone(),
                        object: e
                    }
                }(e, t, n, i, ui, hi, di, mi);
                if (u) {
                    const e = new gt;
                    Ln.getBarycoord(mi, ui, hi, di, e), r && (u.uv = Ln.getInterpolatedAttribute(r, a, l, c, e, new ze)), s && (u.uv1 = Ln.getInterpolatedAttribute(s, a, l, c, e, new ze)), o && (u.normal = Ln.getInterpolatedAttribute(o, a, l, c, e, new gt), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
                    const t = {
                        a: a,
                        b: l,
                        c: c,
                        normal: new gt,
                        materialIndex: 0
                    };
                    Ln.getNormal(ui, hi, di, t.normal), u.face = t, u.barycoord = e
                }
                return u
            }
            class yi extends si {
                constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: s
                    };
                    const o = this;
                    i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                    const a = [],
                        l = [],
                        c = [],
                        u = [];
                    let h = 0,
                        d = 0;

                    function f(e, t, n, i, r, s, f, p, m, g, A) {
                        const v = s / m,
                            y = f / g,
                            _ = s / 2,
                            x = f / 2,
                            E = p / 2,
                            b = m + 1,
                            w = g + 1;
                        let C = 0,
                            S = 0;
                        const T = new gt;
                        for (let s = 0; s < w; s++) {
                            const o = s * y - x;
                            for (let a = 0; a < b; a++) {
                                const h = a * v - _;
                                T[e] = h * i, T[t] = o * r, T[n] = E, l.push(T.x, T.y, T.z), T[e] = 0, T[t] = 0, T[n] = p > 0 ? 1 : -1, c.push(T.x, T.y, T.z), u.push(a / m), u.push(1 - s / g), C += 1
                            }
                        }
                        for (let e = 0; e < g; e++)
                            for (let t = 0; t < m; t++) {
                                const n = h + t + b * e,
                                    i = h + t + b * (e + 1),
                                    r = h + (t + 1) + b * (e + 1),
                                    s = h + (t + 1) + b * e;
                                a.push(n, i, s), a.push(i, r, s), S += 6
                            }
                        o.addGroup(d, S, A), d += S, h += C
                    }
                    f("z", "y", "x", -1, -1, n, t, e, s, r, 0), f("z", "y", "x", 1, -1, n, t, -e, s, r, 1), f("x", "z", "y", 1, 1, e, n, t, i, s, 2), f("x", "z", "y", 1, -1, e, n, -t, i, s, 3), f("x", "y", "z", 1, -1, e, t, n, i, r, 4), f("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Jn(l, 3)), this.setAttribute("normal", new Jn(c, 3)), this.setAttribute("uv", new Jn(u, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new yi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                }
            }

            function _i(e) {
                const t = {};
                for (const n in e) {
                    t[n] = {};
                    for (const i in e[n]) {
                        const r = e[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? t[n][i] = null : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                    }
                }
                return t
            }

            function xi(e) {
                const t = {};
                for (let n = 0; n < e.length; n++) {
                    const i = _i(e[n]);
                    for (const e in i) t[e] = i[e]
                }
                return t
            }

            function Ei(e) {
                const t = e.getRenderTarget();
                return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : qe.workingColorSpace
            }
            const bi = {
                clone: _i,
                merge: xi
            };
            class wi extends Hn {
                static get type() {
                    return "ShaderMaterial"
                }
                constructor(e) {
                    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                        clipCullDistance: !1,
                        multiDraw: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv1: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = _i(e.uniforms), this.uniformsGroups = function(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++) t.push(e[n].clone());
                        return t
                    }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    t.glslVersion = this.glslVersion, t.uniforms = {};
                    for (const n in this.uniforms) {
                        const i = this.uniforms[n].value;
                        i && i.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: i.toJSON(e).uuid
                        } : i && i.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: i.getHex()
                        } : i && i.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: i.toArray()
                        } : i && i.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: i.toArray()
                        } : i && i.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: i.toArray()
                        } : i && i.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: i.toArray()
                        } : i && i.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: i.toArray()
                        } : t.uniforms[n] = {
                            value: i
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
                    const n = {};
                    for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
                    return Object.keys(n).length > 0 && (t.extensions = n), t
                }
            }
            class Ci extends _n {
                constructor() {
                    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Wt, this.projectionMatrix = new Wt, this.projectionMatrixInverse = new Wt, this.coordinateSystem = Te
                }
                copy(e, t) {
                    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
                }
                getWorldDirection(e) {
                    return super.getWorldDirection(e).negate()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Si = new gt,
                Ti = new ze,
                Mi = new ze;
            class Ii extends Ci {
                constructor(e = 50, t = 1, n = .1, i = 2e3) {
                    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                }
                setFocalLength(e) {
                    const t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Pe * Math.atan(t), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const e = Math.tan(.5 * De * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * Pe * Math.atan(Math.tan(.5 * De * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                getViewBounds(e, t, n) {
                    Si.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Si.x, Si.y).multiplyScalar(-e / Si.z), Si.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(Si.x, Si.y).multiplyScalar(-e / Si.z)
                }
                getViewSize(e, t) {
                    return this.getViewBounds(e, Ti, Mi), t.subVectors(Mi, Ti)
                }
                setViewOffset(e, t, n, i, r, s) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = this.near;
                    let t = e * Math.tan(.5 * De * this.fov) / this.zoom,
                        n = 2 * t,
                        i = this.aspect * n,
                        r = -.5 * i;
                    const s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const e = s.fullWidth,
                            o = s.fullHeight;
                        r += s.offsetX * i / e, t -= s.offsetY * n / o, i *= s.width / e, n *= s.height / o
                    }
                    const o = this.filmOffset;
                    0 !== o && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }
            const Bi = -90;
            class Ri extends _n {
                constructor(e, t, n) {
                    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                    const i = new Ii(Bi, 1, e, t);
                    i.layers = this.layers, this.add(i);
                    const r = new Ii(Bi, 1, e, t);
                    r.layers = this.layers, this.add(r);
                    const s = new Ii(Bi, 1, e, t);
                    s.layers = this.layers, this.add(s);
                    const o = new Ii(Bi, 1, e, t);
                    o.layers = this.layers, this.add(o);
                    const a = new Ii(Bi, 1, e, t);
                    a.layers = this.layers, this.add(a);
                    const l = new Ii(Bi, 1, e, t);
                    l.layers = this.layers, this.add(l)
                }
                updateCoordinateSystem() {
                    const e = this.coordinateSystem,
                        t = this.children.concat(),
                        [n, i, r, s, o, a] = t;
                    for (const e of t) this.remove(e);
                    if (e === Te) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), a.up.set(0, 1, 0), a.lookAt(0, 0, -1);
                    else {
                        if (e !== Me) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                        n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), a.up.set(0, -1, 0), a.lookAt(0, 0, -1)
                    }
                    for (const e of t) this.add(e), e.updateMatrixWorld()
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    const {
                        renderTarget: n,
                        activeMipmapLevel: i
                    } = this;
                    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
                    const [r, s, o, a, l, c] = this.children, u = e.getRenderTarget(), h = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), f = e.xr.enabled;
                    e.xr.enabled = !1;
                    const p = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, s), e.setRenderTarget(n, 2, i), e.render(t, o), e.setRenderTarget(n, 3, i), e.render(t, a), e.setRenderTarget(n, 4, i), e.render(t, l), n.texture.generateMipmaps = p, e.setRenderTarget(n, 5, i), e.render(t, c), e.setRenderTarget(u, h, d), e.xr.enabled = f, n.texture.needsPMREMUpdate = !0
                }
            }
            class Di extends ct {
                constructor(e, t, n, i, s, o, a, l, c, u) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : r, n, i, s, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class Pi extends dt {
                constructor(e = 1, t = {}) {
                    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                    const n = {
                            width: e,
                            height: e,
                            depth: 1
                        },
                        i = [n, n, n, n, n, n];
                    this.texture = new Di(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : f
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                    const n = {
                            tEquirect: {
                                value: null
                            }
                        },
                        i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                        s = new yi(5, 5, 5),
                        o = new wi({
                            name: "CubemapFromEquirect",
                            uniforms: _i(n),
                            vertexShader: i,
                            fragmentShader: r,
                            side: 1,
                            blending: 0
                        });
                    o.uniforms.tEquirect.value = t;
                    const a = new Ai(s, o),
                        l = t.minFilter;
                    return t.minFilter === m && (t.minFilter = f), new Ri(1, 10, this).update(e, a), t.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
                }
                clear(e, t, n, i) {
                    const r = e.getRenderTarget();
                    for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
                    e.setRenderTarget(r)
                }
            }
            const Li = new gt,
                Ui = new gt,
                Ni = new He;
            class Oi {
                constructor(e = new gt(1, 0, 0), t = 0) {
                    this.isPlane = !0, this.normal = e, this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, n, i) {
                    return this.normal.set(e, t, n), this.constant = i, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, n) {
                    const i = Li.subVectors(n, t).cross(Ui.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, e), this
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    const e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                }
                intersectLine(e, t) {
                    const n = e.delta(Li),
                        i = this.normal.dot(n);
                    if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    const r = -(e.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
                }
                intersectsLine(e) {
                    const t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    const n = t || Ni.getNormalMatrix(e),
                        i = this.coplanarPoint(Li).applyMatrix4(e),
                        r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Fi = new Ot,
                ki = new gt;
            class Qi {
                constructor(e = new Oi, t = new Oi, n = new Oi, i = new Oi, r = new Oi, s = new Oi) {
                    this.planes = [e, t, n, i, r, s]
                }
                set(e, t, n, i, r, s) {
                    const o = this.planes;
                    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
                }
                copy(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e, t = 2e3) {
                    const n = this.planes,
                        i = e.elements,
                        r = i[0],
                        s = i[1],
                        o = i[2],
                        a = i[3],
                        l = i[4],
                        c = i[5],
                        u = i[6],
                        h = i[7],
                        d = i[8],
                        f = i[9],
                        p = i[10],
                        m = i[11],
                        g = i[12],
                        A = i[13],
                        v = i[14],
                        y = i[15];
                    if (n[0].setComponents(a - r, h - l, m - d, y - g).normalize(), n[1].setComponents(a + r, h + l, m + d, y + g).normalize(), n[2].setComponents(a + s, h + c, m + f, y + A).normalize(), n[3].setComponents(a - s, h - c, m - f, y - A).normalize(), n[4].setComponents(a - o, h - u, m - p, y - v).normalize(), t === Te) n[5].setComponents(a + o, h + u, m + p, y + v).normalize();
                    else {
                        if (t !== Me) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                        n[5].setComponents(o, u, p, v).normalize()
                    }
                    return this
                }
                intersectsObject(e) {
                    if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), Fi.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                    else {
                        const t = e.geometry;
                        null === t.boundingSphere && t.computeBoundingSphere(), Fi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                    }
                    return this.intersectsSphere(Fi)
                }
                intersectsSprite(e) {
                    return Fi.center.set(0, 0, 0), Fi.radius = .7071067811865476, Fi.applyMatrix4(e.matrixWorld), this.intersectsSphere(Fi)
                }
                intersectsSphere(e) {
                    const t = this.planes,
                        n = e.center,
                        i = -e.radius;
                    for (let e = 0; e < 6; e++)
                        if (t[e].distanceToPoint(n) < i) return !1;
                    return !0
                }
                intersectsBox(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const i = t[n];
                        if (ki.x = i.normal.x > 0 ? e.max.x : e.min.x, ki.y = i.normal.y > 0 ? e.max.y : e.min.y, ki.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(ki) < 0) return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }

            function zi() {
                let e = null,
                    t = !1,
                    n = null,
                    i = null;

                function r(t, s) {
                    n(t, s), i = e.requestAnimationFrame(r)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(i), t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function Hi(e) {
                const t = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        const i = t.get(n);
                        i && (e.deleteBuffer(i.buffer), t.delete(n))
                    },
                    update: function(n, i) {
                        if (n.isInterleavedBufferAttribute && (n = n.data), n.isGLBufferAttribute) {
                            const e = t.get(n);
                            return void((!e || e.version < n.version) && t.set(n, {
                                buffer: n.buffer,
                                type: n.type,
                                bytesPerElement: n.elementSize,
                                version: n.version
                            }))
                        }
                        const r = t.get(n);
                        if (void 0 === r) t.set(n, function(t, n) {
                            const i = t.array,
                                r = t.usage,
                                s = i.byteLength,
                                o = e.createBuffer();
                            let a;
                            if (e.bindBuffer(n, o), e.bufferData(n, i, r), t.onUploadCallback(), i instanceof Float32Array) a = e.FLOAT;
                            else if (i instanceof Uint16Array) a = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                            else if (i instanceof Int16Array) a = e.SHORT;
                            else if (i instanceof Uint32Array) a = e.UNSIGNED_INT;
                            else if (i instanceof Int32Array) a = e.INT;
                            else if (i instanceof Int8Array) a = e.BYTE;
                            else if (i instanceof Uint8Array) a = e.UNSIGNED_BYTE;
                            else {
                                if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                a = e.UNSIGNED_BYTE
                            }
                            return {
                                buffer: o,
                                type: a,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version,
                                size: s
                            }
                        }(n, i));
                        else if (r.version < n.version) {
                            if (r.size !== n.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            ! function(t, n, i) {
                                const r = n.array,
                                    s = n.updateRanges;
                                if (e.bindBuffer(i, t), 0 === s.length) e.bufferSubData(i, 0, r);
                                else {
                                    s.sort(((e, t) => e.start - t.start));
                                    let t = 0;
                                    for (let e = 1; e < s.length; e++) {
                                        const n = s[t],
                                            i = s[e];
                                        i.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, i.start + i.count - n.start) : (++t, s[t] = i)
                                    }
                                    s.length = t + 1;
                                    for (let t = 0, n = s.length; t < n; t++) {
                                        const n = s[t];
                                        e.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                                    }
                                    n.clearUpdateRanges()
                                }
                                n.onUploadCallback()
                            }(r.buffer, n, i), r.version = n.version
                        }
                    }
                }
            }
            class Gi extends si {
                constructor(e = 1, t = 1, n = 1, i = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: i
                    };
                    const r = e / 2,
                        s = t / 2,
                        o = Math.floor(n),
                        a = Math.floor(i),
                        l = o + 1,
                        c = a + 1,
                        u = e / o,
                        h = t / a,
                        d = [],
                        f = [],
                        p = [],
                        m = [];
                    for (let e = 0; e < c; e++) {
                        const t = e * h - s;
                        for (let n = 0; n < l; n++) {
                            const i = n * u - r;
                            f.push(i, -t, 0), p.push(0, 0, 1), m.push(n / o), m.push(1 - e / a)
                        }
                    }
                    for (let e = 0; e < a; e++)
                        for (let t = 0; t < o; t++) {
                            const n = t + l * e,
                                i = t + l * (e + 1),
                                r = t + 1 + l * (e + 1),
                                s = t + 1 + l * e;
                            d.push(n, i, s), d.push(i, r, s)
                        }
                    this.setIndex(d), this.setAttribute("position", new Jn(f, 3)), this.setAttribute("normal", new Jn(p, 3)), this.setAttribute("uv", new Jn(m, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new Gi(e.width, e.height, e.widthSegments, e.heightSegments)
                }
            }
            const Vi = {
                    alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                    alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
                    batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                    iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                    lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                    morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                    normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                    opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
                    shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                    uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                    uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                    uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
                },
                ji = {
                    common: {
                        diffuse: {
                            value: new kn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new He
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new He
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new He
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: new He
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new He
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new He
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new He
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new He
                        },
                        normalScale: {
                            value: new ze(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new He
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new He
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new He
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new He
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new kn(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new kn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new He
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new He
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new kn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new ze(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new He
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new He
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                },
                Wi = {
                    basic: {
                        uniforms: xi([ji.common, ji.specularmap, ji.envmap, ji.aomap, ji.lightmap, ji.fog]),
                        vertexShader: Vi.meshbasic_vert,
                        fragmentShader: Vi.meshbasic_frag
                    },
                    lambert: {
                        uniforms: xi([ji.common, ji.specularmap, ji.envmap, ji.aomap, ji.lightmap, ji.emissivemap, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.fog, ji.lights, {
                            emissive: {
                                value: new kn(0)
                            }
                        }]),
                        vertexShader: Vi.meshlambert_vert,
                        fragmentShader: Vi.meshlambert_frag
                    },
                    phong: {
                        uniforms: xi([ji.common, ji.specularmap, ji.envmap, ji.aomap, ji.lightmap, ji.emissivemap, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.fog, ji.lights, {
                            emissive: {
                                value: new kn(0)
                            },
                            specular: {
                                value: new kn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Vi.meshphong_vert,
                        fragmentShader: Vi.meshphong_frag
                    },
                    standard: {
                        uniforms: xi([ji.common, ji.envmap, ji.aomap, ji.lightmap, ji.emissivemap, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.roughnessmap, ji.metalnessmap, ji.fog, ji.lights, {
                            emissive: {
                                value: new kn(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Vi.meshphysical_vert,
                        fragmentShader: Vi.meshphysical_frag
                    },
                    toon: {
                        uniforms: xi([ji.common, ji.aomap, ji.lightmap, ji.emissivemap, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.gradientmap, ji.fog, ji.lights, {
                            emissive: {
                                value: new kn(0)
                            }
                        }]),
                        vertexShader: Vi.meshtoon_vert,
                        fragmentShader: Vi.meshtoon_frag
                    },
                    matcap: {
                        uniforms: xi([ji.common, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Vi.meshmatcap_vert,
                        fragmentShader: Vi.meshmatcap_frag
                    },
                    points: {
                        uniforms: xi([ji.points, ji.fog]),
                        vertexShader: Vi.points_vert,
                        fragmentShader: Vi.points_frag
                    },
                    dashed: {
                        uniforms: xi([ji.common, ji.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Vi.linedashed_vert,
                        fragmentShader: Vi.linedashed_frag
                    },
                    depth: {
                        uniforms: xi([ji.common, ji.displacementmap]),
                        vertexShader: Vi.depth_vert,
                        fragmentShader: Vi.depth_frag
                    },
                    normal: {
                        uniforms: xi([ji.common, ji.bumpmap, ji.normalmap, ji.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Vi.meshnormal_vert,
                        fragmentShader: Vi.meshnormal_frag
                    },
                    sprite: {
                        uniforms: xi([ji.sprite, ji.fog]),
                        vertexShader: Vi.sprite_vert,
                        fragmentShader: Vi.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new He
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: Vi.background_vert,
                        fragmentShader: Vi.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            },
                            backgroundRotation: {
                                value: new He
                            }
                        },
                        vertexShader: Vi.backgroundCube_vert,
                        fragmentShader: Vi.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: Vi.cube_vert,
                        fragmentShader: Vi.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Vi.equirect_vert,
                        fragmentShader: Vi.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: xi([ji.common, ji.displacementmap, {
                            referencePosition: {
                                value: new gt
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Vi.distanceRGBA_vert,
                        fragmentShader: Vi.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: xi([ji.lights, ji.fog, {
                            color: {
                                value: new kn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Vi.shadow_vert,
                        fragmentShader: Vi.shadow_frag
                    }
                };
            Wi.physical = {
                uniforms: xi([Wi.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatMapTransform: {
                        value: new He
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    clearcoatNormalMapTransform: {
                        value: new He
                    },
                    clearcoatNormalScale: {
                        value: new ze(1, 1)
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatRoughnessMapTransform: {
                        value: new He
                    },
                    dispersion: {
                        value: 0
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceMapTransform: {
                        value: new He
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    iridescenceThicknessMapTransform: {
                        value: new He
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new kn(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenColorMapTransform: {
                        value: new He
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    sheenRoughnessMapTransform: {
                        value: new He
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionMapTransform: {
                        value: new He
                    },
                    transmissionSamplerSize: {
                        value: new ze
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    thicknessMapTransform: {
                        value: new He
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new kn(0)
                    },
                    specularColor: {
                        value: new kn(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    },
                    specularColorMapTransform: {
                        value: new He
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularIntensityMapTransform: {
                        value: new He
                    },
                    anisotropyVector: {
                        value: new ze
                    },
                    anisotropyMap: {
                        value: null
                    },
                    anisotropyMapTransform: {
                        value: new He
                    }
                }]),
                vertexShader: Vi.meshphysical_vert,
                fragmentShader: Vi.meshphysical_frag
            };
            const Xi = {
                    r: 0,
                    b: 0,
                    g: 0
                },
                Yi = new nn,
                qi = new Wt;

            function Ki(e, t, n, i, r, s, o) {
                const l = new kn(0);
                let c, u, h = !0 === s ? 0 : 1,
                    d = null,
                    f = 0,
                    p = null;

                function m(e) {
                    let i = !0 === e.isScene ? e.background : null;
                    return i && i.isTexture && (i = (e.backgroundBlurriness > 0 ? n : t).get(i)), i
                }

                function g(t, n) {
                    t.getRGB(Xi, Ei(e)), i.buffers.color.setClear(Xi.r, Xi.g, Xi.b, n, o)
                }
                return {
                    getClearColor: function() {
                        return l
                    },
                    setClearColor: function(e, t = 1) {
                        l.set(e), h = t, g(l, h)
                    },
                    getClearAlpha: function() {
                        return h
                    },
                    setClearAlpha: function(e) {
                        h = e, g(l, h)
                    },
                    render: function(t) {
                        let n = !1;
                        const r = m(t);
                        null === r ? g(l, h) : r && r.isColor && (g(r, 1), n = !0);
                        const s = e.xr.getEnvironmentBlendMode();
                        "additive" === s ? i.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === s && i.buffers.color.setClear(0, 0, 0, 0, o), (e.autoClear || n) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                    },
                    addToRenderList: function(t, n) {
                        const i = m(n);
                        i && (i.isCubeTexture || i.mapping === a) ? (void 0 === u && (u = new Ai(new yi(1, 1, 1), new wi({
                            name: "BackgroundCubeMaterial",
                            uniforms: _i(Wi.backgroundCube.uniforms),
                            vertexShader: Wi.backgroundCube.vertexShader,
                            fragmentShader: Wi.backgroundCube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(u.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), r.update(u)), Yi.copy(n.backgroundRotation), Yi.x *= -1, Yi.y *= -1, Yi.z *= -1, i.isCubeTexture && !1 === i.isRenderTargetTexture && (Yi.y *= -1, Yi.z *= -1), u.material.uniforms.envMap.value = i, u.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(qi.makeRotationFromEuler(Yi)), u.material.toneMapped = qe.getTransfer(i.colorSpace) !== be, d === i && f === i.version && p === e.toneMapping || (u.material.needsUpdate = !0, d = i, f = i.version, p = e.toneMapping), u.layers.enableAll(), t.unshift(u, u.geometry, u.material, 0, 0, null)) : i && i.isTexture && (void 0 === c && (c = new Ai(new Gi(2, 2), new wi({
                            name: "BackgroundMaterial",
                            uniforms: _i(Wi.background.uniforms),
                            vertexShader: Wi.background.vertexShader,
                            fragmentShader: Wi.background.fragmentShader,
                            side: 0,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), r.update(c)), c.material.uniforms.t2D.value = i, c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, c.material.toneMapped = qe.getTransfer(i.colorSpace) !== be, !0 === i.matrixAutoUpdate && i.updateMatrix(), c.material.uniforms.uvTransform.value.copy(i.matrix), d === i && f === i.version && p === e.toneMapping || (c.material.needsUpdate = !0, d = i, f = i.version, p = e.toneMapping), c.layers.enableAll(), t.unshift(c, c.geometry, c.material, 0, 0, null))
                    }
                }
            }

            function Ji(e, t) {
                const n = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                    i = {},
                    r = c(null);
                let s = r,
                    o = !1;

                function a(t) {
                    return e.bindVertexArray(t)
                }

                function l(t) {
                    return e.deleteVertexArray(t)
                }

                function c(e) {
                    const t = [],
                        i = [],
                        r = [];
                    for (let e = 0; e < n; e++) t[e] = 0, i[e] = 0, r[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: i,
                        attributeDivisors: r,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function u() {
                    const e = s.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++) e[t] = 0
                }

                function h(e) {
                    d(e, 0)
                }

                function d(t, n) {
                    const i = s.newAttributes,
                        r = s.enabledAttributes,
                        o = s.attributeDivisors;
                    i[t] = 1, 0 === r[t] && (e.enableVertexAttribArray(t), r[t] = 1), o[t] !== n && (e.vertexAttribDivisor(t, n), o[t] = n)
                }

                function f() {
                    const t = s.newAttributes,
                        n = s.enabledAttributes;
                    for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
                }

                function p(t, n, i, r, s, o, a) {
                    !0 === a ? e.vertexAttribIPointer(t, n, i, s, o) : e.vertexAttribPointer(t, n, i, r, s, o)
                }

                function m() {
                    g(), o = !0, s !== r && (s = r, a(s.object))
                }

                function g() {
                    r.geometry = null, r.program = null, r.wireframe = !1
                }
                return {
                    setup: function(n, r, l, m, g) {
                        let A = !1;
                        const v = function(t, n, r) {
                            const s = !0 === r.wireframe;
                            let o = i[t.id];
                            void 0 === o && (o = {}, i[t.id] = o);
                            let a = o[n.id];
                            void 0 === a && (a = {}, o[n.id] = a);
                            let l = a[s];
                            return void 0 === l && (l = c(e.createVertexArray()), a[s] = l), l
                        }(m, l, r);
                        s !== v && (s = v, a(s.object)), A = function(e, t, n, i) {
                            const r = s.attributes,
                                o = t.attributes;
                            let a = 0;
                            const l = n.getAttributes();
                            for (const t in l)
                                if (l[t].location >= 0) {
                                    const n = r[t];
                                    let i = o[t];
                                    if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (i = e.instanceColor)), void 0 === n) return !0;
                                    if (n.attribute !== i) return !0;
                                    if (i && n.data !== i.data) return !0;
                                    a++
                                } return s.attributesNum !== a || s.index !== i
                        }(n, m, l, g), A && function(e, t, n, i) {
                            const r = {},
                                o = t.attributes;
                            let a = 0;
                            const l = n.getAttributes();
                            for (const t in l)
                                if (l[t].location >= 0) {
                                    let n = o[t];
                                    void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                    const i = {};
                                    i.attribute = n, n && n.data && (i.data = n.data), r[t] = i, a++
                                } s.attributes = r, s.attributesNum = a, s.index = i
                        }(n, m, l, g), null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER), (A || o) && (o = !1, function(n, i, r, s) {
                            u();
                            const o = s.attributes,
                                a = r.getAttributes(),
                                l = i.defaultAttributeValues;
                            for (const i in a) {
                                const r = a[i];
                                if (r.location >= 0) {
                                    let a = o[i];
                                    if (void 0 === a && ("instanceMatrix" === i && n.instanceMatrix && (a = n.instanceMatrix), "instanceColor" === i && n.instanceColor && (a = n.instanceColor)), void 0 !== a) {
                                        const i = a.normalized,
                                            o = a.itemSize,
                                            l = t.get(a);
                                        if (void 0 === l) continue;
                                        const c = l.buffer,
                                            u = l.type,
                                            f = l.bytesPerElement,
                                            m = u === e.INT || u === e.UNSIGNED_INT || a.gpuType === x;
                                        if (a.isInterleavedBufferAttribute) {
                                            const t = a.data,
                                                l = t.stride,
                                                g = a.offset;
                                            if (t.isInstancedInterleavedBuffer) {
                                                for (let e = 0; e < r.locationSize; e++) d(r.location + e, t.meshPerAttribute);
                                                !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = t.meshPerAttribute * t.count)
                                            } else
                                                for (let e = 0; e < r.locationSize; e++) h(r.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, c);
                                            for (let e = 0; e < r.locationSize; e++) p(r.location + e, o / r.locationSize, u, i, l * f, (g + o / r.locationSize * e) * f, m)
                                        } else {
                                            if (a.isInstancedBufferAttribute) {
                                                for (let e = 0; e < r.locationSize; e++) d(r.location + e, a.meshPerAttribute);
                                                !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)
                                            } else
                                                for (let e = 0; e < r.locationSize; e++) h(r.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, c);
                                            for (let e = 0; e < r.locationSize; e++) p(r.location + e, o / r.locationSize, u, i, o * f, o / r.locationSize * e * f, m)
                                        }
                                    } else if (void 0 !== l) {
                                        const t = l[i];
                                        if (void 0 !== t) switch (t.length) {
                                            case 2:
                                                e.vertexAttrib2fv(r.location, t);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(r.location, t);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(r.location, t);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(r.location, t)
                                        }
                                    }
                                }
                            }
                            f()
                        }(n, r, l, m), null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer))
                    },
                    reset: m,
                    resetDefaultState: g,
                    dispose: function() {
                        m();
                        for (const e in i) {
                            const t = i[e];
                            for (const e in t) {
                                const n = t[e];
                                for (const e in n) l(n[e].object), delete n[e];
                                delete t[e]
                            }
                            delete i[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === i[e.id]) return;
                        const t = i[e.id];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n) l(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete i[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (const t in i) {
                            const n = i[t];
                            if (void 0 === n[e.id]) continue;
                            const r = n[e.id];
                            for (const e in r) l(r[e].object), delete r[e];
                            delete n[e.id]
                        }
                    },
                    initAttributes: u,
                    enableAttribute: h,
                    disableUnusedAttributes: f
                }
            }

            function Zi(e, t, n) {
                let i;

                function r(t, r, s) {
                    0 !== s && (e.drawArraysInstanced(i, t, r, s), n.update(r, i, s))
                }
                this.setMode = function(e) {
                    i = e
                }, this.render = function(t, r) {
                    e.drawArrays(i, t, r), n.update(r, i, 1)
                }, this.renderInstances = r, this.renderMultiDraw = function(e, r, s) {
                    if (0 === s) return;
                    t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, s);
                    let o = 0;
                    for (let e = 0; e < s; e++) o += r[e];
                    n.update(o, i, 1)
                }, this.renderMultiDrawInstances = function(e, s, o, a) {
                    if (0 === o) return;
                    const l = t.get("WEBGL_multi_draw");
                    if (null === l)
                        for (let t = 0; t < e.length; t++) r(e[t], s[t], a[t]);
                    else {
                        l.multiDrawArraysInstancedWEBGL(i, e, 0, s, 0, a, 0, o);
                        let t = 0;
                        for (let e = 0; e < o; e++) t += s[e] * a[e];
                        n.update(t, i, 1)
                    }
                }
            }

            function $i(e, t, n, i) {
                let r;

                function s(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                let o = void 0 !== n.precision ? n.precision : "highp";
                const a = s(o);
                a !== o && (o = a);
                const l = !0 === n.logarithmicDepthBuffer,
                    c = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control"),
                    u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                    h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                return {
                    isWebGL2: !0,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r) return r;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            const n = t.get("EXT_texture_filter_anisotropic");
                            r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else r = 0;
                        return r
                    },
                    getMaxPrecision: s,
                    textureFormatReadable: function(t) {
                        return t === I || i.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
                    },
                    textureTypeReadable: function(n) {
                        const r = n === w && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                        return !(n !== A && i.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== b && !r)
                    },
                    precision: o,
                    logarithmicDepthBuffer: l,
                    reverseDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: h,
                    maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
                    maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                    maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
                    maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                    maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
                    maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                    vertexTextures: h > 0,
                    maxSamples: e.getParameter(e.MAX_SAMPLES)
                }
            }

            function er(e) {
                const t = this;
                let n = null,
                    i = 0,
                    r = !1,
                    s = !1;
                const o = new Oi,
                    a = new He,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function c(e, n, i, r) {
                    const s = null !== e ? e.length : 0;
                    let c = null;
                    if (0 !== s) {
                        if (c = l.value, !0 !== r || null === c) {
                            const t = i + 4 * s,
                                r = n.matrixWorldInverse;
                            a.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                            for (let t = 0, n = i; t !== s; ++t, n += 4) o.copy(e[t]).applyMatrix4(r, a), o.normal.toArray(c, n), c[n + 3] = o.constant
                        }
                        l.value = c, l.needsUpdate = !0
                    }
                    return t.numPlanes = s, t.numIntersection = 0, c
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t) {
                    const n = 0 !== e.length || t || 0 !== i || r;
                    return r = t, i = e.length, n
                }, this.beginShadows = function() {
                    s = !0, c(null)
                }, this.endShadows = function() {
                    s = !1
                }, this.setGlobalState = function(e, t) {
                    n = c(e, t, 0)
                }, this.setState = function(o, a, u) {
                    const h = o.clippingPlanes,
                        d = o.clipIntersection,
                        f = o.clipShadows,
                        p = e.get(o);
                    if (!r || null === h || 0 === h.length || s && !f) s ? c(null) : (l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0);
                    else {
                        const e = s ? 0 : i,
                            t = 4 * e;
                        let r = p.clippingState || null;
                        l.value = r, r = c(h, a, t, u);
                        for (let e = 0; e !== t; ++e) r[e] = n[e];
                        p.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
                    }
                }
            }

            function tr(e) {
                let t = new WeakMap;

                function n(e, t) {
                    return t === o ? e.mapping = r : 304 === t && (e.mapping = s), e
                }

                function i(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", i);
                    const r = t.get(n);
                    void 0 !== r && (t.delete(n), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture) {
                            const s = r.mapping;
                            if (s === o || 304 === s) {
                                if (t.has(r)) return n(t.get(r).texture, r.mapping);
                                {
                                    const s = r.image;
                                    if (s && s.height > 0) {
                                        const o = new Pi(s.height);
                                        return o.fromEquirectangularTexture(e, r), t.set(r, o), r.addEventListener("dispose", i), n(o.texture, r.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            class nr extends Ci {
                constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) {
                    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                }
                setViewOffset(e, t, n, i, r, s) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2;
                    let r = n - e,
                        s = n + e,
                        o = i + t,
                        a = i - t;
                    if (null !== this.view && this.view.enabled) {
                        const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += e * this.view.offsetX, s = r + e * this.view.width, o -= t * this.view.offsetY, a = o - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }
            const ir = [.125, .215, .35, .446, .526, .582],
                rr = new nr,
                sr = new kn;
            let or = null,
                ar = 0,
                lr = 0,
                cr = !1;
            const ur = (1 + Math.sqrt(5)) / 2,
                hr = 1 / ur,
                dr = [new gt(-ur, hr, 0), new gt(ur, hr, 0), new gt(-hr, 0, ur), new gt(hr, 0, ur), new gt(0, ur, -hr), new gt(0, ur, hr), new gt(-1, 1, -1), new gt(1, 1, -1), new gt(-1, 1, 1), new gt(1, 1, 1)];
            class fr {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, n = .1, i = 100) {
                    or = this._renderer.getRenderTarget(), ar = this._renderer.getActiveCubeFace(), lr = this._renderer.getActiveMipmapLevel(), cr = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
                    const r = this._allocateTargets();
                    return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
                }
                fromEquirectangular(e, t = null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t = null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = Ar(), this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = gr(), this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                }
                _setSize(e) {
                    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(or, ar, lr), this._renderer.xr.enabled = cr, e.scissorTest = !1, mr(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    e.mapping === r || e.mapping === s ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), or = this._renderer.getRenderTarget(), ar = this._renderer.getActiveCubeFace(), lr = this._renderer.getActiveMipmapLevel(), cr = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
                    const n = t || this._allocateTargets();
                    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
                }
                _allocateTargets() {
                    const e = 3 * Math.max(this._cubeSize, 112),
                        t = 4 * this._cubeSize,
                        n = {
                            magFilter: f,
                            minFilter: f,
                            generateMipmaps: !1,
                            type: w,
                            format: I,
                            colorSpace: xe,
                            depthBuffer: !1
                        },
                        i = pr(e, t, n);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = pr(e, t, n);
                        const {
                            _lodMax: i
                        } = this;
                        ({
                            sizeLods: this._sizeLods,
                            lodPlanes: this._lodPlanes,
                            sigmas: this._sigmas
                        } = function(e) {
                            const t = [],
                                n = [],
                                i = [];
                            let r = e;
                            const s = e - 4 + 1 + ir.length;
                            for (let o = 0; o < s; o++) {
                                const s = Math.pow(2, r);
                                n.push(s);
                                let a = 1 / s;
                                o > e - 4 ? a = ir[o - e + 4 - 1] : 0 === o && (a = 0), i.push(a);
                                const l = 1 / (s - 2),
                                    c = -l,
                                    u = 1 + l,
                                    h = [c, c, u, c, u, u, c, c, u, u, c, u],
                                    d = 6,
                                    f = 6,
                                    p = 3,
                                    m = 2,
                                    g = 1,
                                    A = new Float32Array(p * f * d),
                                    v = new Float32Array(m * f * d),
                                    y = new Float32Array(g * f * d);
                                for (let e = 0; e < d; e++) {
                                    const t = e % 3 * 2 / 3 - 1,
                                        n = e > 2 ? 0 : -1,
                                        i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                    A.set(i, p * f * e), v.set(h, m * f * e);
                                    const r = [e, e, e, e, e, e];
                                    y.set(r, g * f * e)
                                }
                                const _ = new si;
                                _.setAttribute("position", new Yn(A, p)), _.setAttribute("uv", new Yn(v, m)), _.setAttribute("faceIndex", new Yn(y, g)), t.push(_), r > 4 && r--
                            }
                            return {
                                lodPlanes: t,
                                sizeLods: n,
                                sigmas: i
                            }
                        }(i)), this._blurMaterial = function(e, t, n) {
                            const i = new Float32Array(20),
                                r = new gt(0, 1, 0);
                            return new wi({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: 20,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${e}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: i
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: r
                                    }
                                },
                                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            })
                        }(i, e, t)
                    }
                    return i
                }
                _compileMaterial(e) {
                    const t = new Ai(this._lodPlanes[0], e);
                    this._renderer.compile(t, rr)
                }
                _sceneToCubeUV(e, t, n, i) {
                    const r = new Ii(90, 1, t, n),
                        s = [1, -1, 1, 1, 1, 1],
                        o = [1, 1, 1, -1, -1, -1],
                        a = this._renderer,
                        l = a.autoClear,
                        c = a.toneMapping;
                    a.getClearColor(sr), a.toneMapping = 0, a.autoClear = !1;
                    const u = new Gn({
                            name: "PMREM.Background",
                            side: 1,
                            depthWrite: !1,
                            depthTest: !1
                        }),
                        h = new Ai(new yi, u);
                    let d = !1;
                    const f = e.background;
                    f ? f.isColor && (u.color.copy(f), e.background = null, d = !0) : (u.color.copy(sr), d = !0);
                    for (let t = 0; t < 6; t++) {
                        const n = t % 3;
                        0 === n ? (r.up.set(0, s[t], 0), r.lookAt(o[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[t]), r.lookAt(0, o[t], 0)) : (r.up.set(0, s[t], 0), r.lookAt(0, 0, o[t]));
                        const l = this._cubeSize;
                        mr(i, n * l, t > 2 ? l : 0, l, l), a.setRenderTarget(i), d && a.render(h, r), a.render(e, r)
                    }
                    h.geometry.dispose(), h.material.dispose(), a.toneMapping = c, a.autoClear = l, e.background = f
                }
                _textureToCubeUV(e, t) {
                    const n = this._renderer,
                        i = e.mapping === r || e.mapping === s;
                    i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Ar()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = gr());
                    const o = i ? this._cubemapMaterial : this._equirectMaterial,
                        a = new Ai(this._lodPlanes[0], o);
                    o.uniforms.envMap.value = e;
                    const l = this._cubeSize;
                    mr(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, rr)
                }
                _applyPMREM(e) {
                    const t = this._renderer,
                        n = t.autoClear;
                    t.autoClear = !1;
                    const i = this._lodPlanes.length;
                    for (let t = 1; t < i; t++) {
                        const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
                            r = dr[(i - t - 1) % dr.length];
                        this._blur(e, t - 1, t, n, r)
                    }
                    t.autoClear = n
                }
                _blur(e, t, n, i, r) {
                    const s = this._pingPongRenderTarget;
                    this._halfBlur(e, s, t, n, i, "latitudinal", r), this._halfBlur(s, e, n, n, i, "longitudinal", r)
                }
                _halfBlur(e, t, n, i, r, s, o) {
                    const a = this._renderer,
                        l = this._blurMaterial,
                        c = new Ai(this._lodPlanes[i], l),
                        u = l.uniforms,
                        h = this._sizeLods[n] - 1,
                        d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                        f = r / d,
                        p = isFinite(r) ? 1 + Math.floor(3 * f) : 20,
                        m = [];
                    let g = 0;
                    for (let e = 0; e < 20; ++e) {
                        const t = e / f,
                            n = Math.exp(-t * t / 2);
                        m.push(n), 0 === e ? g += n : e < p && (g += 2 * n)
                    }
                    for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
                    u.envMap.value = e.texture, u.samples.value = p, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, o && (u.poleAxis.value = o);
                    const {
                        _lodMax: A
                    } = this;
                    u.dTheta.value = d, u.mipInt.value = A - n;
                    const v = this._sizeLods[i];
                    mr(t, 3 * v * (i > A - 4 ? i - A + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), a.setRenderTarget(t), a.render(c, rr)
                }
            }

            function pr(e, t, n) {
                const i = new dt(e, t, n);
                return i.texture.mapping = a, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
            }

            function mr(e, t, n, i, r) {
                e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
            }

            function gr() {
                return new wi({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function Ar() {
                return new wi({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function vr(e) {
                let t = new WeakMap,
                    n = null;

                function i(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", i);
                    const r = t.get(n);
                    void 0 !== r && (t.delete(n), r.dispose())
                }
                return {
                    get: function(a) {
                        if (a && a.isTexture) {
                            const l = a.mapping,
                                c = l === o || 304 === l,
                                u = l === r || l === s;
                            if (c || u) {
                                let r = t.get(a);
                                const s = void 0 !== r ? r.texture.pmremVersion : 0;
                                if (a.isRenderTargetTexture && a.pmremVersion !== s) return null === n && (n = new fr(e)), r = c ? n.fromEquirectangular(a, r) : n.fromCubemap(a, r), r.texture.pmremVersion = a.pmremVersion, t.set(a, r), r.texture;
                                if (void 0 !== r) return r.texture;
                                {
                                    const s = a.image;
                                    return c && s && s.height > 0 || u && s && function(e) {
                                        let t = 0;
                                        for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                        return 6 === t
                                    }(s) ? (null === n && (n = new fr(e)), r = c ? n.fromEquirectangular(a) : n.fromCubemap(a), r.texture.pmremVersion = a.pmremVersion, t.set(a, r), a.addEventListener("dispose", i), r.texture) : null
                                }
                            }
                        }
                        return a
                    },
                    dispose: function() {
                        t = new WeakMap, null !== n && (n.dispose(), n = null)
                    }
                }
            }

            function yr(e) {
                const t = {};

                function n(n) {
                    if (void 0 !== t[n]) return t[n];
                    let i;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            i = e.getExtension(n)
                    }
                    return t[n] = i, i
                }
                return {
                    has: function(e) {
                        return null !== n(e)
                    },
                    init: function() {
                        n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent")
                    },
                    get: function(e) {
                        const t = n(e);
                        return null === t && Ye("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function _r(e, t, n, i) {
                const r = {},
                    s = new WeakMap;

                function o(e) {
                    const a = e.target;
                    null !== a.index && t.remove(a.index);
                    for (const e in a.attributes) t.remove(a.attributes[e]);
                    for (const e in a.morphAttributes) {
                        const n = a.morphAttributes[e];
                        for (let e = 0, i = n.length; e < i; e++) t.remove(n[e])
                    }
                    a.removeEventListener("dispose", o), delete r[a.id];
                    const l = s.get(a);
                    l && (t.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                }

                function a(e) {
                    const n = [],
                        i = e.index,
                        r = e.attributes.position;
                    let o = 0;
                    if (null !== i) {
                        const e = i.array;
                        o = i.version;
                        for (let t = 0, i = e.length; t < i; t += 3) {
                            const i = e[t + 0],
                                r = e[t + 1],
                                s = e[t + 2];
                            n.push(i, r, r, s, s, i)
                        }
                    } else {
                        if (void 0 === r) return;
                        {
                            const e = r.array;
                            o = r.version;
                            for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                                const e = t + 0,
                                    i = t + 1,
                                    r = t + 2;
                                n.push(e, i, i, r, r, e)
                            }
                        }
                    }
                    const a = new(Ve(n) ? Kn : qn)(n, 1);
                    a.version = o;
                    const l = s.get(e);
                    l && t.remove(l), s.set(e, a)
                }
                return {
                    get: function(e, t) {
                        return !0 === r[t.id] || (t.addEventListener("dispose", o), r[t.id] = !0, n.memory.geometries++), t
                    },
                    update: function(n) {
                        const i = n.attributes;
                        for (const n in i) t.update(i[n], e.ARRAY_BUFFER);
                        const r = n.morphAttributes;
                        for (const n in r) {
                            const i = r[n];
                            for (let n = 0, r = i.length; n < r; n++) t.update(i[n], e.ARRAY_BUFFER)
                        }
                    },
                    getWireframeAttribute: function(e) {
                        const t = s.get(e);
                        if (t) {
                            const n = e.index;
                            null !== n && t.version < n.version && a(e)
                        } else a(e);
                        return s.get(e)
                    }
                }
            }

            function xr(e, t, n) {
                let i, r, s;

                function o(t, o, a) {
                    0 !== a && (e.drawElementsInstanced(i, o, r, t * s, a), n.update(o, i, a))
                }
                this.setMode = function(e) {
                    i = e
                }, this.setIndex = function(e) {
                    r = e.type, s = e.bytesPerElement
                }, this.render = function(t, o) {
                    e.drawElements(i, o, r, t * s), n.update(o, i, 1)
                }, this.renderInstances = o, this.renderMultiDraw = function(e, s, o) {
                    if (0 === o) return;
                    t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, s, 0, r, e, 0, o);
                    let a = 0;
                    for (let e = 0; e < o; e++) a += s[e];
                    n.update(a, i, 1)
                }, this.renderMultiDrawInstances = function(e, a, l, c) {
                    if (0 === l) return;
                    const u = t.get("WEBGL_multi_draw");
                    if (null === u)
                        for (let t = 0; t < e.length; t++) o(e[t] / s, a[t], c[t]);
                    else {
                        u.multiDrawElementsInstancedWEBGL(i, a, 0, r, e, 0, c, 0, l);
                        let t = 0;
                        for (let e = 0; e < l; e++) t += a[e] * c[e];
                        n.update(t, i, 1)
                    }
                }
            }

            function Er(e) {
                const t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function(n, i, r) {
                        switch (t.calls++, i) {
                            case e.TRIANGLES:
                                t.triangles += r * (n / 3);
                                break;
                            case e.LINES:
                                t.lines += r * (n / 2);
                                break;
                            case e.LINE_STRIP:
                                t.lines += r * (n - 1);
                                break;
                            case e.LINE_LOOP:
                                t.lines += r * n;
                                break;
                            case e.POINTS:
                                t.points += r * n
                        }
                    }
                }
            }

            function br(e, t, n) {
                const i = new WeakMap,
                    r = new ut;
                return {
                    update: function(s, o, a) {
                        const l = s.morphTargetInfluences,
                            c = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color,
                            u = void 0 !== c ? c.length : 0;
                        let h = i.get(o);
                        if (void 0 === h || h.count !== u) {
                            void 0 !== h && h.texture.dispose();
                            const d = void 0 !== o.morphAttributes.position,
                                f = void 0 !== o.morphAttributes.normal,
                                p = void 0 !== o.morphAttributes.color,
                                m = o.morphAttributes.position || [],
                                g = o.morphAttributes.normal || [],
                                A = o.morphAttributes.color || [];
                            let v = 0;
                            !0 === d && (v = 1), !0 === f && (v = 2), !0 === p && (v = 3);
                            let y = o.attributes.position.count * v,
                                _ = 1;
                            y > t.maxTextureSize && (_ = Math.ceil(y / t.maxTextureSize), y = t.maxTextureSize);
                            const x = new Float32Array(y * _ * 4 * u),
                                E = new ft(x, y, _, u);
                            E.type = b, E.needsUpdate = !0;
                            const w = 4 * v;
                            for (let S = 0; S < u; S++) {
                                const T = m[S],
                                    M = g[S],
                                    I = A[S],
                                    B = y * _ * 4 * S;
                                for (let R = 0; R < T.count; R++) {
                                    const D = R * w;
                                    !0 === d && (r.fromBufferAttribute(T, R), x[B + D + 0] = r.x, x[B + D + 1] = r.y, x[B + D + 2] = r.z, x[B + D + 3] = 0), !0 === f && (r.fromBufferAttribute(M, R), x[B + D + 4] = r.x, x[B + D + 5] = r.y, x[B + D + 6] = r.z, x[B + D + 7] = 0), !0 === p && (r.fromBufferAttribute(I, R), x[B + D + 8] = r.x, x[B + D + 9] = r.y, x[B + D + 10] = r.z, x[B + D + 11] = 4 === I.itemSize ? r.w : 1)
                                }
                            }

                            function C() {
                                E.dispose(), i.delete(o), o.removeEventListener("dispose", C)
                            }
                            h = {
                                count: u,
                                texture: E,
                                size: new ze(y, _)
                            }, i.set(o, h), o.addEventListener("dispose", C)
                        }
                        if (!0 === s.isInstancedMesh && null !== s.morphTexture) a.getUniforms().setValue(e, "morphTexture", s.morphTexture, n);
                        else {
                            let P = 0;
                            for (let U = 0; U < l.length; U++) P += l[U];
                            const L = o.morphTargetsRelative ? 1 : 1 - P;
                            a.getUniforms().setValue(e, "morphTargetBaseInfluence", L), a.getUniforms().setValue(e, "morphTargetInfluences", l)
                        }
                        a.getUniforms().setValue(e, "morphTargetsTexture", h.texture, n), a.getUniforms().setValue(e, "morphTargetsTextureSize", h.size)
                    }
                }
            }

            function wr(e, t, n, i) {
                let r = new WeakMap;

                function s(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function(o) {
                        const a = i.render.frame,
                            l = o.geometry,
                            c = t.get(o, l);
                        if (r.get(c) !== a && (t.update(c), r.set(c, a)), o.isInstancedMesh && (!1 === o.hasEventListener("dispose", s) && o.addEventListener("dispose", s), r.get(o) !== a && (n.update(o.instanceMatrix, e.ARRAY_BUFFER), null !== o.instanceColor && n.update(o.instanceColor, e.ARRAY_BUFFER), r.set(o, a))), o.isSkinnedMesh) {
                            const e = o.skeleton;
                            r.get(e) !== a && (e.update(), r.set(e, a))
                        }
                        return c
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }
            class Cr extends ct {
                constructor(e, t, n, i, r, s, o, a, l, c = 1026) {
                    if (c !== R && c !== D) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && c === R && (n = E), void 0 === n && c === D && (n = T), super(null, i, r, s, o, a, c, n, l), this.isDepthTexture = !0, this.image = {
                        width: e,
                        height: t
                    }, this.magFilter = void 0 !== o ? o : h, this.minFilter = void 0 !== a ? a : h, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
                }
                copy(e) {
                    return super.copy(e), this.compareFunction = e.compareFunction, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t
                }
            }
            const Sr = new ct,
                Tr = new Cr(1, 1),
                Mr = new ft,
                Ir = new pt,
                Br = new Di,
                Rr = [],
                Dr = [],
                Pr = new Float32Array(16),
                Lr = new Float32Array(9),
                Ur = new Float32Array(4);

            function Nr(e, t, n) {
                const i = e[0];
                if (i <= 0 || i > 0) return e;
                const r = t * n;
                let s = Rr[r];
                if (void 0 === s && (s = new Float32Array(r), Rr[r] = s), 0 !== t) {
                    i.toArray(s, 0);
                    for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(s, r)
                }
                return s
            }

            function Or(e, t) {
                if (e.length !== t.length) return !1;
                for (let n = 0, i = e.length; n < i; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function Fr(e, t) {
                for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
            }

            function kr(e, t) {
                let n = Dr[t];
                void 0 === n && (n = new Int32Array(t), Dr[t] = n);
                for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
                return n
            }

            function Qr(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function zr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (Or(n, t)) return;
                    e.uniform2fv(this.addr, t), Fr(n, t)
                }
            }

            function Hr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (Or(n, t)) return;
                    e.uniform3fv(this.addr, t), Fr(n, t)
                }
            }

            function Gr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (Or(n, t)) return;
                    e.uniform4fv(this.addr, t), Fr(n, t)
                }
            }

            function Vr(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (Or(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), Fr(n, t)
                } else {
                    if (Or(n, i)) return;
                    Ur.set(i), e.uniformMatrix2fv(this.addr, !1, Ur), Fr(n, i)
                }
            }

            function jr(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (Or(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), Fr(n, t)
                } else {
                    if (Or(n, i)) return;
                    Lr.set(i), e.uniformMatrix3fv(this.addr, !1, Lr), Fr(n, i)
                }
            }

            function Wr(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (Or(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), Fr(n, t)
                } else {
                    if (Or(n, i)) return;
                    Pr.set(i), e.uniformMatrix4fv(this.addr, !1, Pr), Fr(n, i)
                }
            }

            function Xr(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function Yr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (Or(n, t)) return;
                    e.uniform2iv(this.addr, t), Fr(n, t)
                }
            }

            function qr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else {
                    if (Or(n, t)) return;
                    e.uniform3iv(this.addr, t), Fr(n, t)
                }
            }

            function Kr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (Or(n, t)) return;
                    e.uniform4iv(this.addr, t), Fr(n, t)
                }
            }

            function Jr(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }

            function Zr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (Or(n, t)) return;
                    e.uniform2uiv(this.addr, t), Fr(n, t)
                }
            }

            function $r(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else {
                    if (Or(n, t)) return;
                    e.uniform3uiv(this.addr, t), Fr(n, t)
                }
            }

            function es(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (Or(n, t)) return;
                    e.uniform4uiv(this.addr, t), Fr(n, t)
                }
            }

            function ts(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                let s;
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), this.type === e.SAMPLER_2D_SHADOW ? (Tr.compareFunction = 515, s = Tr) : s = Sr, n.setTexture2D(t || s, r)
            }

            function ns(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || Ir, r)
            }

            function is(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || Br, r)
            }

            function rs(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || Mr, r)
            }

            function ss(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function os(e, t) {
                const n = Nr(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function as(e, t) {
                const n = Nr(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function ls(e, t) {
                const n = Nr(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function cs(e, t) {
                const n = Nr(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function us(e, t) {
                const n = Nr(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function hs(e, t) {
                const n = Nr(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function ds(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function fs(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function ps(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function ms(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function gs(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function As(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function vs(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function ys(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function _s(e, t, n) {
                const i = this.cache,
                    r = t.length,
                    s = kr(n, r);
                Or(i, s) || (e.uniform1iv(this.addr, s), Fr(i, s));
                for (let e = 0; e !== r; ++e) n.setTexture2D(t[e] || Sr, s[e])
            }

            function xs(e, t, n) {
                const i = this.cache,
                    r = t.length,
                    s = kr(n, r);
                Or(i, s) || (e.uniform1iv(this.addr, s), Fr(i, s));
                for (let e = 0; e !== r; ++e) n.setTexture3D(t[e] || Ir, s[e])
            }

            function Es(e, t, n) {
                const i = this.cache,
                    r = t.length,
                    s = kr(n, r);
                Or(i, s) || (e.uniform1iv(this.addr, s), Fr(i, s));
                for (let e = 0; e !== r; ++e) n.setTextureCube(t[e] || Br, s[e])
            }

            function bs(e, t, n) {
                const i = this.cache,
                    r = t.length,
                    s = kr(n, r);
                Or(i, s) || (e.uniform1iv(this.addr, s), Fr(i, s));
                for (let e = 0; e !== r; ++e) n.setTexture2DArray(t[e] || Mr, s[e])
            }
            class ws {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return Qr;
                            case 35664:
                                return zr;
                            case 35665:
                                return Hr;
                            case 35666:
                                return Gr;
                            case 35674:
                                return Vr;
                            case 35675:
                                return jr;
                            case 35676:
                                return Wr;
                            case 5124:
                            case 35670:
                                return Xr;
                            case 35667:
                            case 35671:
                                return Yr;
                            case 35668:
                            case 35672:
                                return qr;
                            case 35669:
                            case 35673:
                                return Kr;
                            case 5125:
                                return Jr;
                            case 36294:
                                return Zr;
                            case 36295:
                                return $r;
                            case 36296:
                                return es;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return ts;
                            case 35679:
                            case 36299:
                            case 36307:
                                return ns;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return is;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return rs
                        }
                    }(t.type)
                }
            }
            class Cs {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return ss;
                            case 35664:
                                return os;
                            case 35665:
                                return as;
                            case 35666:
                                return ls;
                            case 35674:
                                return cs;
                            case 35675:
                                return us;
                            case 35676:
                                return hs;
                            case 5124:
                            case 35670:
                                return ds;
                            case 35667:
                            case 35671:
                                return fs;
                            case 35668:
                            case 35672:
                                return ps;
                            case 35669:
                            case 35673:
                                return ms;
                            case 5125:
                                return gs;
                            case 36294:
                                return As;
                            case 36295:
                                return vs;
                            case 36296:
                                return ys;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return _s;
                            case 35679:
                            case 36299:
                            case 36307:
                                return xs;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return Es;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return bs
                        }
                    }(t.type)
                }
            }
            class Ss {
                constructor(e) {
                    this.id = e, this.seq = [], this.map = {}
                }
                setValue(e, t, n) {
                    const i = this.seq;
                    for (let r = 0, s = i.length; r !== s; ++r) {
                        const s = i[r];
                        s.setValue(e, t[s.id], n)
                    }
                }
            }
            const Ts = /(\w+)(\])?(\[|\.)?/g;

            function Ms(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function Is(e, t, n) {
                const i = e.name,
                    r = i.length;
                for (Ts.lastIndex = 0;;) {
                    const s = Ts.exec(i),
                        o = Ts.lastIndex;
                    let a = s[1];
                    const l = "]" === s[2],
                        c = s[3];
                    if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) {
                        Ms(n, void 0 === c ? new ws(a, e, t) : new Cs(a, e, t));
                        break
                    } {
                        let e = n.map[a];
                        void 0 === e && (e = new Ss(a), Ms(n, e)), n = e
                    }
                }
            }
            class Bs {
                constructor(e, t) {
                    this.seq = [], this.map = {};
                    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                    for (let i = 0; i < n; ++i) {
                        const n = e.getActiveUniform(t, i);
                        Is(n, e.getUniformLocation(t, n.name), this)
                    }
                }
                setValue(e, t, n, i) {
                    const r = this.map[t];
                    void 0 !== r && r.setValue(e, n, i)
                }
                setOptional(e, t, n) {
                    const i = t[n];
                    void 0 !== i && this.setValue(e, n, i)
                }
                static upload(e, t, n, i) {
                    for (let r = 0, s = t.length; r !== s; ++r) {
                        const s = t[r],
                            o = n[s.id];
                        !1 !== o.needsUpdate && s.setValue(e, o.value, i)
                    }
                }
                static seqWithValue(e, t) {
                    const n = [];
                    for (let i = 0, r = e.length; i !== r; ++i) {
                        const r = e[i];
                        r.id in t && n.push(r)
                    }
                    return n
                }
            }

            function Rs(e, t, n) {
                const i = e.createShader(t);
                return e.shaderSource(i, n), e.compileShader(i), i
            }
            let Ds = 0;
            const Ps = new He;

            function Ls(e, t, n) {
                const i = e.getShaderParameter(t, e.COMPILE_STATUS),
                    r = e.getShaderInfoLog(t).trim();
                if (i && "" === r) return "";
                const s = /ERROR: 0:(\d+)/.exec(r);
                if (s) {
                    const i = parseInt(s[1]);
                    return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                        const n = e.split("\n"),
                            i = [],
                            r = Math.max(t - 6, 0),
                            s = Math.min(t + 6, n.length);
                        for (let e = r; e < s; e++) {
                            const r = e + 1;
                            i.push(`${r===t?">":" "} ${r}: ${n[e]}`)
                        }
                        return i.join("\n")
                    }(e.getShaderSource(t), i)
                }
                return r
            }

            function Us(e, t) {
                const n = function(e) {
                    qe._getMatrix(Ps, qe.workingColorSpace, e);
                    const t = `mat3( ${Ps.elements.map((e=>e.toFixed(4)))} )`;
                    switch (qe.getTransfer(e)) {
                        case Ee:
                            return [t, "LinearTransferOETF"];
                        case be:
                            return [t, "sRGBTransferOETF"];
                        default:
                            return [t, "LinearTransferOETF"]
                    }
                }(t);
                return [`vec4 ${e}( vec4 value ) {`, `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join("\n")
            }

            function Ns(e, t) {
                let n;
                switch (t) {
                    case 1:
                    default:
                        n = "Linear";
                        break;
                    case 2:
                        n = "Reinhard";
                        break;
                    case 3:
                        n = "Cineon";
                        break;
                    case 4:
                        n = "ACESFilmic";
                        break;
                    case 6:
                        n = "AgX";
                        break;
                    case 7:
                        n = "Neutral";
                        break;
                    case 5:
                        n = "Custom"
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }
            const Os = new gt;

            function Fs(e) {
                return "" !== e
            }

            function ks(e, t) {
                const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function Qs(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            const zs = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function Hs(e) {
                return e.replace(zs, Vs)
            }
            const Gs = new Map;

            function Vs(e, t) {
                let n = Vi[t];
                if (void 0 === n) {
                    const e = Gs.get(t);
                    if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">");
                    n = Vi[e]
                }
                return Hs(n)
            }
            const js = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function Ws(e) {
                return e.replace(js, Xs)
            }

            function Xs(e, t, n, i) {
                let r = "";
                for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return r
            }

            function Ys(e) {
                let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function qs(e, t, n, i) {
                const o = e.getContext(),
                    l = n.defines;
                let c = n.vertexShader,
                    u = n.fragmentShader;
                const h = function(e) {
                        let t = "SHADOWMAP_TYPE_BASIC";
                        return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
                    }(n),
                    d = function(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case r:
                            case s:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case a:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    f = function(e) {
                        let t = "ENVMAP_MODE_REFLECTION";
                        return e.envMap && e.envMapMode === s && (t = "ENVMAP_MODE_REFRACTION"), t
                    }(n),
                    p = function(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case 0:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    m = function(e) {
                        const t = e.envMapCubeUVHeight;
                        if (null === t) return null;
                        const n = Math.log2(t) - 2,
                            i = 1 / t;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                            texelHeight: i,
                            maxMip: n
                        }
                    }(n),
                    g = function(e) {
                        return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Fs).join("\n")
                    }(n),
                    A = function(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            !1 !== i && t.push("#define " + n + " " + i)
                        }
                        return t.join("\n")
                    }(l),
                    v = o.createProgram();
                let y, _, x = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A].filter(Fs).join("\n"), y.length > 0 && (y += "\n"), _ = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A].filter(Fs).join("\n"), _.length > 0 && (_ += "\n")) : (y = [Ys(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Fs).join("\n"), _ = [Ys(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + p : "", m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "", m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "", m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Vi.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ns("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Vi.colorspace_pars_fragment, Us("linearToOutputTexel", n.outputColorSpace), (qe.getLuminanceCoefficients(Os), ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${Os.x.toFixed(4)}, ${Os.y.toFixed(4)}, ${Os.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Fs).join("\n")), c = Hs(c), c = ks(c, n), c = Qs(c, n), u = Hs(u), u = ks(u, n), u = Qs(u, n), c = Ws(c), u = Ws(u), !0 !== n.isRawShaderMaterial && (x = "#version 300 es\n", y = [g, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, _ = ["#define varying in", n.glslVersion === Se ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Se ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
                const E = x + y + c,
                    b = x + _ + u,
                    w = Rs(o, o.VERTEX_SHADER, E),
                    C = Rs(o, o.FRAGMENT_SHADER, b);

                function S(t) {
                    if (e.debug.checkShaderErrors) {
                        const n = o.getProgramInfoLog(v).trim(),
                            i = o.getShaderInfoLog(w).trim(),
                            r = o.getShaderInfoLog(C).trim();
                        let s = !0,
                            a = !0;
                        !1 === o.getProgramParameter(v, o.LINK_STATUS) ? (s = !1, "function" == typeof e.debug.onShaderError ? e.debug.onShaderError(o, v, w, C) : (Ls(o, w, "vertex"), Ls(o, C, "fragment"))) : "" !== n || "" !== i && "" !== r || (a = !1), a && (t.diagnostics = {
                            runnable: s,
                            programLog: n,
                            vertexShader: {
                                log: i,
                                prefix: y
                            },
                            fragmentShader: {
                                log: r,
                                prefix: _
                            }
                        })
                    }
                    o.deleteShader(w), o.deleteShader(C), T = new Bs(o, v), M = function(e, t) {
                        const n = {},
                            i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                        for (let r = 0; r < i; r++) {
                            const i = e.getActiveAttrib(t, r),
                                s = i.name;
                            let o = 1;
                            i.type === e.FLOAT_MAT2 && (o = 2), i.type === e.FLOAT_MAT3 && (o = 3), i.type === e.FLOAT_MAT4 && (o = 4), n[s] = {
                                type: i.type,
                                location: e.getAttribLocation(t, s),
                                locationSize: o
                            }
                        }
                        return n
                    }(o, v)
                }
                let T, M;
                o.attachShader(v, w), o.attachShader(v, C), void 0 !== n.index0AttributeName ? o.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(v, 0, "position"), o.linkProgram(v), this.getUniforms = function() {
                    return void 0 === T && S(this), T
                }, this.getAttributes = function() {
                    return void 0 === M && S(this), M
                };
                let I = !1 === n.rendererExtensionParallelShaderCompile;
                return this.isReady = function() {
                    return !1 === I && (I = o.getProgramParameter(v, 37297)), I
                }, this.destroy = function() {
                    i.releaseStatesOfProgram(this), o.deleteProgram(v), this.program = void 0
                }, this.type = n.shaderType, this.name = n.shaderName, this.id = Ds++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = w, this.fragmentShader = C, this
            }
            let Ks = 0;
            class Js {
                constructor() {
                    this.shaderCache = new Map, this.materialCache = new Map
                }
                update(e) {
                    const t = e.vertexShader,
                        n = e.fragmentShader,
                        i = this._getShaderStage(t),
                        r = this._getShaderStage(n),
                        s = this._getShaderCacheForMaterial(e);
                    return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
                }
                remove(e) {
                    const t = this.materialCache.get(e);
                    for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
                    return this.materialCache.delete(e), this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(), this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    const t = this.materialCache;
                    let n = t.get(e);
                    return void 0 === n && (n = new Set, t.set(e, n)), n
                }
                _getShaderStage(e) {
                    const t = this.shaderCache;
                    let n = t.get(e);
                    return void 0 === n && (n = new Zs(e), t.set(e, n)), n
                }
            }
            class Zs {
                constructor(e) {
                    this.id = Ks++, this.code = e, this.usedTimes = 0
                }
            }

            function $s(e, t, n, i, r, s, o) {
                const l = new rn,
                    c = new Js,
                    u = new Set,
                    h = [],
                    d = r.logarithmicDepthBuffer,
                    f = r.vertexTextures;
                let p = r.precision;
                const m = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                };

                function g(e) {
                    return u.add(e), 0 === e ? "uv" : `uv${e}`
                }
                return {
                    getParameters: function(s, l, h, A, v) {
                        const y = A.fog,
                            _ = v.geometry,
                            x = s.isMeshStandardMaterial ? A.environment : null,
                            E = (s.isMeshStandardMaterial ? n : t).get(s.envMap || x),
                            b = E && E.mapping === a ? E.image.height : null,
                            w = m[s.type];
                        null !== s.precision && (p = r.getMaxPrecision(s.precision), s.precision);
                        const C = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color,
                            S = void 0 !== C ? C.length : 0;
                        let T, M, I, B, R = 0;
                        if (void 0 !== _.morphAttributes.position && (R = 1), void 0 !== _.morphAttributes.normal && (R = 2), void 0 !== _.morphAttributes.color && (R = 3), w) {
                            const e = Wi[w];
                            T = e.vertexShader, M = e.fragmentShader
                        } else T = s.vertexShader, M = s.fragmentShader, c.update(s), I = c.getVertexShaderID(s), B = c.getFragmentShaderID(s);
                        const D = e.getRenderTarget(),
                            P = e.state.buffers.depth.getReversed(),
                            L = !0 === v.isInstancedMesh,
                            U = !0 === v.isBatchedMesh,
                            N = !!s.map,
                            O = !!s.matcap,
                            F = !!E,
                            k = !!s.aoMap,
                            Q = !!s.lightMap,
                            z = !!s.bumpMap,
                            H = !!s.normalMap,
                            G = !!s.displacementMap,
                            V = !!s.emissiveMap,
                            j = !!s.metalnessMap,
                            W = !!s.roughnessMap,
                            X = s.anisotropy > 0,
                            Y = s.clearcoat > 0,
                            q = s.dispersion > 0,
                            K = s.iridescence > 0,
                            J = s.sheen > 0,
                            Z = s.transmission > 0,
                            $ = X && !!s.anisotropyMap,
                            ee = Y && !!s.clearcoatMap,
                            te = Y && !!s.clearcoatNormalMap,
                            ne = Y && !!s.clearcoatRoughnessMap,
                            ie = K && !!s.iridescenceMap,
                            re = K && !!s.iridescenceThicknessMap,
                            se = J && !!s.sheenColorMap,
                            oe = J && !!s.sheenRoughnessMap,
                            ae = !!s.specularMap,
                            le = !!s.specularColorMap,
                            ce = !!s.specularIntensityMap,
                            ue = Z && !!s.transmissionMap,
                            he = Z && !!s.thicknessMap,
                            de = !!s.gradientMap,
                            fe = !!s.alphaMap,
                            pe = s.alphaTest > 0,
                            me = !!s.alphaHash,
                            ge = !!s.extensions;
                        let Ae = 0;
                        s.toneMapped && (null !== D && !0 !== D.isXRRenderTarget || (Ae = e.toneMapping));
                        const ve = {
                            shaderID: w,
                            shaderType: s.type,
                            shaderName: s.name,
                            vertexShader: T,
                            fragmentShader: M,
                            defines: s.defines,
                            customVertexShaderID: I,
                            customFragmentShaderID: B,
                            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                            glslVersion: s.glslVersion,
                            precision: p,
                            batching: U,
                            batchingColor: U && null !== v._colorsTexture,
                            instancing: L,
                            instancingColor: L && null !== v.instanceColor,
                            instancingMorph: L && null !== v.morphTexture,
                            supportsVertexTextures: f,
                            outputColorSpace: null === D ? e.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : xe,
                            alphaToCoverage: !!s.alphaToCoverage,
                            map: N,
                            matcap: O,
                            envMap: F,
                            envMapMode: F && E.mapping,
                            envMapCubeUVHeight: b,
                            aoMap: k,
                            lightMap: Q,
                            bumpMap: z,
                            normalMap: H,
                            displacementMap: f && G,
                            emissiveMap: V,
                            normalMapObjectSpace: H && 1 === s.normalMapType,
                            normalMapTangentSpace: H && 0 === s.normalMapType,
                            metalnessMap: j,
                            roughnessMap: W,
                            anisotropy: X,
                            anisotropyMap: $,
                            clearcoat: Y,
                            clearcoatMap: ee,
                            clearcoatNormalMap: te,
                            clearcoatRoughnessMap: ne,
                            dispersion: q,
                            iridescence: K,
                            iridescenceMap: ie,
                            iridescenceThicknessMap: re,
                            sheen: J,
                            sheenColorMap: se,
                            sheenRoughnessMap: oe,
                            specularMap: ae,
                            specularColorMap: le,
                            specularIntensityMap: ce,
                            transmission: Z,
                            transmissionMap: ue,
                            thicknessMap: he,
                            gradientMap: de,
                            opaque: !1 === s.transparent && 1 === s.blending && !1 === s.alphaToCoverage,
                            alphaMap: fe,
                            alphaTest: pe,
                            alphaHash: me,
                            combine: s.combine,
                            mapUv: N && g(s.map.channel),
                            aoMapUv: k && g(s.aoMap.channel),
                            lightMapUv: Q && g(s.lightMap.channel),
                            bumpMapUv: z && g(s.bumpMap.channel),
                            normalMapUv: H && g(s.normalMap.channel),
                            displacementMapUv: G && g(s.displacementMap.channel),
                            emissiveMapUv: V && g(s.emissiveMap.channel),
                            metalnessMapUv: j && g(s.metalnessMap.channel),
                            roughnessMapUv: W && g(s.roughnessMap.channel),
                            anisotropyMapUv: $ && g(s.anisotropyMap.channel),
                            clearcoatMapUv: ee && g(s.clearcoatMap.channel),
                            clearcoatNormalMapUv: te && g(s.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: ne && g(s.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: ie && g(s.iridescenceMap.channel),
                            iridescenceThicknessMapUv: re && g(s.iridescenceThicknessMap.channel),
                            sheenColorMapUv: se && g(s.sheenColorMap.channel),
                            sheenRoughnessMapUv: oe && g(s.sheenRoughnessMap.channel),
                            specularMapUv: ae && g(s.specularMap.channel),
                            specularColorMapUv: le && g(s.specularColorMap.channel),
                            specularIntensityMapUv: ce && g(s.specularIntensityMap.channel),
                            transmissionMapUv: ue && g(s.transmissionMap.channel),
                            thicknessMapUv: he && g(s.thicknessMap.channel),
                            alphaMapUv: fe && g(s.alphaMap.channel),
                            vertexTangents: !!_.attributes.tangent && (H || X),
                            vertexColors: s.vertexColors,
                            vertexAlphas: !0 === s.vertexColors && !!_.attributes.color && 4 === _.attributes.color.itemSize,
                            pointsUvs: !0 === v.isPoints && !!_.attributes.uv && (N || fe),
                            fog: !!y,
                            useFog: !0 === s.fog,
                            fogExp2: !!y && y.isFogExp2,
                            flatShading: !0 === s.flatShading,
                            sizeAttenuation: !0 === s.sizeAttenuation,
                            logarithmicDepthBuffer: d,
                            reverseDepthBuffer: P,
                            skinning: !0 === v.isSkinnedMesh,
                            morphTargets: void 0 !== _.morphAttributes.position,
                            morphNormals: void 0 !== _.morphAttributes.normal,
                            morphColors: void 0 !== _.morphAttributes.color,
                            morphTargetsCount: S,
                            morphTextureStride: R,
                            numDirLights: l.directional.length,
                            numPointLights: l.point.length,
                            numSpotLights: l.spot.length,
                            numSpotLightMaps: l.spotLightMap.length,
                            numRectAreaLights: l.rectArea.length,
                            numHemiLights: l.hemi.length,
                            numDirLightShadows: l.directionalShadowMap.length,
                            numPointLightShadows: l.pointShadowMap.length,
                            numSpotLightShadows: l.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: l.numSpotLightShadowsWithMaps,
                            numLightProbes: l.numLightProbes,
                            numClippingPlanes: o.numPlanes,
                            numClipIntersection: o.numIntersection,
                            dithering: s.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: Ae,
                            decodeVideoTexture: N && !0 === s.map.isVideoTexture && qe.getTransfer(s.map.colorSpace) === be,
                            decodeVideoTextureEmissive: V && !0 === s.emissiveMap.isVideoTexture && qe.getTransfer(s.emissiveMap.colorSpace) === be,
                            premultipliedAlpha: s.premultipliedAlpha,
                            doubleSided: 2 === s.side,
                            flipSided: 1 === s.side,
                            useDepthPacking: s.depthPacking >= 0,
                            depthPacking: s.depthPacking || 0,
                            index0AttributeName: s.index0AttributeName,
                            extensionClipCullDistance: ge && !0 === s.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: (ge && !0 === s.extensions.multiDraw || U) && i.has("WEBGL_multi_draw"),
                            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: s.customProgramCacheKey()
                        };
                        return ve.vertexUv1s = u.has(1), ve.vertexUv2s = u.has(2), ve.vertexUv3s = u.has(3), u.clear(), ve
                    },
                    getProgramCacheKey: function(t) {
                        const n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                        return !1 === t.isRawShaderMaterial && (function(e, t) {
                            e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.numLightProbes), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking)
                        }(n, t), function(e, t) {
                            l.disableAll(), t.supportsVertexTextures && l.enable(0), t.instancing && l.enable(1), t.instancingColor && l.enable(2), t.instancingMorph && l.enable(3), t.matcap && l.enable(4), t.envMap && l.enable(5), t.normalMapObjectSpace && l.enable(6), t.normalMapTangentSpace && l.enable(7), t.clearcoat && l.enable(8), t.iridescence && l.enable(9), t.alphaTest && l.enable(10), t.vertexColors && l.enable(11), t.vertexAlphas && l.enable(12), t.vertexUv1s && l.enable(13), t.vertexUv2s && l.enable(14), t.vertexUv3s && l.enable(15), t.vertexTangents && l.enable(16), t.anisotropy && l.enable(17), t.alphaHash && l.enable(18), t.batching && l.enable(19), t.dispersion && l.enable(20), t.batchingColor && l.enable(21), e.push(l.mask), l.disableAll(), t.fog && l.enable(0), t.useFog && l.enable(1), t.flatShading && l.enable(2), t.logarithmicDepthBuffer && l.enable(3), t.reverseDepthBuffer && l.enable(4), t.skinning && l.enable(5), t.morphTargets && l.enable(6), t.morphNormals && l.enable(7), t.morphColors && l.enable(8), t.premultipliedAlpha && l.enable(9), t.shadowMapEnabled && l.enable(10), t.doubleSided && l.enable(11), t.flipSided && l.enable(12), t.useDepthPacking && l.enable(13), t.dithering && l.enable(14), t.transmission && l.enable(15), t.sheen && l.enable(16), t.opaque && l.enable(17), t.pointsUvs && l.enable(18), t.decodeVideoTexture && l.enable(19), t.decodeVideoTextureEmissive && l.enable(20), t.alphaToCoverage && l.enable(21), e.push(l.mask)
                        }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join()
                    },
                    getUniforms: function(e) {
                        const t = m[e.type];
                        let n;
                        if (t) {
                            const e = Wi[t];
                            n = bi.clone(e.uniforms)
                        } else n = e.uniforms;
                        return n
                    },
                    acquireProgram: function(t, n) {
                        let i;
                        for (let e = 0, t = h.length; e < t; e++) {
                            const t = h[e];
                            if (t.cacheKey === n) {
                                i = t, ++i.usedTimes;
                                break
                            }
                        }
                        return void 0 === i && (i = new qs(e, n, t, s), h.push(i)), i
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            const t = h.indexOf(e);
                            h[t] = h[h.length - 1], h.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        c.remove(e)
                    },
                    programs: h,
                    dispose: function() {
                        c.dispose()
                    }
                }
            }

            function eo() {
                let e = new WeakMap;
                return {
                    has: function(t) {
                        return e.has(t)
                    },
                    get: function(t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, n, i) {
                        e.get(t)[n] = i
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function to(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function no(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function io() {
                const e = [];
                let t = 0;
                const n = [],
                    i = [],
                    r = [];

                function s(n, i, r, s, o, a) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: i,
                        material: r,
                        groupOrder: s,
                        renderOrder: n.renderOrder,
                        z: o,
                        group: a
                    }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = o, l.group = a), t++, l
                }
                return {
                    opaque: n,
                    transmissive: i,
                    transparent: r,
                    init: function() {
                        t = 0, n.length = 0, i.length = 0, r.length = 0
                    },
                    push: function(e, t, o, a, l, c) {
                        const u = s(e, t, o, a, l, c);
                        o.transmission > 0 ? i.push(u) : !0 === o.transparent ? r.push(u) : n.push(u)
                    },
                    unshift: function(e, t, o, a, l, c) {
                        const u = s(e, t, o, a, l, c);
                        o.transmission > 0 ? i.unshift(u) : !0 === o.transparent ? r.unshift(u) : n.unshift(u)
                    },
                    finish: function() {
                        for (let n = t, i = e.length; n < i; n++) {
                            const t = e[n];
                            if (null === t.id) break;
                            t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                        }
                    },
                    sort: function(e, t) {
                        n.length > 1 && n.sort(e || to), i.length > 1 && i.sort(t || no), r.length > 1 && r.sort(t || no)
                    }
                }
            }

            function ro() {
                let e = new WeakMap;
                return {
                    get: function(t, n) {
                        const i = e.get(t);
                        let r;
                        return void 0 === i ? (r = new io, e.set(t, [r])) : n >= i.length ? (r = new io, i.push(r)) : r = i[n], r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function so() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        let n;
                        switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new gt,
                                    color: new kn
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new gt,
                                    direction: new gt,
                                    color: new kn,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new gt,
                                    color: new kn,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new gt,
                                    skyColor: new kn,
                                    groundColor: new kn
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new kn,
                                    position: new gt,
                                    halfWidth: new gt,
                                    halfHeight: new gt
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }
            let oo = 0;

            function ao(e, t) {
                return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
            }

            function lo(e) {
                const t = new so,
                    n = function() {
                        const e = {};
                        return {
                            get: function(t) {
                                if (void 0 !== e[t.id]) return e[t.id];
                                let n;
                                switch (t.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        n = {
                                            shadowIntensity: 1,
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new ze
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            shadowIntensity: 1,
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new ze,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return e[t.id] = n, n
                            }
                        }
                    }(),
                    i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1,
                            numLightProbes: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0,
                        numLightProbes: 0
                    };
                for (let e = 0; e < 9; e++) i.probe.push(new gt);
                const r = new gt,
                    s = new Wt,
                    o = new Wt;
                return {
                    setup: function(r) {
                        let s = 0,
                            o = 0,
                            a = 0;
                        for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
                        let l = 0,
                            c = 0,
                            u = 0,
                            h = 0,
                            d = 0,
                            f = 0,
                            p = 0,
                            m = 0,
                            g = 0,
                            A = 0,
                            v = 0;
                        r.sort(ao);
                        for (let e = 0, y = r.length; e < y; e++) {
                            const y = r[e],
                                _ = y.color,
                                x = y.intensity,
                                E = y.distance,
                                b = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                            if (y.isAmbientLight) s += _.r * x, o += _.g * x, a += _.b * x;
                            else if (y.isLightProbe) {
                                for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(y.sh.coefficients[e], x);
                                v++
                            } else if (y.isDirectionalLight) {
                                const e = t.get(y);
                                if (e.color.copy(y.color).multiplyScalar(y.intensity), y.castShadow) {
                                    const e = y.shadow,
                                        t = n.get(y);
                                    t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, i.directionalShadow[l] = t, i.directionalShadowMap[l] = b, i.directionalShadowMatrix[l] = y.shadow.matrix, f++
                                }
                                i.directional[l] = e, l++
                            } else if (y.isSpotLight) {
                                const e = t.get(y);
                                e.position.setFromMatrixPosition(y.matrixWorld), e.color.copy(_).multiplyScalar(x), e.distance = E, e.coneCos = Math.cos(y.angle), e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), e.decay = y.decay, i.spot[u] = e;
                                const r = y.shadow;
                                if (y.map && (i.spotLightMap[g] = y.map, g++, r.updateMatrices(y), y.castShadow && A++), i.spotLightMatrix[u] = r.matrix, y.castShadow) {
                                    const e = n.get(y);
                                    e.shadowIntensity = r.intensity, e.shadowBias = r.bias, e.shadowNormalBias = r.normalBias, e.shadowRadius = r.radius, e.shadowMapSize = r.mapSize, i.spotShadow[u] = e, i.spotShadowMap[u] = b, m++
                                }
                                u++
                            } else if (y.isRectAreaLight) {
                                const e = t.get(y);
                                e.color.copy(_).multiplyScalar(x), e.halfWidth.set(.5 * y.width, 0, 0), e.halfHeight.set(0, .5 * y.height, 0), i.rectArea[h] = e, h++
                            } else if (y.isPointLight) {
                                const e = t.get(y);
                                if (e.color.copy(y.color).multiplyScalar(y.intensity), e.distance = y.distance, e.decay = y.decay, y.castShadow) {
                                    const e = y.shadow,
                                        t = n.get(y);
                                    t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, t.shadowCameraNear = e.camera.near, t.shadowCameraFar = e.camera.far, i.pointShadow[c] = t, i.pointShadowMap[c] = b, i.pointShadowMatrix[c] = y.shadow.matrix, p++
                                }
                                i.point[c] = e, c++
                            } else if (y.isHemisphereLight) {
                                const e = t.get(y);
                                e.skyColor.copy(y.color).multiplyScalar(x), e.groundColor.copy(y.groundColor).multiplyScalar(x), i.hemi[d] = e, d++
                            }
                        }
                        h > 0 && (!0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = ji.LTC_FLOAT_1, i.rectAreaLTC2 = ji.LTC_FLOAT_2) : (i.rectAreaLTC1 = ji.LTC_HALF_1, i.rectAreaLTC2 = ji.LTC_HALF_2)), i.ambient[0] = s, i.ambient[1] = o, i.ambient[2] = a;
                        const y = i.hash;
                        y.directionalLength === l && y.pointLength === c && y.spotLength === u && y.rectAreaLength === h && y.hemiLength === d && y.numDirectionalShadows === f && y.numPointShadows === p && y.numSpotShadows === m && y.numSpotMaps === g && y.numLightProbes === v || (i.directional.length = l, i.spot.length = u, i.rectArea.length = h, i.point.length = c, i.hemi.length = d, i.directionalShadow.length = f, i.directionalShadowMap.length = f, i.pointShadow.length = p, i.pointShadowMap.length = p, i.spotShadow.length = m, i.spotShadowMap.length = m, i.directionalShadowMatrix.length = f, i.pointShadowMatrix.length = p, i.spotLightMatrix.length = m + g - A, i.spotLightMap.length = g, i.numSpotLightShadowsWithMaps = A, i.numLightProbes = v, y.directionalLength = l, y.pointLength = c, y.spotLength = u, y.rectAreaLength = h, y.hemiLength = d, y.numDirectionalShadows = f, y.numPointShadows = p, y.numSpotShadows = m, y.numSpotMaps = g, y.numLightProbes = v, i.version = oo++)
                    },
                    setupView: function(e, t) {
                        let n = 0,
                            a = 0,
                            l = 0,
                            c = 0,
                            u = 0;
                        const h = t.matrixWorldInverse;
                        for (let t = 0, d = e.length; t < d; t++) {
                            const d = e[t];
                            if (d.isDirectionalLight) {
                                const e = i.directional[n];
                                e.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(h), n++
                            } else if (d.isSpotLight) {
                                const e = i.spot[l];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(h), l++
                            } else if (d.isRectAreaLight) {
                                const e = i.rectArea[c];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), o.identity(), s.copy(d.matrixWorld), s.premultiply(h), o.extractRotation(s), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++
                            } else if (d.isPointLight) {
                                const e = i.point[a];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), a++
                            } else if (d.isHemisphereLight) {
                                const e = i.hemi[u];
                                e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(h), u++
                            }
                        }
                    },
                    state: i
                }
            }

            function co(e) {
                const t = new lo(e),
                    n = [],
                    i = [],
                    r = {
                        lightsArray: n,
                        shadowsArray: i,
                        camera: null,
                        lights: t,
                        transmissionRenderTarget: {}
                    };
                return {
                    init: function(e) {
                        r.camera = e, n.length = 0, i.length = 0
                    },
                    state: r,
                    setupLights: function() {
                        t.setup(n)
                    },
                    setupLightsView: function(e) {
                        t.setupView(n, e)
                    },
                    pushLight: function(e) {
                        n.push(e)
                    },
                    pushShadow: function(e) {
                        i.push(e)
                    }
                }
            }

            function uo(e) {
                let t = new WeakMap;
                return {
                    get: function(n, i = 0) {
                        const r = t.get(n);
                        let s;
                        return void 0 === r ? (s = new co(e), t.set(n, [s])) : i >= r.length ? (s = new co(e), r.push(s)) : s = r[i], s
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            class ho extends Hn {
                static get type() {
                    return "MeshDepthMaterial"
                }
                constructor(e) {
                    super(), this.isMeshDepthMaterial = !0, this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                }
            }
            class fo extends Hn {
                static get type() {
                    return "MeshDistanceMaterial"
                }
                constructor(e) {
                    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                }
            }

            function po(e, t, n) {
                let i = new Qi;
                const r = new ze,
                    s = new ze,
                    o = new ut,
                    a = new ho({
                        depthPacking: ve
                    }),
                    l = new fo,
                    c = {},
                    u = n.maxTextureSize,
                    d = {
                        0: 1,
                        1: 0,
                        2: 2
                    },
                    f = new wi({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new ze
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    p = f.clone();
                p.defines.HORIZONTAL_PASS = 1;
                const m = new si;
                m.setAttribute("position", new Yn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const g = new Ai(m, f),
                    A = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
                let v = this.type;

                function y(n, i) {
                    const s = t.update(g);
                    f.defines.VSM_SAMPLES !== n.blurSamples && (f.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, f.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new dt(r.x, r.y)), f.uniforms.shadow_pass.value = n.map.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, s, f, g, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, s, p, g, null)
                }

                function _(t, n, i, r) {
                    let s = null;
                    const o = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (void 0 !== o) s = o;
                    else if (s = !0 === i.isPointLight ? l : a, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                        const e = s.uuid,
                            t = n.uuid;
                        let i = c[e];
                        void 0 === i && (i = {}, c[e] = i);
                        let r = i[t];
                        void 0 === r && (r = s.clone(), i[t] = r, n.addEventListener("dispose", E)), s = r
                    }
                    return s.visible = n.visible, s.wireframe = n.wireframe, s.side = 3 === r ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], s.alphaMap = n.alphaMap, s.alphaTest = n.alphaTest, s.map = n.map, s.clipShadows = n.clipShadows, s.clippingPlanes = n.clippingPlanes, s.clipIntersection = n.clipIntersection, s.displacementMap = n.displacementMap, s.displacementScale = n.displacementScale, s.displacementBias = n.displacementBias, s.wireframeLinewidth = n.wireframeLinewidth, s.linewidth = n.linewidth, !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial && (e.properties.get(s).light = i), s
                }

                function x(n, r, s, o, a) {
                    if (!1 === n.visible) return;
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                        const i = t.update(n),
                            l = n.material;
                        if (Array.isArray(l)) {
                            const t = i.groups;
                            for (let c = 0, u = t.length; c < u; c++) {
                                const u = t[c],
                                    h = l[u.materialIndex];
                                if (h && h.visible) {
                                    const t = _(n, h, o, a);
                                    n.onBeforeShadow(e, n, r, s, i, t, u), e.renderBufferDirect(s, null, i, t, n, u), n.onAfterShadow(e, n, r, s, i, t, u)
                                }
                            }
                        } else if (l.visible) {
                            const t = _(n, l, o, a);
                            n.onBeforeShadow(e, n, r, s, i, t, null), e.renderBufferDirect(s, null, i, t, n, null), n.onAfterShadow(e, n, r, s, i, t, null)
                        }
                    }
                    const l = n.children;
                    for (let e = 0, t = l.length; e < t; e++) x(l[e], r, s, o, a)
                }

                function E(e) {
                    e.target.removeEventListener("dispose", E);
                    for (const t in c) {
                        const n = c[t],
                            i = e.target.uuid;
                        i in n && (n[i].dispose(), delete n[i])
                    }
                }
                this.render = function(t, n, a) {
                    if (!1 === A.enabled) return;
                    if (!1 === A.autoUpdate && !1 === A.needsUpdate) return;
                    if (0 === t.length) return;
                    const l = e.getRenderTarget(),
                        c = e.getActiveCubeFace(),
                        d = e.getActiveMipmapLevel(),
                        f = e.state;
                    f.setBlending(0), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1);
                    const p = 3 !== v && 3 === this.type,
                        m = 3 === v && 3 !== this.type;
                    for (let l = 0, c = t.length; l < c; l++) {
                        const c = t[l],
                            d = c.shadow;
                        if (void 0 === d) continue;
                        if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue;
                        r.copy(d.mapSize);
                        const g = d.getFrameExtents();
                        if (r.multiply(g), s.copy(d.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / g.x), r.x = s.x * g.x, d.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / g.y), r.y = s.y * g.y, d.mapSize.y = s.y)), null === d.map || !0 === p || !0 === m) {
                            const e = 3 !== this.type ? {
                                minFilter: h,
                                magFilter: h
                            } : {};
                            null !== d.map && d.map.dispose(), d.map = new dt(r.x, r.y, e), d.map.texture.name = c.name + ".shadowMap", d.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(d.map), e.clear();
                        const A = d.getViewportCount();
                        for (let e = 0; e < A; e++) {
                            const t = d.getViewport(e);
                            o.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), f.viewport(o), d.updateMatrices(c, e), i = d.getFrustum(), x(n, a, d.camera, c, this.type)
                        }!0 !== d.isPointLightShadow && 3 === this.type && y(d, a), d.needsUpdate = !1
                    }
                    v = this.type, A.needsUpdate = !1, e.setRenderTarget(l, c, d)
                }
            }
            const mo = {
                0: 1,
                2: 6,
                4: 7,
                3: 5,
                1: 0,
                6: 2,
                7: 4,
                5: 3
            };

            function go(e, n) {
                const i = new function() {
                        let t = !1;
                        const n = new ut;
                        let i = null;
                        const r = new ut(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                i === n || t || (e.colorMask(n, n, n, n), i = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, i, s, o, a) {
                                !0 === a && (t *= o, i *= o, s *= o), n.set(t, i, s, o), !1 === r.equals(n) && (e.clearColor(t, i, s, o), r.copy(n))
                            },
                            reset: function() {
                                t = !1, i = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    r = new function() {
                        let t = !1,
                            i = !1,
                            r = null,
                            s = null,
                            o = null;
                        return {
                            setReversed: function(e) {
                                if (i !== e) {
                                    const e = n.get("EXT_clip_control");
                                    i ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT) : e.clipControlEXT(e.LOWER_LEFT_EXT, e.NEGATIVE_ONE_TO_ONE_EXT);
                                    const t = o;
                                    o = null, this.setClear(t)
                                }
                                i = e
                            },
                            getReversed: function() {
                                return i
                            },
                            setTest: function(t) {
                                t ? z(e.DEPTH_TEST) : H(e.DEPTH_TEST)
                            },
                            setMask: function(n) {
                                r === n || t || (e.depthMask(n), r = n)
                            },
                            setFunc: function(t) {
                                if (i && (t = mo[t]), s !== t) {
                                    switch (t) {
                                        case 0:
                                            e.depthFunc(e.NEVER);
                                            break;
                                        case 1:
                                            e.depthFunc(e.ALWAYS);
                                            break;
                                        case 2:
                                            e.depthFunc(e.LESS);
                                            break;
                                        case 3:
                                        default:
                                            e.depthFunc(e.LEQUAL);
                                            break;
                                        case 4:
                                            e.depthFunc(e.EQUAL);
                                            break;
                                        case 5:
                                            e.depthFunc(e.GEQUAL);
                                            break;
                                        case 6:
                                            e.depthFunc(e.GREATER);
                                            break;
                                        case 7:
                                            e.depthFunc(e.NOTEQUAL)
                                    }
                                    s = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                o !== t && (i && (t = 1 - t), e.clearDepth(t), o = t)
                            },
                            reset: function() {
                                t = !1, r = null, s = null, o = null, i = !1
                            }
                        }
                    },
                    s = new function() {
                        let t = !1,
                            n = null,
                            i = null,
                            r = null,
                            s = null,
                            o = null,
                            a = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function(n) {
                                t || (n ? z(e.STENCIL_TEST) : H(e.STENCIL_TEST))
                            },
                            setMask: function(i) {
                                n === i || t || (e.stencilMask(i), n = i)
                            },
                            setFunc: function(t, n, o) {
                                i === t && r === n && s === o || (e.stencilFunc(t, n, o), i = t, r = n, s = o)
                            },
                            setOp: function(t, n, i) {
                                o === t && a === n && l === i || (e.stencilOp(t, n, i), o = t, a = n, l = i)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                c !== t && (e.clearStencil(t), c = t)
                            },
                            reset: function() {
                                t = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null
                            }
                        }
                    },
                    o = new WeakMap,
                    a = new WeakMap;
                let l = {},
                    c = {},
                    u = new WeakMap,
                    h = [],
                    d = null,
                    f = !1,
                    p = null,
                    m = null,
                    g = null,
                    A = null,
                    v = null,
                    y = null,
                    _ = null,
                    x = new kn(0, 0, 0),
                    E = 0,
                    b = !1,
                    w = null,
                    C = null,
                    S = null,
                    T = null,
                    M = null;
                const I = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                let B = !1,
                    R = 0;
                const D = e.getParameter(e.VERSION); - 1 !== D.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(D)[1]), B = R >= 1) : -1 !== D.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]), B = R >= 2);
                let P = null,
                    L = {};
                const U = e.getParameter(e.SCISSOR_BOX),
                    N = e.getParameter(e.VIEWPORT),
                    O = (new ut).fromArray(U),
                    F = (new ut).fromArray(N);

                function k(t, n, i, r) {
                    const s = new Uint8Array(4),
                        o = e.createTexture();
                    e.bindTexture(t, o), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                    for (let o = 0; o < i; o++) t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, s) : e.texImage2D(n + o, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s);
                    return o
                }
                const Q = {};

                function z(t) {
                    !0 !== l[t] && (e.enable(t), l[t] = !0)
                }

                function H(t) {
                    !1 !== l[t] && (e.disable(t), l[t] = !1)
                }
                Q[e.TEXTURE_2D] = k(e.TEXTURE_2D, e.TEXTURE_2D, 1), Q[e.TEXTURE_CUBE_MAP] = k(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Q[e.TEXTURE_2D_ARRAY] = k(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), Q[e.TEXTURE_3D] = k(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), r.setClear(1), s.setClear(0), z(e.DEPTH_TEST), r.setFunc(3), W(!1), X(1), z(e.CULL_FACE), j(0);
                const G = {
                    [t]: e.FUNC_ADD,
                    101: e.FUNC_SUBTRACT,
                    102: e.FUNC_REVERSE_SUBTRACT
                };
                G[103] = e.MIN, G[104] = e.MAX;
                const V = {
                    200: e.ZERO,
                    201: e.ONE,
                    202: e.SRC_COLOR,
                    204: e.SRC_ALPHA,
                    210: e.SRC_ALPHA_SATURATE,
                    208: e.DST_COLOR,
                    206: e.DST_ALPHA,
                    203: e.ONE_MINUS_SRC_COLOR,
                    205: e.ONE_MINUS_SRC_ALPHA,
                    209: e.ONE_MINUS_DST_COLOR,
                    207: e.ONE_MINUS_DST_ALPHA,
                    211: e.CONSTANT_COLOR,
                    212: e.ONE_MINUS_CONSTANT_COLOR,
                    213: e.CONSTANT_ALPHA,
                    214: e.ONE_MINUS_CONSTANT_ALPHA
                };

                function j(n, i, r, s, o, a, l, c, u, h) {
                    if (0 !== n) {
                        if (!1 === f && (z(e.BLEND), f = !0), 5 === n) o = o || i, a = a || r, l = l || s, i === m && o === v || (e.blendEquationSeparate(G[i], G[o]), m = i, v = o), r === g && s === A && a === y && l === _ || (e.blendFuncSeparate(V[r], V[s], V[a], V[l]), g = r, A = s, y = a, _ = l), !1 !== c.equals(x) && u === E || (e.blendColor(c.r, c.g, c.b, u), x.copy(c), E = u), p = n, b = !1;
                        else if (n !== p || h !== b) {
                            if (m === t && v === t || (e.blendEquation(e.FUNC_ADD), m = t, v = t), h) switch (n) {
                                case 1:
                                    e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case 2:
                                    e.blendFunc(e.ONE, e.ONE);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case 4:
                                    e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)
                            } else switch (n) {
                                case 1:
                                    e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case 2:
                                    e.blendFunc(e.SRC_ALPHA, e.ONE);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case 4:
                                    e.blendFunc(e.ZERO, e.SRC_COLOR)
                            }
                            g = null, A = null, y = null, _ = null, x.set(0, 0, 0), E = 0, p = n, b = h
                        }
                    } else !0 === f && (H(e.BLEND), f = !1)
                }

                function W(t) {
                    w !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), w = t)
                }

                function X(t) {
                    0 !== t ? (z(e.CULL_FACE), t !== C && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : H(e.CULL_FACE), C = t
                }

                function Y(t, n, i) {
                    t ? (z(e.POLYGON_OFFSET_FILL), T === n && M === i || (e.polygonOffset(n, i), T = n, M = i)) : H(e.POLYGON_OFFSET_FILL)
                }
                return {
                    buffers: {
                        color: i,
                        depth: r,
                        stencil: s
                    },
                    enable: z,
                    disable: H,
                    bindFramebuffer: function(t, n) {
                        return c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, t === e.DRAW_FRAMEBUFFER && (c[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (c[e.DRAW_FRAMEBUFFER] = n), !0)
                    },
                    drawBuffers: function(t, n) {
                        let i = h,
                            r = !1;
                        if (t) {
                            i = u.get(n), void 0 === i && (i = [], u.set(n, i));
                            const s = t.textures;
                            if (i.length !== s.length || i[0] !== e.COLOR_ATTACHMENT0) {
                                for (let t = 0, n = s.length; t < n; t++) i[t] = e.COLOR_ATTACHMENT0 + t;
                                i.length = s.length, r = !0
                            }
                        } else i[0] !== e.BACK && (i[0] = e.BACK, r = !0);
                        r && e.drawBuffers(i)
                    },
                    useProgram: function(t) {
                        return d !== t && (e.useProgram(t), d = t, !0)
                    },
                    setBlending: j,
                    setMaterial: function(t, n) {
                        2 === t.side ? H(e.CULL_FACE) : z(e.CULL_FACE);
                        let o = 1 === t.side;
                        n && (o = !o), W(o), 1 === t.blending && !1 === t.transparent ? j(0) : j(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha), r.setFunc(t.depthFunc), r.setTest(t.depthTest), r.setMask(t.depthWrite), i.setMask(t.colorWrite);
                        const a = t.stencilWrite;
                        s.setTest(a), a && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Y(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? z(e.SAMPLE_ALPHA_TO_COVERAGE) : H(e.SAMPLE_ALPHA_TO_COVERAGE)
                    },
                    setFlipSided: W,
                    setCullFace: X,
                    setLineWidth: function(t) {
                        t !== S && (B && e.lineWidth(t), S = t)
                    },
                    setPolygonOffset: Y,
                    setScissorTest: function(t) {
                        t ? z(e.SCISSOR_TEST) : H(e.SCISSOR_TEST)
                    },
                    activeTexture: function(t) {
                        void 0 === t && (t = e.TEXTURE0 + I - 1), P !== t && (e.activeTexture(t), P = t)
                    },
                    bindTexture: function(t, n, i) {
                        void 0 === i && (i = null === P ? e.TEXTURE0 + I - 1 : P);
                        let r = L[i];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        }, L[i] = r), r.type === t && r.texture === n || (P !== i && (e.activeTexture(i), P = i), e.bindTexture(t, n || Q[t]), r.type = t, r.texture = n)
                    },
                    unbindTexture: function() {
                        const t = L[P];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {}
                    },
                    compressedTexImage3D: function() {
                        try {
                            e.compressedTexImage3D.apply(e, arguments)
                        } catch (e) {}
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {}
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {}
                    },
                    updateUBOMapping: function(t, n) {
                        let i = a.get(n);
                        void 0 === i && (i = new WeakMap, a.set(n, i));
                        let r = i.get(t);
                        void 0 === r && (r = e.getUniformBlockIndex(n, t.name), i.set(t, r))
                    },
                    uniformBlockBinding: function(t, n) {
                        const i = a.get(n).get(t);
                        o.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex), o.set(n, i))
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {}
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (e) {}
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {}
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (e) {}
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (e) {}
                    },
                    compressedTexSubImage3D: function() {
                        try {
                            e.compressedTexSubImage3D.apply(e, arguments)
                        } catch (e) {}
                    },
                    scissor: function(t) {
                        !1 === O.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), O.copy(t))
                    },
                    viewport: function(t) {
                        !1 === F.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), F.copy(t))
                    },
                    reset: function() {
                        e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), r.setReversed(!1), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), l = {}, P = null, L = {}, c = {}, u = new WeakMap, h = [], d = null, f = !1, p = null, m = null, g = null, A = null, v = null, y = null, _ = null, x = new kn(0, 0, 0), E = 0, b = !1, w = null, C = null, S = null, T = null, M = null, O.set(0, 0, e.canvas.width, e.canvas.height), F.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), r.reset(), s.reset()
                    }
                }
            }

            function Ao(e, t, n, i) {
                const r = function(e) {
                    switch (e) {
                        case A:
                        case v:
                            return {
                                byteLength: 1, components: 1
                            };
                        case _:
                        case y:
                        case w:
                            return {
                                byteLength: 2, components: 1
                            };
                        case C:
                        case S:
                            return {
                                byteLength: 2, components: 4
                            };
                        case E:
                        case x:
                        case b:
                            return {
                                byteLength: 4, components: 1
                            };
                        case M:
                            return {
                                byteLength: 4, components: 3
                            }
                    }
                    throw new Error(`Unknown texture type ${e}.`)
                }(i);
                switch (n) {
                    case 1021:
                    case B:
                        return e * t;
                    case 1025:
                        return e * t * 2;
                    case P:
                    case L:
                        return e * t / r.components * r.byteLength;
                    case U:
                    case N:
                        return e * t * 2 / r.components * r.byteLength;
                    case 1022:
                        return e * t * 3 / r.components * r.byteLength;
                    case I:
                    case O:
                        return e * t * 4 / r.components * r.byteLength;
                    case F:
                    case k:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case Q:
                    case z:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case G:
                    case j:
                        return Math.max(e, 16) * Math.max(t, 8) / 4;
                    case H:
                    case V:
                        return Math.max(e, 8) * Math.max(t, 8) / 2;
                    case W:
                    case X:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case Y:
                    case q:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case K:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
                    case J:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
                    case Z:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
                    case $:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
                    case ee:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
                    case te:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
                    case ne:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
                    case ie:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
                    case re:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
                    case se:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
                    case oe:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
                    case ae:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
                    case le:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
                    case ce:
                    case ue:
                    case he:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
                    case 36283:
                    case de:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
                    case fe:
                    case pe:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
                }
                throw new Error(`Unable to determine texture byte length for ${n} format.`)
            }

            function vo(e, t, n, i, r, s, o) {
                const a = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                    g = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                    A = new ze,
                    v = new WeakMap;
                let y;
                const x = new WeakMap;
                let w = !1;
                try {
                    w = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}

                function C(e, t) {
                    return w ? new OffscreenCanvas(e, t) : je("canvas")
                }

                function S(e, t, n) {
                    let i = 1;
                    const r = ne(e);
                    if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)), i < 1) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                            const n = Math.floor(i * r.width),
                                s = Math.floor(i * r.height);
                            void 0 === y && (y = C(n, s));
                            const o = t ? C(n, s) : y;
                            return o.width = n, o.height = s, o.getContext("2d").drawImage(e, 0, 0, n, s), o
                        }
                        return e
                    }
                    return e
                }

                function M(e) {
                    return e.generateMipmaps
                }

                function B(t) {
                    e.generateMipmap(t)
                }

                function P(t) {
                    return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
                }

                function L(n, i, r, s, o = !1) {
                    if (null !== n && void 0 !== e[n]) return e[n];
                    let a = i;
                    if (i === e.RED && (r === e.FLOAT && (a = e.R32F), r === e.HALF_FLOAT && (a = e.R16F), r === e.UNSIGNED_BYTE && (a = e.R8)), i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (a = e.R8UI), r === e.UNSIGNED_SHORT && (a = e.R16UI), r === e.UNSIGNED_INT && (a = e.R32UI), r === e.BYTE && (a = e.R8I), r === e.SHORT && (a = e.R16I), r === e.INT && (a = e.R32I)), i === e.RG && (r === e.FLOAT && (a = e.RG32F), r === e.HALF_FLOAT && (a = e.RG16F), r === e.UNSIGNED_BYTE && (a = e.RG8)), i === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (a = e.RG8UI), r === e.UNSIGNED_SHORT && (a = e.RG16UI), r === e.UNSIGNED_INT && (a = e.RG32UI), r === e.BYTE && (a = e.RG8I), r === e.SHORT && (a = e.RG16I), r === e.INT && (a = e.RG32I)), i === e.RGB_INTEGER && (r === e.UNSIGNED_BYTE && (a = e.RGB8UI), r === e.UNSIGNED_SHORT && (a = e.RGB16UI), r === e.UNSIGNED_INT && (a = e.RGB32UI), r === e.BYTE && (a = e.RGB8I), r === e.SHORT && (a = e.RGB16I), r === e.INT && (a = e.RGB32I)), i === e.RGBA_INTEGER && (r === e.UNSIGNED_BYTE && (a = e.RGBA8UI), r === e.UNSIGNED_SHORT && (a = e.RGBA16UI), r === e.UNSIGNED_INT && (a = e.RGBA32UI), r === e.BYTE && (a = e.RGBA8I), r === e.SHORT && (a = e.RGBA16I), r === e.INT && (a = e.RGBA32I)), i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (a = e.RGB9_E5), i === e.RGBA) {
                        const t = o ? Ee : qe.getTransfer(s);
                        r === e.FLOAT && (a = e.RGBA32F), r === e.HALF_FLOAT && (a = e.RGBA16F), r === e.UNSIGNED_BYTE && (a = t === be ? e.SRGB8_ALPHA8 : e.RGBA8), r === e.UNSIGNED_SHORT_4_4_4_4 && (a = e.RGBA4), r === e.UNSIGNED_SHORT_5_5_5_1 && (a = e.RGB5_A1)
                    }
                    return a !== e.R16F && a !== e.R32F && a !== e.RG16F && a !== e.RG32F && a !== e.RGBA16F && a !== e.RGBA32F || t.get("EXT_color_buffer_float"), a
                }

                function U(t, n) {
                    let i;
                    return t ? null === n || n === E || n === T ? i = e.DEPTH24_STENCIL8 : n === b ? i = e.DEPTH32F_STENCIL8 : n === _ && (i = e.DEPTH24_STENCIL8) : null === n || n === E || n === T ? i = e.DEPTH_COMPONENT24 : n === b ? i = e.DEPTH_COMPONENT32F : n === _ && (i = e.DEPTH_COMPONENT16), i
                }

                function N(e, t) {
                    return !0 === M(e) || e.isFramebufferTexture && e.minFilter !== h && e.minFilter !== f ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function O(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", O),
                        function(e) {
                            const t = i.get(e);
                            if (void 0 === t.__webglInit) return;
                            const n = e.source,
                                r = x.get(n);
                            if (r) {
                                const i = r[t.__cacheKey];
                                i.usedTimes--, 0 === i.usedTimes && k(e), 0 === Object.keys(r).length && x.delete(n)
                            }
                            i.remove(e)
                        }(t), t.isVideoTexture && v.delete(t)
                }

                function F(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", F),
                        function(t) {
                            const n = i.get(t);
                            if (t.depthTexture && (t.depthTexture.dispose(), i.remove(t.depthTexture)), t.isWebGLCubeRenderTarget)
                                for (let t = 0; t < 6; t++) {
                                    if (Array.isArray(n.__webglFramebuffer[t]))
                                        for (let i = 0; i < n.__webglFramebuffer[t].length; i++) e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                                    else e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                    n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                                } else {
                                    if (Array.isArray(n.__webglFramebuffer))
                                        for (let t = 0; t < n.__webglFramebuffer.length; t++) e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                    else e.deleteFramebuffer(n.__webglFramebuffer);
                                    if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                                        for (let t = 0; t < n.__webglColorRenderbuffer.length; t++) n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                                    n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                                }
                            const r = t.textures;
                            for (let t = 0, n = r.length; t < n; t++) {
                                const n = i.get(r[t]);
                                n.__webglTexture && (e.deleteTexture(n.__webglTexture), o.memory.textures--), i.remove(r[t])
                            }
                            i.remove(t)
                        }(n)
                }

                function k(t) {
                    const n = i.get(t);
                    e.deleteTexture(n.__webglTexture);
                    const r = t.source;
                    delete x.get(r)[n.__cacheKey], o.memory.textures--
                }
                let Q = 0;

                function z(t, r) {
                    const s = i.get(t);
                    if (t.isVideoTexture && function(e) {
                            const t = o.render.frame;
                            v.get(e) !== t && (v.set(e, t), e.update())
                        }(t), !1 === t.isRenderTargetTexture && t.version > 0 && s.__version !== t.version) {
                        const e = t.image;
                        if (null === e);
                        else if (!1 !== e.complete) return void X(s, t, r)
                    }
                    n.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r)
                }
                const H = {
                        [l]: e.REPEAT,
                        [c]: e.CLAMP_TO_EDGE,
                        [u]: e.MIRRORED_REPEAT
                    },
                    G = {
                        [h]: e.NEAREST,
                        1004: e.NEAREST_MIPMAP_NEAREST,
                        [d]: e.NEAREST_MIPMAP_LINEAR,
                        [f]: e.LINEAR,
                        [p]: e.LINEAR_MIPMAP_NEAREST,
                        [m]: e.LINEAR_MIPMAP_LINEAR
                    },
                    V = {
                        512: e.NEVER,
                        519: e.ALWAYS,
                        513: e.LESS,
                        515: e.LEQUAL,
                        514: e.EQUAL,
                        518: e.GEQUAL,
                        516: e.GREATER,
                        517: e.NOTEQUAL
                    };

                function j(n, s) {
                    if (s.type === b && !1 === t.has("OES_texture_float_linear") && (s.magFilter === f || s.magFilter === p || s.magFilter === d || s.magFilter === m || s.minFilter === f || s.minFilter === p || s.minFilter === d || s.minFilter), e.texParameteri(n, e.TEXTURE_WRAP_S, H[s.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, H[s.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, H[s.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, G[s.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, G[s.minFilter]), s.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, V[s.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        if (s.magFilter === h) return;
                        if (s.minFilter !== d && s.minFilter !== m) return;
                        if (s.type === b && !1 === t.has("OES_texture_float_linear")) return;
                        if (s.anisotropy > 1 || i.get(s).__currentAnisotropy) {
                            const o = t.get("EXT_texture_filter_anisotropic");
                            e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy
                        }
                    }
                }

                function W(t, n) {
                    let i = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", O));
                    const r = n.source;
                    let s = x.get(r);
                    void 0 === s && (s = {}, x.set(r, s));
                    const a = function(e) {
                        const t = [];
                        return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join()
                    }(n);
                    if (a !== t.__cacheKey) {
                        void 0 === s[a] && (s[a] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        }, o.memory.textures++, i = !0), s[a].usedTimes++;
                        const r = s[t.__cacheKey];
                        void 0 !== r && (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && k(n)), t.__cacheKey = a, t.__webglTexture = s[a].texture
                    }
                    return i
                }

                function X(t, o, a) {
                    let l = e.TEXTURE_2D;
                    (o.isDataArrayTexture || o.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY), o.isData3DTexture && (l = e.TEXTURE_3D);
                    const c = W(t, o),
                        u = o.source;
                    n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + a);
                    const h = i.get(u);
                    if (u.version !== h.__version || !0 === c) {
                        n.activeTexture(e.TEXTURE0 + a);
                        const t = qe.getPrimaries(qe.workingColorSpace),
                            i = o.colorSpace === ye ? null : qe.getPrimaries(o.colorSpace),
                            d = o.colorSpace === ye || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                        let f = S(o.image, !1, r.maxTextureSize);
                        f = te(o, f);
                        const p = s.convert(o.format, o.colorSpace),
                            m = s.convert(o.type);
                        let g, A = L(o.internalFormat, p, m, o.colorSpace, o.isVideoTexture);
                        j(l, o);
                        const v = o.mipmaps,
                            y = !0 !== o.isVideoTexture,
                            _ = void 0 === h.__version || !0 === c,
                            x = u.dataReady,
                            E = N(o, f);
                        if (o.isDepthTexture) A = U(o.format === D, o.type), _ && (y ? n.texStorage2D(e.TEXTURE_2D, 1, A, f.width, f.height) : n.texImage2D(e.TEXTURE_2D, 0, A, f.width, f.height, 0, p, m, null));
                        else if (o.isDataTexture)
                            if (v.length > 0) {
                                y && _ && n.texStorage2D(e.TEXTURE_2D, E, A, v[0].width, v[0].height);
                                for (let t = 0, i = v.length; t < i; t++) g = v[t], y ? x && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, g.width, g.height, p, m, g.data) : n.texImage2D(e.TEXTURE_2D, t, A, g.width, g.height, 0, p, m, g.data);
                                o.generateMipmaps = !1
                            } else y ? (_ && n.texStorage2D(e.TEXTURE_2D, E, A, f.width, f.height), x && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f.width, f.height, p, m, f.data)) : n.texImage2D(e.TEXTURE_2D, 0, A, f.width, f.height, 0, p, m, f.data);
                        else if (o.isCompressedTexture)
                            if (o.isCompressedArrayTexture) {
                                y && _ && n.texStorage3D(e.TEXTURE_2D_ARRAY, E, A, v[0].width, v[0].height, f.depth);
                                for (let t = 0, i = v.length; t < i; t++)
                                    if (g = v[t], o.format !== I) {
                                        if (null !== p)
                                            if (y) {
                                                if (x)
                                                    if (o.layerUpdates.size > 0) {
                                                        const i = Ao(g.width, g.height, o.format, o.type);
                                                        for (const r of o.layerUpdates) {
                                                            const s = g.data.subarray(r * i / g.data.BYTES_PER_ELEMENT, (r + 1) * i / g.data.BYTES_PER_ELEMENT);
                                                            n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, r, g.width, g.height, 1, p, s)
                                                        }
                                                        o.clearLayerUpdates()
                                                    } else n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, g.width, g.height, f.depth, p, g.data)
                                            } else n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, A, g.width, g.height, f.depth, 0, g.data, 0, 0)
                                    } else y ? x && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, g.width, g.height, f.depth, p, m, g.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, A, g.width, g.height, f.depth, 0, p, m, g.data)
                            } else {
                                y && _ && n.texStorage2D(e.TEXTURE_2D, E, A, v[0].width, v[0].height);
                                for (let t = 0, i = v.length; t < i; t++) g = v[t], o.format !== I ? null !== p && (y ? x && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, g.width, g.height, p, g.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, A, g.width, g.height, 0, g.data)) : y ? x && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, g.width, g.height, p, m, g.data) : n.texImage2D(e.TEXTURE_2D, t, A, g.width, g.height, 0, p, m, g.data)
                            }
                        else if (o.isDataArrayTexture)
                            if (y) {
                                if (_ && n.texStorage3D(e.TEXTURE_2D_ARRAY, E, A, f.width, f.height, f.depth), x)
                                    if (o.layerUpdates.size > 0) {
                                        const t = Ao(f.width, f.height, o.format, o.type);
                                        for (const i of o.layerUpdates) {
                                            const r = f.data.subarray(i * t / f.data.BYTES_PER_ELEMENT, (i + 1) * t / f.data.BYTES_PER_ELEMENT);
                                            n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, i, f.width, f.height, 1, p, m, r)
                                        }
                                        o.clearLayerUpdates()
                                    } else n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, f.width, f.height, f.depth, p, m, f.data)
                            } else n.texImage3D(e.TEXTURE_2D_ARRAY, 0, A, f.width, f.height, f.depth, 0, p, m, f.data);
                        else if (o.isData3DTexture) y ? (_ && n.texStorage3D(e.TEXTURE_3D, E, A, f.width, f.height, f.depth), x && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, f.width, f.height, f.depth, p, m, f.data)) : n.texImage3D(e.TEXTURE_3D, 0, A, f.width, f.height, f.depth, 0, p, m, f.data);
                        else if (o.isFramebufferTexture) {
                            if (_)
                                if (y) n.texStorage2D(e.TEXTURE_2D, E, A, f.width, f.height);
                                else {
                                    let t = f.width,
                                        i = f.height;
                                    for (let r = 0; r < E; r++) n.texImage2D(e.TEXTURE_2D, r, A, t, i, 0, p, m, null), t >>= 1, i >>= 1
                                }
                        } else if (v.length > 0) {
                            if (y && _) {
                                const t = ne(v[0]);
                                n.texStorage2D(e.TEXTURE_2D, E, A, t.width, t.height)
                            }
                            for (let t = 0, i = v.length; t < i; t++) g = v[t], y ? x && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, p, m, g) : n.texImage2D(e.TEXTURE_2D, t, A, p, m, g);
                            o.generateMipmaps = !1
                        } else if (y) {
                            if (_) {
                                const t = ne(f);
                                n.texStorage2D(e.TEXTURE_2D, E, A, t.width, t.height)
                            }
                            x && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p, m, f)
                        } else n.texImage2D(e.TEXTURE_2D, 0, A, p, m, f);
                        M(o) && B(l), h.__version = u.version, o.onUpdate && o.onUpdate(o)
                    }
                    t.__version = o.version
                }

                function Y(t, r, o, l, c, u) {
                    const h = s.convert(o.format, o.colorSpace),
                        d = s.convert(o.type),
                        f = L(o.internalFormat, h, d, o.colorSpace),
                        p = i.get(r),
                        m = i.get(o);
                    if (m.__renderTarget = r, !p.__hasExternalTextures) {
                        const t = Math.max(1, r.width >> u),
                            i = Math.max(1, r.height >> u);
                        c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, f, t, i, r.depth, 0, h, d, null) : n.texImage2D(c, u, f, t, i, 0, h, d, null)
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, t), ee(r) ? a.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, m.__webglTexture, 0, $(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, m.__webglTexture, u), n.bindFramebuffer(e.FRAMEBUFFER, null)
                }

                function q(t, n, i) {
                    if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer) {
                        const r = n.depthTexture,
                            s = r && r.isDepthTexture ? r.type : null,
                            o = U(n.stencilBuffer, s),
                            l = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            c = $(n);
                        ee(n) ? a.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, o, n.width, n.height) : i ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, o, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, o, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t)
                    } else {
                        const t = n.textures;
                        for (let r = 0; r < t.length; r++) {
                            const o = t[r],
                                l = s.convert(o.format, o.colorSpace),
                                c = s.convert(o.type),
                                u = L(o.internalFormat, l, c, o.colorSpace),
                                h = $(n);
                            i && !1 === ee(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, h, u, n.width, n.height) : ee(n) ? a.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, h, u, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height)
                        }
                    }
                    e.bindRenderbuffer(e.RENDERBUFFER, null)
                }

                function K(t) {
                    const r = i.get(t),
                        s = !0 === t.isWebGLCubeRenderTarget;
                    if (r.__boundDepthTexture !== t.depthTexture) {
                        const e = t.depthTexture;
                        if (r.__depthDisposeCallback && r.__depthDisposeCallback(), e) {
                            const t = () => {
                                delete r.__boundDepthTexture, delete r.__depthDisposeCallback, e.removeEventListener("dispose", t)
                            };
                            e.addEventListener("dispose", t), r.__depthDisposeCallback = t
                        }
                        r.__boundDepthTexture = e
                    }
                    if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                        if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, r) {
                            if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(e.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            const s = i.get(r.depthTexture);
                            s.__renderTarget = r, s.__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), z(r.depthTexture, 0);
                            const o = s.__webglTexture,
                                l = $(r);
                            if (r.depthTexture.format === R) ee(r) ? a.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0);
                            else {
                                if (r.depthTexture.format !== D) throw new Error("Unknown depthTexture format");
                                ee(r) ? a.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0)
                            }
                        }(r.__webglFramebuffer, t)
                    } else if (s) {
                        r.__webglDepthbuffer = [];
                        for (let i = 0; i < 6; i++)
                            if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]), void 0 === r.__webglDepthbuffer[i]) r.__webglDepthbuffer[i] = e.createRenderbuffer(), q(r.__webglDepthbuffer[i], t, !1);
                            else {
                                const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                                    s = r.__webglDepthbuffer[i];
                                e.bindRenderbuffer(e.RENDERBUFFER, s), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, s)
                            }
                    } else if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), void 0 === r.__webglDepthbuffer) r.__webglDepthbuffer = e.createRenderbuffer(), q(r.__webglDepthbuffer, t, !1);
                    else {
                        const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            i = r.__webglDepthbuffer;
                        e.bindRenderbuffer(e.RENDERBUFFER, i), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i)
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                const J = [],
                    Z = [];

                function $(e) {
                    return Math.min(r.maxSamples, e.samples)
                }

                function ee(e) {
                    const n = i.get(e);
                    return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                }

                function te(e, t) {
                    const n = e.colorSpace;
                    return e.format, e.type, !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== xe && n !== ye && qe.getTransfer(n), t
                }

                function ne(e) {
                    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (A.width = e.naturalWidth || e.width, A.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (A.width = e.displayWidth, A.height = e.displayHeight) : (A.width = e.width, A.height = e.height), A
                }
                this.allocateTextureUnit = function() {
                    const e = Q;
                    return r.maxTextures, Q += 1, e
                }, this.resetTextureUnits = function() {
                    Q = 0
                }, this.setTexture2D = z, this.setTexture2DArray = function(t, r) {
                    const s = i.get(t);
                    t.version > 0 && s.__version !== t.version ? X(s, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture, e.TEXTURE0 + r)
                }, this.setTexture3D = function(t, r) {
                    const s = i.get(t);
                    t.version > 0 && s.__version !== t.version ? X(s, t, r) : n.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r)
                }, this.setTextureCube = function(t, o) {
                    const a = i.get(t);
                    t.version > 0 && a.__version !== t.version ? function(t, o, a) {
                        if (6 !== o.image.length) return;
                        const l = W(t, o),
                            c = o.source;
                        n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + a);
                        const u = i.get(c);
                        if (c.version !== u.__version || !0 === l) {
                            n.activeTexture(e.TEXTURE0 + a);
                            const t = qe.getPrimaries(qe.workingColorSpace),
                                i = o.colorSpace === ye ? null : qe.getPrimaries(o.colorSpace),
                                h = o.colorSpace === ye || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                            const d = o.isCompressedTexture || o.image[0].isCompressedTexture,
                                f = o.image[0] && o.image[0].isDataTexture,
                                p = [];
                            for (let e = 0; e < 6; e++) p[e] = d || f ? f ? o.image[e].image : o.image[e] : S(o.image[e], !0, r.maxCubemapSize), p[e] = te(o, p[e]);
                            const m = p[0],
                                g = s.convert(o.format, o.colorSpace),
                                A = s.convert(o.type),
                                v = L(o.internalFormat, g, A, o.colorSpace),
                                y = !0 !== o.isVideoTexture,
                                _ = void 0 === u.__version || !0 === l,
                                x = c.dataReady;
                            let E, b = N(o, m);
                            if (j(e.TEXTURE_CUBE_MAP, o), d) {
                                y && _ && n.texStorage2D(e.TEXTURE_CUBE_MAP, b, v, m.width, m.height);
                                for (let t = 0; t < 6; t++) {
                                    E = p[t].mipmaps;
                                    for (let i = 0; i < E.length; i++) {
                                        const r = E[i];
                                        o.format !== I ? null !== g && (y ? x && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, g, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, v, r.width, r.height, 0, r.data)) : y ? x && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, g, A, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, v, r.width, r.height, 0, g, A, r.data)
                                    }
                                }
                            } else {
                                if (E = o.mipmaps, y && _) {
                                    E.length > 0 && b++;
                                    const t = ne(p[0]);
                                    n.texStorage2D(e.TEXTURE_CUBE_MAP, b, v, t.width, t.height)
                                }
                                for (let t = 0; t < 6; t++)
                                    if (f) {
                                        y ? x && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, p[t].width, p[t].height, g, A, p[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, v, p[t].width, p[t].height, 0, g, A, p[t].data);
                                        for (let i = 0; i < E.length; i++) {
                                            const r = E[i].image[t].image;
                                            y ? x && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, g, A, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, v, r.width, r.height, 0, g, A, r.data)
                                        }
                                    } else {
                                        y ? x && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, g, A, p[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, v, g, A, p[t]);
                                        for (let i = 0; i < E.length; i++) {
                                            const r = E[i];
                                            y ? x && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, g, A, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, v, g, A, r.image[t])
                                        }
                                    }
                            }
                            M(o) && B(e.TEXTURE_CUBE_MAP), u.__version = c.version, o.onUpdate && o.onUpdate(o)
                        }
                        t.__version = o.version
                    }(a, t, o) : n.bindTexture(e.TEXTURE_CUBE_MAP, a.__webglTexture, e.TEXTURE0 + o)
                }, this.rebindTextures = function(t, n, r) {
                    const s = i.get(t);
                    void 0 !== n && Y(s.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== r && K(t)
                }, this.setupRenderTarget = function(t) {
                    const r = t.texture,
                        a = i.get(t),
                        l = i.get(r);
                    t.addEventListener("dispose", F);
                    const c = t.textures,
                        u = !0 === t.isWebGLCubeRenderTarget,
                        h = c.length > 1;
                    if (h || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = r.version, o.memory.textures++), u) {
                        a.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++)
                            if (r.mipmaps && r.mipmaps.length > 0) {
                                a.__webglFramebuffer[t] = [];
                                for (let n = 0; n < r.mipmaps.length; n++) a.__webglFramebuffer[t][n] = e.createFramebuffer()
                            } else a.__webglFramebuffer[t] = e.createFramebuffer()
                    } else {
                        if (r.mipmaps && r.mipmaps.length > 0) {
                            a.__webglFramebuffer = [];
                            for (let t = 0; t < r.mipmaps.length; t++) a.__webglFramebuffer[t] = e.createFramebuffer()
                        } else a.__webglFramebuffer = e.createFramebuffer();
                        if (h)
                            for (let t = 0, n = c.length; t < n; t++) {
                                const n = i.get(c[t]);
                                void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(), o.memory.textures++)
                            }
                        if (t.samples > 0 && !1 === ee(t)) {
                            a.__webglMultisampledFramebuffer = e.createFramebuffer(), a.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, a.__webglMultisampledFramebuffer);
                            for (let n = 0; n < c.length; n++) {
                                const i = c[n];
                                a.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, a.__webglColorRenderbuffer[n]);
                                const r = s.convert(i.format, i.colorSpace),
                                    o = s.convert(i.type),
                                    l = L(i.internalFormat, r, o, i.colorSpace, !0 === t.isXRRenderTarget),
                                    u = $(t);
                                e.renderbufferStorageMultisample(e.RENDERBUFFER, u, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, a.__webglColorRenderbuffer[n])
                            }
                            e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (a.__webglDepthRenderbuffer = e.createRenderbuffer(), q(a.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null)
                        }
                    }
                    if (u) {
                        n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture), j(e.TEXTURE_CUBE_MAP, r);
                        for (let n = 0; n < 6; n++)
                            if (r.mipmaps && r.mipmaps.length > 0)
                                for (let i = 0; i < r.mipmaps.length; i++) Y(a.__webglFramebuffer[n][i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                            else Y(a.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                        M(r) && B(e.TEXTURE_CUBE_MAP), n.unbindTexture()
                    } else if (h) {
                        for (let r = 0, s = c.length; r < s; r++) {
                            const s = c[r],
                                o = i.get(s);
                            n.bindTexture(e.TEXTURE_2D, o.__webglTexture), j(e.TEXTURE_2D, s), Y(a.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0), M(s) && B(e.TEXTURE_2D)
                        }
                        n.unbindTexture()
                    } else {
                        let i = e.TEXTURE_2D;
                        if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), n.bindTexture(i, l.__webglTexture), j(i, r), r.mipmaps && r.mipmaps.length > 0)
                            for (let n = 0; n < r.mipmaps.length; n++) Y(a.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
                        else Y(a.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
                        M(r) && B(i), n.unbindTexture()
                    }
                    t.depthBuffer && K(t)
                }, this.updateRenderTargetMipmap = function(e) {
                    const t = e.textures;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r];
                        if (M(s)) {
                            const t = P(e),
                                r = i.get(s).__webglTexture;
                            n.bindTexture(t, r), B(t), n.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(t) {
                    if (t.samples > 0)
                        if (!1 === ee(t)) {
                            const r = t.textures,
                                s = t.width,
                                o = t.height;
                            let a = e.COLOR_BUFFER_BIT;
                            const l = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                                c = i.get(t),
                                u = r.length > 1;
                            if (u)
                                for (let t = 0; t < r.length; t++) n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                            n.bindFramebuffer(e.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglFramebuffer);
                            for (let n = 0; n < r.length; n++) {
                                if (t.resolveDepthBuffer && (t.depthBuffer && (a |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (a |= e.STENCIL_BUFFER_BIT)), u) {
                                    e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                                    const t = i.get(r[n]).__webglTexture;
                                    e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                                }
                                e.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, e.NEAREST), !0 === g && (J.length = 0, Z.length = 0, J.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && !1 === t.resolveDepthBuffer && (J.push(l), Z.push(l), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, Z)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, J))
                            }
                            if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), u)
                                for (let t = 0; t < r.length; t++) {
                                    n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, c.__webglColorRenderbuffer[t]);
                                    const s = i.get(r[t]).__webglTexture;
                                    n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, s, 0)
                                }
                            n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                        } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && g) {
                        const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
                    }
                }, this.setupDepthRenderbuffer = K, this.setupFrameBufferTexture = Y, this.useMultisampledRTT = ee
            }

            function yo(e, t) {
                return {
                    convert: function(n, i = "") {
                        let r;
                        const s = qe.getTransfer(i);
                        if (n === A) return e.UNSIGNED_BYTE;
                        if (n === C) return e.UNSIGNED_SHORT_4_4_4_4;
                        if (n === S) return e.UNSIGNED_SHORT_5_5_5_1;
                        if (n === M) return e.UNSIGNED_INT_5_9_9_9_REV;
                        if (n === v) return e.BYTE;
                        if (n === y) return e.SHORT;
                        if (n === _) return e.UNSIGNED_SHORT;
                        if (n === x) return e.INT;
                        if (n === E) return e.UNSIGNED_INT;
                        if (n === b) return e.FLOAT;
                        if (n === w) return e.HALF_FLOAT;
                        if (1021 === n) return e.ALPHA;
                        if (1022 === n) return e.RGB;
                        if (n === I) return e.RGBA;
                        if (n === B) return e.LUMINANCE;
                        if (1025 === n) return e.LUMINANCE_ALPHA;
                        if (n === R) return e.DEPTH_COMPONENT;
                        if (n === D) return e.DEPTH_STENCIL;
                        if (n === P) return e.RED;
                        if (n === L) return e.RED_INTEGER;
                        if (n === U) return e.RG;
                        if (n === N) return e.RG_INTEGER;
                        if (n === O) return e.RGBA_INTEGER;
                        if (n === F || n === k || n === Q || n === z)
                            if (s === be) {
                                if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
                                if (n === F) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (n === k) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (n === Q) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (n === z) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (r = t.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
                                if (n === F) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (n === k) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (n === Q) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (n === z) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            } if (n === H || n === G || n === V || n === j) {
                            if (r = t.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
                            if (n === H) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === G) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === V) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === j) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (n === W || n === X || n === Y) {
                            if (r = t.get("WEBGL_compressed_texture_etc"), null === r) return null;
                            if (n === W || n === X) return s === be ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                            if (n === Y) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (n === q || n === K || n === J || n === Z || n === $ || n === ee || n === te || n === ne || n === ie || n === re || n === se || n === oe || n === ae || n === le) {
                            if (r = t.get("WEBGL_compressed_texture_astc"), null === r) return null;
                            if (n === q) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (n === K) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (n === J) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (n === Z) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (n === $) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (n === ee) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (n === te) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (n === ne) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (n === ie) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (n === re) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (n === se) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (n === oe) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (n === ae) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (n === le) return s === be ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (n === ce || n === ue || n === he) {
                            if (r = t.get("EXT_texture_compression_bptc"), null === r) return null;
                            if (n === ce) return s === be ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                            if (n === ue) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                            if (n === he) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                        }
                        if (36283 === n || n === de || n === fe || n === pe) {
                            if (r = t.get("EXT_texture_compression_rgtc"), null === r) return null;
                            if (n === ce) return r.COMPRESSED_RED_RGTC1_EXT;
                            if (n === de) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                            if (n === fe) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                            if (n === pe) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                        }
                        return n === T ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
                    }
                }
            }
            class _o extends Ii {
                constructor(e = []) {
                    super(), this.isArrayCamera = !0, this.cameras = e
                }
            }
            class xo extends _n {
                constructor() {
                    super(), this.isGroup = !0, this.type = "Group"
                }
            }
            const Eo = {
                type: "move"
            };
            class bo {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new xo, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new xo, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new gt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new gt), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new xo, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new gt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new gt), this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                }
                connect(e) {
                    if (e && e.hand) {
                        const t = this._hand;
                        if (t)
                            for (const n of e.hand.values()) this._getHandJoint(t, n)
                    }
                    return this.dispatchEvent({
                        type: "connected",
                        data: e
                    }), this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(e, t, n) {
                    let i = null,
                        r = null,
                        s = null;
                    const o = this._targetRay,
                        a = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState) {
                        if (l && e.hand) {
                            s = !0;
                            for (const i of e.hand.values()) {
                                const e = t.getJointPose(i, n),
                                    r = this._getHandJoint(l, i);
                                null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = e.radius), r.visible = null !== e
                            }
                            const i = l.joints["index-finger-tip"],
                                r = l.joints["thumb-tip"],
                                o = i.position.distanceTo(r.position),
                                a = .02,
                                c = .005;
                            l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else null !== a && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                        null !== o && (i = t.getPose(e.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Eo)))
                    }
                    return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
                }
                _getHandJoint(e, t) {
                    if (void 0 === e.joints[t.jointName]) {
                        const n = new xo;
                        n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
                    }
                    return e.joints[t.jointName]
                }
            }
            class wo {
                constructor() {
                    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
                }
                init(e, t, n) {
                    if (null === this.texture) {
                        const i = new ct;
                        e.properties.get(i).__webglTexture = t.texture, t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i
                    }
                }
                getMesh(e) {
                    if (null !== this.texture && null === this.mesh) {
                        const t = e.cameras[0].viewport,
                            n = new wi({
                                vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: t.z
                                    },
                                    depthHeight: {
                                        value: t.w
                                    }
                                }
                            });
                        this.mesh = new Ai(new Gi(20, 20), n)
                    }
                    return this.mesh
                }
                reset() {
                    this.texture = null, this.mesh = null
                }
                getDepthTexture() {
                    return this.texture
                }
            }
            class Co extends Ie {
                constructor(e, t) {
                    super();
                    const n = this;
                    let i = null,
                        r = 1,
                        s = null,
                        o = "local-floor",
                        a = 1,
                        l = null,
                        c = null,
                        u = null,
                        h = null,
                        d = null,
                        f = null;
                    const p = new wo,
                        m = t.getContextAttributes();
                    let g = null,
                        v = null;
                    const y = [],
                        _ = [],
                        x = new ze;
                    let b = null;
                    const w = new Ii;
                    w.viewport = new ut;
                    const C = new Ii;
                    C.viewport = new ut;
                    const S = [w, C],
                        M = new _o;
                    let B = null,
                        P = null;

                    function L(e) {
                        const t = _.indexOf(e.inputSource);
                        if (-1 === t) return;
                        const n = y[t];
                        void 0 !== n && (n.update(e.inputSource, e.frame, l || s), n.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        }))
                    }

                    function U() {
                        i.removeEventListener("select", L), i.removeEventListener("selectstart", L), i.removeEventListener("selectend", L), i.removeEventListener("squeeze", L), i.removeEventListener("squeezestart", L), i.removeEventListener("squeezeend", L), i.removeEventListener("end", U), i.removeEventListener("inputsourceschange", N);
                        for (let e = 0; e < y.length; e++) {
                            const t = _[e];
                            null !== t && (_[e] = null, y[e].disconnect(t))
                        }
                        B = null, P = null, p.reset(), e.setRenderTarget(g), d = null, h = null, u = null, i = null, v = null, z.stop(), n.isPresenting = !1, e.setPixelRatio(b), e.setSize(x.width, x.height, !1), n.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function N(e) {
                        for (let t = 0; t < e.removed.length; t++) {
                            const n = e.removed[t],
                                i = _.indexOf(n);
                            i >= 0 && (_[i] = null, y[i].disconnect(n))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            const n = e.added[t];
                            let i = _.indexOf(n);
                            if (-1 === i) {
                                for (let e = 0; e < y.length; e++) {
                                    if (e >= _.length) {
                                        _.push(n), i = e;
                                        break
                                    }
                                    if (null === _[e]) {
                                        _[e] = n, i = e;
                                        break
                                    }
                                }
                                if (-1 === i) break
                            }
                            const r = y[i];
                            r && r.connect(n)
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                        let t = y[e];
                        return void 0 === t && (t = new bo, y[e] = t), t.getTargetRaySpace()
                    }, this.getControllerGrip = function(e) {
                        let t = y[e];
                        return void 0 === t && (t = new bo, y[e] = t), t.getGripSpace()
                    }, this.getHand = function(e) {
                        let t = y[e];
                        return void 0 === t && (t = new bo, y[e] = t), t.getHandSpace()
                    }, this.setFramebufferScaleFactor = function(e) {
                        r = e, n.isPresenting
                    }, this.setReferenceSpaceType = function(e) {
                        o = e, n.isPresenting
                    }, this.getReferenceSpace = function() {
                        return l || s
                    }, this.setReferenceSpace = function(e) {
                        l = e
                    }, this.getBaseLayer = function() {
                        return null !== h ? h : d
                    }, this.getBinding = function() {
                        return u
                    }, this.getFrame = function() {
                        return f
                    }, this.getSession = function() {
                        return i
                    }, this.setSession = async function(c) {
                        if (i = c, null !== i) {
                            if (g = e.getRenderTarget(), i.addEventListener("select", L), i.addEventListener("selectstart", L), i.addEventListener("selectend", L), i.addEventListener("squeeze", L), i.addEventListener("squeezestart", L), i.addEventListener("squeezeend", L), i.addEventListener("end", U), i.addEventListener("inputsourceschange", N), !0 !== m.xrCompatible && await t.makeXRCompatible(), b = e.getPixelRatio(), e.getSize(x), void 0 === i.renderState.layers) {
                                const n = {
                                    antialias: m.antialias,
                                    alpha: !0,
                                    depth: m.depth,
                                    stencil: m.stencil,
                                    framebufferScaleFactor: r
                                };
                                d = new XRWebGLLayer(i, t, n), i.updateRenderState({
                                    baseLayer: d
                                }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, !1), v = new dt(d.framebufferWidth, d.framebufferHeight, {
                                    format: I,
                                    type: A,
                                    colorSpace: e.outputColorSpace,
                                    stencilBuffer: m.stencil
                                })
                            } else {
                                let n = null,
                                    s = null,
                                    o = null;
                                m.depth && (o = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = m.stencil ? D : R, s = m.stencil ? T : E);
                                const a = {
                                    colorFormat: t.RGBA8,
                                    depthFormat: o,
                                    scaleFactor: r
                                };
                                u = new XRWebGLBinding(i, t), h = u.createProjectionLayer(a), i.updateRenderState({
                                    layers: [h]
                                }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), v = new dt(h.textureWidth, h.textureHeight, {
                                    format: I,
                                    type: A,
                                    depthTexture: new Cr(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                    stencilBuffer: m.stencil,
                                    colorSpace: e.outputColorSpace,
                                    samples: m.antialias ? 4 : 0,
                                    resolveDepthBuffer: !1 === h.ignoreDepthValues
                                })
                            }
                            v.isXRRenderTarget = !0, this.setFoveation(a), l = null, s = await i.requestReferenceSpace(o), z.setContext(i), z.start(), n.isPresenting = !0, n.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    }, this.getEnvironmentBlendMode = function() {
                        if (null !== i) return i.environmentBlendMode
                    }, this.getDepthTexture = function() {
                        return p.getDepthTexture()
                    };
                    const O = new gt,
                        F = new gt;

                    function k(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === i) return;
                        let t = e.near,
                            n = e.far;
                        null !== p.texture && (p.depthNear > 0 && (t = p.depthNear), p.depthFar > 0 && (n = p.depthFar)), M.near = C.near = w.near = t, M.far = C.far = w.far = n, B === M.near && P === M.far || (i.updateRenderState({
                            depthNear: M.near,
                            depthFar: M.far
                        }), B = M.near, P = M.far), w.layers.mask = 2 | e.layers.mask, C.layers.mask = 4 | e.layers.mask, M.layers.mask = w.layers.mask | C.layers.mask;
                        const r = e.parent,
                            s = M.cameras;
                        k(M, r);
                        for (let e = 0; e < s.length; e++) k(s[e], r);
                        2 === s.length ? function(e, t, n) {
                                O.setFromMatrixPosition(t.matrixWorld), F.setFromMatrixPosition(n.matrixWorld);
                                const i = O.distanceTo(F),
                                    r = t.projectionMatrix.elements,
                                    s = n.projectionMatrix.elements,
                                    o = r[14] / (r[10] - 1),
                                    a = r[14] / (r[10] + 1),
                                    l = (r[9] + 1) / r[5],
                                    c = (r[9] - 1) / r[5],
                                    u = (r[8] - 1) / r[0],
                                    h = (s[8] + 1) / s[0],
                                    d = o * u,
                                    f = o * h,
                                    p = i / (-u + h),
                                    m = p * -u;
                                if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(p), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), -1 === r[10]) e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                                else {
                                    const t = o + p,
                                        n = a + p,
                                        r = d - m,
                                        s = f + (i - m),
                                        u = l * a / n * t,
                                        h = c * a / n * t;
                                    e.projectionMatrix.makePerspective(r, s, u, h, t, n), e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                                }
                            }(M, w, C) : M.projectionMatrix.copy(w.projectionMatrix),
                            function(e, t, n) {
                                null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld)), e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * Pe * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1)
                            }(e, M, r)
                    }, this.getCamera = function() {
                        return M
                    }, this.getFoveation = function() {
                        if (null !== h || null !== d) return a
                    }, this.setFoveation = function(e) {
                        a = e, null !== h && (h.fixedFoveation = e), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e)
                    }, this.hasDepthSensing = function() {
                        return null !== p.texture
                    }, this.getDepthSensingMesh = function() {
                        return p.getMesh(M)
                    };
                    let Q = null;
                    const z = new zi;
                    z.setAnimationLoop((function(t, r) {
                        if (c = r.getViewerPose(l || s), f = r, null !== c) {
                            const t = c.views;
                            null !== d && (e.setRenderTargetFramebuffer(v, d.framebuffer), e.setRenderTarget(v));
                            let n = !1;
                            t.length !== M.cameras.length && (M.cameras.length = 0, n = !0);
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                let s = null;
                                if (null !== d) s = d.getViewport(r);
                                else {
                                    const t = u.getViewSubImage(h, r);
                                    s = t.viewport, 0 === i && (e.setRenderTargetTextures(v, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(v))
                                }
                                let o = S[i];
                                void 0 === o && (o = new Ii, o.layers.enable(i), o.viewport = new ut, S[i] = o), o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale), o.projectionMatrix.fromArray(r.projectionMatrix), o.projectionMatrixInverse.copy(o.projectionMatrix).invert(), o.viewport.set(s.x, s.y, s.width, s.height), 0 === i && (M.matrix.copy(o.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), !0 === n && M.cameras.push(o)
                            }
                            const r = i.enabledFeatures;
                            if (r && r.includes("depth-sensing")) {
                                const n = u.getDepthInformation(t[0]);
                                n && n.isValid && n.texture && p.init(e, n, i.renderState)
                            }
                        }
                        for (let e = 0; e < y.length; e++) {
                            const t = _[e],
                                n = y[e];
                            null !== t && void 0 !== n && n.update(t, r, l || s)
                        }
                        Q && Q(t, r), r.detectedPlanes && n.dispatchEvent({
                            type: "planesdetected",
                            data: r
                        }), f = null
                    })), this.setAnimationLoop = function(e) {
                        Q = e
                    }, this.dispose = function() {}
                }
            }
            const So = new nn,
                To = new Wt;

            function Mo(e, t) {
                function n(e, t) {
                    !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix)
                }

                function i(e, i) {
                    e.opacity.value = i.opacity, i.color && e.diffuse.value.copy(i.color), i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (e.map.value = i.map, n(i.map, e.mapTransform)), i.alphaMap && (e.alphaMap.value = i.alphaMap, n(i.alphaMap, e.alphaMapTransform)), i.bumpMap && (e.bumpMap.value = i.bumpMap, n(i.bumpMap, e.bumpMapTransform), e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, n(i.normalMap, e.normalMapTransform), e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, n(i.displacementMap, e.displacementMapTransform), e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap, n(i.emissiveMap, e.emissiveMapTransform)), i.specularMap && (e.specularMap.value = i.specularMap, n(i.specularMap, e.specularMapTransform)), i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
                    const r = t.get(i),
                        s = r.envMap,
                        o = r.envMapRotation;
                    s && (e.envMap.value = s, So.copy(o), So.x *= -1, So.y *= -1, So.z *= -1, s.isCubeTexture && !1 === s.isRenderTargetTexture && (So.y *= -1, So.z *= -1), e.envMapRotation.value.setFromMatrix4(To.makeRotationFromEuler(So)), e.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = i.reflectivity, e.ior.value = i.ior, e.refractionRatio.value = i.refractionRatio), i.lightMap && (e.lightMap.value = i.lightMap, e.lightMapIntensity.value = i.lightMapIntensity, n(i.lightMap, e.lightMapTransform)), i.aoMap && (e.aoMap.value = i.aoMap, e.aoMapIntensity.value = i.aoMapIntensity, n(i.aoMap, e.aoMapTransform))
                }
                return {
                    refreshFogUniforms: function(t, n) {
                        n.color.getRGB(t.fogColor.value, Ei(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                    },
                    refreshMaterialUniforms: function(e, r, s, o, a) {
                        r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r), function(e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap)
                        }(e, r)) : r.isMeshPhongMaterial ? (i(e, r), function(e, t) {
                            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4)
                        }(e, r)) : r.isMeshStandardMaterial ? (i(e, r), function(e, t) {
                            e.metalness.value = t.metalness, t.metalnessMap && (e.metalnessMap.value = t.metalnessMap, n(t.metalnessMap, e.metalnessMapTransform)), e.roughness.value = t.roughness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap, n(t.roughnessMap, e.roughnessMapTransform)), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                        }(e, r), r.isMeshPhysicalMaterial && function(e, t, i) {
                            e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), 1 === t.side && e.clearcoatNormalScale.value.negate())), t.dispersion > 0 && (e.dispersion.value = t.dispersion), t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform))), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform)), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform))
                        }(e, r, a)) : r.isMeshMatcapMaterial ? (i(e, r), function(e, t) {
                            t.matcap && (e.matcap.value = t.matcap)
                        }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r), function(e, n) {
                            const i = t.get(n).light;
                            e.referencePosition.value.setFromMatrixPosition(i.matrixWorld), e.nearDistance.value = i.shadow.camera.near, e.farDistance.value = i.shadow.camera.far
                        }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, n(t.map, e.mapTransform))
                        }(e, r), r.isLineDashedMaterial && function(e, t) {
                            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                        }(e, r)) : r.isPointsMaterial ? function(e, t, i, r) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * i, e.scale.value = .5 * r, t.map && (e.map.value = t.map, n(t.map, e.uvTransform)), t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, r, s, o) : r.isSpriteMaterial ? function(e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, n(t.map, e.mapTransform)), t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                    }
                }
            }

            function Io(e, t, n, i) {
                let r = {},
                    s = {},
                    o = [];
                const a = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);

                function l(e, t, n, i) {
                    const r = e.value,
                        s = t + "_" + n;
                    if (void 0 === i[s]) return i[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0;
                    {
                        const e = i[s];
                        if ("number" == typeof r || "boolean" == typeof r) {
                            if (e !== r) return i[s] = r, !0
                        } else if (!1 === e.equals(r)) return e.copy(r), !0
                    }
                    return !1
                }

                function c(e) {
                    const t = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture, t
                }

                function u(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", u);
                    const i = o.indexOf(n.__bindingPointIndex);
                    o.splice(i, 1), e.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id]
                }
                return {
                    bind: function(e, t) {
                        const n = t.program;
                        i.uniformBlockBinding(e, n)
                    },
                    update: function(n, h) {
                        let d = r[n.id];
                        void 0 === d && (function(e) {
                            const t = e.uniforms;
                            let n = 0;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = Array.isArray(t[e]) ? t[e] : [t[e]];
                                for (let e = 0, t = i.length; e < t; e++) {
                                    const t = i[e],
                                        r = Array.isArray(t.value) ? t.value : [t.value];
                                    for (let e = 0, i = r.length; e < i; e++) {
                                        const i = c(r[e]),
                                            s = n % 16,
                                            o = s % i.boundary,
                                            a = s + o;
                                        n += o, 0 !== a && 16 - a < i.storage && (n += 16 - a), t.__data = new Float32Array(i.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = n, n += i.storage
                                    }
                                }
                            }
                            const i = n % 16;
                            i > 0 && (n += 16 - i), e.__size = n, e.__cache = {}
                        }(n), d = function(t) {
                            const n = function() {
                                for (let e = 0; e < a; e++)
                                    if (-1 === o.indexOf(e)) return o.push(e), e;
                                return 0
                            }();
                            t.__bindingPointIndex = n;
                            const i = e.createBuffer(),
                                r = t.__size,
                                s = t.usage;
                            return e.bindBuffer(e.UNIFORM_BUFFER, i), e.bufferData(e.UNIFORM_BUFFER, r, s), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, i), i
                        }(n), r[n.id] = d, n.addEventListener("dispose", u));
                        const f = h.program;
                        i.updateUBOMapping(n, f);
                        const p = t.render.frame;
                        s[n.id] !== p && (function(t) {
                            const n = r[t.id],
                                i = t.uniforms,
                                s = t.__cache;
                            e.bindBuffer(e.UNIFORM_BUFFER, n);
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                                for (let i = 0, r = n.length; i < r; i++) {
                                    const r = n[i];
                                    if (!0 === l(r, t, i, s)) {
                                        const t = r.__offset,
                                            n = Array.isArray(r.value) ? r.value : [r.value];
                                        let i = 0;
                                        for (let s = 0; s < n.length; s++) {
                                            const o = n[s],
                                                a = c(o);
                                            "number" == typeof o || "boolean" == typeof o ? (r.__data[0] = o, e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : o.isMatrix3 ? (r.__data[0] = o.elements[0], r.__data[1] = o.elements[1], r.__data[2] = o.elements[2], r.__data[3] = 0, r.__data[4] = o.elements[3], r.__data[5] = o.elements[4], r.__data[6] = o.elements[5], r.__data[7] = 0, r.__data[8] = o.elements[6], r.__data[9] = o.elements[7], r.__data[10] = o.elements[8], r.__data[11] = 0) : (o.toArray(r.__data, i), i += a.storage / Float32Array.BYTES_PER_ELEMENT)
                                        }
                                        e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                                    }
                                }
                            }
                            e.bindBuffer(e.UNIFORM_BUFFER, null)
                        }(n), s[n.id] = p)
                    },
                    dispose: function() {
                        for (const t in r) e.deleteBuffer(r[t]);
                        o = [], r = {}, s = {}
                    }
                }
            }
            class Bo {
                constructor(t = {}) {
                    const {
                        canvas: n = We(),
                        context: i = null,
                        depth: r = !0,
                        stencil: s = !1,
                        alpha: o = !1,
                        antialias: a = !1,
                        premultipliedAlpha: l = !0,
                        preserveDrawingBuffer: c = !1,
                        powerPreference: u = "default",
                        failIfMajorPerformanceCaveat: h = !1,
                        reverseDepthBuffer: d = !1
                    } = t;
                    let f;
                    if (this.isWebGLRenderer = !0, null !== i) {
                        if ("undefined" != typeof WebGLRenderingContext && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                        f = i.getContextAttributes().alpha
                    } else f = o;
                    const p = new Uint32Array(4),
                        g = new Int32Array(4);
                    let v = null,
                        y = null;
                    const x = [],
                        b = [];
                    this.domElement = n, this.debug = {
                        checkShaderErrors: !0,
                        onShaderError: null
                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = _e, this.toneMapping = 0, this.toneMappingExposure = 1;
                    const M = this;
                    let I = !1,
                        B = 0,
                        R = 0,
                        D = null,
                        P = -1,
                        U = null;
                    const F = new ut,
                        k = new ut;
                    let Q = null;
                    const z = new kn(0);
                    let H = 0,
                        G = n.width,
                        V = n.height,
                        j = 1,
                        W = null,
                        X = null;
                    const Y = new ut(0, 0, G, V),
                        q = new ut(0, 0, G, V);
                    let K = !1;
                    const J = new Qi;
                    let Z = !1,
                        $ = !1;
                    const ee = new Wt,
                        te = new Wt,
                        ne = new gt,
                        ie = new ut,
                        re = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };
                    let se = !1;

                    function oe() {
                        return null === D ? j : 1
                    }
                    let ae, le, ce, ue, he, de, fe, pe, me, ge, Ae, ve, ye, Ee, be, we, Ce, Se, Te, Me, Ie, Be, Re, De, Pe = i;

                    function Le(e, t) {
                        return n.getContext(e, t)
                    }
                    try {
                        const t = {
                            alpha: !0,
                            depth: r,
                            stencil: s,
                            antialias: a,
                            premultipliedAlpha: l,
                            preserveDrawingBuffer: c,
                            powerPreference: u,
                            failIfMajorPerformanceCaveat: h
                        };
                        if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${e}`), n.addEventListener("webglcontextlost", Oe, !1), n.addEventListener("webglcontextrestored", Fe, !1), n.addEventListener("webglcontextcreationerror", ke, !1), null === Pe) {
                            const e = "webgl2";
                            if (Pe = Le(e, t), null === Pe) throw Le(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                        }
                    } catch (e) {
                        throw e
                    }

                    function Ue() {
                        ae = new yr(Pe), ae.init(), Be = new yo(Pe, ae), le = new $i(Pe, ae, t, Be), ce = new go(Pe, ae), le.reverseDepthBuffer && d && ce.buffers.depth.setReversed(!0), ue = new Er(Pe), he = new eo, de = new vo(Pe, ae, ce, he, le, Be, ue), fe = new tr(M), pe = new vr(M), me = new Hi(Pe), Re = new Ji(Pe, me), ge = new _r(Pe, me, ue, Re), Ae = new wr(Pe, ge, me, ue), Te = new br(Pe, le, de), we = new er(he), ve = new $s(M, fe, pe, ae, le, Re, we), ye = new Mo(M, he), Ee = new ro, be = new uo(ae), Se = new Ki(M, fe, pe, ce, Ae, f, l), Ce = new po(M, Ae, le), De = new Io(Pe, ue, le, ce), Me = new Zi(Pe, ae, ue), Ie = new xr(Pe, ae, ue), ue.programs = ve.programs, M.capabilities = le, M.extensions = ae, M.properties = he, M.renderLists = Ee, M.shadowMap = Ce, M.state = ce, M.info = ue
                    }
                    Ue();
                    const Ne = new Co(M, Pe);

                    function Oe(e) {
                        e.preventDefault(), I = !0
                    }

                    function Fe() {
                        I = !1;
                        const e = ue.autoReset,
                            t = Ce.enabled,
                            n = Ce.autoUpdate,
                            i = Ce.needsUpdate,
                            r = Ce.type;
                        Ue(), ue.autoReset = e, Ce.enabled = t, Ce.autoUpdate = n, Ce.needsUpdate = i, Ce.type = r
                    }

                    function ke(e) {}

                    function Qe(e) {
                        const t = e.target;
                        t.removeEventListener("dispose", Qe),
                            function(e) {
                                (function(e) {
                                    const t = he.get(e).programs;
                                    void 0 !== t && (t.forEach((function(e) {
                                        ve.releaseProgram(e)
                                    })), e.isShaderMaterial && ve.releaseShaderCache(e))
                                })(e), he.remove(e)
                            }(t)
                    }

                    function ze(e, t, n) {
                        !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1, e.needsUpdate = !0, et(e, t, n), e.side = 0, e.needsUpdate = !0, et(e, t, n), e.side = 2) : et(e, t, n)
                    }
                    this.xr = Ne, this.getContext = function() {
                        return Pe
                    }, this.getContextAttributes = function() {
                        return Pe.getContextAttributes()
                    }, this.forceContextLoss = function() {
                        const e = ae.get("WEBGL_lose_context");
                        e && e.loseContext()
                    }, this.forceContextRestore = function() {
                        const e = ae.get("WEBGL_lose_context");
                        e && e.restoreContext()
                    }, this.getPixelRatio = function() {
                        return j
                    }, this.setPixelRatio = function(e) {
                        void 0 !== e && (j = e, this.setSize(G, V, !1))
                    }, this.getSize = function(e) {
                        return e.set(G, V)
                    }, this.setSize = function(e, t, i = !0) {
                        Ne.isPresenting || (G = e, V = t, n.width = Math.floor(e * j), n.height = Math.floor(t * j), !0 === i && (n.style.width = e + "px", n.style.height = t + "px"), this.setViewport(0, 0, e, t))
                    }, this.getDrawingBufferSize = function(e) {
                        return e.set(G * j, V * j).floor()
                    }, this.setDrawingBufferSize = function(e, t, i) {
                        G = e, V = t, j = i, n.width = Math.floor(e * i), n.height = Math.floor(t * i), this.setViewport(0, 0, e, t)
                    }, this.getCurrentViewport = function(e) {
                        return e.copy(F)
                    }, this.getViewport = function(e) {
                        return e.copy(Y)
                    }, this.setViewport = function(e, t, n, i) {
                        e.isVector4 ? Y.set(e.x, e.y, e.z, e.w) : Y.set(e, t, n, i), ce.viewport(F.copy(Y).multiplyScalar(j).round())
                    }, this.getScissor = function(e) {
                        return e.copy(q)
                    }, this.setScissor = function(e, t, n, i) {
                        e.isVector4 ? q.set(e.x, e.y, e.z, e.w) : q.set(e, t, n, i), ce.scissor(k.copy(q).multiplyScalar(j).round())
                    }, this.getScissorTest = function() {
                        return K
                    }, this.setScissorTest = function(e) {
                        ce.setScissorTest(K = e)
                    }, this.setOpaqueSort = function(e) {
                        W = e
                    }, this.setTransparentSort = function(e) {
                        X = e
                    }, this.getClearColor = function(e) {
                        return e.copy(Se.getClearColor())
                    }, this.setClearColor = function() {
                        Se.setClearColor.apply(Se, arguments)
                    }, this.getClearAlpha = function() {
                        return Se.getClearAlpha()
                    }, this.setClearAlpha = function() {
                        Se.setClearAlpha.apply(Se, arguments)
                    }, this.clear = function(e = !0, t = !0, n = !0) {
                        let i = 0;
                        if (e) {
                            let e = !1;
                            if (null !== D) {
                                const t = D.texture.format;
                                e = t === O || t === N || t === L
                            }
                            if (e) {
                                const e = D.texture.type,
                                    t = e === A || e === E || e === _ || e === T || e === C || e === S,
                                    n = Se.getClearColor(),
                                    i = Se.getClearAlpha(),
                                    r = n.r,
                                    s = n.g,
                                    o = n.b;
                                t ? (p[0] = r, p[1] = s, p[2] = o, p[3] = i, Pe.clearBufferuiv(Pe.COLOR, 0, p)) : (g[0] = r, g[1] = s, g[2] = o, g[3] = i, Pe.clearBufferiv(Pe.COLOR, 0, g))
                            } else i |= Pe.COLOR_BUFFER_BIT
                        }
                        t && (i |= Pe.DEPTH_BUFFER_BIT), n && (i |= Pe.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Pe.clear(i)
                    }, this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }, this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }, this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }, this.dispose = function() {
                        n.removeEventListener("webglcontextlost", Oe, !1), n.removeEventListener("webglcontextrestored", Fe, !1), n.removeEventListener("webglcontextcreationerror", ke, !1), Ee.dispose(), be.dispose(), he.dispose(), fe.dispose(), pe.dispose(), Ae.dispose(), Re.dispose(), De.dispose(), ve.dispose(), Ne.dispose(), Ne.removeEventListener("sessionstart", Ge), Ne.removeEventListener("sessionend", Ve), je.stop()
                    }, this.renderBufferDirect = function(e, t, n, i, r, s) {
                        null === t && (t = re);
                        const o = r.isMesh && r.matrixWorld.determinant() < 0,
                            a = function(e, t, n, i, r) {
                                !0 !== t.isScene && (t = re), de.resetTextureUnits();
                                const s = t.fog,
                                    o = i.isMeshStandardMaterial ? t.environment : null,
                                    a = null === D ? M.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : xe,
                                    l = (i.isMeshStandardMaterial ? pe : fe).get(i.envMap || o),
                                    c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                    u = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                                    h = !!n.morphAttributes.position,
                                    d = !!n.morphAttributes.normal,
                                    f = !!n.morphAttributes.color;
                                let p = 0;
                                i.toneMapped && (null !== D && !0 !== D.isXRRenderTarget || (p = M.toneMapping));
                                const m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                    g = void 0 !== m ? m.length : 0,
                                    A = he.get(i),
                                    v = y.state.lights;
                                if (!0 === Z && (!0 === $ || e !== U)) {
                                    const t = e === U && i.id === P;
                                    we.setState(i, e, t)
                                }
                                let _ = !1;
                                i.version === A.__version ? A.needsLights && A.lightsStateVersion !== v.state.version || A.outputColorSpace !== a || r.isBatchedMesh && !1 === A.batching ? _ = !0 : r.isBatchedMesh || !0 !== A.batching ? r.isBatchedMesh && !0 === A.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === A.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === A.instancing ? _ = !0 : r.isInstancedMesh || !0 !== A.instancing ? r.isSkinnedMesh && !1 === A.skinning ? _ = !0 : r.isSkinnedMesh || !0 !== A.skinning ? r.isInstancedMesh && !0 === A.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === A.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === A.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === A.instancingMorph && null !== r.morphTexture || A.envMap !== l || !0 === i.fog && A.fog !== s ? _ = !0 : void 0 === A.numClippingPlanes || A.numClippingPlanes === we.numPlanes && A.numIntersection === we.numIntersection ? (A.vertexAlphas !== c || A.vertexTangents !== u || A.morphTargets !== h || A.morphNormals !== d || A.morphColors !== f || A.toneMapping !== p || A.morphTargetsCount !== g) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : _ = !0 : (_ = !0, A.__version = i.version);
                                let x = A.currentProgram;
                                !0 === _ && (x = et(i, t, r));
                                let E = !1,
                                    b = !1,
                                    w = !1;
                                const C = x.getUniforms(),
                                    S = A.uniforms;
                                if (ce.useProgram(x.program) && (E = !0, b = !0, w = !0), i.id !== P && (P = i.id, b = !0), E || U !== e) {
                                    ce.buffers.depth.getReversed() ? (ee.copy(e.projectionMatrix), function(e) {
                                        const t = e.elements;
                                        t[2] = .5 * t[2] + .5 * t[3], t[6] = .5 * t[6] + .5 * t[7], t[10] = .5 * t[10] + .5 * t[11], t[14] = .5 * t[14] + .5 * t[15]
                                    }(ee), function(e) {
                                        const t = e.elements; - 1 === t[11] ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = 1 - t[14])
                                    }(ee), C.setValue(Pe, "projectionMatrix", ee)) : C.setValue(Pe, "projectionMatrix", e.projectionMatrix), C.setValue(Pe, "viewMatrix", e.matrixWorldInverse);
                                    const t = C.map.cameraPosition;
                                    void 0 !== t && t.setValue(Pe, ne.setFromMatrixPosition(e.matrixWorld)), le.logarithmicDepthBuffer && C.setValue(Pe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && C.setValue(Pe, "isOrthographic", !0 === e.isOrthographicCamera), U !== e && (U = e, b = !0, w = !0)
                                }
                                if (r.isSkinnedMesh) {
                                    C.setOptional(Pe, r, "bindMatrix"), C.setOptional(Pe, r, "bindMatrixInverse");
                                    const e = r.skeleton;
                                    e && (null === e.boneTexture && e.computeBoneTexture(), C.setValue(Pe, "boneTexture", e.boneTexture, de))
                                }
                                r.isBatchedMesh && (C.setOptional(Pe, r, "batchingTexture"), C.setValue(Pe, "batchingTexture", r._matricesTexture, de), C.setOptional(Pe, r, "batchingIdTexture"), C.setValue(Pe, "batchingIdTexture", r._indirectTexture, de), C.setOptional(Pe, r, "batchingColorTexture"), null !== r._colorsTexture && C.setValue(Pe, "batchingColorTexture", r._colorsTexture, de));
                                const T = n.morphAttributes;
                                var I, B;
                                if (void 0 === T.position && void 0 === T.normal && void 0 === T.color || Te.update(r, n, x), (b || A.receiveShadow !== r.receiveShadow) && (A.receiveShadow = r.receiveShadow, C.setValue(Pe, "receiveShadow", r.receiveShadow)), i.isMeshGouraudMaterial && null !== i.envMap && (S.envMap.value = l, S.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), i.isMeshStandardMaterial && null === i.envMap && null !== t.environment && (S.envMapIntensity.value = t.environmentIntensity), b && (C.setValue(Pe, "toneMappingExposure", M.toneMappingExposure), A.needsLights && (B = w, (I = S).ambientLightColor.needsUpdate = B, I.lightProbe.needsUpdate = B, I.directionalLights.needsUpdate = B, I.directionalLightShadows.needsUpdate = B, I.pointLights.needsUpdate = B, I.pointLightShadows.needsUpdate = B, I.spotLights.needsUpdate = B, I.spotLightShadows.needsUpdate = B, I.rectAreaLights.needsUpdate = B, I.hemisphereLights.needsUpdate = B), s && !0 === i.fog && ye.refreshFogUniforms(S, s), ye.refreshMaterialUniforms(S, i, j, V, y.state.transmissionRenderTarget[e.id]), Bs.upload(Pe, tt(A), S, de)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Bs.upload(Pe, tt(A), S, de), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && C.setValue(Pe, "center", r.center), C.setValue(Pe, "modelViewMatrix", r.modelViewMatrix), C.setValue(Pe, "normalMatrix", r.normalMatrix), C.setValue(Pe, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                                    const e = i.uniformsGroups;
                                    for (let t = 0, n = e.length; t < n; t++) {
                                        const n = e[t];
                                        De.update(n, x), De.bind(n, x)
                                    }
                                }
                                return x
                            }(e, t, n, i, r);
                        ce.setMaterial(i, o);
                        let l = n.index,
                            c = 1;
                        if (!0 === i.wireframe) {
                            if (l = ge.getWireframeAttribute(n), void 0 === l) return;
                            c = 2
                        }
                        const u = n.drawRange,
                            h = n.attributes.position;
                        let d = u.start * c,
                            f = (u.start + u.count) * c;
                        null !== s && (d = Math.max(d, s.start * c), f = Math.min(f, (s.start + s.count) * c)), null !== l ? (d = Math.max(d, 0), f = Math.min(f, l.count)) : null != h && (d = Math.max(d, 0), f = Math.min(f, h.count));
                        const p = f - d;
                        if (p < 0 || p === 1 / 0) return;
                        let m;
                        Re.setup(r, i, a, n, l);
                        let g = Me;
                        if (null !== l && (m = me.get(l), g = Ie, g.setIndex(m)), r.isMesh) !0 === i.wireframe ? (ce.setLineWidth(i.wireframeLinewidth * oe()), g.setMode(Pe.LINES)) : g.setMode(Pe.TRIANGLES);
                        else if (r.isLine) {
                            let e = i.linewidth;
                            void 0 === e && (e = 1), ce.setLineWidth(e * oe()), r.isLineSegments ? g.setMode(Pe.LINES) : r.isLineLoop ? g.setMode(Pe.LINE_LOOP) : g.setMode(Pe.LINE_STRIP)
                        } else r.isPoints ? g.setMode(Pe.POINTS) : r.isSprite && g.setMode(Pe.TRIANGLES);
                        if (r.isBatchedMesh)
                            if (null !== r._multiDrawInstances) g.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                            else if (ae.get("WEBGL_multi_draw")) g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                        else {
                            const e = r._multiDrawStarts,
                                t = r._multiDrawCounts,
                                n = r._multiDrawCount,
                                s = l ? me.get(l).bytesPerElement : 1,
                                o = he.get(i).currentProgram.getUniforms();
                            for (let i = 0; i < n; i++) o.setValue(Pe, "_gl_DrawID", i), g.render(e[i] / s, t[i])
                        } else if (r.isInstancedMesh) g.renderInstances(d, p, r.count);
                        else if (n.isInstancedBufferGeometry) {
                            const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                                t = Math.min(n.instanceCount, e);
                            g.renderInstances(d, p, t)
                        } else g.render(d, p)
                    }, this.compile = function(e, t, n = null) {
                        null === n && (n = e), y = be.get(n), y.init(t), b.push(y), n.traverseVisible((function(e) {
                            e.isLight && e.layers.test(t.layers) && (y.pushLight(e), e.castShadow && y.pushShadow(e))
                        })), e !== n && e.traverseVisible((function(e) {
                            e.isLight && e.layers.test(t.layers) && (y.pushLight(e), e.castShadow && y.pushShadow(e))
                        })), y.setupLights();
                        const i = new Set;
                        return e.traverse((function(e) {
                            if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite)) return;
                            const t = e.material;
                            if (t)
                                if (Array.isArray(t))
                                    for (let r = 0; r < t.length; r++) {
                                        const s = t[r];
                                        ze(s, n, e), i.add(s)
                                    } else ze(t, n, e), i.add(t)
                        })), b.pop(), y = null, i
                    }, this.compileAsync = function(e, t, n = null) {
                        const i = this.compile(e, t, n);
                        return new Promise((t => {
                            function n() {
                                i.forEach((function(e) {
                                    he.get(e).currentProgram.isReady() && i.delete(e)
                                })), 0 !== i.size ? setTimeout(n, 10) : t(e)
                            }
                            null !== ae.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                        }))
                    };
                    let He = null;

                    function Ge() {
                        je.stop()
                    }

                    function Ve() {
                        je.start()
                    }
                    const je = new zi;

                    function Xe(e, t, n, i) {
                        if (!1 === e.visible) return;
                        if (e.layers.test(t.layers))
                            if (e.isGroup) n = e.renderOrder;
                            else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                        else if (e.isLight) y.pushLight(e), e.castShadow && y.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || J.intersectsSprite(e)) {
                                i && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(te);
                                const t = Ae.update(e),
                                    r = e.material;
                                r.visible && v.push(e, t, r, n, ie.z, null)
                            }
                        } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || J.intersectsObject(e))) {
                            const t = Ae.update(e),
                                r = e.material;
                            if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), ie.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), ie.copy(t.boundingSphere.center)), ie.applyMatrix4(e.matrixWorld).applyMatrix4(te)), Array.isArray(r)) {
                                const i = t.groups;
                                for (let s = 0, o = i.length; s < o; s++) {
                                    const o = i[s],
                                        a = r[o.materialIndex];
                                    a && a.visible && v.push(e, t, a, n, ie.z, o)
                                }
                            } else r.visible && v.push(e, t, r, n, ie.z, null)
                        }
                        const r = e.children;
                        for (let e = 0, s = r.length; e < s; e++) Xe(r[e], t, n, i)
                    }

                    function Ke(e, t, n, i) {
                        const r = e.opaque,
                            s = e.transmissive,
                            o = e.transparent;
                        y.setupLightsView(n), !0 === Z && we.setGlobalState(M.clippingPlanes, n), i && ce.viewport(F.copy(i)), r.length > 0 && Ze(r, t, n), s.length > 0 && Ze(s, t, n), o.length > 0 && Ze(o, t, n), ce.buffers.depth.setTest(!0), ce.buffers.depth.setMask(!0), ce.buffers.color.setMask(!0), ce.setPolygonOffset(!1)
                    }

                    function Je(e, t, n, i) {
                        if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
                        void 0 === y.state.transmissionRenderTarget[i.id] && (y.state.transmissionRenderTarget[i.id] = new dt(1, 1, {
                            generateMipmaps: !0,
                            type: ae.has("EXT_color_buffer_half_float") || ae.has("EXT_color_buffer_float") ? w : A,
                            minFilter: m,
                            samples: 4,
                            stencilBuffer: s,
                            resolveDepthBuffer: !1,
                            resolveStencilBuffer: !1,
                            colorSpace: qe.workingColorSpace
                        }));
                        const r = y.state.transmissionRenderTarget[i.id],
                            o = i.viewport || F;
                        r.setSize(o.z, o.w);
                        const a = M.getRenderTarget();
                        M.setRenderTarget(r), M.getClearColor(z), H = M.getClearAlpha(), H < 1 && M.setClearColor(16777215, .5), M.clear(), se && Se.render(n);
                        const l = M.toneMapping;
                        M.toneMapping = 0;
                        const c = i.viewport;
                        if (void 0 !== i.viewport && (i.viewport = void 0), y.setupLightsView(i), !0 === Z && we.setGlobalState(M.clippingPlanes, i), Ze(e, n, i), de.updateMultisampleRenderTarget(r), de.updateRenderTargetMipmap(r), !1 === ae.has("WEBGL_multisampled_render_to_texture")) {
                            let e = !1;
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r],
                                    o = s.object,
                                    a = s.geometry,
                                    l = s.material,
                                    c = s.group;
                                if (2 === l.side && o.layers.test(i.layers)) {
                                    const t = l.side;
                                    l.side = 1, l.needsUpdate = !0, $e(o, n, i, a, l, c), l.side = t, l.needsUpdate = !0, e = !0
                                }
                            }!0 === e && (de.updateMultisampleRenderTarget(r), de.updateRenderTargetMipmap(r))
                        }
                        M.setRenderTarget(a), M.setClearColor(z, H), void 0 !== c && (i.viewport = c), M.toneMapping = l
                    }

                    function Ze(e, t, n) {
                        const i = !0 === t.isScene ? t.overrideMaterial : null;
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r],
                                o = s.object,
                                a = s.geometry,
                                l = null === i ? s.material : i,
                                c = s.group;
                            o.layers.test(n.layers) && $e(o, t, n, a, l, c)
                        }
                    }

                    function $e(e, t, n, i, r, s) {
                        e.onBeforeRender(M, t, n, i, r, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(M, t, n, i, e, s), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1, r.needsUpdate = !0, M.renderBufferDirect(n, t, i, r, e, s), r.side = 0, r.needsUpdate = !0, M.renderBufferDirect(n, t, i, r, e, s), r.side = 2) : M.renderBufferDirect(n, t, i, r, e, s), e.onAfterRender(M, t, n, i, r, s)
                    }

                    function et(e, t, n) {
                        !0 !== t.isScene && (t = re);
                        const i = he.get(e),
                            r = y.state.lights,
                            s = y.state.shadowsArray,
                            o = r.state.version,
                            a = ve.getParameters(e, r.state, s, t, n),
                            l = ve.getProgramCacheKey(a);
                        let c = i.programs;
                        i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? pe : fe).get(e.envMap || i.environment), i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === c && (e.addEventListener("dispose", Qe), c = new Map, i.programs = c);
                        let u = c.get(l);
                        if (void 0 !== u) {
                            if (i.currentProgram === u && i.lightsStateVersion === o) return nt(e, a), u
                        } else a.uniforms = ve.getUniforms(e), e.onBeforeCompile(a, M), u = ve.acquireProgram(a, l), c.set(l, u), i.uniforms = a.uniforms;
                        const h = i.uniforms;
                        return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = we.uniform), nt(e, a), i.needsLights = function(e) {
                            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                        }(e), i.lightsStateVersion = o, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotLightMatrix.value = r.state.spotLightMatrix, h.spotLightMap.value = r.state.spotLightMap, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix), i.currentProgram = u, i.uniformsList = null, u
                    }

                    function tt(e) {
                        if (null === e.uniformsList) {
                            const t = e.currentProgram.getUniforms();
                            e.uniformsList = Bs.seqWithValue(t.seq, e.uniforms)
                        }
                        return e.uniformsList
                    }

                    function nt(e, t) {
                        const n = he.get(e);
                        n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.batchingColor = t.batchingColor, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.instancingMorph = t.instancingMorph, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
                    }
                    je.setAnimationLoop((function(e) {
                        He && He(e)
                    })), "undefined" != typeof self && je.setContext(self), this.setAnimationLoop = function(e) {
                        He = e, Ne.setAnimationLoop(e), null === e ? je.stop() : je.start()
                    }, Ne.addEventListener("sessionstart", Ge), Ne.addEventListener("sessionend", Ve), this.render = function(e, t) {
                        if (void 0 !== t && !0 !== t.isCamera) return;
                        if (!0 === I) return;
                        if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === Ne.enabled && !0 === Ne.isPresenting && (!0 === Ne.cameraAutoUpdate && Ne.updateCamera(t), t = Ne.getCamera()), !0 === e.isScene && e.onBeforeRender(M, e, t, D), y = be.get(e, b.length), y.init(t), b.push(y), te.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), J.setFromProjectionMatrix(te), $ = this.localClippingEnabled, Z = we.init(this.clippingPlanes, $), v = Ee.get(e, x.length), v.init(), x.push(v), !0 === Ne.enabled && !0 === Ne.isPresenting) {
                            const e = M.xr.getDepthSensingMesh();
                            null !== e && Xe(e, t, -1 / 0, M.sortObjects)
                        }
                        Xe(e, t, 0, M.sortObjects), v.finish(), !0 === M.sortObjects && v.sort(W, X), se = !1 === Ne.enabled || !1 === Ne.isPresenting || !1 === Ne.hasDepthSensing(), se && Se.addToRenderList(v, e), this.info.render.frame++, !0 === Z && we.beginShadows();
                        const n = y.state.shadowsArray;
                        Ce.render(n, e, t), !0 === Z && we.endShadows(), !0 === this.info.autoReset && this.info.reset();
                        const i = v.opaque,
                            r = v.transmissive;
                        if (y.setupLights(), t.isArrayCamera) {
                            const n = t.cameras;
                            if (r.length > 0)
                                for (let t = 0, s = n.length; t < s; t++) Je(i, r, e, n[t]);
                            se && Se.render(e);
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                Ke(v, e, i, i.viewport)
                            }
                        } else r.length > 0 && Je(i, r, e, t), se && Se.render(e), Ke(v, e, t);
                        null !== D && (de.updateMultisampleRenderTarget(D), de.updateRenderTargetMipmap(D)), !0 === e.isScene && e.onAfterRender(M, e, t), Re.resetDefaultState(), P = -1, U = null, b.pop(), b.length > 0 ? (y = b[b.length - 1], !0 === Z && we.setGlobalState(M.clippingPlanes, y.state.camera)) : y = null, x.pop(), v = x.length > 0 ? x[x.length - 1] : null
                    }, this.getActiveCubeFace = function() {
                        return B
                    }, this.getActiveMipmapLevel = function() {
                        return R
                    }, this.getRenderTarget = function() {
                        return D
                    }, this.setRenderTargetTextures = function(e, t, n) {
                        he.get(e.texture).__webglTexture = t, he.get(e.depthTexture).__webglTexture = n;
                        const i = he.get(e);
                        i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === ae.has("WEBGL_multisampled_render_to_texture") && (i.__useRenderToTexture = !1)
                    }, this.setRenderTargetFramebuffer = function(e, t) {
                        const n = he.get(e);
                        n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                    }, this.setRenderTarget = function(e, t = 0, n = 0) {
                        D = e, B = t, R = n;
                        let i = !0,
                            r = null,
                            s = !1,
                            o = !1;
                        if (e) {
                            const a = he.get(e);
                            if (void 0 !== a.__useDefaultFramebuffer) ce.bindFramebuffer(Pe.FRAMEBUFFER, null), i = !1;
                            else if (void 0 === a.__webglFramebuffer) de.setupRenderTarget(e);
                            else if (a.__hasExternalTextures) de.rebindTextures(e, he.get(e.texture).__webglTexture, he.get(e.depthTexture).__webglTexture);
                            else if (e.depthBuffer) {
                                const t = e.depthTexture;
                                if (a.__boundDepthTexture !== t) {
                                    if (null !== t && he.has(t) && (e.width !== t.image.width || e.height !== t.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                    de.setupDepthRenderbuffer(e)
                                }
                            }
                            const l = e.texture;
                            (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (o = !0);
                            const c = he.get(e).__webglFramebuffer;
                            e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t], s = !0) : r = e.samples > 0 && !1 === de.useMultisampledRTT(e) ? he.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, F.copy(e.viewport), k.copy(e.scissor), Q = e.scissorTest
                        } else F.copy(Y).multiplyScalar(j).floor(), k.copy(q).multiplyScalar(j).floor(), Q = K;
                        if (ce.bindFramebuffer(Pe.FRAMEBUFFER, r) && i && ce.drawBuffers(e, r), ce.viewport(F), ce.scissor(k), ce.setScissorTest(Q), s) {
                            const i = he.get(e.texture);
                            Pe.framebufferTexture2D(Pe.FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, Pe.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                        } else if (o) {
                            const i = he.get(e.texture),
                                r = t || 0;
                            Pe.framebufferTextureLayer(Pe.FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                        }
                        P = -1
                    }, this.readRenderTargetPixels = function(e, t, n, i, r, s, o) {
                        if (!e || !e.isWebGLRenderTarget) return;
                        let a = he.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                            ce.bindFramebuffer(Pe.FRAMEBUFFER, a);
                            try {
                                const o = e.texture,
                                    a = o.format,
                                    l = o.type;
                                if (!le.textureFormatReadable(a)) return;
                                if (!le.textureTypeReadable(l)) return;
                                t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && Pe.readPixels(t, n, i, r, Be.convert(a), Be.convert(l), s)
                            } finally {
                                const e = null !== D ? he.get(D).__webglFramebuffer : null;
                                ce.bindFramebuffer(Pe.FRAMEBUFFER, e)
                            }
                        }
                    }, this.readRenderTargetPixelsAsync = async function(e, t, n, i, r, s, o) {
                        if (!e || !e.isWebGLRenderTarget) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let a = he.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                            const o = e.texture,
                                l = o.format,
                                c = o.type;
                            if (!le.textureFormatReadable(l)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                            if (!le.textureTypeReadable(c)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                            if (t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r) {
                                ce.bindFramebuffer(Pe.FRAMEBUFFER, a);
                                const e = Pe.createBuffer();
                                Pe.bindBuffer(Pe.PIXEL_PACK_BUFFER, e), Pe.bufferData(Pe.PIXEL_PACK_BUFFER, s.byteLength, Pe.STREAM_READ), Pe.readPixels(t, n, i, r, Be.convert(l), Be.convert(c), 0);
                                const o = null !== D ? he.get(D).__webglFramebuffer : null;
                                ce.bindFramebuffer(Pe.FRAMEBUFFER, o);
                                const u = Pe.fenceSync(Pe.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                return Pe.flush(), await

                                function(e, t, n) {
                                    return new Promise((function(n, i) {
                                        setTimeout((function r() {
                                            switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                                case e.WAIT_FAILED:
                                                    i();
                                                    break;
                                                case e.TIMEOUT_EXPIRED:
                                                    setTimeout(r, 4);
                                                    break;
                                                default:
                                                    n()
                                            }
                                        }), 4)
                                    }))
                                }(Pe, u), Pe.bindBuffer(Pe.PIXEL_PACK_BUFFER, e), Pe.getBufferSubData(Pe.PIXEL_PACK_BUFFER, 0, s), Pe.deleteBuffer(e), Pe.deleteSync(u), s
                            }
                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                        }
                    }, this.copyFramebufferToTexture = function(e, t = null, n = 0) {
                        !0 !== e.isTexture && (Ye("WebGLRenderer: copyFramebufferToTexture function signature has changed."), t = arguments[0] || null, e = arguments[1]);
                        const i = Math.pow(2, -n),
                            r = Math.floor(e.image.width * i),
                            s = Math.floor(e.image.height * i),
                            o = null !== t ? t.x : 0,
                            a = null !== t ? t.y : 0;
                        de.setTexture2D(e, 0), Pe.copyTexSubImage2D(Pe.TEXTURE_2D, n, 0, 0, o, a, r, s), ce.unbindTexture()
                    }, this.copyTextureToTexture = function(e, t, n = null, i = null, r = 0) {
                        let s, o, a, l, c, u, h, d, f;
                        !0 !== e.isTexture && (Ye("WebGLRenderer: copyTextureToTexture function signature has changed."), i = arguments[0] || null, e = arguments[1], t = arguments[2], r = arguments[3] || 0, n = null);
                        const p = e.isCompressedTexture ? e.mipmaps[r] : e.image;
                        null !== n ? (s = n.max.x - n.min.x, o = n.max.y - n.min.y, a = n.isBox3 ? n.max.z - n.min.z : 1, l = n.min.x, c = n.min.y, u = n.isBox3 ? n.min.z : 0) : (s = p.width, o = p.height, a = p.depth || 1, l = 0, c = 0, u = 0), null !== i ? (h = i.x, d = i.y, f = i.z) : (h = 0, d = 0, f = 0);
                        const m = Be.convert(t.format),
                            g = Be.convert(t.type);
                        let A;
                        t.isData3DTexture ? (de.setTexture3D(t, 0), A = Pe.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (de.setTexture2DArray(t, 0), A = Pe.TEXTURE_2D_ARRAY) : (de.setTexture2D(t, 0), A = Pe.TEXTURE_2D), Pe.pixelStorei(Pe.UNPACK_FLIP_Y_WEBGL, t.flipY), Pe.pixelStorei(Pe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), Pe.pixelStorei(Pe.UNPACK_ALIGNMENT, t.unpackAlignment);
                        const v = Pe.getParameter(Pe.UNPACK_ROW_LENGTH),
                            y = Pe.getParameter(Pe.UNPACK_IMAGE_HEIGHT),
                            _ = Pe.getParameter(Pe.UNPACK_SKIP_PIXELS),
                            x = Pe.getParameter(Pe.UNPACK_SKIP_ROWS),
                            E = Pe.getParameter(Pe.UNPACK_SKIP_IMAGES);
                        Pe.pixelStorei(Pe.UNPACK_ROW_LENGTH, p.width), Pe.pixelStorei(Pe.UNPACK_IMAGE_HEIGHT, p.height), Pe.pixelStorei(Pe.UNPACK_SKIP_PIXELS, l), Pe.pixelStorei(Pe.UNPACK_SKIP_ROWS, c), Pe.pixelStorei(Pe.UNPACK_SKIP_IMAGES, u);
                        const b = e.isDataArrayTexture || e.isData3DTexture,
                            w = t.isDataArrayTexture || t.isData3DTexture;
                        if (e.isRenderTargetTexture || e.isDepthTexture) {
                            const n = he.get(e),
                                i = he.get(t),
                                p = he.get(n.__renderTarget),
                                m = he.get(i.__renderTarget);
                            ce.bindFramebuffer(Pe.READ_FRAMEBUFFER, p.__webglFramebuffer), ce.bindFramebuffer(Pe.DRAW_FRAMEBUFFER, m.__webglFramebuffer);
                            for (let n = 0; n < a; n++) b && Pe.framebufferTextureLayer(Pe.READ_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, he.get(e).__webglTexture, r, u + n), e.isDepthTexture ? (w && Pe.framebufferTextureLayer(Pe.DRAW_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, he.get(t).__webglTexture, r, f + n), Pe.blitFramebuffer(l, c, s, o, h, d, s, o, Pe.DEPTH_BUFFER_BIT, Pe.NEAREST)) : w ? Pe.copyTexSubImage3D(A, r, h, d, f + n, l, c, s, o) : Pe.copyTexSubImage2D(A, r, h, d, f + n, l, c, s, o);
                            ce.bindFramebuffer(Pe.READ_FRAMEBUFFER, null), ce.bindFramebuffer(Pe.DRAW_FRAMEBUFFER, null)
                        } else w ? e.isDataTexture || e.isData3DTexture ? Pe.texSubImage3D(A, r, h, d, f, s, o, a, m, g, p.data) : t.isCompressedArrayTexture ? Pe.compressedTexSubImage3D(A, r, h, d, f, s, o, a, m, p.data) : Pe.texSubImage3D(A, r, h, d, f, s, o, a, m, g, p) : e.isDataTexture ? Pe.texSubImage2D(Pe.TEXTURE_2D, r, h, d, s, o, m, g, p.data) : e.isCompressedTexture ? Pe.compressedTexSubImage2D(Pe.TEXTURE_2D, r, h, d, p.width, p.height, m, p.data) : Pe.texSubImage2D(Pe.TEXTURE_2D, r, h, d, s, o, m, g, p);
                        Pe.pixelStorei(Pe.UNPACK_ROW_LENGTH, v), Pe.pixelStorei(Pe.UNPACK_IMAGE_HEIGHT, y), Pe.pixelStorei(Pe.UNPACK_SKIP_PIXELS, _), Pe.pixelStorei(Pe.UNPACK_SKIP_ROWS, x), Pe.pixelStorei(Pe.UNPACK_SKIP_IMAGES, E), 0 === r && t.generateMipmaps && Pe.generateMipmap(A), ce.unbindTexture()
                    }, this.copyTextureToTexture3D = function(e, t, n = null, i = null, r = 0) {
                        return !0 !== e.isTexture && (Ye("WebGLRenderer: copyTextureToTexture3D function signature has changed."), n = arguments[0] || null, i = arguments[1] || null, e = arguments[2], t = arguments[3], r = arguments[4] || 0), Ye('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(e, t, n, i, r)
                    }, this.initRenderTarget = function(e) {
                        void 0 === he.get(e).__webglFramebuffer && de.setupRenderTarget(e)
                    }, this.initTexture = function(e) {
                        e.isCubeTexture ? de.setTextureCube(e, 0) : e.isData3DTexture ? de.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? de.setTexture2DArray(e, 0) : de.setTexture2D(e, 0), ce.unbindTexture()
                    }, this.resetState = function() {
                        B = 0, R = 0, D = null, ce.reset(), Re.reset()
                    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                get coordinateSystem() {
                    return Te
                }
                get outputColorSpace() {
                    return this._outputColorSpace
                }
                set outputColorSpace(e) {
                    this._outputColorSpace = e;
                    const t = this.getContext();
                    t.drawingBufferColorspace = qe._getDrawingBufferColorSpace(e), t.unpackColorSpace = qe._getUnpackColorSpace()
                }
            }
            class Ro extends _n {
                constructor() {
                    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new nn, this.environmentIntensity = 1, this.environmentRotation = new nn, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
                }
            }
            class Do {
                constructor(e, t) {
                    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = Ce, this.updateRanges = [], this.version = 0, this.uuid = Le()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                        n = new this.constructor(t, this.stride);
                    return n.setUsage(this.usage), n
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            const Po = new gt;
            class Lo {
                constructor(e, t, n, i = !1) {
                    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.data.count; t < n; t++) Po.fromBufferAttribute(this, t), Po.applyMatrix4(e), this.setXYZ(t, Po.x, Po.y, Po.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) Po.fromBufferAttribute(this, t), Po.applyNormalMatrix(e), this.setXYZ(t, Po.x, Po.y, Po.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) Po.fromBufferAttribute(this, t), Po.transformDirection(e), this.setXYZ(t, Po.x, Po.y, Po.z);
                    return this
                }
                getComponent(e, t) {
                    let n = this.array[e * this.data.stride + this.offset + t];
                    return this.normalized && (n = Fe(n, this.array)), n
                }
                setComponent(e, t, n) {
                    return this.normalized && (n = ke(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
                }
                setX(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
                }
                setY(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
                }
                setZ(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
                }
                setW(e, t) {
                    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
                }
                getX(e) {
                    let t = this.data.array[e * this.data.stride + this.offset];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                getY(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 1];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                getZ(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 2];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                getW(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 3];
                    return this.normalized && (t = Fe(t, this.array)), t
                }
                setXY(e, t, n) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = ke(t, this.array), n = ke(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                }
                setXYZ(e, t, n, i) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), i = ke(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
                }
                setXYZW(e, t, n, i, r) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), i = ke(i, this.array), r = ke(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
                }
                clone(e) {
                    if (void 0 === e) {
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return new Yn(new this.array.constructor(e), this.itemSize, this.normalized)
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Lo(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                }
                toJSON(e) {
                    if (void 0 === e) {
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: e,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }
            const Uo = new gt,
                No = new ut,
                Oo = new ut,
                Fo = new gt,
                ko = new Wt,
                Qo = new gt,
                zo = new Ot,
                Ho = new Wt,
                Go = new jt;
            class Vo extends Ai {
                constructor(e, t) {
                    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = i, this.bindMatrix = new Wt, this.bindMatrixInverse = new Wt, this.boundingBox = null, this.boundingSphere = null
                }
                computeBoundingBox() {
                    const e = this.geometry;
                    null === this.boundingBox && (this.boundingBox = new yt), this.boundingBox.makeEmpty();
                    const t = e.getAttribute("position");
                    for (let e = 0; e < t.count; e++) this.getVertexPosition(e, Qo), this.boundingBox.expandByPoint(Qo)
                }
                computeBoundingSphere() {
                    const e = this.geometry;
                    null === this.boundingSphere && (this.boundingSphere = new Ot), this.boundingSphere.makeEmpty();
                    const t = e.getAttribute("position");
                    for (let e = 0; e < t.count; e++) this.getVertexPosition(e, Qo), this.boundingSphere.expandByPoint(Qo)
                }
                copy(e, t) {
                    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                }
                raycast(e, t) {
                    const n = this.material,
                        i = this.matrixWorld;
                    void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), zo.copy(this.boundingSphere), zo.applyMatrix4(i), !1 !== e.ray.intersectsSphere(zo) && (Ho.copy(i).invert(), Go.copy(e.ray).applyMatrix4(Ho), null !== this.boundingBox && !1 === Go.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Go)))
                }
                getVertexPosition(e, t) {
                    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
                }
                bind(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    const e = new ut,
                        t = this.geometry.attributes.skinWeight;
                    for (let n = 0, i = t.count; n < i; n++) {
                        e.fromBufferAttribute(t, n);
                        const i = 1 / e.manhattanLength();
                        i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.bindMode === i ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
                }
                applyBoneTransform(e, t) {
                    const n = this.skeleton,
                        i = this.geometry;
                    No.fromBufferAttribute(i.attributes.skinIndex, e), Oo.fromBufferAttribute(i.attributes.skinWeight, e), Uo.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let e = 0; e < 4; e++) {
                        const i = Oo.getComponent(e);
                        if (0 !== i) {
                            const r = No.getComponent(e);
                            ko.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(Fo.copy(Uo).applyMatrix4(ko), i)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            class jo extends _n {
                constructor() {
                    super(), this.isBone = !0, this.type = "Bone"
                }
            }
            class Wo extends ct {
                constructor(e = null, t = 1, n = 1, i, r, s, o, a, l = 1003, c = 1003, u, h) {
                    super(null, s, o, a, l, c, i, r, u, h), this.isDataTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n
                    }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            const Xo = new Wt,
                Yo = new Wt;
            class qo {
                constructor(e = [], t = []) {
                    this.uuid = Le(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
                }
                init() {
                    const e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        this.boneInverses = [];
                        for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Wt)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = new Wt;
                        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                    }
                }
                update() {
                    const e = this.bones,
                        t = this.boneInverses,
                        n = this.boneMatrices,
                        i = this.boneTexture;
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i] ? e[i].matrixWorld : Yo;
                        Xo.multiplyMatrices(r, t[i]), Xo.toArray(n, 16 * i)
                    }
                    null !== i && (i.needsUpdate = !0)
                }
                clone() {
                    return new qo(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length);
                    e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
                    const t = new Float32Array(e * e * 4);
                    t.set(this.boneMatrices);
                    const n = new Wo(t, e, e, I, b);
                    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
                }
                getBoneByName(e) {
                    for (let t = 0, n = this.bones.length; t < n; t++) {
                        const n = this.bones[t];
                        if (n.name === e) return n
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let n = 0, i = e.bones.length; n < i; n++) {
                        let i = t[e.bones[n]];
                        void 0 === i && (i = new jo), this.bones.push(i), this.boneInverses.push((new Wt).fromArray(e.boneInverses[n]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.6,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    const t = this.bones,
                        n = this.boneInverses;
                    for (let i = 0, r = t.length; i < r; i++) {
                        const r = t[i];
                        e.bones.push(r.uuid);
                        const s = n[i];
                        e.boneInverses.push(s.toArray())
                    }
                    return e
                }
            }
            class Ko extends Yn {
                constructor(e, t, n, i = 1) {
                    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }
            const Jo = new Wt,
                Zo = new Wt,
                $o = [],
                ea = new yt,
                ta = new Wt,
                na = new Ai,
                ia = new Ot;
            class ra extends Ai {
                constructor(e, t, n) {
                    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Ko(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                    for (let e = 0; e < n; e++) this.setMatrixAt(e, ta)
                }
                computeBoundingBox() {
                    const e = this.geometry,
                        t = this.count;
                    null === this.boundingBox && (this.boundingBox = new yt), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, Jo), ea.copy(e.boundingBox).applyMatrix4(Jo), this.boundingBox.union(ea)
                }
                computeBoundingSphere() {
                    const e = this.geometry,
                        t = this.count;
                    null === this.boundingSphere && (this.boundingSphere = new Ot), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, Jo), ia.copy(e.boundingSphere).applyMatrix4(Jo), this.boundingSphere.union(ia)
                }
                copy(e, t) {
                    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                getMorphAt(e, t) {
                    const n = t.morphTargetInfluences,
                        i = this.morphTexture.source.data.data,
                        r = e * (n.length + 1) + 1;
                    for (let e = 0; e < n.length; e++) n[e] = i[r + e]
                }
                raycast(e, t) {
                    const n = this.matrixWorld,
                        i = this.count;
                    if (na.geometry = this.geometry, na.material = this.material, void 0 !== na.material && (null === this.boundingSphere && this.computeBoundingSphere(), ia.copy(this.boundingSphere), ia.applyMatrix4(n), !1 !== e.ray.intersectsSphere(ia)))
                        for (let r = 0; r < i; r++) {
                            this.getMatrixAt(r, Jo), Zo.multiplyMatrices(n, Jo), na.matrixWorld = Zo, na.raycast(e, $o);
                            for (let e = 0, n = $o.length; e < n; e++) {
                                const n = $o[e];
                                n.instanceId = r, n.object = this, t.push(n)
                            }
                            $o.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new Ko(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                setMorphAt(e, t) {
                    const n = t.morphTargetInfluences,
                        i = n.length + 1;
                    null === this.morphTexture && (this.morphTexture = new Wo(new Float32Array(i * this.count), i, this.count, P, b));
                    const r = this.morphTexture.source.data.data;
                    let s = 0;
                    for (let e = 0; e < n.length; e++) s += n[e];
                    const o = this.geometry.morphTargetsRelative ? 1 : 1 - s,
                        a = i * e;
                    r[a] = o, r.set(n, a + 1)
                }
                updateMorphTargets() {}
                dispose() {
                    return this.dispatchEvent({
                        type: "dispose"
                    }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null), this
                }
            }
            class sa extends Hn {
                static get type() {
                    return "LineBasicMaterial"
                }
                constructor(e) {
                    super(), this.isLineBasicMaterial = !0, this.color = new kn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
                }
            }
            const oa = new gt,
                aa = new gt,
                la = new Wt,
                ca = new jt,
                ua = new Ot,
                ha = new gt,
                da = new gt;
            class fa extends _n {
                constructor(e = new si, t = new sa) {
                    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (null === e.index) {
                        const t = e.attributes.position,
                            n = [0];
                        for (let e = 1, i = t.count; e < i; e++) oa.fromBufferAttribute(t, e - 1), aa.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += oa.distanceTo(aa);
                        e.setAttribute("lineDistance", new Jn(n, 1))
                    }
                    return this
                }
                raycast(e, t) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Line.threshold,
                        s = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), ua.copy(n.boundingSphere), ua.applyMatrix4(i), ua.radius += r, !1 === e.ray.intersectsSphere(ua)) return;
                    la.copy(i).invert(), ca.copy(e.ray).applyMatrix4(la);
                    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o,
                        l = this.isLineSegments ? 2 : 1,
                        c = n.index,
                        u = n.attributes.position;
                    if (null !== c) {
                        const n = Math.max(0, s.start),
                            i = Math.min(c.count, s.start + s.count);
                        for (let r = n, s = i - 1; r < s; r += l) {
                            const n = c.getX(r),
                                i = c.getX(r + 1),
                                s = pa(this, e, ca, a, n, i);
                            s && t.push(s)
                        }
                        if (this.isLineLoop) {
                            const r = c.getX(i - 1),
                                s = c.getX(n),
                                o = pa(this, e, ca, a, r, s);
                            o && t.push(o)
                        }
                    } else {
                        const n = Math.max(0, s.start),
                            i = Math.min(u.count, s.start + s.count);
                        for (let r = n, s = i - 1; r < s; r += l) {
                            const n = pa(this, e, ca, a, r, r + 1);
                            n && t.push(n)
                        }
                        if (this.isLineLoop) {
                            const r = pa(this, e, ca, a, i - 1, n);
                            r && t.push(r)
                        }
                    }
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }

            function pa(e, t, n, i, r, s) {
                const o = e.geometry.attributes.position;
                if (oa.fromBufferAttribute(o, r), aa.fromBufferAttribute(o, s), n.distanceSqToSegment(oa, aa, ha, da) > i) return;
                ha.applyMatrix4(e.matrixWorld);
                const a = t.ray.origin.distanceTo(ha);
                return a < t.near || a > t.far ? void 0 : {
                    distance: a,
                    point: da.clone().applyMatrix4(e.matrixWorld),
                    index: r,
                    face: null,
                    faceIndex: null,
                    barycoord: null,
                    object: e
                }
            }
            const ma = new gt,
                ga = new gt;
            class Aa extends fa {
                constructor(e, t) {
                    super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (null === e.index) {
                        const t = e.attributes.position,
                            n = [];
                        for (let e = 0, i = t.count; e < i; e += 2) ma.fromBufferAttribute(t, e), ga.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + ma.distanceTo(ga);
                        e.setAttribute("lineDistance", new Jn(n, 1))
                    }
                    return this
                }
            }
            class va extends fa {
                constructor(e, t) {
                    super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
                }
            }
            class ya extends Hn {
                static get type() {
                    return "PointsMaterial"
                }
                constructor(e) {
                    super(), this.isPointsMaterial = !0, this.color = new kn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            const _a = new Wt,
                xa = new jt,
                Ea = new Ot,
                ba = new gt;
            class wa extends _n {
                constructor(e = new si, t = new ya) {
                    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                }
                raycast(e, t) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Points.threshold,
                        s = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Ea.copy(n.boundingSphere), Ea.applyMatrix4(i), Ea.radius += r, !1 === e.ray.intersectsSphere(Ea)) return;
                    _a.copy(i).invert(), xa.copy(e.ray).applyMatrix4(_a);
                    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o,
                        l = n.index,
                        c = n.attributes.position;
                    if (null !== l)
                        for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                            const r = l.getX(n);
                            ba.fromBufferAttribute(c, r), Ca(ba, r, a, i, e, t, this)
                        } else
                            for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++) ba.fromBufferAttribute(c, n), Ca(ba, n, a, i, e, t, this)
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }

            function Ca(e, t, n, i, r, s, o) {
                const a = xa.distanceSqToPoint(e);
                if (a < n) {
                    const n = new gt;
                    xa.closestPointToPoint(e, n), n.applyMatrix4(i);
                    const l = r.ray.origin.distanceTo(n);
                    if (l < r.near || l > r.far) return;
                    s.push({
                        distance: l,
                        distanceToRay: Math.sqrt(a),
                        point: n,
                        index: t,
                        face: null,
                        faceIndex: null,
                        barycoord: null,
                        object: o
                    })
                }
            }
            class Sa extends ct {
                constructor(e, t) {
                    super({
                        width: e,
                        height: t
                    }), this.isFramebufferTexture = !0, this.magFilter = h, this.minFilter = h, this.generateMipmaps = !1, this.needsUpdate = !0
                }
            }
            class Ta extends ct {
                constructor(e, t, n, i, r, s, o, a, l, c, u, h) {
                    super(null, s, o, a, l, c, i, r, u, h), this.isCompressedTexture = !0, this.image = {
                        width: t,
                        height: n
                    }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            class Ma extends Ta {
                constructor(e, t, n, i, r, s) {
                    super(e, t, n, r, s), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = c, this.layerUpdates = new Set
                }
                addLayerUpdate(e) {
                    this.layerUpdates.add(e)
                }
                clearLayerUpdates() {
                    this.layerUpdates.clear()
                }
            }
            class Ia extends Ta {
                constructor(e, t, n) {
                    super(void 0, e[0].width, e[0].height, t, n, r), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
                }
            }
            class Ba extends si {
                constructor(e = 1, t = 32, n = 16, i = 0, r = 2 * Math.PI, s = 0, o = Math.PI) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: i,
                        phiLength: r,
                        thetaStart: s,
                        thetaLength: o
                    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                    const a = Math.min(s + o, Math.PI);
                    let l = 0;
                    const c = [],
                        u = new gt,
                        h = new gt,
                        d = [],
                        f = [],
                        p = [],
                        m = [];
                    for (let d = 0; d <= n; d++) {
                        const g = [],
                            A = d / n;
                        let v = 0;
                        0 === d && 0 === s ? v = .5 / t : d === n && a === Math.PI && (v = -.5 / t);
                        for (let n = 0; n <= t; n++) {
                            const a = n / t;
                            u.x = -e * Math.cos(i + a * r) * Math.sin(s + A * o), u.y = e * Math.cos(s + A * o), u.z = e * Math.sin(i + a * r) * Math.sin(s + A * o), f.push(u.x, u.y, u.z), h.copy(u).normalize(), p.push(h.x, h.y, h.z), m.push(a + v, 1 - A), g.push(l++)
                        }
                        c.push(g)
                    }
                    for (let e = 0; e < n; e++)
                        for (let i = 0; i < t; i++) {
                            const t = c[e][i + 1],
                                r = c[e][i],
                                o = c[e + 1][i],
                                l = c[e + 1][i + 1];
                            (0 !== e || s > 0) && d.push(t, r, l), (e !== n - 1 || a < Math.PI) && d.push(r, o, l)
                        }
                    this.setIndex(d), this.setAttribute("position", new Jn(f, 3)), this.setAttribute("normal", new Jn(p, 3)), this.setAttribute("uv", new Jn(m, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new Ba(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
                }
            }
            class Ra extends Hn {
                static get type() {
                    return "MeshStandardMaterial"
                }
                constructor(e) {
                    super(), this.isMeshStandardMaterial = !0, this.defines = {
                        STANDARD: ""
                    }, this.color = new kn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ze(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new nn, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class Da extends Ra {
                static get type() {
                    return "MeshPhysicalMaterial"
                }
                constructor(e) {
                    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ze(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return Ue(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new kn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new kn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new kn(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
                }
                get anisotropy() {
                    return this._anisotropy
                }
                set anisotropy(e) {
                    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                }
                get iridescence() {
                    return this._iridescence
                }
                set iridescence(e) {
                    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
                }
                get dispersion() {
                    return this._dispersion
                }
                set dispersion(e) {
                    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                }
            }
            class Pa extends Hn {
                static get type() {
                    return "MeshNormalMaterial"
                }
                constructor(e) {
                    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ze(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                }
            }

            function La(e, t, n) {
                return e && e.constructor !== t ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e
            }

            function Ua(e) {
                const t = e.length,
                    n = new Array(t);
                for (let e = 0; e !== t; ++e) n[e] = e;
                return n.sort((function(t, n) {
                    return e[t] - e[n]
                })), n
            }

            function Na(e, t, n) {
                const i = e.length,
                    r = new e.constructor(i);
                for (let s = 0, o = 0; o !== i; ++s) {
                    const i = n[s] * t;
                    for (let n = 0; n !== t; ++n) r[o++] = e[i + n]
                }
                return r
            }

            function Oa(e, t, n, i) {
                let r = 1,
                    s = e[0];
                for (; void 0 !== s && void 0 === s[i];) s = e[r++];
                if (void 0 === s) return;
                let o = s[i];
                if (void 0 !== o)
                    if (Array.isArray(o))
                        do {
                            o = s[i], void 0 !== o && (t.push(s.time), n.push.apply(n, o)), s = e[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== o.toArray)
                    do {
                        o = s[i], void 0 !== o && (t.push(s.time), o.toArray(n, n.length)), s = e[r++]
                    } while (void 0 !== s);
                else
                    do {
                        o = s[i], void 0 !== o && (t.push(s.time), n.push(o)), s = e[r++]
                    } while (void 0 !== s)
            }
            class Fa {
                constructor(e, t, n, i) {
                    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    const t = this.parameterPositions;
                    let n = this._cachedIndex,
                        i = t[n],
                        r = t[n - 1];
                    e: {
                        t: {
                            let s;n: {
                                i: if (!(e < i)) {
                                    for (let s = n + 2;;) {
                                        if (void 0 === i) {
                                            if (e < r) break i;
                                            return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                        }
                                        if (n === s) break;
                                        if (r = i, i = t[++n], e < i) break t
                                    }
                                    s = t.length;
                                    break n
                                }if (e >= r) break e;
                                {
                                    const o = t[1];
                                    e < o && (n = 2, r = o);
                                    for (let s = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                        if (n === s) break;
                                        if (i = r, r = t[--n - 1], e >= r) break t
                                    }
                                    s = n, n = 0
                                }
                            }
                            for (; n < s;) {
                                const i = n + s >>> 1;
                                e < t[i] ? s = i : n = i + 1
                            }
                            if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                            if (void 0 === i) return n = t.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, e, i)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = e * i;
                    for (let e = 0; e !== i; ++e) t[e] = n[r + e];
                    return t
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class ka extends Fa {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: 2400,
                        endingEnd: 2400
                    }
                }
                intervalChanged_(e, t, n) {
                    const i = this.parameterPositions;
                    let r = e - 2,
                        s = e + 1,
                        o = i[r],
                        a = i[s];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case 2401:
                            r = e, o = 2 * t - n;
                            break;
                        case 2402:
                            r = i.length - 2, o = t + i[r] - i[r + 1];
                            break;
                        default:
                            r = e, o = n
                    }
                    if (void 0 === a) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            s = e, a = 2 * n - t;
                            break;
                        case 2402:
                            s = 1, a = n + i[1] - i[0];
                            break;
                        default:
                            s = e - 1, a = t
                    }
                    const l = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = e * o,
                        l = a - o,
                        c = this._offsetPrev,
                        u = this._offsetNext,
                        h = this._weightPrev,
                        d = this._weightNext,
                        f = (n - t) / (i - t),
                        p = f * f,
                        m = p * f,
                        g = -h * m + 2 * h * p - h * f,
                        A = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1,
                        v = (-1 - d) * m + (1.5 + d) * p + .5 * f,
                        y = d * m - d * p;
                    for (let e = 0; e !== o; ++e) r[e] = g * s[c + e] + A * s[l + e] + v * s[a + e] + y * s[u + e];
                    return r
                }
            }
            class Qa extends Fa {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = e * o,
                        l = a - o,
                        c = (n - t) / (i - t),
                        u = 1 - c;
                    for (let e = 0; e !== o; ++e) r[e] = s[l + e] * u + s[a + e] * c;
                    return r
                }
            }
            class za extends Fa {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class Ha {
                constructor(e, t, n, i) {
                    if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e, this.times = La(t, this.TimeBufferType), this.values = La(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    const t = e.constructor;
                    let n;
                    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
                    else {
                        n = {
                            name: e.name,
                            times: La(e.times, Array),
                            values: La(e.values, Array)
                        };
                        const t = e.getInterpolation();
                        t !== e.DefaultInterpolation && (n.interpolation = t)
                    }
                    return n.type = e.ValueTypeName, n
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new za(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new Qa(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new ka(this.times, this.values, this.getValueSize(), e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                        case me:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case ge:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case Ae:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(t);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return this
                    }
                    return this.createInterpolant = t, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return me;
                        case this.InterpolantFactoryMethodLinear:
                            return ge;
                        case this.InterpolantFactoryMethodSmooth:
                            return Ae
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
                    }
                    return this
                }
                trim(e, t) {
                    const n = this.times,
                        i = n.length;
                    let r = 0,
                        s = i - 1;
                    for (; r !== i && n[r] < e;) ++r;
                    for (; - 1 !== s && n[s] > t;) --s;
                    if (++s, 0 !== r || s !== i) {
                        r >= s && (s = Math.max(s, 1), r = s - 1);
                        const e = this.getValueSize();
                        this.times = n.slice(r, s), this.values = this.values.slice(r * e, s * e)
                    }
                    return this
                }
                validate() {
                    let e = !0;
                    const t = this.getValueSize();
                    t - Math.floor(t) != 0 && (e = !1);
                    const n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (e = !1);
                    let s = null;
                    for (let t = 0; t !== r; t++) {
                        const i = n[t];
                        if ("number" == typeof i && isNaN(i)) {
                            e = !1;
                            break
                        }
                        if (null !== s && s > i) {
                            e = !1;
                            break
                        }
                        s = i
                    }
                    if (void 0 !== i && function(e) {
                            return ArrayBuffer.isView(e) && !(e instanceof DataView)
                        }(i))
                        for (let t = 0, n = i.length; t !== n; ++t) {
                            const n = i[t];
                            if (isNaN(n)) {
                                e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    const e = this.times.slice(),
                        t = this.values.slice(),
                        n = this.getValueSize(),
                        i = this.getInterpolation() === Ae,
                        r = e.length - 1;
                    let s = 1;
                    for (let o = 1; o < r; ++o) {
                        let r = !1;
                        const a = e[o];
                        if (a !== e[o + 1] && (1 !== o || a !== e[0]))
                            if (i) r = !0;
                            else {
                                const e = o * n,
                                    i = e - n,
                                    s = e + n;
                                for (let o = 0; o !== n; ++o) {
                                    const n = t[e + o];
                                    if (n !== t[i + o] || n !== t[s + o]) {
                                        r = !0;
                                        break
                                    }
                                }
                            } if (r) {
                            if (o !== s) {
                                e[s] = e[o];
                                const i = o * n,
                                    r = s * n;
                                for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
                            }++s
                        }
                    }
                    if (r > 0) {
                        e[s] = e[r];
                        for (let e = r * n, i = s * n, o = 0; o !== n; ++o) t[i + o] = t[e + o];
                        ++s
                    }
                    return s !== e.length ? (this.times = e.slice(0, s), this.values = t.slice(0, s * n)) : (this.times = e, this.values = t), this
                }
                clone() {
                    const e = this.times.slice(),
                        t = this.values.slice(),
                        n = new this.constructor(this.name, e, t);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }
            Ha.prototype.TimeBufferType = Float32Array, Ha.prototype.ValueBufferType = Float32Array, Ha.prototype.DefaultInterpolation = ge;
            class Ga extends Ha {
                constructor(e, t, n) {
                    super(e, t, n)
                }
            }
            Ga.prototype.ValueTypeName = "bool", Ga.prototype.ValueBufferType = Array, Ga.prototype.DefaultInterpolation = me, Ga.prototype.InterpolantFactoryMethodLinear = void 0, Ga.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Va extends Ha {}
            Va.prototype.ValueTypeName = "color";
            class ja extends Ha {}
            ja.prototype.ValueTypeName = "number";
            class Wa extends Fa {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = (n - t) / (i - t);
                    let l = e * o;
                    for (let e = l + o; l !== e; l += 4) mt.slerpFlat(r, 0, s, l - o, s, l, a);
                    return r
                }
            }
            class Xa extends Ha {
                InterpolantFactoryMethodLinear(e) {
                    return new Wa(this.times, this.values, this.getValueSize(), e)
                }
            }
            Xa.prototype.ValueTypeName = "quaternion", Xa.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Ya extends Ha {
                constructor(e, t, n) {
                    super(e, t, n)
                }
            }
            Ya.prototype.ValueTypeName = "string", Ya.prototype.ValueBufferType = Array, Ya.prototype.DefaultInterpolation = me, Ya.prototype.InterpolantFactoryMethodLinear = void 0, Ya.prototype.InterpolantFactoryMethodSmooth = void 0;
            class qa extends Ha {}
            qa.prototype.ValueTypeName = "vector";
            class Ka {
                constructor(e = "", t = -1, n = [], i = 2500) {
                    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Le(), this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    const t = [],
                        n = e.tracks,
                        i = 1 / (e.fps || 1);
                    for (let e = 0, r = n.length; e !== r; ++e) t.push(Ja(n[e]).scale(i));
                    const r = new this(e.name, e.duration, t, e.blendMode);
                    return r.uuid = e.uuid, r
                }
                static toJSON(e) {
                    const t = [],
                        n = e.tracks,
                        i = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let e = 0, i = n.length; e !== i; ++e) t.push(Ha.toJSON(n[e]));
                    return i
                }
                static CreateFromMorphTargetSequence(e, t, n, i) {
                    const r = t.length,
                        s = [];
                    for (let e = 0; e < r; e++) {
                        let o = [],
                            a = [];
                        o.push((e + r - 1) % r, e, (e + 1) % r), a.push(0, 1, 0);
                        const l = Ua(o);
                        o = Na(o, 1, l), a = Na(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new ja(".morphTargetInfluences[" + t[e].name + "]", o, a).scale(1 / n))
                    }
                    return new this(e, -1, s)
                }
                static findByName(e, t) {
                    let n = e;
                    if (!Array.isArray(e)) {
                        const t = e;
                        n = t.geometry && t.geometry.animations || t.animations
                    }
                    for (let e = 0; e < n.length; e++)
                        if (n[e].name === t) return n[e];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, n) {
                    const i = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t],
                            s = n.name.match(r);
                        if (s && s.length > 1) {
                            const e = s[1];
                            let t = i[e];
                            t || (i[e] = t = []), t.push(n)
                        }
                    }
                    const s = [];
                    for (const e in i) s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                    return s
                }
                static parseAnimation(e, t) {
                    if (!e) return null;
                    const n = function(e, t, n, i, r) {
                            if (0 !== n.length) {
                                const s = [],
                                    o = [];
                                Oa(n, s, o, i), 0 !== s.length && r.push(new e(t, s, o))
                            }
                        },
                        i = [],
                        r = e.name || "default",
                        s = e.fps || 30,
                        o = e.blendMode;
                    let a = e.length || -1;
                    const l = e.hierarchy || [];
                    for (let e = 0; e < l.length; e++) {
                        const r = l[e].keys;
                        if (r && 0 !== r.length)
                            if (r[0].morphTargets) {
                                const e = {};
                                let t;
                                for (t = 0; t < r.length; t++)
                                    if (r[t].morphTargets)
                                        for (let n = 0; n < r[t].morphTargets.length; n++) e[r[t].morphTargets[n]] = -1;
                                for (const n in e) {
                                    const e = [],
                                        s = [];
                                    for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                        const i = r[t];
                                        e.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                    }
                                    i.push(new ja(".morphTargetInfluence[" + n + "]", e, s))
                                }
                                a = e.length * s
                            } else {
                                const s = ".bones[" + t[e].name + "]";
                                n(qa, s + ".position", r, "pos", i), n(Xa, s + ".quaternion", r, "rot", i), n(qa, s + ".scale", r, "scl", i)
                            }
                    }
                    return 0 === i.length ? null : new this(r, a, i, o)
                }
                resetDuration() {
                    let e = 0;
                    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                        const n = this.tracks[t];
                        e = Math.max(e, n.times[n.times.length - 1])
                    }
                    return this.duration = e, this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
                clone() {
                    const e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new this.constructor(this.name, this.duration, e, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }

            function Ja(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const t = function(e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return ja;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return qa;
                        case "color":
                            return Va;
                        case "quaternion":
                            return Xa;
                        case "bool":
                        case "boolean":
                            return Ga;
                        case "string":
                            return Ya
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    const t = [],
                        n = [];
                    Oa(e.keys, t, n, "value"), e.times = t, e.values = n
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }
            const Za = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e) {
                    if (!1 !== this.enabled) return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class $a {
                constructor(e, t, n) {
                    const i = this;
                    let r, s = !1,
                        o = 0,
                        a = 0;
                    const l = [];
                    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                        a++, !1 === s && void 0 !== i.onStart && i.onStart(e, o, a), s = !0
                    }, this.itemEnd = function(e) {
                        o++, void 0 !== i.onProgress && i.onProgress(e, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad())
                    }, this.itemError = function(e) {
                        void 0 !== i.onError && i.onError(e)
                    }, this.resolveURL = function(e) {
                        return r ? r(e) : e
                    }, this.setURLModifier = function(e) {
                        return r = e, this
                    }, this.addHandler = function(e, t) {
                        return l.push(e, t), this
                    }, this.removeHandler = function(e) {
                        const t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2), this
                    }, this.getHandler = function(e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            const n = l[t],
                                i = l[t + 1];
                            if (n.global && (n.lastIndex = 0), n.test(e)) return i
                        }
                        return null
                    }
                }
            }
            const el = new $a;
            class tl {
                constructor(e) {
                    this.manager = void 0 !== e ? e : el, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    const n = this;
                    return new Promise((function(i, r) {
                        n.load(e, i, t, r)
                    }))
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e, this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e, this
                }
                setPath(e) {
                    return this.path = e, this
                }
                setResourcePath(e) {
                    return this.resourcePath = e, this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e, this
                }
            }
            tl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
            const nl = {};
            class il extends Error {
                constructor(e, t) {
                    super(e), this.response = t
                }
            }
            class rl extends tl {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = Za.get(e);
                    if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => {
                        t && t(r), this.manager.itemEnd(e)
                    }), 0), r;
                    if (void 0 !== nl[e]) return void nl[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    nl[e] = [], nl[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    const s = new Request(e, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin"
                        }),
                        o = this.mimeType,
                        a = this.responseType;
                    fetch(s).then((t => {
                        if (200 === t.status || 0 === t.status) {
                            if (t.status, "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                            const n = nl[e],
                                i = t.body.getReader(),
                                r = t.headers.get("X-File-Size") || t.headers.get("Content-Length"),
                                s = r ? parseInt(r) : 0,
                                o = 0 !== s;
                            let a = 0;
                            const l = new ReadableStream({
                                start(e) {
                                    ! function t() {
                                        i.read().then((({
                                            done: i,
                                            value: r
                                        }) => {
                                            if (i) e.close();
                                            else {
                                                a += r.byteLength;
                                                const i = new ProgressEvent("progress", {
                                                    lengthComputable: o,
                                                    loaded: a,
                                                    total: s
                                                });
                                                for (let e = 0, t = n.length; e < t; e++) {
                                                    const t = n[e];
                                                    t.onProgress && t.onProgress(i)
                                                }
                                                e.enqueue(r), t()
                                            }
                                        }), (t => {
                                            e.error(t)
                                        }))
                                    }()
                                }
                            });
                            return new Response(l)
                        }
                        throw new il(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t)
                    })).then((e => {
                        switch (a) {
                            case "arraybuffer":
                                return e.arrayBuffer();
                            case "blob":
                                return e.blob();
                            case "document":
                                return e.text().then((e => (new DOMParser).parseFromString(e, o)));
                            case "json":
                                return e.json();
                            default:
                                if (void 0 === o) return e.text();
                                {
                                    const t = /charset="?([^;"\s]*)"?/i.exec(o),
                                        n = t && t[1] ? t[1].toLowerCase() : void 0,
                                        i = new TextDecoder(n);
                                    return e.arrayBuffer().then((e => i.decode(e)))
                                }
                        }
                    })).then((t => {
                        Za.add(e, t);
                        const n = nl[e];
                        delete nl[e];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            i.onLoad && i.onLoad(t)
                        }
                    })).catch((t => {
                        const n = nl[e];
                        if (void 0 === n) throw this.manager.itemError(e), t;
                        delete nl[e];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            i.onError && i.onError(t)
                        }
                        this.manager.itemError(e)
                    })).finally((() => {
                        this.manager.itemEnd(e)
                    })), this.manager.itemStart(e)
                }
                setResponseType(e) {
                    return this.responseType = e, this
                }
                setMimeType(e) {
                    return this.mimeType = e, this
                }
            }
            class sl extends tl {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        s = Za.get(e);
                    if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
                        t && t(s), r.manager.itemEnd(e)
                    }), 0), s;
                    const o = je("img");

                    function a() {
                        c(), Za.add(e, this), t && t(this), r.manager.itemEnd(e)
                    }

                    function l(t) {
                        c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }

                    function c() {
                        o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1)
                    }
                    return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o
                }
            }
            class ol extends tl {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        s = new Wo,
                        o = new rl(this.manager);
                    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(e, (function(e) {
                        let n;
                        try {
                            n = r.parse(e)
                        } catch (e) {
                            if (void 0 === i) return;
                            i(e)
                        }
                        void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : c, s.wrapT = void 0 !== n.wrapT ? n.wrapT : c, s.magFilter = void 0 !== n.magFilter ? n.magFilter : f, s.minFilter = void 0 !== n.minFilter ? n.minFilter : f, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace && (s.colorSpace = n.colorSpace), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = m), 1 === n.mipmapCount && (s.minFilter = f), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, t && t(s, n)
                    }), n, i), s
                }
            }
            class al extends tl {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = new ct,
                        s = new sl(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function(e) {
                        r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
                    }), n, i), r
                }
            }
            class ll extends _n {
                constructor(e, t = 1) {
                    super(), this.isLight = !0, this.type = "Light", this.color = new kn(e), this.intensity = t
                }
                dispose() {}
                copy(e, t) {
                    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t
                }
            }
            const cl = new Wt,
                ul = new gt,
                hl = new gt;
            class dl {
                constructor(e) {
                    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ze(512, 512), this.map = null, this.mapPass = null, this.matrix = new Wt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Qi, this._frameExtents = new ze(1, 1), this._viewportCount = 1, this._viewports = [new ut(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    const t = this.camera,
                        n = this.matrix;
                    ul.setFromMatrixPosition(e.matrixWorld), t.position.copy(ul), hl.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(hl), t.updateMatrixWorld(), cl.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(cl), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(cl)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = {};
                    return 1 !== this.intensity && (e.intensity = this.intensity), 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }
            class fl extends dl {
                constructor() {
                    super(new Ii(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                }
                updateMatrices(e) {
                    const t = this.camera,
                        n = 2 * Pe * e.angle * this.focus,
                        i = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e), this.focus = e.focus, this
                }
            }
            class pl extends ll {
                constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 2) {
                    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(_n.DEFAULT_UP), this.updateMatrix(), this.target = new _n, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.map = null, this.shadow = new fl
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            const ml = new Wt,
                gl = new gt,
                Al = new gt;
            class vl extends dl {
                constructor() {
                    super(new Ii(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ze(4, 2), this._viewportCount = 6, this._viewports = [new ut(2, 1, 1, 1), new ut(0, 1, 1, 1), new ut(3, 1, 1, 1), new ut(1, 1, 1, 1), new ut(3, 0, 1, 1), new ut(1, 0, 1, 1)], this._cubeDirections = [new gt(1, 0, 0), new gt(-1, 0, 0), new gt(0, 0, 1), new gt(0, 0, -1), new gt(0, 1, 0), new gt(0, -1, 0)], this._cubeUps = [new gt(0, 1, 0), new gt(0, 1, 0), new gt(0, 1, 0), new gt(0, 1, 0), new gt(0, 0, 1), new gt(0, 0, -1)]
                }
                updateMatrices(e, t = 0) {
                    const n = this.camera,
                        i = this.matrix,
                        r = e.distance || n.far;
                    r !== n.far && (n.far = r, n.updateProjectionMatrix()), gl.setFromMatrixPosition(e.matrixWorld), n.position.copy(gl), Al.copy(n.position), Al.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Al), n.updateMatrixWorld(), i.makeTranslation(-gl.x, -gl.y, -gl.z), ml.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ml)
                }
            }
            class yl extends ll {
                constructor(e, t, n = 0, i = 2) {
                    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new vl
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }
            class _l extends dl {
                constructor() {
                    super(new nr(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                }
            }
            class xl extends ll {
                constructor(e, t) {
                    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(_n.DEFAULT_UP), this.updateMatrix(), this.target = new _n, this.shadow = new _l
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            class El extends ll {
                constructor(e, t) {
                    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
                }
            }
            class bl {
                static decodeText(e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    let t = "";
                    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (e) {
                        return t
                    }
                }
                static extractUrlBase(e) {
                    const t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.slice(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                }
            }
            class wl extends tl {
                constructor(e) {
                    super(e), this.isImageBitmapLoader = !0, this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(e) {
                    return this.options = e, this
                }
                load(e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        s = Za.get(e);
                    if (void 0 !== s) return r.manager.itemStart(e), s.then ? void s.then((n => {
                        t && t(n), r.manager.itemEnd(e)
                    })).catch((e => {
                        i && i(e)
                    })) : (setTimeout((function() {
                        t && t(s), r.manager.itemEnd(e)
                    }), 0), s);
                    const o = {};
                    o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader;
                    const a = fetch(e, o).then((function(e) {
                        return e.blob()
                    })).then((function(e) {
                        return createImageBitmap(e, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    })).then((function(n) {
                        return Za.add(e, n), t && t(n), r.manager.itemEnd(e), n
                    })).catch((function(t) {
                        i && i(t), Za.remove(e), r.manager.itemError(e), r.manager.itemEnd(e)
                    }));
                    Za.add(e, a), r.manager.itemStart(e)
                }
            }
            class Cl {
                constructor(e = !0) {
                    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = Sl(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const t = Sl();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }

            function Sl() {
                return performance.now()
            }
            const Tl = "\\[\\]\\.:\\/",
                Ml = new RegExp("[" + Tl + "]", "g"),
                Il = "[^" + Tl + "]",
                Bl = "[^" + Tl.replace("\\.", "") + "]",
                Rl = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Il) + /(WCOD+)?/.source.replace("WCOD", Bl) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Il) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Il) + "$"),
                Dl = ["material", "materials", "bones", "map"];
            class Pl {
                constructor(e, t, n) {
                    this.path = t, this.parsedPath = n || Pl.parseTrackName(t), this.node = Pl.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new Pl.Composite(e, t, n) : new Pl(e, t, n)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(Ml, "")
                }
                static parseTrackName(e) {
                    const t = Rl.exec(e);
                    if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    const n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        const e = n.nodeName.substring(i + 1); - 1 !== Dl.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
                static findNode(e, t) {
                    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        const n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        const n = function(e) {
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    if (r.name === t || r.uuid === t) return r;
                                    const s = n(r.children);
                                    if (s) return s
                                }
                                return null
                            },
                            i = n(e.children);
                        if (i) return i
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                }
                bind() {
                    let e = this.node;
                    const t = this.parsedPath,
                        n = t.objectName,
                        i = t.propertyName;
                    let r = t.propertyIndex;
                    if (e || (e = Pl.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return;
                    if (n) {
                        let i = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return;
                                if (!e.material.materials) return;
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return;
                                e = e.skeleton.bones;
                                for (let t = 0; t < e.length; t++)
                                    if (e[t].name === i) {
                                        i = t;
                                        break
                                    } break;
                            case "map":
                                if ("map" in e) {
                                    e = e.map;
                                    break
                                }
                                if (!e.material) return;
                                if (!e.material.map) return;
                                e = e.material.map;
                                break;
                            default:
                                if (void 0 === e[n]) return;
                                e = e[n]
                        }
                        if (void 0 !== i) {
                            if (void 0 === e[i]) return;
                            e = e[i]
                        }
                    }
                    const s = e[i];
                    if (void 0 === s) return void t.nodeName;
                    let o = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                    let a = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry) return;
                            if (!e.geometry.morphAttributes) return;
                            void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                        }
                        a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            Pl.Composite = class {
                constructor(e, t, n) {
                    const i = n || Pl.parseTrackName(t);
                    this._targetGroup = e, this._bindings = e.subscribe_(t, i)
                }
                getValue(e, t) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(e, t)
                }
                setValue(e, t) {
                    const n = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
                }
                bind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                }
                unbind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }, Pl.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, Pl.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, Pl.prototype.GetterByBindingType = [Pl.prototype._getValue_direct, Pl.prototype._getValue_array, Pl.prototype._getValue_arrayElement, Pl.prototype._getValue_toArray], Pl.prototype.SetterByBindingTypeAndVersioning = [
                [Pl.prototype._setValue_direct, Pl.prototype._setValue_direct_setNeedsUpdate, Pl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [Pl.prototype._setValue_array, Pl.prototype._setValue_array_setNeedsUpdate, Pl.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [Pl.prototype._setValue_arrayElement, Pl.prototype._setValue_arrayElement_setNeedsUpdate, Pl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [Pl.prototype._setValue_fromArray, Pl.prototype._setValue_fromArray_setNeedsUpdate, Pl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class Ll {
                constructor(e) {
                    this.value = e
                }
                clone() {
                    return new Ll(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }
            const Ul = new Wt;
            class Nl {
                constructor(e, t, n = 0, i = 1 / 0) {
                    this.ray = new jt(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new rn, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera && (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t)
                }
                setFromXRController(e) {
                    return Ul.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Ul), this
                }
                intersectObject(e, t = !0, n = []) {
                    return Fl(e, this, n, t), n.sort(Ol), n
                }
                intersectObjects(e, t = !0, n = []) {
                    for (let i = 0, r = e.length; i < r; i++) Fl(e[i], this, n, t);
                    return n.sort(Ol), n
                }
            }

            function Ol(e, t) {
                return e.distance - t.distance
            }

            function Fl(e, t, n, i) {
                let r = !0;
                if (e.layers.test(t.layers) && !1 === e.raycast(t, n) && (r = !1), !0 === r && !0 === i) {
                    const i = e.children;
                    for (let e = 0, r = i.length; e < r; e++) Fl(i[e], t, n, !0)
                }
            }
            class kl {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
                makeSafe() {
                    const e = 1e-6;
                    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Ue(t / this.radius, -1, 1))), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Ql extends dt {
                constructor(e = 1, t = 1, n = 1, i = {}) {
                    super(e, t, {
                        ...i,
                        count: n
                    }), this.isWebGLMultipleRenderTargets = !0
                }
                get texture() {
                    return this.textures
                }
            }
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: e
                }
            })), "undefined" != typeof window && (window.__THREE__ || (window.__THREE__ = e));
            class zl extends ol {
                constructor(e) {
                    super(e), this.type = w
                }
                parse(e) {
                    const t = function(e, t) {
                            switch (e) {
                                case 1:
                                    throw new Error("THREE.RGBELoader: Read Error: " + (t || ""));
                                case 2:
                                    throw new Error("THREE.RGBELoader: Write Error: " + (t || ""));
                                case 3:
                                    throw new Error("THREE.RGBELoader: Bad File Format: " + (t || ""));
                                default:
                                    throw new Error("THREE.RGBELoader: Memory Error: " + (t || ""))
                            }
                        },
                        n = function(e, t, n) {
                            t = t || 1024;
                            let i = e.pos,
                                r = -1,
                                s = 0,
                                o = "",
                                a = String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                            for (; 0 > (r = a.indexOf("\n")) && s < t && i < e.byteLength;) o += a, s += a.length, i += 128, a += String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                            return -1 < r && (e.pos += s + r + 1, o + a.slice(0, r))
                        },
                        i = function(e, t, n, i) {
                            const r = e[t + 3],
                                s = Math.pow(2, r - 128) / 255;
                            n[i + 0] = e[t + 0] * s, n[i + 1] = e[t + 1] * s, n[i + 2] = e[t + 2] * s, n[i + 3] = 1
                        },
                        r = function(e, t, n, i) {
                            const r = e[t + 3],
                                s = Math.pow(2, r - 128) / 255;
                            n[i + 0] = jn.toHalfFloat(Math.min(e[t + 0] * s, 65504)), n[i + 1] = jn.toHalfFloat(Math.min(e[t + 1] * s, 65504)), n[i + 2] = jn.toHalfFloat(Math.min(e[t + 2] * s, 65504)), n[i + 3] = jn.toHalfFloat(1)
                        },
                        s = new Uint8Array(e);
                    s.pos = 0;
                    const o = function(e) {
                            const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                                r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                                s = /^\s*FORMAT=(\S+)\s*$/,
                                o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                                a = {
                                    valid: 0,
                                    string: "",
                                    comments: "",
                                    programtype: "RGBE",
                                    format: "",
                                    gamma: 1,
                                    exposure: 1,
                                    width: 0,
                                    height: 0
                                };
                            let l, c;
                            for ((e.pos >= e.byteLength || !(l = n(e))) && t(1, "no header found"), (c = l.match(/^#\?(\S+)/)) || t(3, "bad initial token"), a.valid |= 1, a.programtype = c[1], a.string += l + "\n"; l = n(e), !1 !== l;)
                                if (a.string += l + "\n", "#" !== l.charAt(0)) {
                                    if ((c = l.match(i)) && (a.gamma = parseFloat(c[1])), (c = l.match(r)) && (a.exposure = parseFloat(c[1])), (c = l.match(s)) && (a.valid |= 2, a.format = c[1]), (c = l.match(o)) && (a.valid |= 4, a.height = parseInt(c[1], 10), a.width = parseInt(c[2], 10)), 2 & a.valid && 4 & a.valid) break
                                } else a.comments += l + "\n";
                            return 2 & a.valid || t(3, "missing format specifier"), 4 & a.valid || t(3, "missing image size specifier"), a
                        }(s),
                        a = o.width,
                        l = o.height,
                        c = function(e, n, i) {
                            const r = n;
                            if (r < 8 || r > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                            r !== (e[2] << 8 | e[3]) && t(3, "wrong scanline width");
                            const s = new Uint8Array(4 * n * i);
                            s.length || t(4, "unable to allocate buffer space");
                            let o = 0,
                                a = 0;
                            const l = 4 * r,
                                c = new Uint8Array(4),
                                u = new Uint8Array(l);
                            let h = i;
                            for (; h > 0 && a < e.byteLength;) {
                                a + 4 > e.byteLength && t(1), c[0] = e[a++], c[1] = e[a++], c[2] = e[a++], c[3] = e[a++], 2 == c[0] && 2 == c[1] && (c[2] << 8 | c[3]) == r || t(3, "bad rgbe scanline format");
                                let n, i = 0;
                                for (; i < l && a < e.byteLength;) {
                                    n = e[a++];
                                    const r = n > 128;
                                    if (r && (n -= 128), (0 === n || i + n > l) && t(3, "bad scanline data"), r) {
                                        const t = e[a++];
                                        for (let e = 0; e < n; e++) u[i++] = t
                                    } else u.set(e.subarray(a, a + n), i), i += n, a += n
                                }
                                const d = r;
                                for (let e = 0; e < d; e++) {
                                    let t = 0;
                                    s[o] = u[e + t], t += r, s[o + 1] = u[e + t], t += r, s[o + 2] = u[e + t], t += r, s[o + 3] = u[e + t], o += 4
                                }
                                h--
                            }
                            return s
                        }(s.subarray(s.pos), a, l);
                    let u, h, d;
                    switch (this.type) {
                        case b:
                            d = c.length / 4;
                            const e = new Float32Array(4 * d);
                            for (let t = 0; t < d; t++) i(c, 4 * t, e, 4 * t);
                            u = e, h = b;
                            break;
                        case w:
                            d = c.length / 4;
                            const t = new Uint16Array(4 * d);
                            for (let e = 0; e < d; e++) r(c, 4 * e, t, 4 * e);
                            u = t, h = w;
                            break;
                        default:
                            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
                    }
                    return {
                        width: a,
                        height: l,
                        data: u,
                        header: o.string,
                        gamma: o.gamma,
                        exposure: o.exposure,
                        type: h
                    }
                }
                setDataType(e) {
                    return this.type = e, this
                }
                load(e, t, n, i) {
                    return super.load(e, (function(e, n) {
                        switch (e.type) {
                            case b:
                            case w:
                                e.colorSpace = xe, e.minFilter = f, e.magFilter = f, e.generateMipmaps = !1, e.flipY = !0
                        }
                        t && t(e, n)
                    }), n, i)
                }
            }
            var Hl = function(e, t) {
                return Hl = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(e, t) {
                    e.__proto__ = t
                } || function(e, t) {
                    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
                }, Hl(e, t)
            };

            function Gl(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

                function n() {
                    this.constructor = e
                }
                Hl(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
            }

            function Vl(e, t) {
                var n, i, r, s = {
                        label: 0,
                        sent: function() {
                            if (1 & r[0]) throw r[1];
                            return r[1]
                        },
                        trys: [],
                        ops: []
                    },
                    o = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype);
                return o.next = a(0), o.throw = a(1), o.return = a(2), "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                    return this
                }), o;

                function a(a) {
                    return function(l) {
                        return function(a) {
                            if (n) throw new TypeError("Generator is already executing.");
                            for (; o && (o = 0, a[0] && (s = 0)), s;) try {
                                if (n = 1, i && (r = 2 & a[0] ? i.return : a[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, a[1])).done) return r;
                                switch (i = 0, r && (a = [2 & a[0], r.value]), a[0]) {
                                    case 0:
                                    case 1:
                                        r = a;
                                        break;
                                    case 4:
                                        return s.label++, {
                                            value: a[1],
                                            done: !1
                                        };
                                    case 5:
                                        s.label++, i = a[1], a = [0];
                                        continue;
                                    case 7:
                                        a = s.ops.pop(), s.trys.pop();
                                        continue;
                                    default:
                                        if (!((r = (r = s.trys).length > 0 && r[r.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                                            s = 0;
                                            continue
                                        }
                                        if (3 === a[0] && (!r || a[1] > r[0] && a[1] < r[3])) {
                                            s.label = a[1];
                                            break
                                        }
                                        if (6 === a[0] && s.label < r[1]) {
                                            s.label = r[1], r = a;
                                            break
                                        }
                                        if (r && s.label < r[2]) {
                                            s.label = r[2], s.ops.push(a);
                                            break
                                        }
                                        r[2] && s.ops.pop(), s.trys.pop();
                                        continue
                                }
                                a = t.call(e, s)
                            } catch (e) {
                                a = [6, e], i = 0
                            } finally {
                                n = r = 0
                            }
                            if (5 & a[0]) throw a[1];
                            return {
                                value: a[0] ? a[1] : void 0,
                                done: !0
                            }
                        }([a, l])
                    }
                }
            }

            function jl(e) {
                var t = "function" == typeof Symbol && Symbol.iterator,
                    n = t && e[t],
                    i = 0;
                if (n) return n.call(e);
                if (e && "number" == typeof e.length) return {
                    next: function() {
                        return e && i >= e.length && (e = void 0), {
                            value: e && e[i++],
                            done: !e
                        }
                    }
                };
                throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }

            function Wl(e, t) {
                var n = "function" == typeof Symbol && e[Symbol.iterator];
                if (!n) return e;
                var i, r, s = n.call(e),
                    o = [];
                try {
                    for (;
                        (void 0 === t || t-- > 0) && !(i = s.next()).done;) o.push(i.value)
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        i && !i.done && (n = s.return) && n.call(s)
                    } finally {
                        if (r) throw r.error
                    }
                }
                return o
            }

            function Xl(e, t, n) {
                if (2 === arguments.length)
                    for (var i, r = 0, s = t.length; r < s; r++) !i && r in t || (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
                return e.concat(i || Array.prototype.slice.call(t))
            }

            function Yl(e) {
                return this instanceof Yl ? (this.v = e, this) : new Yl(e)
            }

            function ql(e) {
                return "function" == typeof e
            }

            function Kl(e) {
                var t = e((function(e) {
                    Error.call(e), e.stack = (new Error).stack
                }));
                return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t
            }
            "function" == typeof SuppressedError && SuppressedError;
            var Jl = Kl((function(e) {
                return function(t) {
                    e(this), this.message = t ? t.length + " errors occurred during unsubscription:\n" + t.map((function(e, t) {
                        return t + 1 + ") " + e.toString()
                    })).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = t
                }
            }));

            function Zl(e, t) {
                if (e) {
                    var n = e.indexOf(t);
                    0 <= n && e.splice(n, 1)
                }
            }
            var $l = function() {
                    function e(e) {
                        this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null
                    }
                    return e.prototype.unsubscribe = function() {
                        var e, t, n, i, r;
                        if (!this.closed) {
                            this.closed = !0;
                            var s = this._parentage;
                            if (s)
                                if (this._parentage = null, Array.isArray(s)) try {
                                    for (var o = jl(s), a = o.next(); !a.done; a = o.next()) a.value.remove(this)
                                } catch (t) {
                                    e = {
                                        error: t
                                    }
                                } finally {
                                    try {
                                        a && !a.done && (t = o.return) && t.call(o)
                                    } finally {
                                        if (e) throw e.error
                                    }
                                } else s.remove(this);
                            var l = this.initialTeardown;
                            if (ql(l)) try {
                                l()
                            } catch (e) {
                                r = e instanceof Jl ? e.errors : [e]
                            }
                            var c = this._finalizers;
                            if (c) {
                                this._finalizers = null;
                                try {
                                    for (var u = jl(c), h = u.next(); !h.done; h = u.next()) {
                                        var d = h.value;
                                        try {
                                            nc(d)
                                        } catch (e) {
                                            r = null != r ? r : [], e instanceof Jl ? r = Xl(Xl([], Wl(r)), Wl(e.errors)) : r.push(e)
                                        }
                                    }
                                } catch (e) {
                                    n = {
                                        error: e
                                    }
                                } finally {
                                    try {
                                        h && !h.done && (i = u.return) && i.call(u)
                                    } finally {
                                        if (n) throw n.error
                                    }
                                }
                            }
                            if (r) throw new Jl(r)
                        }
                    }, e.prototype.add = function(t) {
                        var n;
                        if (t && t !== this)
                            if (this.closed) nc(t);
                            else {
                                if (t instanceof e) {
                                    if (t.closed || t._hasParent(this)) return;
                                    t._addParent(this)
                                }(this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t)
                            }
                    }, e.prototype._hasParent = function(e) {
                        var t = this._parentage;
                        return t === e || Array.isArray(t) && t.includes(e)
                    }, e.prototype._addParent = function(e) {
                        var t = this._parentage;
                        this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e
                    }, e.prototype._removeParent = function(e) {
                        var t = this._parentage;
                        t === e ? this._parentage = null : Array.isArray(t) && Zl(t, e)
                    }, e.prototype.remove = function(t) {
                        var n = this._finalizers;
                        n && Zl(n, t), t instanceof e && t._removeParent(this)
                    }, e.EMPTY = function() {
                        var t = new e;
                        return t.closed = !0, t
                    }(), e
                }(),
                ec = $l.EMPTY;

            function tc(e) {
                return e instanceof $l || e && "closed" in e && ql(e.remove) && ql(e.add) && ql(e.unsubscribe)
            }

            function nc(e) {
                ql(e) ? e() : e.unsubscribe()
            }
            var ic = void 0,
                rc = {
                    setTimeout: function(e, t) {
                        for (var n = [], i = 2; i < arguments.length; i++) n[i - 2] = arguments[i];
                        return setTimeout.apply(void 0, Xl([e, t], Wl(n)))
                    },
                    clearTimeout: function(e) {
                        return clearTimeout(e)
                    },
                    delegate: void 0
                };

            function sc(e) {
                rc.setTimeout((function() {
                    throw e
                }))
            }

            function oc() {}

            function ac(e) {
                e()
            }
            var lc = function(e) {
                    function t(t) {
                        var n = e.call(this) || this;
                        return n.isStopped = !1, t ? (n.destination = t, tc(t) && t.add(n)) : n.destination = dc, n
                    }
                    return Gl(t, e), t.create = function(e, t, n) {
                        return new uc(e, t, n)
                    }, t.prototype.next = function(e) {
                        this.isStopped || this._next(e)
                    }, t.prototype.error = function(e) {
                        this.isStopped || (this.isStopped = !0, this._error(e))
                    }, t.prototype.complete = function() {
                        this.isStopped || (this.isStopped = !0, this._complete())
                    }, t.prototype.unsubscribe = function() {
                        this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null)
                    }, t.prototype._next = function(e) {
                        this.destination.next(e)
                    }, t.prototype._error = function(e) {
                        try {
                            this.destination.error(e)
                        } finally {
                            this.unsubscribe()
                        }
                    }, t.prototype._complete = function() {
                        try {
                            this.destination.complete()
                        } finally {
                            this.unsubscribe()
                        }
                    }, t
                }($l),
                cc = function() {
                    function e(e) {
                        this.partialObserver = e
                    }
                    return e.prototype.next = function(e) {
                        var t = this.partialObserver;
                        if (t.next) try {
                            t.next(e)
                        } catch (e) {
                            hc(e)
                        }
                    }, e.prototype.error = function(e) {
                        var t = this.partialObserver;
                        if (t.error) try {
                            t.error(e)
                        } catch (e) {
                            hc(e)
                        } else hc(e)
                    }, e.prototype.complete = function() {
                        var e = this.partialObserver;
                        if (e.complete) try {
                            e.complete()
                        } catch (e) {
                            hc(e)
                        }
                    }, e
                }(),
                uc = function(e) {
                    function t(t, n, i) {
                        var r, s = e.call(this) || this;
                        return r = ql(t) || !t ? {
                            next: null != t ? t : void 0,
                            error: null != n ? n : void 0,
                            complete: null != i ? i : void 0
                        } : t, s.destination = new cc(r), s
                    }
                    return Gl(t, e), t
                }(lc);

            function hc(e) {
                sc(e)
            }
            var dc = {
                    closed: !0,
                    next: oc,
                    error: function(e) {
                        throw e
                    },
                    complete: oc
                },
                fc = "function" == typeof Symbol && Symbol.observable || "@@observable";

            function pc(e) {
                return e
            }
            var mc = function() {
                function e(e) {
                    e && (this._subscribe = e)
                }
                return e.prototype.lift = function(t) {
                    var n = new e;
                    return n.source = this, n.operator = t, n
                }, e.prototype.subscribe = function(e, t, n) {
                    var i, r = this,
                        s = (i = e) && i instanceof lc || function(e) {
                            return e && ql(e.next) && ql(e.error) && ql(e.complete)
                        }(i) && tc(i) ? e : new uc(e, t, n);
                    return ac((function() {
                        var e = r,
                            t = e.operator,
                            n = e.source;
                        s.add(t ? t.call(s, n) : n ? r._subscribe(s) : r._trySubscribe(s))
                    })), s
                }, e.prototype._trySubscribe = function(e) {
                    try {
                        return this._subscribe(e)
                    } catch (t) {
                        e.error(t)
                    }
                }, e.prototype.forEach = function(e, t) {
                    var n = this;
                    return new(t = gc(t))((function(t, i) {
                        var r = new uc({
                            next: function(t) {
                                try {
                                    e(t)
                                } catch (e) {
                                    i(e), r.unsubscribe()
                                }
                            },
                            error: i,
                            complete: t
                        });
                        n.subscribe(r)
                    }))
                }, e.prototype._subscribe = function(e) {
                    var t;
                    return null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(e)
                }, e.prototype[fc] = function() {
                    return this
                }, e.prototype.pipe = function() {
                    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                    return function(e) {
                        return 0 === e.length ? pc : 1 === e.length ? e[0] : function(t) {
                            return e.reduce((function(e, t) {
                                return t(e)
                            }), t)
                        }
                    }(e)(this)
                }, e.prototype.toPromise = function(e) {
                    var t = this;
                    return new(e = gc(e))((function(e, n) {
                        var i;
                        t.subscribe((function(e) {
                            return i = e
                        }), (function(e) {
                            return n(e)
                        }), (function() {
                            return e(i)
                        }))
                    }))
                }, e.create = function(t) {
                    return new e(t)
                }, e
            }();

            function gc(e) {
                var t;
                return null !== (t = null != e ? e : ic) && void 0 !== t ? t : Promise
            }
            var Ac = Kl((function(e) {
                    return function() {
                        e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed"
                    }
                })),
                vc = function(e) {
                    function t() {
                        var t = e.call(this) || this;
                        return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t
                    }
                    return Gl(t, e), t.prototype.lift = function(e) {
                        var t = new yc(this, this);
                        return t.operator = e, t
                    }, t.prototype._throwIfClosed = function() {
                        if (this.closed) throw new Ac
                    }, t.prototype.next = function(e) {
                        var t = this;
                        ac((function() {
                            var n, i;
                            if (t._throwIfClosed(), !t.isStopped) {
                                t.currentObservers || (t.currentObservers = Array.from(t.observers));
                                try {
                                    for (var r = jl(t.currentObservers), s = r.next(); !s.done; s = r.next()) s.value.next(e)
                                } catch (e) {
                                    n = {
                                        error: e
                                    }
                                } finally {
                                    try {
                                        s && !s.done && (i = r.return) && i.call(r)
                                    } finally {
                                        if (n) throw n.error
                                    }
                                }
                            }
                        }))
                    }, t.prototype.error = function(e) {
                        var t = this;
                        ac((function() {
                            if (t._throwIfClosed(), !t.isStopped) {
                                t.hasError = t.isStopped = !0, t.thrownError = e;
                                for (var n = t.observers; n.length;) n.shift().error(e)
                            }
                        }))
                    }, t.prototype.complete = function() {
                        var e = this;
                        ac((function() {
                            if (e._throwIfClosed(), !e.isStopped) {
                                e.isStopped = !0;
                                for (var t = e.observers; t.length;) t.shift().complete()
                            }
                        }))
                    }, t.prototype.unsubscribe = function() {
                        this.isStopped = this.closed = !0, this.observers = this.currentObservers = null
                    }, Object.defineProperty(t.prototype, "observed", {
                        get: function() {
                            var e;
                            return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype._trySubscribe = function(t) {
                        return this._throwIfClosed(), e.prototype._trySubscribe.call(this, t)
                    }, t.prototype._subscribe = function(e) {
                        return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e)
                    }, t.prototype._innerSubscribe = function(e) {
                        var t = this,
                            n = this,
                            i = n.hasError,
                            r = n.isStopped,
                            s = n.observers;
                        return i || r ? ec : (this.currentObservers = null, s.push(e), new $l((function() {
                            t.currentObservers = null, Zl(s, e)
                        })))
                    }, t.prototype._checkFinalizedStatuses = function(e) {
                        var t = this,
                            n = t.hasError,
                            i = t.thrownError,
                            r = t.isStopped;
                        n ? e.error(i) : r && e.complete()
                    }, t.prototype.asObservable = function() {
                        var e = new mc;
                        return e.source = this, e
                    }, t.create = function(e, t) {
                        return new yc(e, t)
                    }, t
                }(mc),
                yc = function(e) {
                    function t(t, n) {
                        var i = e.call(this) || this;
                        return i.destination = t, i.source = n, i
                    }
                    return Gl(t, e), t.prototype.next = function(e) {
                        var t, n;
                        null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.next) || void 0 === n || n.call(t, e)
                    }, t.prototype.error = function(e) {
                        var t, n;
                        null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.error) || void 0 === n || n.call(t, e)
                    }, t.prototype.complete = function() {
                        var e, t;
                        null === (t = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === t || t.call(e)
                    }, t.prototype._subscribe = function(e) {
                        var t, n;
                        return null !== (n = null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(e)) && void 0 !== n ? n : ec
                    }, t
                }(vc),
                _c = function(e) {
                    function t(t) {
                        var n = e.call(this) || this;
                        return n._value = t, n
                    }
                    return Gl(t, e), Object.defineProperty(t.prototype, "value", {
                        get: function() {
                            return this.getValue()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype._subscribe = function(t) {
                        var n = e.prototype._subscribe.call(this, t);
                        return !n.closed && t.next(this._value), n
                    }, t.prototype.getValue = function() {
                        var e = this,
                            t = e.hasError,
                            n = e.thrownError,
                            i = e._value;
                        if (t) throw n;
                        return this._throwIfClosed(), i
                    }, t.prototype.next = function(t) {
                        e.prototype.next.call(this, this._value = t)
                    }, t
                }(vc);

            function xc() {
                window.innerWidth < 768 && Ec.layout.next("mobile"), window.innerWidth >= 768 && Ec.layout.next("desktop")
            }
            var Ec = {
                loading: new _c({
                    isLoading: !0,
                    percent: null
                }),
                errors: new _c({
                    isError: !1,
                    message: null
                }),
                layout: new _c(null),
                resizeEvent: new _c(!1),
                deviceOrientation: new _c(null),
                renderingStatus: new _c(!1),
                modelLoadingIndicator: new _c({
                    isLoading: !1,
                    name: ""
                }),
                cam: new _c("bath"),
                complectation: new _c({
                    layout: "studio"
                })
            };
            xc(), window.addEventListener("resize", (function() {
                Ec.resizeEvent.next(!0), xc()
            }));
            for (var bc = [], wc = 0; wc < 256; wc++) bc[wc] = (wc < 16 ? "0" : "") + wc.toString(16);
            var Cc = 1234567,
                Sc = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        var e = 4294967295 * Math.random() | 0,
                            t = 4294967295 * Math.random() | 0,
                            n = 4294967295 * Math.random() | 0,
                            i = 4294967295 * Math.random() | 0;
                        return (bc[255 & e] + bc[e >> 8 & 255] + bc[e >> 16 & 255] + bc[e >> 24 & 255] + "-" + bc[255 & t] + bc[t >> 8 & 255] + "-" + bc[t >> 16 & 15 | 64] + bc[t >> 24 & 255] + "-" + bc[63 & n | 128] + bc[n >> 8 & 255] + "-" + bc[n >> 16 & 255] + bc[n >> 24 & 255] + bc[255 & i] + bc[i >> 8 & 255] + bc[i >> 16 & 255] + bc[i >> 24 & 255]).toUpperCase()
                    },
                    clamp: function(e, t, n) {
                        return Math.max(t, Math.min(n, e))
                    },
                    euclideanModulo: function(e, t) {
                        return (e % t + t) % t
                    },
                    mapLinear: function(e, t, n, i, r) {
                        return i + (e - t) * (r - i) / (n - t)
                    },
                    lerp: function(e, t, n) {
                        return (1 - n) * e + n * t
                    },
                    smoothstep: function(e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                    },
                    smootherstep: function(e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                    },
                    randInt: function(e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1))
                    },
                    randFloat: function(e, t) {
                        return e + Math.random() * (t - e)
                    },
                    randFloatSpread: function(e) {
                        return e * (.5 - Math.random())
                    },
                    seededRandom: function(e) {
                        return void 0 !== e && (Cc = e % 2147483647), ((Cc = 16807 * Cc % 2147483647) - 1) / 2147483646
                    },
                    degToRad: function(e) {
                        return e * Sc.DEG2RAD
                    },
                    radToDeg: function(e) {
                        return e * Sc.RAD2DEG
                    },
                    isPowerOfTwo: function(e) {
                        return !(e & e - 1) && 0 !== e
                    },
                    ceilPowerOfTwo: function(e) {
                        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                    },
                    floorPowerOfTwo: function(e) {
                        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                    },
                    setQuaternionFromProperEuler: function(e, t, n, i, r) {
                        var s = Math.cos,
                            o = Math.sin,
                            a = s(n / 2),
                            l = o(n / 2),
                            c = s((t + i) / 2),
                            u = o((t + i) / 2),
                            h = s((t - i) / 2),
                            d = o((t - i) / 2),
                            f = s((i - t) / 2),
                            p = o((i - t) / 2);
                        switch (r) {
                            case "XYX":
                                e.set(a * u, l * h, l * d, a * c);
                                break;
                            case "YZY":
                                e.set(l * d, a * u, l * h, a * c);
                                break;
                            case "ZXZ":
                                e.set(l * h, l * d, a * u, a * c);
                                break;
                            case "XZX":
                                e.set(a * u, l * p, l * f, a * c);
                                break;
                            case "YXY":
                                e.set(l * f, a * u, l * p, a * c);
                                break;
                            case "ZYZ":
                                e.set(l * p, l * f, a * u, a * c)
                        }
                    }
                };

            function Tc(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function Mc(e, t) {
                e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
            }
            var Ic, Bc, Rc, Dc, Pc, Lc, Uc, Nc, Oc, Fc, kc, Qc = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                zc = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                Hc = 1e8,
                Gc = 1e-8,
                Vc = 2 * Math.PI,
                jc = Vc / 4,
                Wc = 0,
                Xc = Math.sqrt,
                Yc = Math.cos,
                qc = Math.sin,
                Kc = function(e) {
                    return "string" == typeof e
                },
                Jc = function(e) {
                    return "function" == typeof e
                },
                Zc = function(e) {
                    return "number" == typeof e
                },
                $c = function(e) {
                    return void 0 === e
                },
                eu = function(e) {
                    return "object" == typeof e
                },
                tu = function(e) {
                    return !1 !== e
                },
                nu = function() {
                    return "undefined" != typeof window
                },
                iu = function(e) {
                    return Jc(e) || Kc(e)
                },
                ru = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
                su = Array.isArray,
                ou = /(?:-?\.?\d|\.)+/gi,
                au = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                lu = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                cu = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                uu = /[+-]=-?[.\d]+/,
                hu = /[^,'"\[\]\s]+/gi,
                du = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                fu = {},
                pu = {},
                mu = function(e) {
                    return (pu = Gu(e, fu)) && Gd
                },
                gu = function(e, t) {
                    return !t && void 0
                },
                Au = function(e, t) {
                    return e && (fu[e] = t) && pu && (pu[e] = t) || fu
                },
                vu = function() {
                    return 0
                },
                yu = {
                    suppressEvents: !0,
                    isStart: !0,
                    kill: !1
                },
                _u = {
                    suppressEvents: !0,
                    kill: !1
                },
                xu = {
                    suppressEvents: !0
                },
                Eu = {},
                bu = [],
                wu = {},
                Cu = {},
                Su = {},
                Tu = 30,
                Mu = [],
                Iu = "",
                Bu = function(e) {
                    var t, n, i = e[0];
                    if (eu(i) || Jc(i) || (e = [e]), !(t = (i._gsap || {}).harness)) {
                        for (n = Mu.length; n-- && !Mu[n].targetTest(i););
                        t = Mu[n]
                    }
                    for (n = e.length; n--;) e[n] && (e[n]._gsap || (e[n]._gsap = new id(e[n], t))) || e.splice(n, 1);
                    return e
                },
                Ru = function(e) {
                    return e._gsap || Bu(_h(e))[0]._gsap
                },
                Du = function(e, t, n) {
                    return (n = e[t]) && Jc(n) ? e[t]() : $c(n) && e.getAttribute && e.getAttribute(t) || n
                },
                Pu = function(e, t) {
                    return (e = e.split(",")).forEach(t) || e
                },
                Lu = function(e) {
                    return Math.round(1e5 * e) / 1e5 || 0
                },
                Uu = function(e) {
                    return Math.round(1e7 * e) / 1e7 || 0
                },
                Nu = function(e, t) {
                    var n = t.charAt(0),
                        i = parseFloat(t.substr(2));
                    return e = parseFloat(e), "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i
                },
                Ou = function(e, t) {
                    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;);
                    return i < n
                },
                Fu = function() {
                    var e, t, n = bu.length,
                        i = bu.slice(0);
                    for (wu = {}, bu.length = 0, e = 0; e < n; e++)(t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
                },
                ku = function(e, t, n, i) {
                    bu.length && !Bc && Fu(), e.render(t, n, Bc && t < 0 && (e._initted || e._startAt)), bu.length && !Bc && Fu()
                },
                Qu = function(e) {
                    var t = parseFloat(e);
                    return (t || 0 === t) && (e + "").match(hu).length < 2 ? t : Kc(e) ? e.trim() : e
                },
                zu = function(e) {
                    return e
                },
                Hu = function(e, t) {
                    for (var n in t) n in e || (e[n] = t[n]);
                    return e
                },
                Gu = function(e, t) {
                    for (var n in t) e[n] = t[n];
                    return e
                },
                Vu = function e(t, n) {
                    for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = eu(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
                    return t
                },
                ju = function(e, t) {
                    var n, i = {};
                    for (n in e) n in t || (i[n] = e[n]);
                    return i
                },
                Wu = function(e) {
                    var t, n = e.parent || Dc,
                        i = e.keyframes ? (t = su(e.keyframes), function(e, n) {
                            for (var i in n) i in e || "duration" === i && t || "ease" === i || (e[i] = n[i])
                        }) : Hu;
                    if (tu(e.inherit))
                        for (; n;) i(e, n.vars.defaults), n = n.parent || n._dp;
                    return e
                },
                Xu = function(e, t, n, i, r) {
                    var s, o = e[i];
                    if (r)
                        for (s = t[r]; o && o[r] > s;) o = o._prev;
                    return o ? (t._next = o._next, o._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = o, t.parent = t._dp = e, t
                },
                Yu = function(e, t, n, i) {
                    void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                    var r = t._prev,
                        s = t._next;
                    r ? r._next = s : e[n] === t && (e[n] = s), s ? s._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null
                },
                qu = function(e, t) {
                    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
                },
                Ku = function(e, t) {
                    if (e && (!t || t._end > e._dur || t._start < 0))
                        for (var n = e; n;) n._dirty = 1, n = n.parent;
                    return e
                },
                Ju = function(e, t, n, i) {
                    return e._startAt && (Bc ? e._startAt.revert(_u) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
                },
                Zu = function e(t) {
                    return !t || t._ts && e(t.parent)
                },
                $u = function(e) {
                    return e._repeat ? eh(e._tTime, e = e.duration() + e._rDelay) * e : 0
                },
                eh = function(e, t) {
                    var n = Math.floor(e = Uu(e / t));
                    return e && n === e ? n - 1 : n
                },
                th = function(e, t) {
                    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
                },
                nh = function(e) {
                    return e._end = Uu(e._start + (e._tDur / Math.abs(e._ts || e._rts || Gc) || 0))
                },
                ih = function(e, t) {
                    var n = e._dp;
                    return n && n.smoothChildTiming && e._ts && (e._start = Uu(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), nh(e), n._dirty || Ku(n, e)), e
                },
                rh = function(e, t) {
                    var n;
                    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = th(e.rawTime(), t), (!t._dur || gh(0, t.totalDuration(), n) - t._tTime > Gc) && t.render(n, !0)), Ku(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                        if (e._dur < e.duration())
                            for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                        e._zTime = -1e-8
                    }
                },
                sh = function(e, t, n, i) {
                    return t.parent && qu(t), t._start = Uu((Zc(n) ? n : n || e !== Dc ? fh(e, n, t) : e._time) + t._delay), t._end = Uu(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), Xu(e, t, "_first", "_last", e._sort ? "_start" : 0), ch(t) || (e._recent = t), i || rh(e, t), e._ts < 0 && ih(e, e._tTime), e
                },
                oh = function(e, t) {
                    return fu.ScrollTrigger ? fu.ScrollTrigger.create(t, e) : void 0
                },
                ah = function(e, t, n, i, r) {
                    return hd(e, t, r), e._initted ? !n && e._pt && !Bc && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && Oc !== Vh.frame ? (bu.push(e), e._lazy = [r, i], 1) : void 0 : 1
                },
                lh = function e(t) {
                    var n = t.parent;
                    return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
                },
                ch = function(e) {
                    var t = e.data;
                    return "isFromStart" === t || "isStart" === t
                },
                uh = function(e, t, n, i) {
                    var r = e._repeat,
                        s = Uu(t) || 0,
                        o = e._tTime / e._tDur;
                    return o && !i && (e._time *= s / e._dur), e._dur = s, e._tDur = r ? r < 0 ? 1e10 : Uu(s * (r + 1) + e._rDelay * r) : s, o > 0 && !i && ih(e, e._tTime = e._tDur * o), e.parent && nh(e), n || Ku(e.parent, e), e
                },
                hh = function(e) {
                    return e instanceof sd ? Ku(e) : uh(e, e._dur)
                },
                dh = {
                    _start: 0,
                    endTime: vu,
                    totalDuration: vu
                },
                fh = function e(t, n, i) {
                    var r, s, o, a = t.labels,
                        l = t._recent || dh,
                        c = t.duration() >= Hc ? l.endTime(!1) : t._dur;
                    return Kc(n) && (isNaN(n) || n in a) ? (s = n.charAt(0), o = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = c), a[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), o && i && (s = s / 100 * (su(i) ? i[0] : i).totalDuration()), r > 1 ? e(t, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n
                },
                ph = function(e, t, n) {
                    var i, r, s = Zc(t[1]),
                        o = (s ? 2 : 1) + (e < 2 ? 0 : 1),
                        a = t[o];
                    if (s && (a.duration = t[1]), a.parent = n, e) {
                        for (i = a, r = n; r && !("immediateRender" in i);) i = r.vars.defaults || {}, r = tu(r.vars.inherit) && r.parent;
                        a.immediateRender = tu(i.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[o - 1]
                    }
                    return new gd(t[0], a, t[o + 1])
                },
                mh = function(e, t) {
                    return e || 0 === e ? t(e) : t
                },
                gh = function(e, t, n) {
                    return n < e ? e : n > t ? t : n
                },
                Ah = function(e, t) {
                    return Kc(e) && (t = du.exec(e)) ? t[1] : ""
                },
                vh = [].slice,
                yh = function(e, t) {
                    return e && eu(e) && "length" in e && (!t && !e.length || e.length - 1 in e && eu(e[0])) && !e.nodeType && e !== Pc
                },
                _h = function(e, t, n) {
                    return Rc && !t && Rc.selector ? Rc.selector(e) : !Kc(e) || n || !Lc && jh() ? su(e) ? function(e, t, n) {
                        return void 0 === n && (n = []), e.forEach((function(e) {
                            var i;
                            return Kc(e) && !t || yh(e, 1) ? (i = n).push.apply(i, _h(e)) : n.push(e)
                        })) || n
                    }(e, n) : yh(e) ? vh.call(e, 0) : e ? [e] : [] : vh.call((t || Uc).querySelectorAll(e), 0)
                },
                xh = function(e) {
                    return e = _h(e)[0] || gu() || {},
                        function(t) {
                            var n = e.current || e.nativeElement || e;
                            return _h(t, n.querySelectorAll ? n : n === e ? gu() || Uc.createElement("div") : e)
                        }
                },
                Eh = function(e) {
                    return e.sort((function() {
                        return .5 - Math.random()
                    }))
                },
                bh = function(e) {
                    if (Jc(e)) return e;
                    var t = eu(e) ? e : {
                            each: e
                        },
                        n = Zh(t.ease),
                        i = t.from || 0,
                        r = parseFloat(t.base) || 0,
                        s = {},
                        o = i > 0 && i < 1,
                        a = isNaN(i) || o,
                        l = t.axis,
                        c = i,
                        u = i;
                    return Kc(i) ? c = u = {
                            center: .5,
                            edges: .5,
                            end: 1
                        } [i] || 0 : !o && a && (c = i[0], u = i[1]),
                        function(e, o, h) {
                            var d, f, p, m, g, A, v, y, _, x = (h || t).length,
                                E = s[x];
                            if (!E) {
                                if (!(_ = "auto" === t.grid ? 0 : (t.grid || [1, Hc])[1])) {
                                    for (v = -Hc; v < (v = h[_++].getBoundingClientRect().left) && _ < x;);
                                    _ < x && _--
                                }
                                for (E = s[x] = [], d = a ? Math.min(_, x) * c - .5 : i % _, f = _ === Hc ? 0 : a ? x * u / _ - .5 : i / _ | 0, v = 0, y = Hc, A = 0; A < x; A++) p = A % _ - d, m = f - (A / _ | 0), E[A] = g = l ? Math.abs("y" === l ? m : p) : Xc(p * p + m * m), g > v && (v = g), g < y && (y = g);
                                "random" === i && Eh(E), E.max = v - y, E.min = y, E.v = x = (parseFloat(t.amount) || parseFloat(t.each) * (_ > x ? x - 1 : l ? "y" === l ? x / _ : _ : Math.max(_, x / _)) || 0) * ("edges" === i ? -1 : 1), E.b = x < 0 ? r - x : r, E.u = Ah(t.amount || t.each) || 0, n = n && x < 0 ? Kh(n) : n
                            }
                            return x = (E[e] - E.min) / E.max || 0, Uu(E.b + (n ? n(x) : x) * E.v) + E.u
                        }
                },
                wh = function(e) {
                    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
                    return function(n) {
                        var i = Uu(Math.round(parseFloat(n) / e) * e * t);
                        return (i - i % 1) / t + (Zc(n) ? 0 : Ah(n))
                    }
                },
                Ch = function(e, t) {
                    var n, i, r = su(e);
                    return !r && eu(e) && (n = r = e.radius || Hc, e.values ? (e = _h(e.values), (i = !Zc(e[0])) && (n *= n)) : e = wh(e.increment)), mh(t, r ? Jc(e) ? function(t) {
                        return i = e(t), Math.abs(i - t) <= n ? i : t
                    } : function(t) {
                        for (var r, s, o = parseFloat(i ? t.x : t), a = parseFloat(i ? t.y : 0), l = Hc, c = 0, u = e.length; u--;)(r = i ? (r = e[u].x - o) * r + (s = e[u].y - a) * s : Math.abs(e[u] - o)) < l && (l = r, c = u);
                        return c = !n || l <= n ? e[c] : t, i || c === t || Zc(t) ? c : c + Ah(t)
                    } : wh(e))
                },
                Sh = function(e, t, n, i) {
                    return mh(su(e) ? !t : !0 === n ? !!(n = 0) : !i, (function() {
                        return su(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i
                    }))
                },
                Th = function(e, t, n) {
                    return mh(n, (function(n) {
                        return e[~~t(n)]
                    }))
                },
                Mh = function(e) {
                    for (var t, n, i, r, s = 0, o = ""; ~(t = e.indexOf("random(", s));) i = e.indexOf(")", t), r = "[" === e.charAt(t + 7), n = e.substr(t + 7, i - t - 7).match(r ? hu : ou), o += e.substr(s, t - s) + Sh(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1;
                    return o + e.substr(s, e.length - s)
                },
                Ih = function(e, t, n, i, r) {
                    var s = t - e,
                        o = i - n;
                    return mh(r, (function(t) {
                        return n + ((t - e) / s * o || 0)
                    }))
                },
                Bh = function(e, t, n) {
                    var i, r, s, o = e.labels,
                        a = Hc;
                    for (i in o)(r = o[i] - t) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i, a = r);
                    return s
                },
                Rh = function(e, t, n) {
                    var i, r, s, o = e.vars,
                        a = o[t],
                        l = Rc,
                        c = e._ctx;
                    if (a) return i = o[t + "Params"], r = o.callbackScope || e, n && bu.length && Fu(), c && (Rc = c), s = i ? a.apply(r, i) : a.call(r), Rc = l, s
                },
                Dh = function(e) {
                    return qu(e), e.scrollTrigger && e.scrollTrigger.kill(!!Bc), e.progress() < 1 && Rh(e, "onInterrupt"), e
                },
                Ph = [],
                Lh = function(e) {
                    if (e)
                        if (e = !e.name && e.default || e, nu() || e.headless) {
                            var t = e.name,
                                n = Jc(e),
                                i = t && !n && e.init ? function() {
                                    this._props = []
                                } : e,
                                r = {
                                    init: vu,
                                    render: Cd,
                                    add: cd,
                                    kill: Td,
                                    modifier: Sd,
                                    rawVars: 0
                                },
                                s = {
                                    targetTest: 0,
                                    get: 0,
                                    getSetter: xd,
                                    aliases: {},
                                    register: 0
                                };
                            if (jh(), e !== i) {
                                if (Cu[t]) return;
                                Hu(i, Hu(ju(e, r), s)), Gu(i.prototype, Gu(r, ju(e, s))), Cu[i.prop = t] = i, e.targetTest && (Mu.push(i), Eu[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                            }
                            Au(t, i), e.register && e.register(Gd, i, Bd)
                        } else Ph.push(e)
                },
                Uh = 255,
                Nh = {
                    aqua: [0, Uh, Uh],
                    lime: [0, Uh, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, Uh],
                    navy: [0, 0, 128],
                    white: [Uh, Uh, Uh],
                    olive: [128, 128, 0],
                    yellow: [Uh, Uh, 0],
                    orange: [Uh, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [Uh, 0, 0],
                    pink: [Uh, 192, 203],
                    cyan: [0, Uh, Uh],
                    transparent: [Uh, Uh, Uh, 0]
                },
                Oh = function(e, t, n) {
                    return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * Uh + .5 | 0
                },
                Fh = function(e, t, n) {
                    var i, r, s, o, a, l, c, u, h, d, f = e ? Zc(e) ? [e >> 16, e >> 8 & Uh, e & Uh] : 0 : Nh.black;
                    if (!f) {
                        if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Nh[e]) f = Nh[e];
                        else if ("#" === e.charAt(0)) {
                            if (e.length < 6 && (i = e.charAt(1), r = e.charAt(2), s = e.charAt(3), e = "#" + i + i + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(f = parseInt(e.substr(1, 6), 16)) >> 16, f >> 8 & Uh, f & Uh, parseInt(e.substr(7), 16) / 255];
                            f = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & Uh, e & Uh]
                        } else if ("hsl" === e.substr(0, 3))
                            if (f = d = e.match(ou), t) {
                                if (~e.indexOf("=")) return f = e.match(au), n && f.length < 4 && (f[3] = 1), f
                            } else o = +f[0] % 360 / 360, a = +f[1] / 100, i = 2 * (l = +f[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), f.length > 3 && (f[3] *= 1), f[0] = Oh(o + 1 / 3, i, r), f[1] = Oh(o, i, r), f[2] = Oh(o - 1 / 3, i, r);
                        else f = e.match(ou) || Nh.transparent;
                        f = f.map(Number)
                    }
                    return t && !d && (i = f[0] / Uh, r = f[1] / Uh, s = f[2] / Uh, l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2, c === u ? o = a = 0 : (h = c - u, a = l > .5 ? h / (2 - c - u) : h / (c + u), o = c === i ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - i) / h + 2 : (i - r) / h + 4, o *= 60), f[0] = ~~(o + .5), f[1] = ~~(100 * a + .5), f[2] = ~~(100 * l + .5)), n && f.length < 4 && (f[3] = 1), f
                },
                kh = function(e) {
                    var t = [],
                        n = [],
                        i = -1;
                    return e.split(zh).forEach((function(e) {
                        var r = e.match(lu) || [];
                        t.push.apply(t, r), n.push(i += r.length + 1)
                    })), t.c = n, t
                },
                Qh = function(e, t, n) {
                    var i, r, s, o, a = "",
                        l = (e + a).match(zh),
                        c = t ? "hsla(" : "rgba(",
                        u = 0;
                    if (!l) return e;
                    if (l = l.map((function(e) {
                            return (e = Fh(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
                        })), n && (s = kh(e), (i = n.c).join(a) !== s.c.join(a)))
                        for (o = (r = e.replace(zh, "1").split(lu)).length - 1; u < o; u++) a += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
                    if (!r)
                        for (o = (r = e.split(zh)).length - 1; u < o; u++) a += r[u] + l[u];
                    return a + r[o]
                },
                zh = function() {
                    var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                    for (e in Nh) t += "|" + e + "\\b";
                    return new RegExp(t + ")", "gi")
                }(),
                Hh = /hsl[a]?\(/,
                Gh = function(e) {
                    var t, n = e.join(" ");
                    if (zh.lastIndex = 0, zh.test(n)) return t = Hh.test(n), e[1] = Qh(e[1], t), e[0] = Qh(e[0], t, kh(e[1])), !0
                },
                Vh = function() {
                    var e, t, n, i, r, s, o = Date.now,
                        a = 500,
                        l = 33,
                        c = o(),
                        u = c,
                        h = 1e3 / 240,
                        d = h,
                        f = [],
                        p = function n(p) {
                            var m, g, A, v, y = o() - u,
                                _ = !0 === p;
                            if ((y > a || y < 0) && (c += y - l), ((m = (A = (u += y) - c) - d) > 0 || _) && (v = ++i.frame, r = A - 1e3 * i.time, i.time = A /= 1e3, d += m + (m >= h ? 4 : h - m), g = 1), _ || (e = t(n)), g)
                                for (s = 0; s < f.length; s++) f[s](A, r, v, p)
                        };
                    return i = {
                        time: 0,
                        frame: 0,
                        tick: function() {
                            p(!0)
                        },
                        deltaRatio: function(e) {
                            return r / (1e3 / (e || 60))
                        },
                        wake: function() {
                            Nc && (!Lc && nu() && (Pc = Lc = window, Uc = Pc.document || {}, fu.gsap = Gd, (Pc.gsapVersions || (Pc.gsapVersions = [])).push(Gd.version), mu(pu || Pc.GreenSockGlobals || !Pc.gsap && Pc || {}), Ph.forEach(Lh)), n = "undefined" != typeof requestAnimationFrame && requestAnimationFrame, e && i.sleep(), t = n || function(e) {
                                return setTimeout(e, d - 1e3 * i.time + 1 | 0)
                            }, kc = 1, p(2))
                        },
                        sleep: function() {
                            (n ? cancelAnimationFrame : clearTimeout)(e), kc = 0, t = vu
                        },
                        lagSmoothing: function(e, t) {
                            a = e || 1 / 0, l = Math.min(t || 33, a)
                        },
                        fps: function(e) {
                            h = 1e3 / (e || 240), d = 1e3 * i.time + h
                        },
                        add: function(e, t, n) {
                            var r = t ? function(t, n, s, o) {
                                e(t, n, s, o), i.remove(r)
                            } : e;
                            return i.remove(e), f[n ? "unshift" : "push"](r), jh(), r
                        },
                        remove: function(e, t) {
                            ~(t = f.indexOf(e)) && f.splice(t, 1) && s >= t && s--
                        },
                        _listeners: f
                    }, i
                }(),
                jh = function() {
                    return !kc && Vh.wake()
                },
                Wh = {},
                Xh = /^[\d.\-M][\d.\-,\s]/,
                Yh = /["']/g,
                qh = function(e) {
                    for (var t, n, i, r = {}, s = e.substr(1, e.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++) n = s[a], t = a !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, t), r[o] = isNaN(i) ? i.replace(Yh, "").trim() : +i, o = n.substr(t + 1).trim();
                    return r
                },
                Kh = function(e) {
                    return function(t) {
                        return 1 - e(1 - t)
                    }
                },
                Jh = function e(t, n) {
                    for (var i, r = t._first; r;) r instanceof sd ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
                },
                Zh = function(e, t) {
                    return e && (Jc(e) ? e : Wh[e] || function(e) {
                        var t, n, i, r, s = (e + "").split("("),
                            o = Wh[s[0]];
                        return o && s.length > 1 && o.config ? o.config.apply(null, ~e.indexOf("{") ? [qh(s[1])] : (t = e, n = t.indexOf("(") + 1, i = t.indexOf(")"), r = t.indexOf("(", n), t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(Qu)) : Wh._CE && Xh.test(e) ? Wh._CE("", e) : o
                    }(e)) || t
                },
                $h = function(e, t, n, i) {
                    void 0 === n && (n = function(e) {
                        return 1 - t(1 - e)
                    }), void 0 === i && (i = function(e) {
                        return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
                    });
                    var r, s = {
                        easeIn: t,
                        easeOut: n,
                        easeInOut: i
                    };
                    return Pu(e, (function(e) {
                        for (var t in Wh[e] = fu[e] = s, Wh[r = e.toLowerCase()] = n, s) Wh[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Wh[e + "." + t] = s[t]
                    })), s
                },
                ed = function(e) {
                    return function(t) {
                        return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
                    }
                },
                td = function e(t, n, i) {
                    var r = n >= 1 ? n : 1,
                        s = (i || (t ? .3 : .45)) / (n < 1 ? n : 1),
                        o = s / Vc * (Math.asin(1 / r) || 0),
                        a = function(e) {
                            return 1 === e ? 1 : r * Math.pow(2, -10 * e) * qc((e - o) * s) + 1
                        },
                        l = "out" === t ? a : "in" === t ? function(e) {
                            return 1 - a(1 - e)
                        } : ed(a);
                    return s = Vc / s, l.config = function(n, i) {
                        return e(t, n, i)
                    }, l
                },
                nd = function e(t, n) {
                    void 0 === n && (n = 1.70158);
                    var i = function(e) {
                            return e ? --e * e * ((n + 1) * e + n) + 1 : 0
                        },
                        r = "out" === t ? i : "in" === t ? function(e) {
                            return 1 - i(1 - e)
                        } : ed(i);
                    return r.config = function(n) {
                        return e(t, n)
                    }, r
                };
            Pu("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
                    var n = t < 5 ? t + 1 : t;
                    $h(e + ",Power" + (n - 1), t ? function(e) {
                        return Math.pow(e, n)
                    } : function(e) {
                        return e
                    }, (function(e) {
                        return 1 - Math.pow(1 - e, n)
                    }), (function(e) {
                        return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2
                    }))
                })), Wh.Linear.easeNone = Wh.none = Wh.Linear.easeIn, $h("Elastic", td("in"), td("out"), td()),
                function(e, t) {
                    var n = 1 / t,
                        i = function(i) {
                            return i < n ? e * i * i : i < .7272727272727273 ? e * Math.pow(i - 1.5 / t, 2) + .75 : i < .9090909090909092 ? e * (i -= 2.25 / t) * i + .9375 : e * Math.pow(i - 2.625 / t, 2) + .984375
                        };
                    $h("Bounce", (function(e) {
                        return 1 - i(1 - e)
                    }), i)
                }(7.5625, 2.75), $h("Expo", (function(e) {
                    return Math.pow(2, 10 * (e - 1)) * e + e * e * e * e * e * e * (1 - e)
                })), $h("Circ", (function(e) {
                    return -(Xc(1 - e * e) - 1)
                })), $h("Sine", (function(e) {
                    return 1 === e ? 1 : 1 - Yc(e * jc)
                })), $h("Back", nd("in"), nd("out"), nd()), Wh.SteppedEase = Wh.steps = fu.SteppedEase = {
                    config: function(e, t) {
                        void 0 === e && (e = 1);
                        var n = 1 / e,
                            i = e + (t ? 0 : 1),
                            r = t ? 1 : 0;
                        return function(e) {
                            return ((i * gh(0, .99999999, e) | 0) + r) * n
                        }
                    }
                }, zc.ease = Wh["quad.out"], Pu("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
                    return Iu += e + "," + e + "Params,"
                }));
            var id = function(e, t) {
                    this.id = Wc++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Du, this.set = t ? t.getSetter : xd
                },
                rd = function() {
                    function e(e) {
                        this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, uh(this, +e.duration, 1, 1), this.data = e.data, Rc && (this._ctx = Rc, Rc.data.push(this)), kc || Vh.wake()
                    }
                    var t = e.prototype;
                    return t.delay = function(e) {
                        return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
                    }, t.duration = function(e) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
                    }, t.totalDuration = function(e) {
                        return arguments.length ? (this._dirty = 0, uh(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                    }, t.totalTime = function(e, t) {
                        if (jh(), !arguments.length) return this._tTime;
                        var n = this._dp;
                        if (n && n.smoothChildTiming && this._ts) {
                            for (ih(this, e), !n._dp || n.parent || rh(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && sh(this._dp, this, this._start - this._delay)
                        }
                        return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === Gc || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), ku(this, e, t)), this
                    }, t.time = function(e, t) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + $u(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
                    }, t.totalProgress = function(e, t) {
                        return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
                    }, t.progress = function(e, t) {
                        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + $u(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                    }, t.iteration = function(e, t) {
                        var n = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? eh(this._tTime, n) + 1 : 1
                    }, t.timeScale = function(e, t) {
                        if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                        if (this._rts === e) return this;
                        var n = this.parent && this._ts ? th(this.parent._time, this) : this._tTime;
                        return this._rts = +e || 0, this._ts = this._ps || -1e-8 === e ? 0 : this._rts, this.totalTime(gh(-Math.abs(this._delay), this._tDur, n), !1 !== t), nh(this),
                            function(e) {
                                for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                                return e
                            }(this)
                    }, t.paused = function(e) {
                        return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (jh(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== Gc && (this._tTime -= Gc)))), this) : this._ps
                    }, t.startTime = function(e) {
                        if (arguments.length) {
                            this._start = e;
                            var t = this.parent || this._dp;
                            return t && (t._sort || !this.parent) && sh(t, this, e - this._delay), this
                        }
                        return this._start
                    }, t.endTime = function(e) {
                        return this._start + (tu(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                    }, t.rawTime = function(e) {
                        var t = this.parent || this._dp;
                        return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? th(t.rawTime(e), this) : this._tTime : this._tTime
                    }, t.revert = function(e) {
                        void 0 === e && (e = xu);
                        var t = Bc;
                        return Bc = e, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e), this.totalTime(-.01, e.suppressEvents)), "nested" !== this.data && !1 !== e.kill && this.kill(), Bc = t, this
                    }, t.globalTime = function(e) {
                        for (var t = this, n = arguments.length ? e : t.rawTime(); t;) n = t._start + n / (Math.abs(t._ts) || 1), t = t._dp;
                        return !this.parent && this._sat ? this._sat.globalTime(e) : n
                    }, t.repeat = function(e) {
                        return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, hh(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                    }, t.repeatDelay = function(e) {
                        if (arguments.length) {
                            var t = this._time;
                            return this._rDelay = e, hh(this), t ? this.time(t) : this
                        }
                        return this._rDelay
                    }, t.yoyo = function(e) {
                        return arguments.length ? (this._yoyo = e, this) : this._yoyo
                    }, t.seek = function(e, t) {
                        return this.totalTime(fh(this, e), tu(t))
                    }, t.restart = function(e, t) {
                        return this.play().totalTime(e ? -this._delay : 0, tu(t)), this._dur || (this._zTime = -1e-8), this
                    }, t.play = function(e, t) {
                        return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                    }, t.reverse = function(e, t) {
                        return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                    }, t.pause = function(e, t) {
                        return null != e && this.seek(e, t), this.paused(!0)
                    }, t.resume = function() {
                        return this.paused(!1)
                    }, t.reversed = function(e) {
                        return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)), this) : this._rts < 0
                    }, t.invalidate = function() {
                        return this._initted = this._act = 0, this._zTime = -1e-8, this
                    }, t.isActive = function() {
                        var e, t = this.parent || this._dp,
                            n = this._start;
                        return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - Gc))
                    }, t.eventCallback = function(e, t, n) {
                        var i = this.vars;
                        return arguments.length > 1 ? (t ? (i[e] = t, n && (i[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete i[e], this) : i[e]
                    }, t.then = function(e) {
                        var t = this;
                        return new Promise((function(n) {
                            var i = Jc(e) ? e : zu,
                                r = function() {
                                    var e = t.then;
                                    t.then = null, Jc(i) && (i = i(t)) && (i.then || i === t) && (t.then = e), n(i), t.then = e
                                };
                            t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
                        }))
                    }, t.kill = function() {
                        Dh(this)
                    }, e
                }();
            Hu(rd.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -1e-8,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var sd = function(e) {
                function t(t, n) {
                    var i;
                    return void 0 === t && (t = {}), (i = e.call(this, t) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = tu(t.sortChildren), Dc && sh(t.parent || Dc, Tc(i), n), t.reversed && i.reverse(), t.paused && i.paused(!0), t.scrollTrigger && oh(Tc(i), t.scrollTrigger), i
                }
                Mc(t, e);
                var n = t.prototype;
                return n.to = function(e, t, n) {
                    return ph(0, arguments, this), this
                }, n.from = function(e, t, n) {
                    return ph(1, arguments, this), this
                }, n.fromTo = function(e, t, n, i) {
                    return ph(2, arguments, this), this
                }, n.set = function(e, t, n) {
                    return t.duration = 0, t.parent = this, Wu(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new gd(e, t, fh(this, n), 1), this
                }, n.call = function(e, t, n) {
                    return sh(this, gd.delayedCall(0, e, t), n)
                }, n.staggerTo = function(e, t, n, i, r, s, o) {
                    return n.duration = t, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = o, n.parent = this, new gd(e, n, fh(this, r)), this
                }, n.staggerFrom = function(e, t, n, i, r, s, o) {
                    return n.runBackwards = 1, Wu(n).immediateRender = tu(n.immediateRender), this.staggerTo(e, t, n, i, r, s, o)
                }, n.staggerFromTo = function(e, t, n, i, r, s, o, a) {
                    return i.startAt = n, Wu(i).immediateRender = tu(i.immediateRender), this.staggerTo(e, t, i, r, s, o, a)
                }, n.render = function(e, t, n) {
                    var i, r, s, o, a, l, c, u, h, d, f, p, m = this._time,
                        g = this._dirty ? this.totalDuration() : this._tDur,
                        A = this._dur,
                        v = e <= 0 ? 0 : Uu(e),
                        y = this._zTime < 0 != e < 0 && (this._initted || !A);
                    if (this !== Dc && v > g && e >= 0 && (v = g), v !== this._tTime || n || y) {
                        if (m !== this._time && A && (v += this._time - m, e += this._time - m), i = v, h = this._start, l = !(u = this._ts), y && (A || (m = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) {
                            if (f = this._yoyo, a = A + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * a + e, t, n);
                            if (i = Uu(v % a), v === g ? (o = this._repeat, i = A) : ((o = ~~(d = Uu(v / a))) && o === d && (i = A, o--), i > A && (i = A)), d = eh(this._tTime, a), !m && this._tTime && d !== o && this._tTime - d * a - this._dur <= 0 && (d = o), f && 1 & o && (i = A - i, p = 1), o !== d && !this._lock) {
                                var _ = f && 1 & d,
                                    x = _ === (f && 1 & o);
                                if (o < d && (_ = !_), m = _ ? 0 : v % A ? A : v, this._lock = 1, this.render(m || (p ? 0 : Uu(o * a)), t, !A)._lock = 0, this._tTime = v, !t && this.parent && Rh(this, "onRepeat"), this.vars.repeatRefresh && !p && (this.invalidate()._lock = 1), m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                                if (A = this._dur, g = this._tDur, x && (this._lock = 2, m = _ ? A : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !p && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                                Jh(this, p)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(e, t, n) {
                                var i;
                                if (n > t)
                                    for (i = e._first; i && i._start <= n;) {
                                        if ("isPause" === i.data && i._start > t) return i;
                                        i = i._next
                                    } else
                                        for (i = e._last; i && i._start >= n;) {
                                            if ("isPause" === i.data && i._start < t) return i;
                                            i = i._prev
                                        }
                            }(this, Uu(m), Uu(i)), c && (v -= i - (i = c._start))), this._tTime = v, this._time = i, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, m = 0), !m && i && !t && !o && (Rh(this, "onStart"), this._tTime !== v)) return this;
                        if (i >= m && e >= 0)
                            for (r = this._first; r;) {
                                if (s = r._next, (r._act || i >= r._start) && r._ts && c !== r) {
                                    if (r.parent !== this) return this.render(e, t, n);
                                    if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, t, n), i !== this._time || !this._ts && !l) {
                                        c = 0, s && (v += this._zTime = -1e-8);
                                        break
                                    }
                                }
                                r = s
                            } else {
                                r = this._last;
                                for (var E = e < 0 ? e : i; r;) {
                                    if (s = r._prev, (r._act || E <= r._end) && r._ts && c !== r) {
                                        if (r.parent !== this) return this.render(e, t, n);
                                        if (r.render(r._ts > 0 ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, t, n || Bc && (r._initted || r._startAt)), i !== this._time || !this._ts && !l) {
                                            c = 0, s && (v += this._zTime = E ? -1e-8 : Gc);
                                            break
                                        }
                                    }
                                    r = s
                                }
                            }
                        if (c && !t && (this.pause(), c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = h, nh(this), this.render(e, t, n);
                        this._onUpdate && !t && Rh(this, "onUpdate", !0), (v === g && this._tTime >= this.totalDuration() || !v && m) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((e || !A) && (v === g && this._ts > 0 || !v && this._ts < 0) && qu(this, 1), t || e < 0 && !m || !v && !m && g || (Rh(this, v === g && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < g && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }, n.add = function(e, t) {
                    var n = this;
                    if (Zc(t) || (t = fh(this, t, e)), !(e instanceof rd)) {
                        if (su(e)) return e.forEach((function(e) {
                            return n.add(e, t)
                        })), this;
                        if (Kc(e)) return this.addLabel(e, t);
                        if (!Jc(e)) return this;
                        e = gd.delayedCall(0, e)
                    }
                    return this !== e ? sh(this, e, t) : this
                }, n.getChildren = function(e, t, n, i) {
                    void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = -Hc);
                    for (var r = [], s = this._first; s;) s._start >= i && (s instanceof gd ? t && r.push(s) : (n && r.push(s), e && r.push.apply(r, s.getChildren(!0, t, n)))), s = s._next;
                    return r
                }, n.getById = function(e) {
                    for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)
                        if (t[n].vars.id === e) return t[n]
                }, n.remove = function(e) {
                    return Kc(e) ? this.removeLabel(e) : Jc(e) ? this.killTweensOf(e) : (e.parent === this && Yu(this, e), e === this._recent && (this._recent = this._last), Ku(this))
                }, n.totalTime = function(t, n) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Uu(Vh.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime
                }, n.addLabel = function(e, t) {
                    return this.labels[e] = fh(this, t), this
                }, n.removeLabel = function(e) {
                    return delete this.labels[e], this
                }, n.addPause = function(e, t, n) {
                    var i = gd.delayedCall(0, t || vu, n);
                    return i.data = "isPause", this._hasPause = 1, sh(this, i, fh(this, e))
                }, n.removePause = function(e) {
                    var t = this._first;
                    for (e = fh(this, e); t;) t._start === e && "isPause" === t.data && qu(t), t = t._next
                }, n.killTweensOf = function(e, t, n) {
                    for (var i = this.getTweensOf(e, n), r = i.length; r--;) od !== i[r] && i[r].kill(e, t);
                    return this
                }, n.getTweensOf = function(e, t) {
                    for (var n, i = [], r = _h(e), s = this._first, o = Zc(t); s;) s instanceof gd ? Ou(s._targets, r) && (o ? (!od || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n), s = s._next;
                    return i
                }, n.tweenTo = function(e, t) {
                    t = t || {};
                    var n, i = this,
                        r = fh(i, e),
                        s = t,
                        o = s.startAt,
                        a = s.onStart,
                        l = s.onStartParams,
                        c = s.immediateRender,
                        u = gd.to(i, Hu({
                            ease: t.ease || "none",
                            lazy: !1,
                            immediateRender: !1,
                            time: r,
                            overwrite: "auto",
                            duration: t.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale()) || Gc,
                            onStart: function() {
                                if (i.pause(), !n) {
                                    var e = t.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale());
                                    u._dur !== e && uh(u, e, 0, 1).render(u._time, !0, !0), n = 1
                                }
                                a && a.apply(u, l || [])
                            }
                        }, t));
                    return c ? u.render(0) : u
                }, n.tweenFromTo = function(e, t, n) {
                    return this.tweenTo(t, Hu({
                        startAt: {
                            time: fh(this, e)
                        }
                    }, n))
                }, n.recent = function() {
                    return this._recent
                }, n.nextLabel = function(e) {
                    return void 0 === e && (e = this._time), Bh(this, fh(this, e))
                }, n.previousLabel = function(e) {
                    return void 0 === e && (e = this._time), Bh(this, fh(this, e), 1)
                }, n.currentLabel = function(e) {
                    return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + Gc)
                }, n.shiftChildren = function(e, t, n) {
                    void 0 === n && (n = 0);
                    for (var i, r = this._first, s = this.labels; r;) r._start >= n && (r._start += e, r._end += e), r = r._next;
                    if (t)
                        for (i in s) s[i] >= n && (s[i] += e);
                    return Ku(this)
                }, n.invalidate = function(t) {
                    var n = this._first;
                    for (this._lock = 0; n;) n.invalidate(t), n = n._next;
                    return e.prototype.invalidate.call(this, t)
                }, n.clear = function(e) {
                    void 0 === e && (e = !0);
                    for (var t, n = this._first; n;) t = n._next, this.remove(n), n = t;
                    return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), Ku(this)
                }, n.totalDuration = function(e) {
                    var t, n, i, r = 0,
                        s = this,
                        o = s._last,
                        a = Hc;
                    if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e));
                    if (s._dirty) {
                        for (i = s.parent; o;) t = o._prev, o._dirty && o.totalDuration(), (n = o._start) > a && s._sort && o._ts && !s._lock ? (s._lock = 1, sh(s, o, n - o._delay, 1)._lock = 0) : a = n, n < 0 && o._ts && (r -= n, (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -1 / 0), a = 0), o._end > r && o._ts && (r = o._end), o = t;
                        uh(s, s === Dc && s._time > r ? s._time : r, 1, 1), s._dirty = 0
                    }
                    return s._tDur
                }, t.updateRoot = function(e) {
                    if (Dc._ts && (ku(Dc, th(e, Dc)), Oc = Vh.frame), Vh.frame >= Tu) {
                        Tu += Qc.autoSleep || 120;
                        var t = Dc._first;
                        if ((!t || !t._ts) && Qc.autoSleep && Vh._listeners.length < 2) {
                            for (; t && !t._ts;) t = t._next;
                            t || Vh.sleep()
                        }
                    }
                }, t
            }(rd);
            Hu(sd.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var od, ad, ld = function(e, t, n, i, r, s, o) {
                    var a, l, c, u, h, d, f, p, m = new Bd(this._pt, e, t, 0, 1, wd, null, r),
                        g = 0,
                        A = 0;
                    for (m.b = n, m.e = i, n += "", (f = ~(i += "").indexOf("random(")) && (i = Mh(i)), s && (s(p = [n, i], e, t), n = p[0], i = p[1]), l = n.match(cu) || []; a = cu.exec(i);) u = a[0], h = i.substring(g, a.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[A++] && (d = parseFloat(l[A - 1]) || 0, m._pt = {
                        _next: m._pt,
                        p: h || 1 === A ? h : ",",
                        s: d,
                        c: "=" === u.charAt(1) ? Nu(d, u) - d : parseFloat(u) - d,
                        m: c && c < 4 ? Math.round : 0
                    }, g = cu.lastIndex);
                    return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = o, (uu.test(i) || f) && (m.e = 0), this._pt = m, m
                },
                cd = function(e, t, n, i, r, s, o, a, l, c) {
                    Jc(i) && (i = i(r || 0, e, s));
                    var u, h = e[t],
                        d = "get" !== n ? n : Jc(h) ? l ? e[t.indexOf("set") || !Jc(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : h,
                        f = Jc(h) ? l ? yd : vd : Ad;
                    if (Kc(i) && (~i.indexOf("random(") && (i = Mh(i)), "=" === i.charAt(1) && ((u = Nu(d, i) + (Ah(d) || 0)) || 0 === u) && (i = u)), !c || d !== i || ad) return isNaN(d * i) || "" === i ? ld.call(this, e, t, d, i, f, a || Qc.stringFilter, l) : (u = new Bd(this._pt, e, t, +d || 0, i - (d || 0), "boolean" == typeof h ? bd : Ed, 0, f), l && (u.fp = l), o && u.modifier(o, this, e), this._pt = u)
                },
                ud = function(e, t, n, i, r, s) {
                    var o, a, l, c;
                    if (Cu[e] && !1 !== (o = new Cu[e]).init(r, o.rawVars ? t[e] : function(e, t, n, i, r) {
                            if (Jc(e) && (e = fd(e, r, t, n, i)), !eu(e) || e.style && e.nodeType || su(e) || ru(e)) return Kc(e) ? fd(e, r, t, n, i) : e;
                            var s, o = {};
                            for (s in e) o[s] = fd(e[s], r, t, n, i);
                            return o
                        }(t[e], i, r, s, n), n, i, s) && (n._pt = a = new Bd(n._pt, r, e, 0, 1, o.render, o, 0, o.priority), n !== Fc))
                        for (l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length; c--;) l[o._props[c]] = a;
                    return o
                },
                hd = function e(t, n, i) {
                    var r, s, o, a, l, c, u, h, d, f, p, m, g, A = t.vars,
                        v = A.ease,
                        y = A.startAt,
                        _ = A.immediateRender,
                        x = A.lazy,
                        E = A.onUpdate,
                        b = A.runBackwards,
                        w = A.yoyoEase,
                        C = A.keyframes,
                        S = A.autoRevert,
                        T = t._dur,
                        M = t._startAt,
                        I = t._targets,
                        B = t.parent,
                        R = B && "nested" === B.data ? B.vars.targets : I,
                        D = "auto" === t._overwrite && !Ic,
                        P = t.timeline;
                    if (P && (!C || !v) && (v = "none"), t._ease = Zh(v, zc.ease), t._yEase = w ? Kh(Zh(!0 === w ? v : w, zc.ease)) : 0, w && t._yoyo && !t._repeat && (w = t._yEase, t._yEase = t._ease, t._ease = w), t._from = !P && !!A.runBackwards, !P || C && !A.stagger) {
                        if (m = (h = I[0] ? Ru(I[0]).harness : 0) && A[h.prop], r = ju(A, Eu), M && (M._zTime < 0 && M.progress(1), n < 0 && b && _ && !S ? M.render(-1, !0) : M.revert(b && T ? _u : yu), M._lazy = 0), y) {
                            if (qu(t._startAt = gd.set(I, Hu({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: B,
                                    immediateRender: !0,
                                    lazy: !M && tu(x),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: E && function() {
                                        return Rh(t, "onUpdate")
                                    },
                                    stagger: 0
                                }, y))), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (Bc || !_ && !S) && t._startAt.revert(_u), _ && T && n <= 0 && i <= 0) return void(n && (t._zTime = n))
                        } else if (b && T && !M)
                            if (n && (_ = !1), o = Hu({
                                    overwrite: !1,
                                    data: "isFromStart",
                                    lazy: _ && !M && tu(x),
                                    immediateRender: _,
                                    stagger: 0,
                                    parent: B
                                }, r), m && (o[h.prop] = m), qu(t._startAt = gd.set(I, o)), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (Bc ? t._startAt.revert(_u) : t._startAt.render(-1, !0)), t._zTime = n, _) {
                                if (!n) return
                            } else e(t._startAt, Gc, Gc);
                        for (t._pt = t._ptCache = 0, x = T && tu(x) || x && !T, s = 0; s < I.length; s++) {
                            if (u = (l = I[s])._gsap || Bu(I)[s]._gsap, t._ptLookup[s] = f = {}, wu[u.id] && bu.length && Fu(), p = R === I ? s : R.indexOf(l), h && !1 !== (d = new h).init(l, m || r, t, p, R) && (t._pt = a = new Bd(t._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function(e) {
                                    f[e] = a
                                })), d.priority && (c = 1)), !h || m)
                                for (o in r) Cu[o] && (d = ud(o, r, t, p, l, R)) ? d.priority && (c = 1) : f[o] = a = cd.call(t, l, o, "get", r[o], p, R, 0, A.stringFilter);
                            t._op && t._op[s] && t.kill(l, t._op[s]), D && t._pt && (od = t, Dc.killTweensOf(l, f, t.globalTime(n)), g = !t.parent, od = 0), t._pt && x && (wu[u.id] = 1)
                        }
                        c && Id(t), t._onInit && t._onInit(t)
                    }
                    t._onUpdate = E, t._initted = (!t._op || t._pt) && !g, C && n <= 0 && P.render(Hc, !0, !0)
                },
                dd = function(e, t, n, i) {
                    var r, s, o = t.ease || i || "power1.inOut";
                    if (su(t)) s = n[e] || (n[e] = []), t.forEach((function(e, n) {
                        return s.push({
                            t: n / (t.length - 1) * 100,
                            v: e,
                            e: o
                        })
                    }));
                    else
                        for (r in t) s = n[r] || (n[r] = []), "ease" === r || s.push({
                            t: parseFloat(e),
                            v: t[r],
                            e: o
                        })
                },
                fd = function(e, t, n, i, r) {
                    return Jc(e) ? e.call(t, n, i, r) : Kc(e) && ~e.indexOf("random(") ? Mh(e) : e
                },
                pd = Iu + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                md = {};
            Pu(pd + ",id,stagger,delay,duration,paused,scrollTrigger", (function(e) {
                return md[e] = 1
            }));
            var gd = function(e) {
                function t(t, n, i, r) {
                    var s;
                    "number" == typeof n && (i.duration = n, n = i, i = null);
                    var o, a, l, c, u, h, d, f, p = (s = e.call(this, r ? n : Wu(n)) || this).vars,
                        m = p.duration,
                        g = p.delay,
                        A = p.immediateRender,
                        v = p.stagger,
                        y = p.overwrite,
                        _ = p.keyframes,
                        x = p.defaults,
                        E = p.scrollTrigger,
                        b = p.yoyoEase,
                        w = n.parent || Dc,
                        C = (su(t) || ru(t) ? Zc(t[0]) : "length" in n) ? [t] : _h(t);
                    if (s._targets = C.length ? Bu(C) : gu(0, !Qc.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = y, _ || v || iu(m) || iu(g)) {
                        if (n = s.vars, (o = s.timeline = new sd({
                                data: "nested",
                                defaults: x || {},
                                targets: w && "nested" === w.data ? w.vars.targets : C
                            })).kill(), o.parent = o._dp = Tc(s), o._start = 0, v || iu(m) || iu(g)) {
                            if (c = C.length, d = v && bh(v), eu(v))
                                for (u in v) ~pd.indexOf(u) && (f || (f = {}), f[u] = v[u]);
                            for (a = 0; a < c; a++)(l = ju(n, md)).stagger = 0, b && (l.yoyoEase = b), f && Gu(l, f), h = C[a], l.duration = +fd(m, Tc(s), a, h, C), l.delay = (+fd(g, Tc(s), a, h, C) || 0) - s._delay, !v && 1 === c && l.delay && (s._delay = g = l.delay, s._start += g, l.delay = 0), o.to(h, l, d ? d(a, h, C) : 0), o._ease = Wh.none;
                            o.duration() ? m = g = 0 : s.timeline = 0
                        } else if (_) {
                            Wu(Hu(o.vars.defaults, {
                                ease: "none"
                            })), o._ease = Zh(_.ease || n.ease || "none");
                            var S, T, M, I = 0;
                            if (su(_)) _.forEach((function(e) {
                                return o.to(C, e, ">")
                            })), o.duration();
                            else {
                                for (u in l = {}, _) "ease" === u || "easeEach" === u || dd(u, _[u], l, _.easeEach);
                                for (u in l)
                                    for (S = l[u].sort((function(e, t) {
                                            return e.t - t.t
                                        })), I = 0, a = 0; a < S.length; a++)(M = {
                                        ease: (T = S[a]).e,
                                        duration: (T.t - (a ? S[a - 1].t : 0)) / 100 * m
                                    })[u] = T.v, o.to(C, M, I), I += M.duration;
                                o.duration() < m && o.to({}, {
                                    duration: m - o.duration()
                                })
                            }
                        }
                        m || s.duration(m = o.duration())
                    } else s.timeline = 0;
                    return !0 !== y || Ic || (od = Tc(s), Dc.killTweensOf(C), od = 0), sh(w, Tc(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), (A || !m && !_ && s._start === Uu(w._time) && tu(A) && Zu(Tc(s)) && "nested" !== w.data) && (s._tTime = -1e-8, s.render(Math.max(0, -g) || 0)), E && oh(Tc(s), E), s
                }
                Mc(t, e);
                var n = t.prototype;
                return n.render = function(e, t, n) {
                    var i, r, s, o, a, l, c, u, h, d = this._time,
                        f = this._tDur,
                        p = this._dur,
                        m = e < 0,
                        g = e > f - Gc && !m ? f : e < Gc ? 0 : e;
                    if (p) {
                        if (g !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m || this._lazy) {
                            if (i = g, u = this.timeline, this._repeat) {
                                if (o = p + this._rDelay, this._repeat < -1 && m) return this.totalTime(100 * o + e, t, n);
                                if (i = Uu(g % o), g === f ? (s = this._repeat, i = p) : (s = ~~(a = Uu(g / o))) && s === a ? (i = p, s--) : i > p && (i = p), (l = this._yoyo && 1 & s) && (h = this._yEase, i = p - i), a = eh(this._tTime, o), i === d && !n && this._initted && s === a) return this._tTime = g, this;
                                s !== a && (u && this._yEase && Jh(u, l), this.vars.repeatRefresh && !l && !this._lock && i !== o && this._initted && (this._lock = n = 1, this.render(Uu(o * s), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (ah(this, m ? e : i, n, t, g)) return this._tTime = 0, this;
                                if (!(d === this._time || n && this.vars.repeatRefresh && s !== a)) return this;
                                if (p !== this._dur) return this.render(e, t, n)
                            }
                            if (this._tTime = g, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(i / p), this._from && (this.ratio = c = 1 - c), i && !d && !t && !s && (Rh(this, "onStart"), this._tTime !== g)) return this;
                            for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                            u && u.render(e < 0 ? e : u._dur * u._ease(i / this._dur), t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (m && Ju(this, e, 0, n), Rh(this, "onUpdate")), this._repeat && s !== a && this.vars.onRepeat && !t && this.parent && Rh(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && Ju(this, e, 0, !0), (e || !p) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && qu(this, 1), t || m && !d || !(g || d || l) || (Rh(this, g === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < f && this.timeScale() > 0) && this._prom()))
                        }
                    } else ! function(e, t, n, i) {
                        var r, s, o, a = e.ratio,
                            l = t < 0 || !t && (!e._start && lh(e) && (e._initted || !ch(e)) || (e._ts < 0 || e._dp._ts < 0) && !ch(e)) ? 0 : 1,
                            c = e._rDelay,
                            u = 0;
                        if (c && e._repeat && (u = gh(0, e._tDur, t), s = eh(u, c), e._yoyo && 1 & s && (l = 1 - l), s !== eh(e._tTime, c) && (a = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== a || Bc || i || e._zTime === Gc || !t && e._zTime) {
                            if (!e._initted && ah(e, t, i, n, u)) return;
                            for (o = e._zTime, e._zTime = t || (n ? Gc : 0), n || (n = t && !o), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = u, r = e._pt; r;) r.r(l, r.d), r = r._next;
                            t < 0 && Ju(e, t, 0, !0), e._onUpdate && !n && Rh(e, "onUpdate"), u && e._repeat && !n && e.parent && Rh(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && qu(e, 1), n || Bc || (Rh(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                        } else e._zTime || (e._zTime = t)
                    }(this, e, t, n);
                    return this
                }, n.targets = function() {
                    return this._targets
                }, n.invalidate = function(t) {
                    return (!t || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), e.prototype.invalidate.call(this, t)
                }, n.resetTo = function(e, t, n, i, r) {
                    kc || Vh.wake(), this._ts || this.play();
                    var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                    return this._initted || hd(this, s),
                        function(e, t, n, i, r, s, o, a) {
                            var l, c, u, h, d = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                            if (!d)
                                for (d = e._ptCache[t] = [], u = e._ptLookup, h = e._targets.length; h--;) {
                                    if ((l = u[h][t]) && l.d && l.d._pt)
                                        for (l = l.d._pt; l && l.p !== t && l.fp !== t;) l = l._next;
                                    if (!l) return ad = 1, e.vars[t] = "+=0", hd(e, o), ad = 0, a ? gu() : 1;
                                    d.push(l)
                                }
                            for (h = d.length; h--;)(l = (c = d[h])._pt || c).s = !i && 0 !== i || r ? l.s + (i || 0) + s * l.c : i, l.c = n - l.s, c.e && (c.e = Lu(n) + Ah(c.e)), c.b && (c.b = l.s + Ah(c.b))
                        }(this, e, t, n, i, this._ease(s / this._dur), s, r) ? this.resetTo(e, t, n, i, 1) : (ih(this, 0), this.parent || Xu(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
                }, n.kill = function(e, t) {
                    if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? Dh(this) : this.scrollTrigger && this.scrollTrigger.kill(!!Bc), this;
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(e, t, od && !0 !== od.vars.overwrite)._first || Dh(this), this.parent && n !== this.timeline.totalDuration() && uh(this, this._dur * this.timeline._tDur / n, 0, 1), this
                    }
                    var i, r, s, o, a, l, c, u = this._targets,
                        h = e ? _h(e) : u,
                        d = this._ptLookup,
                        f = this._pt;
                    if ((!t || "all" === t) && function(e, t) {
                            for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];);
                            return n < 0
                        }(u, h)) return "all" === t && (this._pt = 0), Dh(this);
                    for (i = this._op = this._op || [], "all" !== t && (Kc(t) && (a = {}, Pu(t, (function(e) {
                            return a[e] = 1
                        })), t = a), t = function(e, t) {
                            var n, i, r, s, o = e[0] ? Ru(e[0]).harness : 0,
                                a = o && o.aliases;
                            if (!a) return t;
                            for (i in n = Gu({}, t), a)
                                if (i in n)
                                    for (r = (s = a[i].split(",")).length; r--;) n[s[r]] = n[i];
                            return n
                        }(u, t)), c = u.length; c--;)
                        if (~h.indexOf(u[c]))
                            for (a in r = d[c], "all" === t ? (i[c] = t, o = r, s = {}) : (s = i[c] = i[c] || {}, o = t), o)(l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || Yu(this, l, "_pt"), delete r[a]), "all" !== s && (s[a] = 1);
                    return this._initted && !this._pt && f && Dh(this), this
                }, t.to = function(e, n) {
                    return new t(e, n, arguments[2])
                }, t.from = function(e, t) {
                    return ph(1, arguments)
                }, t.delayedCall = function(e, n, i, r) {
                    return new t(n, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: e,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: i,
                        onReverseCompleteParams: i,
                        callbackScope: r
                    })
                }, t.fromTo = function(e, t, n) {
                    return ph(2, arguments)
                }, t.set = function(e, n) {
                    return n.duration = 0, n.repeatDelay || (n.repeat = 0), new t(e, n)
                }, t.killTweensOf = function(e, t, n) {
                    return Dc.killTweensOf(e, t, n)
                }, t
            }(rd);
            Hu(gd.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), Pu("staggerTo,staggerFrom,staggerFromTo", (function(e) {
                gd[e] = function() {
                    var t = new sd,
                        n = vh.call(arguments, 0);
                    return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
                }
            }));
            var Ad = function(e, t, n) {
                    return e[t] = n
                },
                vd = function(e, t, n) {
                    return e[t](n)
                },
                yd = function(e, t, n, i) {
                    return e[t](i.fp, n)
                },
                _d = function(e, t, n) {
                    return e.setAttribute(t, n)
                },
                xd = function(e, t) {
                    return Jc(e[t]) ? vd : $c(e[t]) && e.setAttribute ? _d : Ad
                },
                Ed = function(e, t) {
                    return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
                },
                bd = function(e, t) {
                    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
                },
                wd = function(e, t) {
                    var n = t._pt,
                        i = "";
                    if (!e && t.b) i = t.b;
                    else if (1 === e && t.e) i = t.e;
                    else {
                        for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i, n = n._next;
                        i += t.c
                    }
                    t.set(t.t, t.p, i, t)
                },
                Cd = function(e, t) {
                    for (var n = t._pt; n;) n.r(e, n.d), n = n._next
                },
                Sd = function(e, t, n, i) {
                    for (var r, s = this._pt; s;) r = s._next, s.p === i && s.modifier(e, t, n), s = r
                },
                Td = function(e) {
                    for (var t, n, i = this._pt; i;) n = i._next, i.p === e && !i.op || i.op === e ? Yu(this, i, "_pt") : i.dep || (t = 1), i = n;
                    return !t
                },
                Md = function(e, t, n, i) {
                    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
                },
                Id = function(e) {
                    for (var t, n, i, r, s = e._pt; s;) {
                        for (t = s._next, n = i; n && n.pr > s.pr;) n = n._next;
                        (s._prev = n ? n._prev : r) ? s._prev._next = s: i = s, (s._next = n) ? n._prev = s : r = s, s = t
                    }
                    e._pt = i
                },
                Bd = function() {
                    function e(e, t, n, i, r, s, o, a, l) {
                        this.t = t, this.s = i, this.c = r, this.p = n, this.r = s || Ed, this.d = o || this, this.set = a || Ad, this.pr = l || 0, this._next = e, e && (e._prev = this)
                    }
                    return e.prototype.modifier = function(e, t, n) {
                        this.mSet = this.mSet || this.set, this.set = Md, this.m = e, this.mt = n, this.tween = t
                    }, e
                }();
            Pu(Iu + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
                return Eu[e] = 1
            })), fu.TweenMax = fu.TweenLite = gd, fu.TimelineLite = fu.TimelineMax = sd, Dc = new sd({
                sortChildren: !1,
                defaults: zc,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), Qc.stringFilter = Gh;
            var Rd = [],
                Dd = {},
                Pd = [],
                Ld = 0,
                Ud = 0,
                Nd = function(e) {
                    return (Dd[e] || Pd).map((function(e) {
                        return e()
                    }))
                },
                Od = function() {
                    var e = Date.now(),
                        t = [];
                    e - Ld > 2 && (Nd("matchMediaInit"), Rd.forEach((function(e) {
                        var n, i, r, s, o = e.queries,
                            a = e.conditions;
                        for (i in o)(n = Pc.matchMedia(o[i]).matches) && (r = 1), n !== a[i] && (a[i] = n, s = 1);
                        s && (e.revert(), r && t.push(e))
                    })), Nd("matchMediaRevert"), t.forEach((function(e) {
                        return e.onMatch(e, (function(t) {
                            return e.add(null, t)
                        }))
                    })), Ld = e, Nd("matchMedia"))
                },
                Fd = function() {
                    function e(e, t) {
                        this.selector = t && xh(t), this.data = [], this._r = [], this.isReverted = !1, this.id = Ud++, e && this.add(e)
                    }
                    var t = e.prototype;
                    return t.add = function(e, t, n) {
                        Jc(e) && (n = t, t = e, e = Jc);
                        var i = this,
                            r = function() {
                                var e, r = Rc,
                                    s = i.selector;
                                return r && r !== i && r.data.push(i), n && (i.selector = xh(n)), Rc = i, e = t.apply(i, arguments), Jc(e) && i._r.push(e), Rc = r, i.selector = s, i.isReverted = !1, e
                            };
                        return i.last = r, e === Jc ? r(i, (function(e) {
                            return i.add(null, e)
                        })) : e ? i[e] = r : r
                    }, t.ignore = function(e) {
                        var t = Rc;
                        Rc = null, e(this), Rc = t
                    }, t.getTweens = function() {
                        var t = [];
                        return this.data.forEach((function(n) {
                            return n instanceof e ? t.push.apply(t, n.getTweens()) : n instanceof gd && !(n.parent && "nested" === n.parent.data) && t.push(n)
                        })), t
                    }, t.clear = function() {
                        this._r.length = this.data.length = 0
                    }, t.kill = function(e, t) {
                        var n = this;
                        if (e ? function() {
                                for (var t, i = n.getTweens(), r = n.data.length; r--;) "isFlip" === (t = n.data[r]).data && (t.revert(), t.getChildren(!0, !0, !1).forEach((function(e) {
                                    return i.splice(i.indexOf(e), 1)
                                })));
                                for (i.map((function(e) {
                                        return {
                                            g: e._dur || e._delay || e._sat && !e._sat.vars.immediateRender ? e.globalTime(0) : -1 / 0,
                                            t: e
                                        }
                                    })).sort((function(e, t) {
                                        return t.g - e.g || -1 / 0
                                    })).forEach((function(t) {
                                        return t.t.revert(e)
                                    })), r = n.data.length; r--;)(t = n.data[r]) instanceof sd ? "nested" !== t.data && (t.scrollTrigger && t.scrollTrigger.revert(), t.kill()) : !(t instanceof gd) && t.revert && t.revert(e);
                                n._r.forEach((function(t) {
                                    return t(e, n)
                                })), n.isReverted = !0
                            }() : this.data.forEach((function(e) {
                                return e.kill && e.kill()
                            })), this.clear(), t)
                            for (var i = Rd.length; i--;) Rd[i].id === this.id && Rd.splice(i, 1)
                    }, t.revert = function(e) {
                        this.kill(e || {})
                    }, e
                }(),
                kd = function() {
                    function e(e) {
                        this.contexts = [], this.scope = e, Rc && Rc.data.push(this)
                    }
                    var t = e.prototype;
                    return t.add = function(e, t, n) {
                        eu(e) || (e = {
                            matches: e
                        });
                        var i, r, s, o = new Fd(0, n || this.scope),
                            a = o.conditions = {};
                        for (r in Rc && !o.selector && (o.selector = Rc.selector), this.contexts.push(o), t = o.add("onMatch", t), o.queries = e, e) "all" === r ? s = 1 : (i = Pc.matchMedia(e[r])) && (Rd.indexOf(o) < 0 && Rd.push(o), (a[r] = i.matches) && (s = 1), i.addListener ? i.addListener(Od) : i.addEventListener("change", Od));
                        return s && t(o, (function(e) {
                            return o.add(null, e)
                        })), this
                    }, t.revert = function(e) {
                        this.kill(e || {})
                    }, t.kill = function(e) {
                        this.contexts.forEach((function(t) {
                            return t.kill(e, !0)
                        }))
                    }, e
                }(),
                Qd = {
                    registerPlugin: function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        t.forEach((function(e) {
                            return Lh(e)
                        }))
                    },
                    timeline: function(e) {
                        return new sd(e)
                    },
                    getTweensOf: function(e, t) {
                        return Dc.getTweensOf(e, t)
                    },
                    getProperty: function(e, t, n, i) {
                        Kc(e) && (e = _h(e)[0]);
                        var r = Ru(e || {}).get,
                            s = n ? zu : Qu;
                        return "native" === n && (n = ""), e ? t ? s((Cu[t] && Cu[t].get || r)(e, t, n, i)) : function(t, n, i) {
                            return s((Cu[t] && Cu[t].get || r)(e, t, n, i))
                        } : e
                    },
                    quickSetter: function(e, t, n) {
                        if ((e = _h(e)).length > 1) {
                            var i = e.map((function(e) {
                                    return Gd.quickSetter(e, t, n)
                                })),
                                r = i.length;
                            return function(e) {
                                for (var t = r; t--;) i[t](e)
                            }
                        }
                        e = e[0] || {};
                        var s = Cu[t],
                            o = Ru(e),
                            a = o.harness && (o.harness.aliases || {})[t] || t,
                            l = s ? function(t) {
                                var i = new s;
                                Fc._pt = 0, i.init(e, n ? t + n : t, Fc, 0, [e]), i.render(1, i), Fc._pt && Cd(1, Fc)
                            } : o.set(e, a);
                        return s ? l : function(t) {
                            return l(e, a, n ? t + n : t, o, 1)
                        }
                    },
                    quickTo: function(e, t, n) {
                        var i, r = Gd.to(e, Hu(((i = {})[t] = "+=0.1", i.paused = !0, i.stagger = 0, i), n || {})),
                            s = function(e, n, i) {
                                return r.resetTo(t, e, n, i)
                            };
                        return s.tween = r, s
                    },
                    isTweening: function(e) {
                        return Dc.getTweensOf(e, !0).length > 0
                    },
                    defaults: function(e) {
                        return e && e.ease && (e.ease = Zh(e.ease, zc.ease)), Vu(zc, e || {})
                    },
                    config: function(e) {
                        return Vu(Qc, e || {})
                    },
                    registerEffect: function(e) {
                        var t = e.name,
                            n = e.effect,
                            i = e.plugins,
                            r = e.defaults,
                            s = e.extendTimeline;
                        (i || "").split(",").forEach((function(e) {
                            return e && !Cu[e] && !fu[e] && gu()
                        })), Su[t] = function(e, t, i) {
                            return n(_h(e), Hu(t || {}, r), i)
                        }, s && (sd.prototype[t] = function(e, n, i) {
                            return this.add(Su[t](e, eu(n) ? n : (i = n) && {}, this), i)
                        })
                    },
                    registerEase: function(e, t) {
                        Wh[e] = Zh(t)
                    },
                    parseEase: function(e, t) {
                        return arguments.length ? Zh(e, t) : Wh
                    },
                    getById: function(e) {
                        return Dc.getById(e)
                    },
                    exportRoot: function(e, t) {
                        void 0 === e && (e = {});
                        var n, i, r = new sd(e);
                        for (r.smoothChildTiming = tu(e.smoothChildTiming), Dc.remove(r), r._dp = 0, r._time = r._tTime = Dc._time, n = Dc._first; n;) i = n._next, !t && !n._dur && n instanceof gd && n.vars.onComplete === n._targets[0] || sh(r, n, n._start - n._delay), n = i;
                        return sh(Dc, r, 0), r
                    },
                    context: function(e, t) {
                        return e ? new Fd(e, t) : Rc
                    },
                    matchMedia: function(e) {
                        return new kd(e)
                    },
                    matchMediaRefresh: function() {
                        return Rd.forEach((function(e) {
                            var t, n, i = e.conditions;
                            for (n in i) i[n] && (i[n] = !1, t = 1);
                            t && e.revert()
                        })) || Od()
                    },
                    addEventListener: function(e, t) {
                        var n = Dd[e] || (Dd[e] = []);
                        ~n.indexOf(t) || n.push(t)
                    },
                    removeEventListener: function(e, t) {
                        var n = Dd[e],
                            i = n && n.indexOf(t);
                        i >= 0 && n.splice(i, 1)
                    },
                    utils: {
                        wrap: function e(t, n, i) {
                            var r = n - t;
                            return su(t) ? Th(t, e(0, t.length), n) : mh(i, (function(e) {
                                return (r + (e - t) % r) % r + t
                            }))
                        },
                        wrapYoyo: function e(t, n, i) {
                            var r = n - t,
                                s = 2 * r;
                            return su(t) ? Th(t, e(0, t.length - 1), n) : mh(i, (function(e) {
                                return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e)
                            }))
                        },
                        distribute: bh,
                        random: Sh,
                        snap: Ch,
                        normalize: function(e, t, n) {
                            return Ih(e, t, 0, 1, n)
                        },
                        getUnit: Ah,
                        clamp: function(e, t, n) {
                            return mh(n, (function(n) {
                                return gh(e, t, n)
                            }))
                        },
                        splitColor: Fh,
                        toArray: _h,
                        selector: xh,
                        mapRange: Ih,
                        pipe: function() {
                            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                            return function(e) {
                                return t.reduce((function(e, t) {
                                    return t(e)
                                }), e)
                            }
                        },
                        unitize: function(e, t) {
                            return function(n) {
                                return e(parseFloat(n)) + (t || Ah(n))
                            }
                        },
                        interpolate: function e(t, n, i, r) {
                            var s = isNaN(t + n) ? 0 : function(e) {
                                return (1 - e) * t + e * n
                            };
                            if (!s) {
                                var o, a, l, c, u, h = Kc(t),
                                    d = {};
                                if (!0 === i && (r = 1) && (i = null), h) t = {
                                    p: t
                                }, n = {
                                    p: n
                                };
                                else if (su(t) && !su(n)) {
                                    for (l = [], c = t.length, u = c - 2, a = 1; a < c; a++) l.push(e(t[a - 1], t[a]));
                                    c--, s = function(e) {
                                        e *= c;
                                        var t = Math.min(u, ~~e);
                                        return l[t](e - t)
                                    }, i = n
                                } else r || (t = Gu(su(t) ? [] : {}, t));
                                if (!l) {
                                    for (o in n) cd.call(d, t, o, "get", n[o]);
                                    s = function(e) {
                                        return Cd(e, d) || (h ? t.p : t)
                                    }
                                }
                            }
                            return mh(i, s)
                        },
                        shuffle: Eh
                    },
                    install: mu,
                    effects: Su,
                    ticker: Vh,
                    updateRoot: sd.updateRoot,
                    plugins: Cu,
                    globalTimeline: Dc,
                    core: {
                        PropTween: Bd,
                        globals: Au,
                        Tween: gd,
                        Timeline: sd,
                        Animation: rd,
                        getCache: Ru,
                        _removeLinkedListItem: Yu,
                        reverting: function() {
                            return Bc
                        },
                        context: function(e) {
                            return e && Rc && (Rc.data.push(e), e._ctx = Rc), Rc
                        },
                        suppressOverwrites: function(e) {
                            return Ic = e
                        }
                    }
                };
            Pu("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
                return Qd[e] = gd[e]
            })), Vh.add(sd.updateRoot), Fc = Qd.to({}, {
                duration: 0
            });
            var zd = function(e, t) {
                    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
                    return n
                },
                Hd = function(e, t) {
                    return {
                        name: e,
                        rawVars: 1,
                        init: function(e, n, i) {
                            i._onInit = function(e) {
                                var i, r;
                                if (Kc(n) && (i = {}, Pu(n, (function(e) {
                                        return i[e] = 1
                                    })), n = i), t) {
                                    for (r in i = {}, n) i[r] = t(n[r]);
                                    n = i
                                }! function(e, t) {
                                    var n, i, r, s = e._targets;
                                    for (n in t)
                                        for (i = s.length; i--;)(r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = zd(r, n)), r && r.modifier && r.modifier(t[n], e, s[i], n))
                                }(e, n)
                            }
                        }
                    }
                },
                Gd = Qd.registerPlugin({
                    name: "attr",
                    init: function(e, t, n, i, r) {
                        var s, o, a;
                        for (s in this.tween = n, t) a = e.getAttribute(s) || "", (o = this.add(e, "setAttribute", (a || 0) + "", t[s], i, r, 0, 0, s)).op = s, o.b = a, this._props.push(s)
                    },
                    render: function(e, t) {
                        for (var n = t._pt; n;) Bc ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next
                    }
                }, {
                    name: "endArray",
                    init: function(e, t) {
                        for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
                    }
                }, Hd("roundProps", wh), Hd("modifiers"), Hd("snap", Ch)) || Qd;
            gd.version = sd.version = Gd.version = "3.12.7", Nc = 1, nu() && jh(), Wh.Power0, Wh.Power1;
            var Vd = Wh.Power2,
                jd = (Wh.Power3, Wh.Power4, Wh.Linear),
                Wd = (Wh.Quad, Wh.Cubic, Wh.Quart, Wh.Quint, Wh.Strong, Wh.Elastic, Wh.Back, Wh.SteppedEase, Wh.Bounce, Wh.Sine, Wh.Expo, Wh.Circ, {
                    pano: {
                        preload: !0,
                        quality: {
                            useBicubic: !0,
                            sharpness: .2,
                            lodBias: -.5
                        },
                        geometry: {
                            adaptiveLOD: !0,
                            baseTessellation: 128,
                            maxTessellation: 768,
                            projection: "equirectangular",
                            useAdaptiveGeometry: !0
                        }
                    },
                    postProcessing: {
                        enabled: !1,
                        antialias: {
                            multisampling: 8
                        },
                        fxaa: {
                            enabled: !0,
                            threshold: .063
                        }
                    },
                    animation: {
                        move: {
                            duration: .15,
                            ease: jd,
                            easeName: "Linear"
                        },
                        hotspot: {
                            fadeInDuration: .4,
                            hoverTransitionTime: .5,
                            staggerDelay: .05
                        },
                        camera: {
                            zoomDuration: .5
                        }
                    },
                    container: null,
                    paths: {
                        models_path: "/assets/tour/models/",
                        textures_path: "/assets/tour/textures/",
                        decoders_path: "/assets/tour/decoders/",
                        assets_path: "/assets/tour/assets/"
                    },
                    loadOnDemand: {
                        enabled: !0,
                        loadingManager: {
                            enabled: !0
                        }
                    },
                    useCompressedTextures: !1,
                    renderer: {
                        renderOnDemand: {
                            enabled: !0
                        },
                        outputEncoding: _e,
                        get pixelRatio() {
                            var e = window.devicePixelRatio || 1;
                            return Math.min(2, Math.max(1, e))
                        },
                        exposure: 1,
                        toneMapping: 0,
                        defaultRenderer: {
                            antialias: !0,
                            alpha: !0,
                            powerPreference: "high-performance",
                            stencil: !1
                        },
                        hdr: {
                            enabled: !1
                        }
                    },
                    camera: {
                        portraitAspect: .875,
                        landscapeAspect: 4 / 3.5,
                        near: 5,
                        far: 50,
                        fov: 80,
                        initPos: {
                            x: -10.873648212948423,
                            y: .4188578127354573,
                            z: 5.075787066382408
                        }
                    },
                    light: {
                        intensity: 1
                    },
                    envMap: {
                        intensity: 1.5
                    },
                    materials: {
                        metal: {
                            metalness: .2,
                            roughness: .3
                        },
                        wood: {
                            metalness: .2,
                            roughness: .7
                        }
                    },
                    maps: {
                        lightMap: {
                            intensity: .01
                        },
                        aoMap: {
                            intensity: 1
                        }
                    },
                    aoMap: {
                        air: {
                            intensity: .5
                        },
                        desk: {
                            intensity: .5
                        },
                        roof: {
                            intensity: .5
                        },
                        patio: {
                            intensity: .5
                        },
                        exterior: {
                            intensity: .4
                        }
                    },
                    controls: {
                        thirdPerson: {
                            focalOffset: {
                                x: 0,
                                y: 0,
                                z: 0
                            },
                            smoothTime: .3,
                            draggingSmoothTime: .3,
                            polarRotateSpeed: 1,
                            azimuthRotateSpeed: 1,
                            maxDistance: 4,
                            minDistance: 3,
                            maxPolarAngle: Sc.degToRad(88),
                            minPolarAngle: Sc.degToRad(0),
                            minAzimuthAngle: -1 / 0,
                            maxAzimuthAngle: 1 / 0,
                            minZoom: 1,
                            maxZoom: 3,
                            defaultZoom: 2,
                            near: .5
                        },
                        hideZoomControls: !1,
                        firstPerson: {
                            focalOffset: {
                                x: 0,
                                y: 0,
                                z: 0
                            },
                            minZoom: .5,
                            maxZoom: 1.5,
                            defaultZoom: 1,
                            near: .01,
                            polarRotateSpeed: -1,
                            azimuthRotateSpeed: -1,
                            smoothTime: .1,
                            draggingSmoothTime: .1,
                            maxPolarAngle: Math.PI,
                            minPolarAngle: 0,
                            minAzimuthAngle: -1 / 0,
                            maxAzimuthAngle: 1 / 0
                        }
                    },
                    environment: {
                        assetsArray: [{
                            id: 1,
                            hdrTexturePath: "hdr/1",
                            name: "hdr-1",
                            defaultHdrIntensity: .9
                        }, {
                            id: 2,
                            hdrTexturePath: "hdr/2",
                            name: "hdr-2",
                            isDefault: !0,
                            defaultHdrIntensity: 1.5
                        }, {
                            id: 3,
                            hdrTexturePath: "hdr/spiaggia_di_mondello_1k",
                            name: "hdr-3",
                            defaultHdrIntensity: .9
                        }, {
                            id: 4,
                            hdrTexturePath: "hdr/overcast",
                            name: "overcast",
                            defaultHdrIntensity: .05
                        }]
                    },
                    shadowMesh: {
                        opacity: .8
                    },
                    hotspot: {
                        size: .4,
                        opacity: .6,
                        hoverOpacity: .8,
                        hoverTransitionTime: 1
                    },
                    cursor: {
                        visible: !0,
                        color: "FFFFEE",
                        size: .4,
                        lerpFactor: .1
                    },
                    infospot: {
                        visible: !0
                    },
                    textures: [],
                    models: {
                        samara: {
                            assetsArray: [{
                                name: "studio",
                                totalAssetsCount: 11,
                                textures: []
                            }, {
                                name: "1B",
                                totalAssetsCount: 17,
                                textures: []
                            }, {
                                name: "2B",
                                totalAssetsCount: 15,
                                textures: []
                            }, {
                                name: "xl8",
                                totalAssetsCount: 19,
                                textures: []
                            }, {
                                name: "xl10",
                                totalAssetsCount: 19,
                                textures: []
                            }, {
                                name: "xl10-4k",
                                totalAssetsCount: 19,
                                textures: []
                            }],
                            scale: {
                                x: 1,
                                y: 1,
                                z: 1
                            },
                            rotation: Math.PI
                        }
                    }
                }),
                Xd = new $a;
            Xd.onStart = function(e, t, n) {}, Xd.onProgress = function(e, t, n) {
                var i;
                if (Wd.loadOnDemand.loadingManager.enabled) {
                    var r = (null === (i = window.engine) || void 0 === i || null === (i = i.state) || void 0 === i || null === (i = i.model) || void 0 === i ? void 0 : i.value) || Ec.complectation.value.layout || "studio",
                        s = Wd.models.samara.assetsArray.find((function(e) {
                            return e.name === r
                        }));
                    if (s) {
                        var o = Math.min((t / s.totalAssetsCount * 100).toFixed(), 100);
                        Ec.loading.next({
                            isLoading: !0,
                            percent: Number(o)
                        })
                    }
                }
            }, Xd.onLoad = function(e, t, n) {}, Xd.onError = function(e) {
                Ec.errors.next({
                    isError: !0,
                    message: "Error ".concat(e)
                })
            };
            class Yd {
                constructor(e = 4) {
                    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
                }
                _initWorker(e) {
                    if (!this.workers[e]) {
                        const t = this.workerCreator();
                        t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t
                    }
                }
                _getIdleWorker() {
                    for (let e = 0; e < this.pool; e++)
                        if (!(this.workerStatus & 1 << e)) return e;
                    return -1
                }
                _onMessage(e, t) {
                    const n = this.workersResolve[e];
                    if (n && n(t), this.queue.length) {
                        const {
                            resolve: t,
                            msg: n,
                            transfer: i
                        } = this.queue.shift();
                        this.workersResolve[e] = t, this.workers[e].postMessage(n, i)
                    } else this.workerStatus ^= 1 << e
                }
                setWorkerCreator(e) {
                    this.workerCreator = e
                }
                setWorkerLimit(e) {
                    this.pool = e
                }
                postMessage(e, t) {
                    return new Promise((n => {
                        const i = this._getIdleWorker(); - 1 !== i ? (this._initWorker(i), this.workerStatus |= 1 << i, this.workersResolve[i] = n, this.workers[i].postMessage(e, t)) : this.queue.push({
                            resolve: n,
                            msg: e,
                            transfer: t
                        })
                    }))
                }
                dispose() {
                    this.workers.forEach((e => e.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
                }
            }
            const qd = 1000066e3;
            class Kd {
                constructor() {
                    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                        vendorId: 0,
                        descriptorType: 0,
                        descriptorBlockSize: 0,
                        versionNumber: 2,
                        colorModel: 0,
                        colorPrimaries: 1,
                        transferFunction: 2,
                        flags: 0,
                        texelBlockDimension: [0, 0, 0, 0],
                        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                        samples: []
                    }], this.keyValue = {}, this.globalData = null
                }
            }
            class Jd {
                constructor(e, t, n, i) {
                    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = i, this._offset = 0
                }
                _nextUint8() {
                    const e = this._dataView.getUint8(this._offset);
                    return this._offset += 1, e
                }
                _nextUint16() {
                    const e = this._dataView.getUint16(this._offset, this._littleEndian);
                    return this._offset += 2, e
                }
                _nextUint32() {
                    const e = this._dataView.getUint32(this._offset, this._littleEndian);
                    return this._offset += 4, e
                }
                _nextUint64() {
                    const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                    return this._offset += 8, e
                }
                _nextInt32() {
                    const e = this._dataView.getInt32(this._offset, this._littleEndian);
                    return this._offset += 4, e
                }
                _nextUint8Array(e) {
                    const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
                    return this._offset += e, t
                }
                _skip(e) {
                    return this._offset += e, this
                }
                _scan(e, t) {
                    void 0 === t && (t = 0);
                    const n = this._offset;
                    let i = 0;
                    for (; this._dataView.getUint8(this._offset) !== t && i < e;) i++, this._offset++;
                    return i < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i)
                }
            }
            const Zd = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

            function $d(e) {
                return (new TextDecoder).decode(e)
            }
            let ef, tf, nf;
            const rf = {
                env: {
                    emscripten_notify_memory_growth: function(e) {
                        nf = new Uint8Array(tf.exports.memory.buffer)
                    }
                }
            };
            class sf {
                init() {
                    return ef || (ef = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + of).then((e => e.arrayBuffer())).then((e => WebAssembly.instantiate(e, rf))).then(this._init) : WebAssembly.instantiate(Buffer.from(of, "base64"), rf).then(this._init), ef)
                }
                _init(e) {
                    tf = e.instance, rf.env.emscripten_notify_memory_growth(0)
                }
                decode(e, t = 0) {
                    if (!tf) throw new Error("ZSTDDecoder: Await .init() before decoding.");
                    const n = e.byteLength,
                        i = tf.exports.malloc(n);
                    nf.set(e, i), t = t || Number(tf.exports.ZSTD_findDecompressedSize(i, n));
                    const r = tf.exports.malloc(t),
                        s = tf.exports.ZSTD_decompress(r, t, i, n),
                        o = nf.slice(r, r + s);
                    return tf.exports.free(i), tf.exports.free(r), o
                }
            }
            const of = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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", af = new WeakMap;
            let lf;
            class cf extends tl {
                constructor(e) {
                    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Yd, this.workerSourceURL = "", this.workerConfig = null
                }
                setTranscoderPath(e) {
                    return this.transcoderPath = e, this
                }
                setWorkerLimit(e) {
                    return this.workerPool.setWorkerLimit(e), this
                }
                async detectSupportAsync(e) {
                    return this.workerConfig = {
                        astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
                        astcHDRSupported: !1,
                        etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
                        etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
                        dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
                        bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
                        pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
                    }, this
                }
                detectSupport(e) {
                    return !0 === e.isWebGPURenderer ? this.workerConfig = {
                        astcSupported: e.hasFeature("texture-compression-astc"),
                        astcHDRSupported: !1,
                        etc1Supported: e.hasFeature("texture-compression-etc1"),
                        etc2Supported: e.hasFeature("texture-compression-etc2"),
                        dxtSupported: e.hasFeature("texture-compression-bc"),
                        bptcSupported: e.hasFeature("texture-compression-bptc"),
                        pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
                    } : this.workerConfig = {
                        astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
                        astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
                        etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
                        etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                        dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                        bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                        pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                    }, this
                }
                init() {
                    if (!this.transcoderPending) {
                        const e = new rl(this.manager);
                        e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
                        const t = e.loadAsync("basis_transcoder.js"),
                            n = new rl(this.manager);
                        n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
                        const i = n.loadAsync("basis_transcoder.wasm");
                        this.transcoderPending = Promise.all([t, i]).then((([e, t]) => {
                            const n = cf.BasisWorker.toString(),
                                i = ["/* constants */", "let _EngineFormat = " + JSON.stringify(cf.EngineFormat), "let _EngineType = " + JSON.stringify(cf.EngineType), "let _TranscoderFormat = " + JSON.stringify(cf.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(cf.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                            this.workerSourceURL = URL.createObjectURL(new Blob([i])), this.transcoderBinary = t, this.workerPool.setWorkerCreator((() => {
                                const e = new Worker(this.workerSourceURL),
                                    t = this.transcoderBinary.slice(0);
                                return e.postMessage({
                                    type: "init",
                                    config: this.workerConfig,
                                    transcoderBinary: t
                                }, [t]), e
                            }))
                        }))
                    }
                    return this.transcoderPending
                }
                load(e, t, n, i) {
                    if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                    const r = new rl(this.manager);
                    r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, (e => {
                        this.parse(e, t, i)
                    }), n, i)
                }
                parse(e, t, n) {
                    if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                    if (af.has(e)) return af.get(e).promise.then(t).catch(n);
                    this._createTexture(e).then((e => t ? t(e) : null)).catch(n)
                }
                _createTextureFrom(e, t) {
                    const {
                        type: n,
                        error: i,
                        data: {
                            faces: r,
                            width: s,
                            height: o,
                            format: a,
                            type: l,
                            dfdFlags: c
                        }
                    } = e;
                    if ("error" === n) return Promise.reject(i);
                    let u;
                    if (6 === t.faceCount) u = new Ia(r, a, l);
                    else {
                        const e = r[0].mipmaps;
                        u = t.layerCount > 1 ? new Ma(e, s, o, t.layerCount, a, l) : new Ta(e, s, o, a, l)
                    }
                    return u.minFilter = 1 === r[0].mipmaps.length ? f : m, u.magFilter = f, u.generateMipmaps = !1, u.needsUpdate = !0, u.colorSpace = ff(t), u.premultiplyAlpha = !!(1 & c), u
                }
                async _createTexture(e, t = {}) {
                    const n = function(e) {
                            const t = new Uint8Array(e.buffer, e.byteOffset, Zd.length);
                            if (t[0] !== Zd[0] || t[1] !== Zd[1] || t[2] !== Zd[2] || t[3] !== Zd[3] || t[4] !== Zd[4] || t[5] !== Zd[5] || t[6] !== Zd[6] || t[7] !== Zd[7] || t[8] !== Zd[8] || t[9] !== Zd[9] || t[10] !== Zd[10] || t[11] !== Zd[11]) throw new Error("Missing KTX 2.0 identifier.");
                            const n = new Kd,
                                i = 17 * Uint32Array.BYTES_PER_ELEMENT,
                                r = new Jd(e, Zd.length, i, !0);
                            n.vkFormat = r._nextUint32(), n.typeSize = r._nextUint32(), n.pixelWidth = r._nextUint32(), n.pixelHeight = r._nextUint32(), n.pixelDepth = r._nextUint32(), n.layerCount = r._nextUint32(), n.faceCount = r._nextUint32();
                            const s = r._nextUint32();
                            n.supercompressionScheme = r._nextUint32();
                            const o = r._nextUint32(),
                                a = r._nextUint32(),
                                l = r._nextUint32(),
                                c = r._nextUint32(),
                                u = r._nextUint64(),
                                h = r._nextUint64(),
                                d = new Jd(e, Zd.length + i, 3 * s * 8, !0);
                            for (let t = 0; t < s; t++) n.levels.push({
                                levelData: new Uint8Array(e.buffer, e.byteOffset + d._nextUint64(), d._nextUint64()),
                                uncompressedByteLength: d._nextUint64()
                            });
                            const f = new Jd(e, o, a, !0),
                                p = {
                                    vendorId: f._skip(4)._nextUint16(),
                                    descriptorType: f._nextUint16(),
                                    versionNumber: f._nextUint16(),
                                    descriptorBlockSize: f._nextUint16(),
                                    colorModel: f._nextUint8(),
                                    colorPrimaries: f._nextUint8(),
                                    transferFunction: f._nextUint8(),
                                    flags: f._nextUint8(),
                                    texelBlockDimension: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
                                    bytesPlane: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
                                    samples: []
                                },
                                m = (p.descriptorBlockSize / 4 - 6) / 4;
                            for (let e = 0; e < m; e++) {
                                const t = {
                                    bitOffset: f._nextUint16(),
                                    bitLength: f._nextUint8(),
                                    channelType: f._nextUint8(),
                                    samplePosition: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
                                    sampleLower: -1 / 0,
                                    sampleUpper: 1 / 0
                                };
                                64 & t.channelType ? (t.sampleLower = f._nextInt32(), t.sampleUpper = f._nextInt32()) : (t.sampleLower = f._nextUint32(), t.sampleUpper = f._nextUint32()), p.samples[e] = t
                            }
                            n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(p);
                            const g = new Jd(e, l, c, !0);
                            for (; g._offset < c;) {
                                const e = g._nextUint32(),
                                    t = g._scan(e),
                                    i = $d(t);
                                if (n.keyValue[i] = g._nextUint8Array(e - t.byteLength - 1), i.match(/^ktx/i)) {
                                    const e = $d(n.keyValue[i]);
                                    n.keyValue[i] = e.substring(0, e.lastIndexOf("\0"))
                                }
                                g._skip(e % 4 ? 4 - e % 4 : 0)
                            }
                            if (h <= 0) return n;
                            const A = new Jd(e, u, h, !0),
                                v = A._nextUint16(),
                                y = A._nextUint16(),
                                _ = A._nextUint32(),
                                x = A._nextUint32(),
                                E = A._nextUint32(),
                                b = A._nextUint32(),
                                w = [];
                            for (let e = 0; e < s; e++) w.push({
                                imageFlags: A._nextUint32(),
                                rgbSliceByteOffset: A._nextUint32(),
                                rgbSliceByteLength: A._nextUint32(),
                                alphaSliceByteOffset: A._nextUint32(),
                                alphaSliceByteLength: A._nextUint32()
                            });
                            const C = u + A._offset,
                                S = C + _,
                                T = S + x,
                                M = T + E,
                                I = new Uint8Array(e.buffer, e.byteOffset + C, _),
                                B = new Uint8Array(e.buffer, e.byteOffset + S, x),
                                R = new Uint8Array(e.buffer, e.byteOffset + T, E),
                                D = new Uint8Array(e.buffer, e.byteOffset + M, b);
                            return n.globalData = {
                                endpointCount: v,
                                selectorCount: y,
                                imageDescs: w,
                                endpointsData: I,
                                selectorsData: B,
                                tablesData: R,
                                extendedData: D
                            }, n
                        }(new Uint8Array(e)),
                        i = n.vkFormat === qd && 167 === n.dataFormatDescriptor[0].colorModel;
                    if (0 !== n.vkFormat && (!i || this.workerConfig.astcHDRSupported)) return async function(e) {
                        const {
                            vkFormat: t
                        } = e;
                        if (void 0 === hf[t]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                        let n;
                        2 === e.supercompressionScheme && (lf || (lf = new Promise((async e => {
                            const t = new sf;
                            await t.init(), e(t)
                        }))), n = await lf);
                        const i = [];
                        for (let r = 0; r < e.levels.length; r++) {
                            const s = Math.max(1, e.pixelWidth >> r),
                                o = Math.max(1, e.pixelHeight >> r),
                                a = e.pixelDepth ? Math.max(1, e.pixelDepth >> r) : 0,
                                l = e.levels[r];
                            let c, u;
                            if (0 === e.supercompressionScheme) c = l.levelData;
                            else {
                                if (2 !== e.supercompressionScheme) throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                                c = n.decode(l.levelData, l.uncompressedByteLength)
                            }
                            u = df[t] === b ? new Float32Array(c.buffer, c.byteOffset, c.byteLength / Float32Array.BYTES_PER_ELEMENT) : df[t] === w ? new Uint16Array(c.buffer, c.byteOffset, c.byteLength / Uint16Array.BYTES_PER_ELEMENT) : c, i.push({
                                data: u,
                                width: s,
                                height: o,
                                depth: a
                            })
                        }
                        let r;
                        if (uf.has(hf[t])) r = 0 === e.pixelDepth ? new Wo(i[0].data, e.pixelWidth, e.pixelHeight) : new pt(i[0].data, e.pixelWidth, e.pixelHeight, e.pixelDepth);
                        else {
                            if (e.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                            r = new Ta(i, e.pixelWidth, e.pixelHeight)
                        }
                        return r.mipmaps = i, r.type = df[t], r.format = hf[t], r.colorSpace = ff(e), r.needsUpdate = !0, Promise.resolve(r)
                    }(n);
                    const r = t,
                        s = this.init().then((() => this.workerPool.postMessage({
                            type: "transcode",
                            buffer: e,
                            taskConfig: r
                        }, [e]))).then((e => this._createTextureFrom(e.data, n)));
                    return af.set(e, {
                        promise: s
                    }), s
                }
                dispose() {
                    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
                }
            }
            cf.BasisFormat = {
                ETC1S: 0,
                UASTC: 1,
                UASTC_HDR: 2
            }, cf.TranscoderFormat = {
                ETC1: 0,
                ETC2: 1,
                BC1: 2,
                BC3: 3,
                BC4: 4,
                BC5: 5,
                BC7_M6_OPAQUE_ONLY: 6,
                BC7_M5: 7,
                PVRTC1_4_RGB: 8,
                PVRTC1_4_RGBA: 9,
                ASTC_4x4: 10,
                ATC_RGB: 11,
                ATC_RGBA_INTERPOLATED_ALPHA: 12,
                RGBA32: 13,
                RGB565: 14,
                BGR565: 15,
                RGBA4444: 16,
                BC6H: 22,
                RGB_HALF: 24,
                RGBA_HALF: 25
            }, cf.EngineFormat = {
                RGBAFormat: I,
                RGBA_ASTC_4x4_Format: q,
                RGB_BPTC_UNSIGNED_Format: he,
                RGBA_BPTC_Format: ce,
                RGBA_ETC2_EAC_Format: Y,
                RGBA_PVRTC_4BPPV1_Format: V,
                RGBA_S3TC_DXT5_Format: z,
                RGB_ETC1_Format: W,
                RGB_ETC2_Format: X,
                RGB_PVRTC_4BPPV1_Format: H,
                RGBA_S3TC_DXT1_Format: k
            }, cf.EngineType = {
                UnsignedByteType: A,
                HalfFloatType: w,
                FloatType: b
            }, cf.BasisWorker = function() {
                let e, t, n;
                const i = _EngineFormat,
                    r = _EngineType,
                    s = _TranscoderFormat,
                    o = _BasisFormat;
                self.addEventListener("message", (function(i) {
                    const s = i.data;
                    switch (s.type) {
                        case "init":
                            e = s.config, a = s.transcoderBinary, t = new Promise((e => {
                                n = {
                                    wasmBinary: a,
                                    onRuntimeInitialized: e
                                }, BASIS(n)
                            })).then((() => {
                                n.initializeBasis(), n.KTX2File
                            }));
                            break;
                        case "transcode":
                            t.then((() => {
                                try {
                                    const {
                                        faces: t,
                                        buffers: i,
                                        width: a,
                                        height: h,
                                        hasAlpha: d,
                                        format: f,
                                        type: p,
                                        dfdFlags: m
                                    } = function(t) {
                                        const i = new n.KTX2File(new Uint8Array(t));

                                        function s() {
                                            i.close(), i.delete()
                                        }
                                        if (!i.isValid()) throw s(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                        let a;
                                        if (i.isUASTC()) a = o.UASTC;
                                        else if (i.isETC1S()) a = o.ETC1S;
                                        else {
                                            if (!i.isHDR()) throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
                                            a = o.UASTC_HDR
                                        }
                                        const h = i.getWidth(),
                                            d = i.getHeight(),
                                            f = i.getLayers() || 1,
                                            p = i.getLevels(),
                                            m = i.getFaces(),
                                            g = i.getHasAlpha(),
                                            A = i.getDFDFlags(),
                                            {
                                                transcoderFormat: v,
                                                engineFormat: y,
                                                engineType: _
                                            } = function(t, n, i, r) {
                                                const s = l[t];
                                                for (let o = 0; o < s.length; o++) {
                                                    const a = s[o];
                                                    if ((!a.if || e[a.if]) && (a.basisFormat.includes(t) && !(r && a.transcoderFormat.length < 2) && (!a.needsPowerOfTwo || c(n) && c(i)))) return {
                                                        transcoderFormat: a.transcoderFormat[r ? 1 : 0],
                                                        engineFormat: a.engineFormat[r ? 1 : 0],
                                                        engineType: a.engineType[0]
                                                    }
                                                }
                                                throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")
                                            }(a, h, d, g);
                                        if (!h || !d || !p) throw s(), new Error("THREE.KTX2Loader:\tInvalid texture");
                                        if (!i.startTranscoding()) throw s(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                                        const x = [],
                                            E = [];
                                        for (let e = 0; e < m; e++) {
                                            const t = [];
                                            for (let n = 0; n < p; n++) {
                                                const o = [];
                                                let a, l;
                                                for (let t = 0; t < f; t++) {
                                                    const c = i.getImageLevelInfo(n, t, e);
                                                    0 === e && 0 === n && 0 === t && (c.origWidth % 4 != 0 || c.origHeight), p > 1 ? (a = c.origWidth, l = c.origHeight) : (a = c.width, l = c.height);
                                                    let u = new Uint8Array(i.getImageTranscodedSizeInBytes(n, t, 0, v));
                                                    const h = i.transcodeImage(u, n, t, e, v, 0, -1, -1);
                                                    if (_ === r.HalfFloatType && (u = new Uint16Array(u.buffer, u.byteOffset, u.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !h) throw s(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                                    o.push(u)
                                                }
                                                const c = u(o);
                                                t.push({
                                                    data: c,
                                                    width: a,
                                                    height: l
                                                }), E.push(c.buffer)
                                            }
                                            x.push({
                                                mipmaps: t,
                                                width: h,
                                                height: d,
                                                format: y,
                                                type: _
                                            })
                                        }
                                        return s(), {
                                            faces: x,
                                            buffers: E,
                                            width: h,
                                            height: d,
                                            hasAlpha: g,
                                            dfdFlags: A,
                                            format: y,
                                            type: _
                                        }
                                    }(s.buffer);
                                    self.postMessage({
                                        type: "transcode",
                                        id: s.id,
                                        data: {
                                            faces: t,
                                            width: a,
                                            height: h,
                                            hasAlpha: d,
                                            format: f,
                                            type: p,
                                            dfdFlags: m
                                        }
                                    }, i)
                                } catch (e) {
                                    self.postMessage({
                                        type: "error",
                                        id: s.id,
                                        error: e.message
                                    })
                                }
                            }))
                    }
                    var a
                }));
                const a = [{
                        if: "astcSupported",
                        basisFormat: [o.UASTC],
                        transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
                        engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
                        engineType: [r.UnsignedByteType],
                        priorityETC1S: 1 / 0,
                        priorityUASTC: 1,
                        needsPowerOfTwo: !1
                    }, {
                        if: "bptcSupported",
                        basisFormat: [o.ETC1S, o.UASTC],
                        transcoderFormat: [s.BC7_M5, s.BC7_M5],
                        engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
                        engineType: [r.UnsignedByteType],
                        priorityETC1S: 3,
                        priorityUASTC: 2,
                        needsPowerOfTwo: !1
                    }, {
                        if: "dxtSupported",
                        basisFormat: [o.ETC1S, o.UASTC],
                        transcoderFormat: [s.BC1, s.BC3],
                        engineFormat: [i.RGBA_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
                        engineType: [r.UnsignedByteType],
                        priorityETC1S: 4,
                        priorityUASTC: 5,
                        needsPowerOfTwo: !1
                    }, {
                        if: "etc2Supported",
                        basisFormat: [o.ETC1S, o.UASTC],
                        transcoderFormat: [s.ETC1, s.ETC2],
                        engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
                        engineType: [r.UnsignedByteType],
                        priorityETC1S: 1,
                        priorityUASTC: 3,
                        needsPowerOfTwo: !1
                    }, {
                        if: "etc1Supported",
                        basisFormat: [o.ETC1S, o.UASTC],
                        transcoderFormat: [s.ETC1],
                        engineFormat: [i.RGB_ETC1_Format],
                        engineType: [r.UnsignedByteType],
                        priorityETC1S: 2,
                        priorityUASTC: 4,
                        needsPowerOfTwo: !1
                    }, {
                        if: "pvrtcSupported",
                        basisFormat: [o.ETC1S, o.UASTC],
                        transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
                        engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
                        engineType: [r.UnsignedByteType],
                        priorityETC1S: 5,
                        priorityUASTC: 6,
                        needsPowerOfTwo: !0
                    }, {
                        if: "bptcSupported",
                        basisFormat: [o.UASTC_HDR],
                        transcoderFormat: [s.BC6H],
                        engineFormat: [i.RGB_BPTC_UNSIGNED_Format],
                        engineType: [r.HalfFloatType],
                        priorityHDR: 1,
                        needsPowerOfTwo: !1
                    }, {
                        basisFormat: [o.ETC1S, o.UASTC],
                        transcoderFormat: [s.RGBA32, s.RGBA32],
                        engineFormat: [i.RGBAFormat, i.RGBAFormat],
                        engineType: [r.UnsignedByteType, r.UnsignedByteType],
                        priorityETC1S: 100,
                        priorityUASTC: 100,
                        needsPowerOfTwo: !1
                    }, {
                        basisFormat: [o.UASTC_HDR],
                        transcoderFormat: [s.RGBA_HALF],
                        engineFormat: [i.RGBAFormat],
                        engineType: [r.HalfFloatType],
                        priorityHDR: 100,
                        needsPowerOfTwo: !1
                    }],
                    l = {
                        [o.ETC1S]: a.filter((e => e.basisFormat.includes(o.ETC1S))).sort(((e, t) => e.priorityUASTC - t.priorityUASTC)),
                        [o.UASTC]: a.filter((e => e.basisFormat.includes(o.UASTC))).sort(((e, t) => e.priorityUASTC - t.priorityUASTC)),
                        [o.UASTC_HDR]: a.filter((e => e.basisFormat.includes(o.UASTC_HDR))).sort(((e, t) => e.priorityHDR - t.priorityHDR))
                    };

                function c(e) {
                    return e <= 2 || !(e & e - 1) && 0 !== e
                }

                function u(e) {
                    if (1 === e.length) return e[0];
                    let t = 0;
                    for (let n = 0; n < e.length; n++) t += e[n].byteLength;
                    const n = new Uint8Array(t);
                    let i = 0;
                    for (let t = 0; t < e.length; t++) {
                        const r = e[t];
                        n.set(r, i), i += r.byteLength
                    }
                    return n
                }
            };
            const uf = new Set([I, U, P]),
                hf = {
                    109: I,
                    97: I,
                    37: I,
                    43: I,
                    103: U,
                    83: U,
                    16: U,
                    22: U,
                    100: P,
                    76: P,
                    15: P,
                    9: P,
                    [qd]: q,
                    166: $,
                    165: $
                },
                df = {
                    109: b,
                    97: w,
                    37: A,
                    43: A,
                    103: b,
                    83: w,
                    16: A,
                    22: A,
                    100: b,
                    76: w,
                    15: A,
                    9: A,
                    [qd]: w,
                    166: A,
                    165: A
                };

            function ff(e) {
                const t = e.dataFormatDescriptor[0];
                return 1 === t.colorPrimaries ? 2 === t.transferFunction ? _e : xe : 10 === t.colorPrimaries ? 2 === t.transferFunction ? "display-p3" : "display-p3-linear" : (t.colorPrimaries, ye)
            }

            function pf(e, t) {
                for (var n = e.length, i = 0; i < n; ++i)
                    if (t(e[i], i)) return !0;
                return !1
            }

            function mf(e, t) {
                for (var n = e.length, i = 0; i < n; ++i)
                    if (t(e[i], i)) return e[i];
                return null
            }

            function gf(e) {
                var t = e;
                if (void 0 === t) {
                    if ("undefined" == typeof navigator || !navigator) return "";
                    t = navigator.userAgent || ""
                }
                return t.toLowerCase()
            }

            function Af(e, t) {
                try {
                    return new RegExp(e, "g").exec(t)
                } catch (e) {
                    return null
                }
            }

            function vf(e) {
                return e.replace(/_/g, ".")
            }

            function yf(e, t) {
                var n = null,
                    i = "-1";
                return pf(e, (function(e) {
                    var r = Af("(" + e.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", t);
                    return !(!r || e.brand || (n = e, i = r[3] || "-1", e.versionAlias ? i = e.versionAlias : e.versionTest && (i = function(e, t) {
                        var n = Af("(" + e + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", t);
                        return n ? n[3] : ""
                    }(e.versionTest.toLowerCase(), t) || i), i = vf(i), 0))
                })), {
                    preset: n,
                    version: i
                }
            }

            function _f(e, t) {
                var n = {
                    brand: "",
                    version: "-1"
                };
                return pf(e, (function(e) {
                    var i = xf(t, e);
                    return !!i && (n.brand = e.id, n.version = e.versionAlias || i.version, "-1" !== n.version)
                })), n
            }

            function xf(e, t) {
                return mf(e, (function(e) {
                    var n = e.brand;
                    return Af("" + t.test, n.toLowerCase())
                }))
            }
            var Ef = [{
                    test: "phantomjs",
                    id: "phantomjs"
                }, {
                    test: "whale",
                    id: "whale"
                }, {
                    test: "edgios|edge|edg",
                    id: "edge"
                }, {
                    test: "msie|trident|windows phone",
                    id: "ie",
                    versionTest: "iemobile|msie|rv"
                }, {
                    test: "miuibrowser",
                    id: "miui browser"
                }, {
                    test: "samsungbrowser",
                    id: "samsung internet"
                }, {
                    test: "samsung",
                    id: "samsung internet",
                    versionTest: "version"
                }, {
                    test: "chrome|crios",
                    id: "chrome"
                }, {
                    test: "firefox|fxios",
                    id: "firefox"
                }, {
                    test: "android",
                    id: "android browser",
                    versionTest: "version"
                }, {
                    test: "safari|iphone|ipad|ipod",
                    id: "safari",
                    versionTest: "version"
                }],
                bf = [{
                    test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
                    id: "chrome",
                    versionTest: "chrome"
                }, {
                    test: "chromium",
                    id: "chrome"
                }, {
                    test: "whale",
                    id: "chrome",
                    versionAlias: "-1",
                    brand: !0
                }],
                wf = [{
                    test: "applewebkit",
                    id: "webkit",
                    versionTest: "applewebkit|safari"
                }],
                Cf = [{
                    test: "(?=(iphone|ipad))(?!(.*version))",
                    id: "webview"
                }, {
                    test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
                    id: "webview"
                }, {
                    test: "webview",
                    id: "webview"
                }],
                Sf = [{
                    test: "windows phone",
                    id: "windows phone"
                }, {
                    test: "windows 2000",
                    id: "window",
                    versionAlias: "5.0"
                }, {
                    test: "windows nt",
                    id: "window"
                }, {
                    test: "win32|windows",
                    id: "window"
                }, {
                    test: "iphone|ipad|ipod",
                    id: "ios",
                    versionTest: "iphone os|cpu os"
                }, {
                    test: "macos|macintel|mac os x",
                    id: "mac"
                }, {
                    test: "android|linux armv81",
                    id: "android"
                }, {
                    test: "tizen",
                    id: "tizen"
                }, {
                    test: "webos|web0s",
                    id: "webos"
                }];

            function Tf(e) {
                return !!yf(Cf, e).preset
            }
            const Mf = function(e) {
                return void 0 === e && function() {
                    if ("undefined" == typeof navigator || !navigator || !navigator.userAgentData) return !1;
                    var e = navigator.userAgentData,
                        t = e.brands || e.uaList;
                    return !(!t || !t.length)
                }() ? function(e) {
                    var t = navigator.userAgentData,
                        n = (t.uaList || t.brands).slice(),
                        i = e,
                        r = t.mobile || !1,
                        s = n[0],
                        o = (t.platform || navigator.platform).toLowerCase(),
                        a = {
                            name: s.brand,
                            version: s.version,
                            majorVersion: -1,
                            webkit: !1,
                            webkitVersion: "-1",
                            chromium: !1,
                            chromiumVersion: "-1",
                            webview: !!_f(Cf, n).brand || Tf(gf())
                        },
                        l = {
                            name: "unknown",
                            version: "-1",
                            majorVersion: -1
                        };
                    a.webkit = !a.chromium && pf(wf, (function(e) {
                        return xf(n, e)
                    }));
                    var c = _f(bf, n);
                    if (a.chromium = !!c.brand, a.chromiumVersion = c.version || "-1", !a.chromium) {
                        var u = _f(wf, n);
                        a.webkit = !!u.brand, a.webkitVersion = u.version || "-1"
                    }
                    var h = mf(Sf, (function(e) {
                        return new RegExp("" + e.test, "g").exec(o)
                    }));
                    if (l.name = h ? h.id : "", i);
                    else {
                        var d = _f(Ef, n);
                        a.name = d.brand || a.name, a.version = d.brand && e ? e.uaFullVersion : d.version
                    }
                    return a.webkit && (l.name = r ? "ios" : "mac"), "ios" === l.name && a.webview && (a.version = "-1"), l.version = vf(l.version), a.version = vf(a.version), l.majorVersion = parseInt(l.version, 10), a.majorVersion = parseInt(a.version, 10), {
                        browser: a,
                        os: l,
                        isMobile: r,
                        isHints: !0
                    }
                }() : function(e) {
                    var t = gf(e),
                        n = !!/mobi/g.exec(t),
                        i = {
                            name: "unknown",
                            version: "-1",
                            majorVersion: -1,
                            webview: Tf(t),
                            chromium: !1,
                            chromiumVersion: "-1",
                            webkit: !1,
                            webkitVersion: "-1"
                        },
                        r = {
                            name: "unknown",
                            version: "-1",
                            majorVersion: -1
                        },
                        s = yf(Ef, t),
                        o = s.preset,
                        a = s.version,
                        l = yf(Sf, t),
                        c = l.preset,
                        u = l.version,
                        h = yf(bf, t);
                    if (i.chromium = !!h.preset, i.chromiumVersion = h.version, !i.chromium) {
                        var d = yf(wf, t);
                        i.webkit = !!d.preset, i.webkitVersion = d.version
                    }
                    return c && (r.name = c.id, r.version = u, r.majorVersion = parseInt(u, 10)), o && (i.name = o.id, i.version = a, i.webview && "ios" === r.name && "safari" !== i.name && (i.webview = !1)), i.majorVersion = parseInt(i.version, 10), {
                        browser: i,
                        os: r,
                        isMobile: n,
                        isHints: !1
                    }
                }(e)
            };
            var If;
            try {
                If = Mf()
            } catch (e) {
                If = {
                    os: {
                        name: "unknown",
                        version: "0"
                    },
                    browser: {
                        name: "unknown",
                        version: "0"
                    },
                    isMobile: !1,
                    isDesktop: !0
                }
            }

            function Bf(e) {
                return Bf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, Bf(e)
            }

            function Rf(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function Df(e, t, n) {
                return (t = Nf(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function Pf() {
                Pf = function() {
                    return t
                };
                var e, t = {},
                    n = Object.prototype,
                    i = n.hasOwnProperty,
                    r = Object.defineProperty || function(e, t, n) {
                        e[t] = n.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    o = s.iterator || "@@iterator",
                    a = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, n) {
                    return Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, n) {
                        return e[t] = n
                    }
                }

                function u(e, t, n, i) {
                    var s = t && t.prototype instanceof A ? t : A,
                        o = Object.create(s.prototype),
                        a = new B(i || []);
                    return r(o, "_invoke", {
                        value: S(e, n, a)
                    }), o
                }

                function h(e, t, n) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, n)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart",
                    f = "suspendedYield",
                    p = "executing",
                    m = "completed",
                    g = {};

                function A() {}

                function v() {}

                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }));
                var x = Object.getPrototypeOf,
                    E = x && x(x(R([])));
                E && E !== n && i.call(E, o) && (_ = E);
                var b = y.prototype = A.prototype = Object.create(_);

                function w(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function C(e, t) {
                    function n(r, s, o, a) {
                        var l = h(e[r], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                u = c.value;
                            return u && "object" == Bf(u) && i.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                n("next", e, o, a)
                            }), (function(e) {
                                n("throw", e, o, a)
                            })) : t.resolve(u).then((function(e) {
                                c.value = e, o(c)
                            }), (function(e) {
                                return n("throw", e, o, a)
                            }))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(e, i) {
                            function r() {
                                return new t((function(t, r) {
                                    n(e, i, t, r)
                                }))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }

                function S(t, n, i) {
                    var r = d;
                    return function(s, o) {
                        if (r === p) throw Error("Generator is already running");
                        if (r === m) {
                            if ("throw" === s) throw o;
                            return {
                                value: e,
                                done: !0
                            }
                        }
                        for (i.method = s, i.arg = o;;) {
                            var a = i.delegate;
                            if (a) {
                                var l = T(a, i);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === i.method) i.sent = i._sent = i.arg;
                            else if ("throw" === i.method) {
                                if (r === d) throw r = m, i.arg;
                                i.dispatchException(i.arg)
                            } else "return" === i.method && i.abrupt("return", i.arg);
                            r = p;
                            var c = h(t, n, i);
                            if ("normal" === c.type) {
                                if (r = i.done ? m : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: i.done
                                }
                            }
                            "throw" === c.type && (r = m, i.method = "throw", i.arg = c.arg)
                        }
                    }
                }

                function T(t, n) {
                    var i = n.method,
                        r = t.iterator[i];
                    if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
                }

                function M(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function I(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function B(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(M, this), this.reset(!0)
                }

                function R(t) {
                    if (t || "" === t) {
                        var n = t[o];
                        if (n) return n.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var r = -1,
                                s = function n() {
                                    for (; ++r < t.length;)
                                        if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = e, n.done = !0, n
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(Bf(t) + " is not iterable")
                }
                return v.prototype = y, r(b, "constructor", {
                    value: y,
                    configurable: !0
                }), r(y, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(b), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, w(C.prototype), c(C.prototype, a, (function() {
                    return this
                })), t.AsyncIterator = C, t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new C(u(e, n, i, r), s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                        return e.done ? e.value : o.next()
                    }))
                }, w(b), c(b, l, "Generator"), c(b, o, (function() {
                    return this
                })), c(b, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = Object(e),
                        n = [];
                    for (var i in t) n.push(i);
                    return n.reverse(),
                        function e() {
                            for (; n.length;) {
                                var i = n.pop();
                                if (i in t) return e.value = i, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, t.values = R, B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !t)
                            for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done) throw t;
                        var n = this;

                        function r(i, r) {
                            return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s],
                                a = o.completion;
                            if ("root" === o.tryLoc) return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc"),
                                    c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                } else {
                                    if (!c) throw Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(o)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.tryLoc === e) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    I(n)
                                }
                                return r
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = e), g
                    }
                }, t
            }

            function Lf(e, t, n, i, r, s, o) {
                try {
                    var a = e[s](o),
                        l = a.value
                } catch (e) {
                    return void n(e)
                }
                a.done ? t(l) : Promise.resolve(l).then(i, r)
            }

            function Uf(e) {
                return function() {
                    var t = this,
                        n = arguments;
                    return new Promise((function(i, r) {
                        var s = e.apply(t, n);

                        function o(e) {
                            Lf(s, i, r, o, a, "next", e)
                        }

                        function a(e) {
                            Lf(s, i, r, o, a, "throw", e)
                        }
                        o(void 0)
                    }))
                }
            }

            function Nf(e) {
                var t = function(e, t) {
                    if ("object" != Bf(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, t);
                        if ("object" != Bf(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e, "string");
                return "symbol" == Bf(t) ? t : t + ""
            }
            If.os && null !== If.os.version && void 0 !== If.os.version && (If.os.version = String(If.os.version)), If.browser && null !== If.browser.version && void 0 !== If.browser.version && (If.browser.version = String(If.browser.version));
            var Of = function() {
                return function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, Nf(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e() {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.isDestroyed = !1
                }), [{
                    key: "init",
                    value: (n = Uf(Pf().mark((function e(t) {
                        return Pf().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    this.engine = t, Wd.useCompressedTextures && (null === this.engine.renderer.getContext().getExtension("WEBGL_compressed_texture_s3tc_srgb") && (Wd.useCompressedTextures = !1), this.ktx2Loader = new cf(Xd), this.ktx2Loader.setTranscoderPath("".concat(Wd.paths.decoders_path, "basis/")), this.ktx2Loader.detectSupport(this.engine.renderer)), this.rgbeLoader = new zl(Xd), "mac" === If.os.name && "safari" === If.browser.name && "12.1.2" === If.browser.version && this.rgbeLoader.setDataType(b), "ios" === If.os.name && (window.createImageBitmap = void 0), this.textureLoader = new al(Xd), this.path = Wd.paths.textures_path, this.textureLoader.setPath(this.path), this.rgbeLoader.setPath(this.path);
                                case 9:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function(e) {
                        return n.apply(this, arguments)
                    })
                }, {
                    key: "load",
                    value: (t = Uf(Pf().mark((function e(t) {
                        var n, i = this;
                        return Pf().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return n = [].concat(Wd.textures.flatMap((function(e) {
                                        return e.loadedTexture ? [] : i.loadTexture(e, "map")
                                    })), Wd.models.samara.assetsArray.flatMap((function(e) {
                                        return e.texturesPromises = e.texturesPromises || [], t || e.name === i.engine.assets.initialAsset ? e.textures.flatMap((function(t) {
                                            if (!t.loadedTexture) {
                                                var n = i.loadTexture(t, "map");
                                                return e.texturesPromises.push(n), n
                                            }
                                            return []
                                        })) : []
                                    })), t ? [] : Wd.environment.assetsArray.flatMap(function() {
                                        var e = Uf(Pf().mark((function e(t) {
                                            return Pf().wrap((function(e) {
                                                for (;;) switch (e.prev = e.next) {
                                                    case 0:
                                                        if (!Wd.loadOnDemand.enabled || !t.isDefault || t.loadedHDRTexture || t.loadingHDRTexture) {
                                                            e.next = 5;
                                                            break
                                                        }
                                                        return t.loadingHDRTexture = !0, e.abrupt("return", i.loadTexture(t, "pmrem"));
                                                    case 5:
                                                        return e.abrupt("return", Promise.resolve({
                                                            name: t.name,
                                                            status: "skipped"
                                                        }));
                                                    case 6:
                                                    case "end":
                                                        return e.stop()
                                                }
                                            }), e)
                                        })));
                                        return function(t) {
                                            return e.apply(this, arguments)
                                        }
                                    }())), e.abrupt("return", Promise.all(n));
                                case 2:
                                case "end":
                                    return e.stop()
                            }
                        }), e)
                    }))), function(e) {
                        return t.apply(this, arguments)
                    })
                }, {
                    key: "getHdrTexture",
                    value: function(e) {
                        return Wd.environment.assetsArray.find((function(t) {
                            return t.name === e
                        })).loadedHDRTexture
                    }
                }, {
                    key: "getTexture",
                    value: function(e) {
                        var t = Wd.textures.find((function(t) {
                            return t.name === e
                        }));
                        if (t || Wd.models.samara.assetsArray.filter((function(n) {
                                return n.textures.some((function(n) {
                                    n.name === e && (t = n)
                                }))
                            })), t) return t.loadedTexture
                    }
                }, {
                    key: "loadTexture",
                    value: (e = Uf(Pf().mark((function e(t, n) {
                        var i, r, s, o, a, l;
                        return Pf().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (e.prev = 0, "pmrem" !== n) {
                                        e.next = 15;
                                        break
                                    }
                                    if (!this.isDestroyed && this.engine && this.engine.renderer) {
                                        e.next = 5;
                                        break
                                    }
                                    return e.abrupt("return");
                                case 5:
                                    return e.next = 7, this.rgbeLoader.loadAsync(t.hdrTexturePath);
                                case 7:
                                    if (i = e.sent, !this.isDestroyed && this.engine && this.engine.renderer) {
                                        e.next = 12;
                                        break
                                    }
                                    return i.dispose(), e.abrupt("return");
                                case 12:
                                    r = new Pi(256).fromEquirectangularTexture(this.engine.renderer, i), t.loadedHDRTexture = r.texture, t.loadingHDRTexture = !1;
                                case 15:
                                    if ("map" !== n) {
                                        e.next = 39;
                                        break
                                    }
                                    if (t.loadedTexture) {
                                        e.next = 39;
                                        break
                                    }
                                    if (!(t.isHDR || t.path && t.path.endsWith(".hdr"))) {
                                        e.next = 24;
                                        break
                                    }
                                    return e.next = 20, this.rgbeLoader.loadAsync(t.path);
                                case 20:
                                    s = e.sent, Wd.renderer.hdr.enabled && (s.type = Wd.renderer.hdr.type), e.next = 37;
                                    break;
                                case 24:
                                    if (o = window.innerWidth <= 768, a = t.path, o && a && a.includes("2506/") && (l = a.replace("2506/", "2506/mobile/"), a = l), !t.ktxPath || !Wd.useCompressedTextures) {
                                        e.next = 33;
                                        break
                                    }
                                    return e.next = 30, this.ktx2Loader.loadAsync(this.path + t.ktxPath);
                                case 30:
                                    e.t0 = e.sent, e.next = 36;
                                    break;
                                case 33:
                                    return e.next = 35, this.textureLoader.loadAsync(a);
                                case 35:
                                    e.t0 = e.sent;
                                case 36:
                                    s = e.t0;
                                case 37:
                                    this.setupTexture(s, t), t.loadedTexture = s;
                                case 39:
                                    return e.abrupt("return", Promise.resolve(Df({}, t.name, "loaded")));
                                case 42:
                                    return e.prev = 42, e.t1 = e.catch(0), e.abrupt("return", Promise.reject(e.t1));
                                case 45:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this, [
                            [0, 42]
                        ])
                    }))), function(t, n) {
                        return e.apply(this, arguments)
                    })
                }, {
                    key: "setupTexture",
                    value: function(e, t) {
                        t.anisotropy && (e.anisotropy = this.engine.renderer.capabilities.getMaxAnisotropy()), t.repeat && (e.wrapT = e.wrapS = l, t.repeatSet && e.repeat.set(t.repeatSet, t.repeatSet)), t.nonSrgb || (e.colorSpace = _e), t.rotation && (e.rotation = t.rotation), void 0 !== t.generateMipmaps && (e.generateMipmaps = t.generateMipmaps), t.minFilter && ("LinearMipMapLinearFilter" === t.minFilter ? e.minFilter = g : "NearestFilter" === t.minFilter ? e.minFilter = h : "LinearFilter" === t.minFilter && (e.minFilter = f)), t.magFilter && ("LinearFilter" === t.magFilter ? e.magFilter = f : "NearestFilter" === t.magFilter && (e.magFilter = h)), t.flip || (e.flipY = !1)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.isDestroyed = !0, this.textures && (Object.entries(this.textures).forEach((function(e) {
                            var t = function(e, t) {
                                    return function(e) {
                                        if (Array.isArray(e)) return e
                                    }(e) || function(e, t) {
                                        var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                        if (null != n) {
                                            var i, r, s, o, a = [],
                                                l = !0,
                                                c = !1;
                                            try {
                                                if (s = (n = n.call(e)).next, 0 === t);
                                                else
                                                    for (; !(l = (i = s.call(n)).done) && (a.push(i.value), a.length !== t); l = !0);
                                            } catch (e) {
                                                c = !0, r = e
                                            } finally {
                                                try {
                                                    if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                                } finally {
                                                    if (c) throw r
                                                }
                                            }
                                            return a
                                        }
                                    }(e, t) || function(e, t) {
                                        if (e) {
                                            if ("string" == typeof e) return Rf(e, t);
                                            var n = {}.toString.call(e).slice(8, -1);
                                            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Rf(e, t) : void 0
                                        }
                                    }(e, t) || function() {
                                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }()
                                }(e, 2),
                                n = (t[0], t[1]);
                            n && n.dispose && n.dispose()
                        })), this.textures = {}), Wd.textures && Wd.textures.forEach((function(e) {
                            e.loadedTexture && e.loadedTexture.dispose && (e.loadedTexture.dispose(), e.loadedTexture = null)
                        })), this.ktx2Loader && (this.ktx2Loader.dispose(), this.ktx2Loader = null)
                    }
                }]);
                var e, t, n
            }();
            const Ff = Object.freeze({
                NONE: 0,
                ROTATE: 1,
                TRUCK: 2,
                OFFSET: 4,
                DOLLY: 8,
                ZOOM: 16,
                TOUCH_ROTATE: 32,
                TOUCH_TRUCK: 64,
                TOUCH_OFFSET: 128,
                TOUCH_DOLLY: 256,
                TOUCH_ZOOM: 512,
                TOUCH_DOLLY_TRUCK: 1024,
                TOUCH_DOLLY_OFFSET: 2048,
                TOUCH_DOLLY_ROTATE: 4096,
                TOUCH_ZOOM_TRUCK: 8192,
                TOUCH_ZOOM_OFFSET: 16384,
                TOUCH_ZOOM_ROTATE: 32768
            });

            function kf(e) {
                return e.isPerspectiveCamera
            }

            function Qf(e) {
                return e.isOrthographicCamera
            }
            const zf = 2 * Math.PI,
                Hf = Math.PI / 2,
                Gf = Math.PI / 180;

            function Vf(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }

            function jf(e, t = 1e-5) {
                return Math.abs(e) < t
            }

            function Wf(e, t, n = 1e-5) {
                return jf(e - t, n)
            }

            function Xf(e, t) {
                return Math.round(e / t) * t
            }

            function Yf(e) {
                return isFinite(e) ? e : e < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE
            }

            function qf(e) {
                return Math.abs(e) < Number.MAX_VALUE ? e : e * (1 / 0)
            }

            function Kf(e, t, n, i, r = 1 / 0, s) {
                const o = 2 / (i = Math.max(1e-4, i)),
                    a = o * s,
                    l = 1 / (1 + a + .48 * a * a + .235 * a * a * a);
                let c = e - t;
                const u = t,
                    h = r * i;
                c = Vf(c, -h, h), t = e - c;
                const d = (n.value + o * c) * s;
                n.value = (n.value - o * d) * l;
                let f = t + (c + d) * l;
                return u - e > 0 == f > u && (f = u, n.value = (f - u) / s), f
            }

            function Jf(e, t, n, i, r = 1 / 0, s, o) {
                const a = 2 / (i = Math.max(1e-4, i)),
                    l = a * s,
                    c = 1 / (1 + l + .48 * l * l + .235 * l * l * l);
                let u = t.x,
                    h = t.y,
                    d = t.z,
                    f = e.x - u,
                    p = e.y - h,
                    m = e.z - d;
                const g = u,
                    A = h,
                    v = d,
                    y = r * i,
                    _ = f * f + p * p + m * m;
                if (_ > y * y) {
                    const e = Math.sqrt(_);
                    f = f / e * y, p = p / e * y, m = m / e * y
                }
                u = e.x - f, h = e.y - p, d = e.z - m;
                const x = (n.x + a * f) * s,
                    E = (n.y + a * p) * s,
                    b = (n.z + a * m) * s;
                n.x = (n.x - a * x) * c, n.y = (n.y - a * E) * c, n.z = (n.z - a * b) * c, o.x = u + (f + x) * c, o.y = h + (p + E) * c, o.z = d + (m + b) * c;
                const w = g - e.x,
                    C = A - e.y,
                    S = v - e.z;
                return w * (o.x - g) + C * (o.y - A) + S * (o.z - v) > 0 && (o.x = g, o.y = A, o.z = v, n.x = (o.x - g) / s, n.y = (o.y - A) / s, n.z = (o.z - v) / s), o
            }

            function Zf(e, t) {
                t.set(0, 0), e.forEach((e => {
                    t.x += e.clientX, t.y += e.clientY
                })), t.x /= e.length, t.y /= e.length
            }

            function $f(e, t) {
                return !!Qf(e)
            }
            class ep {
                constructor() {
                    this._listeners = {}
                }
                addEventListener(e, t) {
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    const n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    const n = this._listeners[e];
                    if (void 0 !== n) {
                        const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                    }
                }
                removeAllEventListeners(e) {
                    e ? Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0) : this._listeners = {}
                }
                dispatchEvent(e) {
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const n = t.slice(0);
                        for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e)
                    }
                }
            }
            var tp;
            const np = 1 / 8,
                ip = /Mac/.test(null === (tp = null === globalThis || void 0 === globalThis ? void 0 : globalThis.navigator) || void 0 === tp ? void 0 : tp.platform);
            let rp, sp, op, ap, lp, cp, up, hp, dp, fp, pp, mp, gp, Ap, vp, yp, _p, xp, Ep, bp, wp, Cp, Sp;
            class Tp extends ep {
                static install(e) {
                    rp = e.THREE, sp = Object.freeze(new rp.Vector3(0, 0, 0)), op = Object.freeze(new rp.Vector3(0, 1, 0)), ap = Object.freeze(new rp.Vector3(0, 0, 1)), lp = new rp.Vector2, cp = new rp.Vector3, up = new rp.Vector3, hp = new rp.Vector3, dp = new rp.Vector3, fp = new rp.Vector3, pp = new rp.Vector3, mp = new rp.Vector3, gp = new rp.Vector3, Ap = new rp.Vector3, vp = new rp.Spherical, yp = new rp.Spherical, _p = new rp.Box3, xp = new rp.Box3, Ep = new rp.Sphere, bp = new rp.Quaternion, wp = new rp.Quaternion, Cp = new rp.Matrix4, Sp = new rp.Raycaster
                }
                static get ACTION() {
                    return Ff
                }
                constructor(e, t) {
                    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = .01, this.maxZoom = 1 / 0, this.smoothTime = .25, this.draggingSmoothTime = .125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = .01, this.colliderMeshes = [], this.cancel = () => {}, this._enabled = !0, this._state = Ff.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect, this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = 0, this._thetaVelocity = {
                        value: 0
                    }, this._phiVelocity = {
                        value: 0
                    }, this._radiusVelocity = {
                        value: 0
                    }, this._targetVelocity = new rp.Vector3, this._focalOffsetVelocity = new rp.Vector3, this._zoomVelocity = {
                        value: 0
                    }, this._truckInternal = (e, t, n) => {
                        let i, r;
                        if (kf(this._camera)) {
                            const n = cp.copy(this._camera.position).sub(this._target),
                                s = this._camera.getEffectiveFOV() * Gf,
                                o = n.length() * Math.tan(.5 * s);
                            i = this.truckSpeed * e * o / this._elementRect.height, r = this.truckSpeed * t * o / this._elementRect.height
                        } else {
                            if (!Qf(this._camera)) return;
                            {
                                const n = this._camera;
                                i = e * (n.right - n.left) / n.zoom / this._elementRect.width, r = t * (n.top - n.bottom) / n.zoom / this._elementRect.height
                            }
                        }
                        this.verticalDragToForward ? (n ? this.setFocalOffset(this._focalOffsetEnd.x + i, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(i, 0, !0), this.forward(-r, !0)) : n ? this.setFocalOffset(this._focalOffsetEnd.x + i, this._focalOffsetEnd.y + r, this._focalOffsetEnd.z, !0) : this.truck(i, r, !0)
                    }, this._rotateInternal = (e, t) => {
                        const n = zf * this.azimuthRotateSpeed * e / this._elementRect.height,
                            i = zf * this.polarRotateSpeed * t / this._elementRect.height;
                        this.rotate(n, i, !0)
                    }, this._dollyInternal = (e, t, n) => {
                        const i = Math.pow(.95, -e * this.dollySpeed),
                            r = this._sphericalEnd.radius,
                            s = this._sphericalEnd.radius * i,
                            o = Vf(s, this.minDistance, this.maxDistance),
                            a = o - s;
                        this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(s, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(a, !0), this._dollyToNoClamp(o, !0)) : this._dollyToNoClamp(o, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? s : o) - r, this._dollyControlCoord.set(t, n)), this._lastDollyDirection = Math.sign(-e)
                    }, this._zoomInternal = (e, t, n) => {
                        const i = Math.pow(.95, e * this.dollySpeed),
                            r = this._zoom,
                            s = this._zoom * i;
                        this.zoomTo(s, !0), this.dollyToCursor && (this._changedZoom += s - r, this._dollyControlCoord.set(t, n))
                    }, this._camera = e, this._yAxisUpSpace = (new rp.Quaternion).setFromUnitVectors(this._camera.up, op), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = Ff.NONE, this._target = new rp.Vector3, this._targetEnd = this._target.clone(), this._focalOffset = new rp.Vector3, this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = (new rp.Spherical).setFromVector3(cp.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [new rp.Vector3, new rp.Vector3, new rp.Vector3, new rp.Vector3], this._updateNearPlaneCorners(), this._boundary = new rp.Box3(new rp.Vector3(-1 / 0, -1 / 0, -1 / 0), new rp.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new rp.Vector2, this.mouseButtons = {
                        left: Ff.ROTATE,
                        middle: Ff.DOLLY,
                        right: Ff.TRUCK,
                        wheel: kf(this._camera) ? Ff.DOLLY : Qf(this._camera) ? Ff.ZOOM : Ff.NONE
                    }, this.touches = {
                        one: Ff.TOUCH_ROTATE,
                        two: kf(this._camera) ? Ff.TOUCH_DOLLY_TRUCK : Qf(this._camera) ? Ff.TOUCH_ZOOM_TRUCK : Ff.NONE,
                        three: Ff.TOUCH_TRUCK
                    };
                    const n = new rp.Vector2,
                        i = new rp.Vector2,
                        r = new rp.Vector2,
                        s = e => {
                            if (!this._enabled || !this._domElement) return;
                            if (0 !== this._interactiveArea.left || 0 !== this._interactiveArea.top || 1 !== this._interactiveArea.width || 1 !== this._interactiveArea.height) {
                                const t = this._domElement.getBoundingClientRect(),
                                    n = e.clientX / t.width,
                                    i = e.clientY / t.height;
                                if (n < this._interactiveArea.left || n > this._interactiveArea.right || i < this._interactiveArea.top || i > this._interactiveArea.bottom) return
                            }
                            const t = "mouse" !== e.pointerType ? null : 1 == (1 & e.buttons) ? 1 : 4 == (4 & e.buttons) ? 4 : 2 == (2 & e.buttons) ? 2 : null;
                            if (null !== t) {
                                const e = this._findPointerByMouseButton(t);
                                e && this._disposePointer(e)
                            }
                            if (1 == (1 & e.buttons) && this._lockedPointer) return;
                            const n = {
                                pointerId: e.pointerId,
                                clientX: e.clientX,
                                clientY: e.clientY,
                                deltaX: 0,
                                deltaY: 0,
                                mouseButton: t
                            };
                            this._activePointers.push(n), this._domElement.ownerDocument.removeEventListener("pointermove", o, {
                                passive: !1
                            }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.ownerDocument.addEventListener("pointermove", o, {
                                passive: !1
                            }), this._domElement.ownerDocument.addEventListener("pointerup", a), this._isDragging = !0, h(e)
                        },
                        o = e => {
                            e.cancelable && e.preventDefault();
                            const t = e.pointerId,
                                n = this._lockedPointer || this._findPointerById(t);
                            if (n) {
                                if (n.clientX = e.clientX, n.clientY = e.clientY, n.deltaX = e.movementX, n.deltaY = e.movementY, this._state = 0, "touch" === e.pointerType) switch (this._activePointers.length) {
                                    case 1:
                                        this._state = this.touches.one;
                                        break;
                                    case 2:
                                        this._state = this.touches.two;
                                        break;
                                    case 3:
                                        this._state = this.touches.three
                                } else(!this._isDragging && this._lockedPointer || this._isDragging && 1 == (1 & e.buttons)) && (this._state = this._state | this.mouseButtons.left), this._isDragging && 4 == (4 & e.buttons) && (this._state = this._state | this.mouseButtons.middle), this._isDragging && 2 == (2 & e.buttons) && (this._state = this._state | this.mouseButtons.right);
                                d()
                            }
                        },
                        a = e => {
                            const t = this._findPointerById(e.pointerId);
                            if (!t || t !== this._lockedPointer) {
                                if (t && this._disposePointer(t), "touch" === e.pointerType) switch (this._activePointers.length) {
                                    case 0:
                                        this._state = Ff.NONE;
                                        break;
                                    case 1:
                                        this._state = this.touches.one;
                                        break;
                                    case 2:
                                        this._state = this.touches.two;
                                        break;
                                    case 3:
                                        this._state = this.touches.three
                                } else this._state = Ff.NONE;
                                f()
                            }
                        };
                    let l = -1;
                    const c = e => {
                            if (!this._domElement) return;
                            if (!this._enabled || this.mouseButtons.wheel === Ff.NONE) return;
                            if (0 !== this._interactiveArea.left || 0 !== this._interactiveArea.top || 1 !== this._interactiveArea.width || 1 !== this._interactiveArea.height) {
                                const t = this._domElement.getBoundingClientRect(),
                                    n = e.clientX / t.width,
                                    i = e.clientY / t.height;
                                if (n < this._interactiveArea.left || n > this._interactiveArea.right || i < this._interactiveArea.top || i > this._interactiveArea.bottom) return
                            }
                            if (e.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Ff.ROTATE || this.mouseButtons.wheel === Ff.TRUCK) {
                                const e = performance.now();
                                l - e < 1e3 && this._getClientRect(this._elementRect), l = e
                            }
                            const t = ip ? -1 : -3,
                                n = 1 === e.deltaMode ? e.deltaY / t : e.deltaY / (10 * t),
                                i = this.dollyToCursor ? (e.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0,
                                r = this.dollyToCursor ? (e.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
                            switch (this.mouseButtons.wheel) {
                                case Ff.ROTATE:
                                    this._rotateInternal(e.deltaX, e.deltaY), this._isUserControllingRotate = !0;
                                    break;
                                case Ff.TRUCK:
                                    this._truckInternal(e.deltaX, e.deltaY, !1), this._isUserControllingTruck = !0;
                                    break;
                                case Ff.OFFSET:
                                    this._truckInternal(e.deltaX, e.deltaY, !0), this._isUserControllingOffset = !0;
                                    break;
                                case Ff.DOLLY:
                                    this._dollyInternal(-n, i, r), this._isUserControllingDolly = !0;
                                    break;
                                case Ff.ZOOM:
                                    this._zoomInternal(-n, i, r), this._isUserControllingZoom = !0
                            }
                            this.dispatchEvent({
                                type: "control"
                            })
                        },
                        u = e => {
                            if (this._domElement && this._enabled) {
                                if (this.mouseButtons.right === Tp.ACTION.NONE) {
                                    const t = e instanceof PointerEvent ? e.pointerId : 0,
                                        n = this._findPointerById(t);
                                    return n && this._disposePointer(n), this._domElement.ownerDocument.removeEventListener("pointermove", o, {
                                        passive: !1
                                    }), void this._domElement.ownerDocument.removeEventListener("pointerup", a)
                                }
                                e.preventDefault()
                            }
                        },
                        h = e => {
                            if (this._enabled) {
                                if (Zf(this._activePointers, lp), this._getClientRect(this._elementRect), n.copy(lp), i.copy(lp), this._activePointers.length >= 2) {
                                    const e = lp.x - this._activePointers[1].clientX,
                                        t = lp.y - this._activePointers[1].clientY,
                                        n = Math.sqrt(e * e + t * t);
                                    r.set(0, n);
                                    const s = .5 * (this._activePointers[0].clientX + this._activePointers[1].clientX),
                                        o = .5 * (this._activePointers[0].clientY + this._activePointers[1].clientY);
                                    i.set(s, o)
                                }
                                if (this._state = 0, e)
                                    if ("pointerType" in e && "touch" === e.pointerType) switch (this._activePointers.length) {
                                        case 1:
                                            this._state = this.touches.one;
                                            break;
                                        case 2:
                                            this._state = this.touches.two;
                                            break;
                                        case 3:
                                            this._state = this.touches.three
                                    } else this._lockedPointer || 1 != (1 & e.buttons) || (this._state = this._state | this.mouseButtons.left), 4 == (4 & e.buttons) && (this._state = this._state | this.mouseButtons.middle), 2 == (2 & e.buttons) && (this._state = this._state | this.mouseButtons.right);
                                    else this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
                                (this._state & Ff.ROTATE) !== Ff.ROTATE && (this._state & Ff.TOUCH_ROTATE) !== Ff.TOUCH_ROTATE && (this._state & Ff.TOUCH_DOLLY_ROTATE) !== Ff.TOUCH_DOLLY_ROTATE && (this._state & Ff.TOUCH_ZOOM_ROTATE) !== Ff.TOUCH_ZOOM_ROTATE || (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), (this._state & Ff.TRUCK) !== Ff.TRUCK && (this._state & Ff.TOUCH_TRUCK) !== Ff.TOUCH_TRUCK && (this._state & Ff.TOUCH_DOLLY_TRUCK) !== Ff.TOUCH_DOLLY_TRUCK && (this._state & Ff.TOUCH_ZOOM_TRUCK) !== Ff.TOUCH_ZOOM_TRUCK || (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), (this._state & Ff.DOLLY) !== Ff.DOLLY && (this._state & Ff.TOUCH_DOLLY) !== Ff.TOUCH_DOLLY && (this._state & Ff.TOUCH_DOLLY_TRUCK) !== Ff.TOUCH_DOLLY_TRUCK && (this._state & Ff.TOUCH_DOLLY_OFFSET) !== Ff.TOUCH_DOLLY_OFFSET && (this._state & Ff.TOUCH_DOLLY_ROTATE) !== Ff.TOUCH_DOLLY_ROTATE || (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), (this._state & Ff.ZOOM) !== Ff.ZOOM && (this._state & Ff.TOUCH_ZOOM) !== Ff.TOUCH_ZOOM && (this._state & Ff.TOUCH_ZOOM_TRUCK) !== Ff.TOUCH_ZOOM_TRUCK && (this._state & Ff.TOUCH_ZOOM_OFFSET) !== Ff.TOUCH_ZOOM_OFFSET && (this._state & Ff.TOUCH_ZOOM_ROTATE) !== Ff.TOUCH_ZOOM_ROTATE || (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), (this._state & Ff.OFFSET) !== Ff.OFFSET && (this._state & Ff.TOUCH_OFFSET) !== Ff.TOUCH_OFFSET && (this._state & Ff.TOUCH_DOLLY_OFFSET) !== Ff.TOUCH_DOLLY_OFFSET && (this._state & Ff.TOUCH_ZOOM_OFFSET) !== Ff.TOUCH_ZOOM_OFFSET || (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({
                                    type: "controlstart"
                                })
                            }
                        },
                        d = () => {
                            if (!this._enabled || !this._dragNeedsUpdate) return;
                            this._dragNeedsUpdate = !1, Zf(this._activePointers, lp);
                            const e = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null,
                                t = e ? -e.deltaX : i.x - lp.x,
                                s = e ? -e.deltaY : i.y - lp.y;
                            if (i.copy(lp), (this._state & Ff.ROTATE) !== Ff.ROTATE && (this._state & Ff.TOUCH_ROTATE) !== Ff.TOUCH_ROTATE && (this._state & Ff.TOUCH_DOLLY_ROTATE) !== Ff.TOUCH_DOLLY_ROTATE && (this._state & Ff.TOUCH_ZOOM_ROTATE) !== Ff.TOUCH_ZOOM_ROTATE || (this._rotateInternal(t, s), this._isUserControllingRotate = !0), (this._state & Ff.DOLLY) === Ff.DOLLY || (this._state & Ff.ZOOM) === Ff.ZOOM) {
                                const e = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0,
                                    t = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0,
                                    i = this.dollyDragInverted ? -1 : 1;
                                (this._state & Ff.DOLLY) === Ff.DOLLY ? (this._dollyInternal(i * s * np, e, t), this._isUserControllingDolly = !0) : (this._zoomInternal(i * s * np, e, t), this._isUserControllingZoom = !0)
                            }
                            if ((this._state & Ff.TOUCH_DOLLY) === Ff.TOUCH_DOLLY || (this._state & Ff.TOUCH_ZOOM) === Ff.TOUCH_ZOOM || (this._state & Ff.TOUCH_DOLLY_TRUCK) === Ff.TOUCH_DOLLY_TRUCK || (this._state & Ff.TOUCH_ZOOM_TRUCK) === Ff.TOUCH_ZOOM_TRUCK || (this._state & Ff.TOUCH_DOLLY_OFFSET) === Ff.TOUCH_DOLLY_OFFSET || (this._state & Ff.TOUCH_ZOOM_OFFSET) === Ff.TOUCH_ZOOM_OFFSET || (this._state & Ff.TOUCH_DOLLY_ROTATE) === Ff.TOUCH_DOLLY_ROTATE || (this._state & Ff.TOUCH_ZOOM_ROTATE) === Ff.TOUCH_ZOOM_ROTATE) {
                                const e = lp.x - this._activePointers[1].clientX,
                                    t = lp.y - this._activePointers[1].clientY,
                                    n = Math.sqrt(e * e + t * t),
                                    s = r.y - n;
                                r.set(0, n);
                                const o = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0,
                                    a = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
                                (this._state & Ff.TOUCH_DOLLY) === Ff.TOUCH_DOLLY || (this._state & Ff.TOUCH_DOLLY_ROTATE) === Ff.TOUCH_DOLLY_ROTATE || (this._state & Ff.TOUCH_DOLLY_TRUCK) === Ff.TOUCH_DOLLY_TRUCK || (this._state & Ff.TOUCH_DOLLY_OFFSET) === Ff.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(s * np, o, a), this._isUserControllingDolly = !0) : (this._zoomInternal(s * np, o, a), this._isUserControllingZoom = !0)
                            }(this._state & Ff.TRUCK) !== Ff.TRUCK && (this._state & Ff.TOUCH_TRUCK) !== Ff.TOUCH_TRUCK && (this._state & Ff.TOUCH_DOLLY_TRUCK) !== Ff.TOUCH_DOLLY_TRUCK && (this._state & Ff.TOUCH_ZOOM_TRUCK) !== Ff.TOUCH_ZOOM_TRUCK || (this._truckInternal(t, s, !1), this._isUserControllingTruck = !0), (this._state & Ff.OFFSET) !== Ff.OFFSET && (this._state & Ff.TOUCH_OFFSET) !== Ff.TOUCH_OFFSET && (this._state & Ff.TOUCH_DOLLY_OFFSET) !== Ff.TOUCH_DOLLY_OFFSET && (this._state & Ff.TOUCH_ZOOM_OFFSET) !== Ff.TOUCH_ZOOM_OFFSET || (this._truckInternal(t, s, !0), this._isUserControllingOffset = !0), this.dispatchEvent({
                                type: "control"
                            })
                        },
                        f = () => {
                            Zf(this._activePointers, lp), i.copy(lp), this._dragNeedsUpdate = !1, (0 === this._activePointers.length || 1 === this._activePointers.length && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), 0 === this._activePointers.length && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", o, {
                                passive: !1
                            }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this.dispatchEvent({
                                type: "controlend"
                            }))
                        };
                    this.lockPointer = () => {
                        this._enabled && this._domElement && (this.cancel(), this._lockedPointer = {
                            pointerId: -1,
                            clientX: 0,
                            clientY: 0,
                            deltaX: 0,
                            deltaY: 0,
                            mouseButton: null
                        }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", o, {
                            passive: !1
                        }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", p), this._domElement.ownerDocument.addEventListener("pointerlockerror", m), this._domElement.ownerDocument.addEventListener("pointermove", o, {
                            passive: !1
                        }), this._domElement.ownerDocument.addEventListener("pointerup", a), h())
                    }, this.unlockPointer = () => {
                        var e, t, n;
                        null !== this._lockedPointer && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), null === (e = this._domElement) || void 0 === e || e.ownerDocument.exitPointerLock(), null === (t = this._domElement) || void 0 === t || t.ownerDocument.removeEventListener("pointerlockchange", p), null === (n = this._domElement) || void 0 === n || n.ownerDocument.removeEventListener("pointerlockerror", m), this.cancel()
                    };
                    const p = () => {
                            this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer()
                        },
                        m = () => {
                            this.unlockPointer()
                        };
                    this._addAllEventListeners = e => {
                        this._domElement = e, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", s), this._domElement.addEventListener("pointercancel", a), this._domElement.addEventListener("wheel", c, {
                            passive: !1
                        }), this._domElement.addEventListener("contextmenu", u)
                    }, this._removeAllEventListeners = () => {
                        this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", s), this._domElement.removeEventListener("pointercancel", a), this._domElement.removeEventListener("wheel", c, {
                            passive: !1
                        }), this._domElement.removeEventListener("contextmenu", u), this._domElement.ownerDocument.removeEventListener("pointermove", o, {
                            passive: !1
                        }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.ownerDocument.removeEventListener("pointerlockchange", p), this._domElement.ownerDocument.removeEventListener("pointerlockerror", m))
                    }, this.cancel = () => {
                        this._state !== Ff.NONE && (this._state = Ff.NONE, this._activePointers.length = 0, f())
                    }, t && this.connect(t), this.update(0)
                }
                get camera() {
                    return this._camera
                }
                set camera(e) {
                    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0
                }
                get enabled() {
                    return this._enabled
                }
                set enabled(e) {
                    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""))
                }
                get active() {
                    return !this._hasRested
                }
                get currentAction() {
                    return this._state
                }
                get distance() {
                    return this._spherical.radius
                }
                set distance(e) {
                    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0)
                }
                get azimuthAngle() {
                    return this._spherical.theta
                }
                set azimuthAngle(e) {
                    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0)
                }
                get polarAngle() {
                    return this._spherical.phi
                }
                set polarAngle(e) {
                    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0)
                }
                get boundaryEnclosesCamera() {
                    return this._boundaryEnclosesCamera
                }
                set boundaryEnclosesCamera(e) {
                    this._boundaryEnclosesCamera = e, this._needsUpdate = !0
                }
                set interactiveArea(e) {
                    this._interactiveArea.width = Vf(e.width, 0, 1), this._interactiveArea.height = Vf(e.height, 0, 1), this._interactiveArea.x = Vf(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Vf(e.y, 0, 1 - this._interactiveArea.height)
                }
                addEventListener(e, t) {
                    super.addEventListener(e, t)
                }
                removeEventListener(e, t) {
                    super.removeEventListener(e, t)
                }
                rotate(e, t, n = !1) {
                    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n)
                }
                rotateAzimuthTo(e, t = !1) {
                    return this.rotateTo(e, this._sphericalEnd.phi, t)
                }
                rotatePolarTo(e, t = !1) {
                    return this.rotateTo(this._sphericalEnd.theta, e, t)
                }
                rotateTo(e, t, n = !1) {
                    this._isUserControllingRotate = !1;
                    const i = Vf(e, this.minAzimuthAngle, this.maxAzimuthAngle),
                        r = Vf(t, this.minPolarAngle, this.maxPolarAngle);
                    this._sphericalEnd.theta = i, this._sphericalEnd.phi = r, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
                    const s = !n || Wf(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Wf(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
                    return this._createOnRestPromise(s)
                }
                dolly(e, t = !1) {
                    return this.dollyTo(this._sphericalEnd.radius - e, t)
                }
                dollyTo(e, t = !1) {
                    return this._isUserControllingDolly = !1, this._lastDollyDirection = 0, this._changedDolly = 0, this._dollyToNoClamp(Vf(e, this.minDistance, this.maxDistance), t)
                }
                _dollyToNoClamp(e, t = !1) {
                    const n = this._sphericalEnd.radius;
                    if (this.colliderMeshes.length >= 1) {
                        const t = this._collisionTest(),
                            i = Wf(t, this._spherical.radius);
                        if (!(n > e) && i) return Promise.resolve();
                        this._sphericalEnd.radius = Math.min(e, t)
                    } else this._sphericalEnd.radius = e;
                    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
                    const i = !t || Wf(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
                    return this._createOnRestPromise(i)
                }
                dollyInFixed(e, t = !1) {
                    this._targetEnd.add(this._getCameraDirection(dp).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
                    const n = !t || Wf(this._target.x, this._targetEnd.x, this.restThreshold) && Wf(this._target.y, this._targetEnd.y, this.restThreshold) && Wf(this._target.z, this._targetEnd.z, this.restThreshold);
                    return this._createOnRestPromise(n)
                }
                zoom(e, t = !1) {
                    return this.zoomTo(this._zoomEnd + e, t)
                }
                zoomTo(e, t = !1) {
                    this._isUserControllingZoom = !1, this._zoomEnd = Vf(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
                    const n = !t || Wf(this._zoom, this._zoomEnd, this.restThreshold);
                    return this._changedZoom = 0, this._createOnRestPromise(n)
                }
                pan(e, t, n = !1) {
                    return this.truck(e, t, n)
                }
                truck(e, t, n = !1) {
                    this._camera.updateMatrix(), fp.setFromMatrixColumn(this._camera.matrix, 0), pp.setFromMatrixColumn(this._camera.matrix, 1), fp.multiplyScalar(e), pp.multiplyScalar(-t);
                    const i = cp.copy(fp).add(pp),
                        r = up.copy(this._targetEnd).add(i);
                    return this.moveTo(r.x, r.y, r.z, n)
                }
                forward(e, t = !1) {
                    cp.setFromMatrixColumn(this._camera.matrix, 0), cp.crossVectors(this._camera.up, cp), cp.multiplyScalar(e);
                    const n = up.copy(this._targetEnd).add(cp);
                    return this.moveTo(n.x, n.y, n.z, t)
                }
                elevate(e, t = !1) {
                    return cp.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + cp.x, this._targetEnd.y + cp.y, this._targetEnd.z + cp.z, t)
                }
                moveTo(e, t, n, i = !1) {
                    this._isUserControllingTruck = !1;
                    const r = cp.set(e, t, n).sub(this._targetEnd);
                    this._encloseToBoundary(this._targetEnd, r, this.boundaryFriction), this._needsUpdate = !0, i || this._target.copy(this._targetEnd);
                    const s = !i || Wf(this._target.x, this._targetEnd.x, this.restThreshold) && Wf(this._target.y, this._targetEnd.y, this.restThreshold) && Wf(this._target.z, this._targetEnd.z, this.restThreshold);
                    return this._createOnRestPromise(s)
                }
                lookInDirectionOf(e, t, n, i = !1) {
                    const r = cp.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
                    return this.setPosition(r.x, r.y, r.z, i)
                }
                fitToBox(e, t, {
                    cover: n = !1,
                    paddingLeft: i = 0,
                    paddingRight: r = 0,
                    paddingBottom: s = 0,
                    paddingTop: o = 0
                } = {}) {
                    const a = [],
                        l = e.isBox3 ? _p.copy(e) : _p.setFromObject(e);
                    l.isEmpty() && Promise.resolve();
                    const c = Xf(this._sphericalEnd.theta, Hf),
                        u = Xf(this._sphericalEnd.phi, Hf);
                    a.push(this.rotateTo(c, u, t));
                    const h = cp.setFromSpherical(this._sphericalEnd).normalize(),
                        d = bp.setFromUnitVectors(h, ap),
                        f = Wf(Math.abs(h.y), 1);
                    f && d.multiply(wp.setFromAxisAngle(op, c)), d.multiply(this._yAxisUpSpaceInverse);
                    const p = xp.makeEmpty();
                    up.copy(l.min).applyQuaternion(d), p.expandByPoint(up), up.copy(l.min).setX(l.max.x).applyQuaternion(d), p.expandByPoint(up), up.copy(l.min).setY(l.max.y).applyQuaternion(d), p.expandByPoint(up), up.copy(l.max).setZ(l.min.z).applyQuaternion(d), p.expandByPoint(up), up.copy(l.min).setZ(l.max.z).applyQuaternion(d), p.expandByPoint(up), up.copy(l.max).setY(l.min.y).applyQuaternion(d), p.expandByPoint(up), up.copy(l.max).setX(l.min.x).applyQuaternion(d), p.expandByPoint(up), up.copy(l.max).applyQuaternion(d), p.expandByPoint(up), p.min.x -= i, p.min.y -= s, p.max.x += r, p.max.y += o, d.setFromUnitVectors(ap, h), f && d.premultiply(wp.invert()), d.premultiply(this._yAxisUpSpace);
                    const m = p.getSize(cp),
                        g = p.getCenter(up).applyQuaternion(d);
                    if (kf(this._camera)) {
                        const e = this.getDistanceToFitBox(m.x, m.y, m.z, n);
                        a.push(this.moveTo(g.x, g.y, g.z, t)), a.push(this.dollyTo(e, t)), a.push(this.setFocalOffset(0, 0, 0, t))
                    } else if (Qf(this._camera)) {
                        const e = this._camera,
                            i = e.right - e.left,
                            r = e.top - e.bottom,
                            s = n ? Math.max(i / m.x, r / m.y) : Math.min(i / m.x, r / m.y);
                        a.push(this.moveTo(g.x, g.y, g.z, t)), a.push(this.zoomTo(s, t)), a.push(this.setFocalOffset(0, 0, 0, t))
                    }
                    return Promise.all(a)
                }
                fitToSphere(e, t) {
                    const n = [],
                        i = "isObject3D" in e ? Tp.createBoundingSphere(e, Ep) : Ep.copy(e);
                    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), kf(this._camera)) {
                        const e = this.getDistanceToFitSphere(i.radius);
                        n.push(this.dollyTo(e, t))
                    } else if (Qf(this._camera)) {
                        const e = this._camera.right - this._camera.left,
                            r = this._camera.top - this._camera.bottom,
                            s = 2 * i.radius,
                            o = Math.min(e / s, r / s);
                        n.push(this.zoomTo(o, t))
                    }
                    return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n)
                }
                setLookAt(e, t, n, i, r, s, o = !1) {
                    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = 0, this._changedDolly = 0;
                    const a = up.set(i, r, s),
                        l = cp.set(e, t, n);
                    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(l.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, o || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
                    const c = !o || Wf(this._target.x, this._targetEnd.x, this.restThreshold) && Wf(this._target.y, this._targetEnd.y, this.restThreshold) && Wf(this._target.z, this._targetEnd.z, this.restThreshold) && Wf(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Wf(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Wf(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
                    return this._createOnRestPromise(c)
                }
                lerpLookAt(e, t, n, i, r, s, o, a, l, c, u, h, d, f = !1) {
                    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = 0, this._changedDolly = 0;
                    const p = cp.set(i, r, s),
                        m = up.set(e, t, n);
                    vp.setFromVector3(m.sub(p).applyQuaternion(this._yAxisUpSpace));
                    const g = hp.set(c, u, h),
                        A = up.set(o, a, l);
                    yp.setFromVector3(A.sub(g).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(p.lerp(g, d));
                    const v = yp.theta - vp.theta,
                        y = yp.phi - vp.phi,
                        _ = yp.radius - vp.radius;
                    this._sphericalEnd.set(vp.radius + _ * d, vp.phi + y * d, vp.theta + v * d), this.normalizeRotations(), this._needsUpdate = !0, f || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
                    const x = !f || Wf(this._target.x, this._targetEnd.x, this.restThreshold) && Wf(this._target.y, this._targetEnd.y, this.restThreshold) && Wf(this._target.z, this._targetEnd.z, this.restThreshold) && Wf(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Wf(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Wf(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
                    return this._createOnRestPromise(x)
                }
                setPosition(e, t, n, i = !1) {
                    return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i)
                }
                setTarget(e, t, n, i = !1) {
                    const r = this.getPosition(cp),
                        s = this.setLookAt(r.x, r.y, r.z, e, t, n, i);
                    return this._sphericalEnd.phi = Vf(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), s
                }
                setFocalOffset(e, t, n, i = !1) {
                    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, i || this._focalOffset.copy(this._focalOffsetEnd);
                    const r = !i || Wf(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Wf(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Wf(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
                    return this._createOnRestPromise(r)
                }
                setOrbitPoint(e, t, n) {
                    this._camera.updateMatrixWorld(), fp.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), pp.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), mp.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
                    const i = cp.set(e, t, n),
                        r = i.distanceTo(this._camera.position),
                        s = i.sub(this._camera.position);
                    fp.multiplyScalar(s.x), pp.multiplyScalar(s.y), mp.multiplyScalar(s.z), cp.copy(fp).add(pp).add(mp), cp.z = cp.z + r, this.dollyTo(r, !1), this.setFocalOffset(-cp.x, cp.y, -cp.z, !1), this.moveTo(e, t, n, !1)
                }
                setBoundary(e) {
                    if (!e) return this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), void(this._needsUpdate = !0);
                    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0
                }
                setViewport(e, t, n, i) {
                    null !== e ? (this._viewport = this._viewport || new rp.Vector4, "number" == typeof e ? this._viewport.set(e, t, n, i) : this._viewport.copy(e)) : this._viewport = null
                }
                getDistanceToFitBox(e, t, n, i = !1) {
                    if ($f(this._camera)) return this._spherical.radius;
                    const r = e / t,
                        s = this._camera.getEffectiveFOV() * Gf,
                        o = this._camera.aspect;
                    return .5 * ((i ? r > o : r < o) ? t : e / o) / Math.tan(.5 * s) + .5 * n
                }
                getDistanceToFitSphere(e) {
                    if ($f(this._camera)) return this._spherical.radius;
                    const t = this._camera.getEffectiveFOV() * Gf,
                        n = 2 * Math.atan(Math.tan(.5 * t) * this._camera.aspect),
                        i = 1 < this._camera.aspect ? t : n;
                    return e / Math.sin(.5 * i)
                }
                getTarget(e, t = !0) {
                    return (e && e.isVector3 ? e : new rp.Vector3).copy(t ? this._targetEnd : this._target)
                }
                getPosition(e, t = !0) {
                    return (e && e.isVector3 ? e : new rp.Vector3).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target)
                }
                getSpherical(e, t = !0) {
                    return (e || new rp.Spherical).copy(t ? this._sphericalEnd : this._spherical)
                }
                getFocalOffset(e, t = !0) {
                    return (e && e.isVector3 ? e : new rp.Vector3).copy(t ? this._focalOffsetEnd : this._focalOffset)
                }
                normalizeRotations() {
                    this._sphericalEnd.theta = this._sphericalEnd.theta % zf, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += zf), this._spherical.theta += zf * Math.round((this._sphericalEnd.theta - this._spherical.theta) / zf)
                }
                stop() {
                    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd
                }
                reset(e = !1) {
                    if (!Wf(this._camera.up.x, this._cameraUp0.x) || !Wf(this._camera.up.y, this._cameraUp0.y) || !Wf(this._camera.up.z, this._cameraUp0.z)) {
                        this._camera.up.copy(this._cameraUp0);
                        const e = this.getPosition(cp);
                        this.updateCameraUp(), this.setPosition(e.x, e.y, e.z)
                    }
                    const t = [this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e), this.zoomTo(this._zoom0, e)];
                    return Promise.all(t)
                }
                saveState() {
                    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset)
                }
                updateCameraUp() {
                    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, op), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()
                }
                applyCameraUp() {
                    const e = cp.subVectors(this._target, this._camera.position).normalize(),
                        t = up.crossVectors(e, this._camera.up);
                    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
                    const n = this.getPosition(cp);
                    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z)
                }
                update(e) {
                    const t = this._sphericalEnd.theta - this._spherical.theta,
                        n = this._sphericalEnd.phi - this._spherical.phi,
                        i = this._sphericalEnd.radius - this._spherical.radius,
                        r = gp.subVectors(this._targetEnd, this._target),
                        s = Ap.subVectors(this._focalOffsetEnd, this._focalOffset),
                        o = this._zoomEnd - this._zoom;
                    if (jf(t)) this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
                    else {
                        const t = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
                        this._spherical.theta = Kf(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, t, 1 / 0, e), this._needsUpdate = !0
                    }
                    if (jf(n)) this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
                    else {
                        const t = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
                        this._spherical.phi = Kf(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, t, 1 / 0, e), this._needsUpdate = !0
                    }
                    if (jf(i)) this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
                    else {
                        const t = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
                        this._spherical.radius = Kf(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, t, this.maxSpeed, e), this._needsUpdate = !0
                    }
                    if (jf(r.x) && jf(r.y) && jf(r.z)) this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
                    else {
                        const t = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
                        Jf(this._target, this._targetEnd, this._targetVelocity, t, this.maxSpeed, e, this._target), this._needsUpdate = !0
                    }
                    if (jf(s.x) && jf(s.y) && jf(s.z)) this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
                    else {
                        const t = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
                        Jf(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, t, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0
                    }
                    if (jf(o)) this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
                    else {
                        const t = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
                        this._zoom = Kf(this._zoom, this._zoomEnd, this._zoomVelocity, t, 1 / 0, e)
                    }
                    if (this.dollyToCursor)
                        if (kf(this._camera) && 0 !== this._changedDolly) {
                            const e = this._spherical.radius - this._lastDistance,
                                t = this._camera,
                                n = this._getCameraDirection(dp),
                                i = cp.copy(n).cross(t.up).normalize();
                            0 === i.lengthSq() && (i.x = 1);
                            const r = up.crossVectors(i, n),
                                s = this._sphericalEnd.radius * Math.tan(t.getEffectiveFOV() * Gf * .5),
                                o = (this._sphericalEnd.radius - e - this._sphericalEnd.radius) / this._sphericalEnd.radius,
                                a = hp.copy(this._targetEnd).add(i.multiplyScalar(this._dollyControlCoord.x * s * t.aspect)).add(r.multiplyScalar(this._dollyControlCoord.y * s)),
                                l = cp.copy(this._targetEnd).lerp(a, o),
                                c = 1 === this._lastDollyDirection && this._spherical.radius <= this.minDistance,
                                u = -1 === this._lastDollyDirection && this.maxDistance <= this._spherical.radius;
                            if (this.infinityDolly && (c || u)) {
                                this._sphericalEnd.radius -= e, this._spherical.radius -= e;
                                const t = up.copy(n).multiplyScalar(-e);
                                l.add(t)
                            }
                            this._boundary.clampPoint(l, l);
                            const h = up.subVectors(l, this._targetEnd);
                            this._targetEnd.copy(l), this._target.add(h), this._changedDolly -= e, jf(this._changedDolly) && (this._changedDolly = 0)
                        } else if (Qf(this._camera) && 0 !== this._changedZoom) {
                        const e = this._zoom - this._lastZoom,
                            t = this._camera,
                            n = cp.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                            i = up.set(0, 0, -1).applyQuaternion(t.quaternion),
                            r = hp.copy(n).add(i.multiplyScalar(-n.dot(t.up))),
                            s = -(this._zoom - e - this._zoom) / this._zoom,
                            o = this._getCameraDirection(dp),
                            a = this._targetEnd.dot(o),
                            l = cp.copy(this._targetEnd).lerp(r, s),
                            c = l.dot(o),
                            u = o.multiplyScalar(c - a);
                        l.sub(u), this._boundary.clampPoint(l, l);
                        const h = up.subVectors(l, this._targetEnd);
                        this._targetEnd.copy(l), this._target.add(h), this._changedZoom -= e, jf(this._changedZoom) && (this._changedZoom = 0)
                    }
                    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
                    const a = this._collisionTest();
                    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!jf(this._focalOffset.x) || !jf(this._focalOffset.y) || !jf(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), fp.setFromMatrixColumn(this._camera.matrix, 0), pp.setFromMatrixColumn(this._camera.matrix, 1), mp.setFromMatrixColumn(this._camera.matrix, 2), fp.multiplyScalar(this._focalOffset.x), pp.multiplyScalar(-this._focalOffset.y), mp.multiplyScalar(this._focalOffset.z), cp.copy(fp).add(pp).add(mp), this._camera.position.add(cp)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), cp.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
                    const l = this._needsUpdate;
                    return l && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({
                        type: "wake"
                    }), this.dispatchEvent({
                        type: "update"
                    })) : l ? (this.dispatchEvent({
                        type: "update"
                    }), jf(t, this.restThreshold) && jf(n, this.restThreshold) && jf(i, this.restThreshold) && jf(r.x, this.restThreshold) && jf(r.y, this.restThreshold) && jf(r.z, this.restThreshold) && jf(s.x, this.restThreshold) && jf(s.y, this.restThreshold) && jf(s.z, this.restThreshold) && jf(o, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({
                        type: "rest"
                    }))) : !l && this._updatedLastTime && this.dispatchEvent({
                        type: "sleep"
                    }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = l, this._needsUpdate = !1, l
                }
                toJSON() {
                    return JSON.stringify({
                        enabled: this._enabled,
                        minDistance: this.minDistance,
                        maxDistance: Yf(this.maxDistance),
                        minZoom: this.minZoom,
                        maxZoom: Yf(this.maxZoom),
                        minPolarAngle: this.minPolarAngle,
                        maxPolarAngle: Yf(this.maxPolarAngle),
                        minAzimuthAngle: Yf(this.minAzimuthAngle),
                        maxAzimuthAngle: Yf(this.maxAzimuthAngle),
                        smoothTime: this.smoothTime,
                        draggingSmoothTime: this.draggingSmoothTime,
                        dollySpeed: this.dollySpeed,
                        truckSpeed: this.truckSpeed,
                        dollyToCursor: this.dollyToCursor,
                        verticalDragToForward: this.verticalDragToForward,
                        target: this._targetEnd.toArray(),
                        position: cp.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
                        zoom: this._zoomEnd,
                        focalOffset: this._focalOffsetEnd.toArray(),
                        target0: this._target0.toArray(),
                        position0: this._position0.toArray(),
                        zoom0: this._zoom0,
                        focalOffset0: this._focalOffset0.toArray()
                    })
                }
                fromJSON(e, t = !1) {
                    const n = JSON.parse(e);
                    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = qf(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = qf(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = qf(n.maxPolarAngle), this.minAzimuthAngle = qf(n.minAzimuthAngle), this.maxAzimuthAngle = qf(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), vp.setFromVector3(cp.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(vp.theta, vp.phi, t), this.dollyTo(vp.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0
                }
                connect(e) {
                    this._domElement || (e.setAttribute("data-camera-controls-version", "2.9.0"), this._addAllEventListeners(e), this._getClientRect(this._elementRect))
                }
                disconnect() {
                    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0)
                }
                dispose() {
                    this.removeAllEventListeners(), this.disconnect()
                }
                _getTargetDirection(e) {
                    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)
                }
                _getCameraDirection(e) {
                    return this._getTargetDirection(e).negate()
                }
                _findPointerById(e) {
                    return this._activePointers.find((t => t.pointerId === e))
                }
                _findPointerByMouseButton(e) {
                    return this._activePointers.find((t => t.mouseButton === e))
                }
                _disposePointer(e) {
                    this._activePointers.splice(this._activePointers.indexOf(e), 1)
                }
                _encloseToBoundary(e, t, n) {
                    const i = t.lengthSq();
                    if (0 === i) return e;
                    const r = up.copy(t).add(e),
                        s = this._boundary.clampPoint(r, hp).sub(r),
                        o = s.lengthSq();
                    if (0 === o) return e.add(t);
                    if (o === i) return e;
                    if (0 === n) return e.add(t).add(s);
                    {
                        const i = 1 + n * o / t.dot(s);
                        return e.add(up.copy(t).multiplyScalar(i)).add(s.multiplyScalar(1 - n))
                    }
                }
                _updateNearPlaneCorners() {
                    if (kf(this._camera)) {
                        const e = this._camera,
                            t = e.near,
                            n = e.getEffectiveFOV() * Gf,
                            i = Math.tan(.5 * n) * t,
                            r = i * e.aspect;
                        this._nearPlaneCorners[0].set(-r, -i, 0), this._nearPlaneCorners[1].set(r, -i, 0), this._nearPlaneCorners[2].set(r, i, 0), this._nearPlaneCorners[3].set(-r, i, 0)
                    } else if (Qf(this._camera)) {
                        const e = this._camera,
                            t = 1 / e.zoom,
                            n = e.left * t,
                            i = e.right * t,
                            r = e.top * t,
                            s = e.bottom * t;
                        this._nearPlaneCorners[0].set(n, r, 0), this._nearPlaneCorners[1].set(i, r, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(n, s, 0)
                    }
                }
                _collisionTest() {
                    let e = 1 / 0;
                    if (!(this.colliderMeshes.length >= 1)) return e;
                    if ($f(this._camera)) return e;
                    const t = this._getTargetDirection(dp);
                    Cp.lookAt(sp, t, this._camera.up);
                    for (let n = 0; n < 4; n++) {
                        const i = up.copy(this._nearPlaneCorners[n]);
                        i.applyMatrix4(Cp);
                        const r = hp.addVectors(this._target, i);
                        Sp.set(r, t), Sp.far = this._spherical.radius + 1;
                        const s = Sp.intersectObjects(this.colliderMeshes);
                        0 !== s.length && s[0].distance < e && (e = s[0].distance)
                    }
                    return e
                }
                _getClientRect(e) {
                    if (!this._domElement) return;
                    const t = this._domElement.getBoundingClientRect();
                    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e
                }
                _createOnRestPromise(e) {
                    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({
                        type: "transitionstart"
                    }), new Promise((e => {
                        const t = () => {
                            this.removeEventListener("rest", t), e()
                        };
                        this.addEventListener("rest", t)
                    })))
                }
                _addAllEventListeners(e) {}
                _removeAllEventListeners() {}
                get dampingFactor() {
                    return 0
                }
                set dampingFactor(e) {}
                get draggingDampingFactor() {
                    return 0
                }
                set draggingDampingFactor(e) {}
                static createBoundingSphere(e, t = new rp.Sphere) {
                    const n = t,
                        i = n.center;
                    _p.makeEmpty(), e.traverseVisible((e => {
                        e.isMesh && _p.expandByObject(e)
                    })), _p.getCenter(i);
                    let r = 0;
                    return e.traverseVisible((e => {
                        if (!e.isMesh) return;
                        const t = e,
                            n = t.geometry.clone();
                        n.applyMatrix4(t.matrixWorld);
                        const s = n.attributes.position;
                        for (let e = 0, t = s.count; e < t; e++) cp.fromBufferAttribute(s, e), r = Math.max(r, i.distanceToSquared(cp))
                    })), n.radius = Math.sqrt(r), n
                }
            }
            var Mp;
            ! function(e) {
                e.HOLD_START = "holdStart", e.HOLD_END = "holdEnd", e.HOLDING = "holding"
            }(Mp || (Mp = {}));
            class Ip {
                constructor() {
                    this._listeners = {}
                }
                addEventListener(e, t) {
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                }
                removeEventListener(e, t) {
                    const n = this._listeners[e];
                    if (void 0 !== n) {
                        const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const n = t.slice(0);
                        for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e)
                    }
                }
            }
            class Bp extends Ip {
                constructor(e) {
                    super(), this._enabled = !0, this._holding = !1, this._intervalId = -1, this._deltaTime = 0, this._elapsedTime = 0, this._lastTime = 0, this._holdStart = e => {
                        if (!this._enabled) return;
                        if (this._holding) return;
                        this._deltaTime = 0, this._elapsedTime = 0, this._lastTime = performance.now(), this.dispatchEvent({
                            type: Mp.HOLD_START,
                            deltaTime: this._deltaTime,
                            elapsedTime: this._elapsedTime,
                            originalEvent: e
                        }), this._holding = !0;
                        const t = () => {
                            this._intervalId = this.holdIntervalDelay ? window.setTimeout(t, this.holdIntervalDelay) : window.requestAnimationFrame(t);
                            const n = performance.now();
                            this._deltaTime = n - this._lastTime, this._elapsedTime += this._deltaTime, this._lastTime = performance.now(), this.dispatchEvent({
                                type: Mp.HOLDING,
                                deltaTime: this._deltaTime,
                                elapsedTime: this._elapsedTime,
                                originalEvent: e
                            })
                        };
                        this._intervalId = this.holdIntervalDelay ? window.setTimeout(t, this.holdIntervalDelay) : window.requestAnimationFrame(t)
                    }, this._holdEnd = e => {
                        if (!this._enabled) return;
                        if (!this._holding) return;
                        const t = performance.now();
                        this._deltaTime = t - this._lastTime, this._elapsedTime += this._deltaTime, this._lastTime = performance.now(), this.dispatchEvent({
                            type: Mp.HOLD_END,
                            deltaTime: this._deltaTime,
                            elapsedTime: this._elapsedTime,
                            originalEvent: e
                        }), window.clearTimeout(this._intervalId), window.cancelAnimationFrame(this._intervalId), this._holding = !1
                    }, this.holdIntervalDelay = e
                }
                get enabled() {
                    return this._enabled
                }
                set enabled(e) {
                    this._enabled !== e && (this._enabled = e, this._enabled || this._holdEnd())
                }
            }
            class Rp extends Bp {
                constructor(e, t) {
                    super(t), this._holdStart = this._holdStart.bind(this), this._holdEnd = this._holdEnd.bind(this), document.addEventListener("keydown", (t => {
                        (function(e) {
                            const t = e.target;
                            return "INPUT" === t.tagName || "SELECT" === t.tagName || "TEXTAREA" === t.tagName || t.isContentEditable
                        })(t) || t.keyCode === e && this._holdStart(t)
                    })), document.addEventListener("keyup", (t => {
                        t.keyCode === e && this._holdEnd(t)
                    })), window.addEventListener("blur", this._holdEnd)
                }
            }
            var Dp, Pp, Lp, Up, Np, Op, Fp, kp, Qp = {},
                zp = 180 / Math.PI,
                Hp = Math.PI / 180,
                Gp = Math.atan2,
                Vp = /([A-Z])/g,
                jp = /(left|right|width|margin|padding|x)/i,
                Wp = /[\s,\(]\S/,
                Xp = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                Yp = function(e, t) {
                    return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
                },
                qp = function(e, t) {
                    return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
                },
                Kp = function(e, t) {
                    return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
                },
                Jp = function(e, t) {
                    var n = t.s + t.c * e;
                    t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
                },
                Zp = function(e, t) {
                    return t.set(t.t, t.p, e ? t.e : t.b, t)
                },
                $p = function(e, t) {
                    return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
                },
                em = function(e, t, n) {
                    return e.style[t] = n
                },
                tm = function(e, t, n) {
                    return e.style.setProperty(t, n)
                },
                nm = function(e, t, n) {
                    return e._gsap[t] = n
                },
                im = function(e, t, n) {
                    return e._gsap.scaleX = e._gsap.scaleY = n
                },
                rm = function(e, t, n, i, r) {
                    var s = e._gsap;
                    s.scaleX = s.scaleY = n, s.renderTransform(r, s)
                },
                sm = function(e, t, n, i, r) {
                    var s = e._gsap;
                    s[t] = n, s.renderTransform(r, s)
                },
                om = "transform",
                am = om + "Origin",
                lm = function e(t, n) {
                    var i = this,
                        r = this.target,
                        s = r.style,
                        o = r._gsap;
                    if (t in Qp && s) {
                        if (this.tfm = this.tfm || {}, "transform" === t) return Xp.transform.split(",").forEach((function(t) {
                            return e.call(i, t, n)
                        }));
                        if (~(t = Xp[t] || t).indexOf(",") ? t.split(",").forEach((function(e) {
                                return i.tfm[e] = Sm(r, e)
                            })) : this.tfm[t] = o.x ? o[t] : Sm(r, t), t === am && (this.tfm.zOrigin = o.zOrigin), this.props.indexOf(om) >= 0) return;
                        o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(am, n, "")), t = om
                    }(s || n) && this.props.push(t, n, s[t])
                },
                cm = function(e) {
                    e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
                },
                um = function() {
                    var e, t, n = this.props,
                        i = this.target,
                        r = i.style,
                        s = i._gsap;
                    for (e = 0; e < n.length; e += 3) n[e + 1] ? 2 === n[e + 1] ? i[n[e]](n[e + 2]) : i[n[e]] = n[e + 2] : n[e + 2] ? r[n[e]] = n[e + 2] : r.removeProperty("--" === n[e].substr(0, 2) ? n[e] : n[e].replace(Vp, "-$1").toLowerCase());
                    if (this.tfm) {
                        for (t in this.tfm) s[t] = this.tfm[t];
                        s.svg && (s.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (e = Fp()) && e.isStart || r[om] || (cm(r), s.zOrigin && r[am] && (r[am] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1)
                    }
                },
                hm = function(e, t) {
                    var n = {
                        target: e,
                        props: [],
                        revert: um,
                        save: lm
                    };
                    return e._gsap || Gd.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach((function(e) {
                        return n.save(e)
                    })), n
                },
                dm = function(e, t) {
                    var n = Pp.createElementNS ? Pp.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Pp.createElement(e);
                    return n && n.style ? n : Pp.createElement(e)
                },
                fm = function e(t, n, i) {
                    var r = getComputedStyle(t);
                    return r[n] || r.getPropertyValue(n.replace(Vp, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, mm(n) || n, 1) || ""
                },
                pm = "O,Moz,ms,Ms,Webkit".split(","),
                mm = function(e, t, n) {
                    var i = (t || Np).style,
                        r = 5;
                    if (e in i && !n) return e;
                    for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(pm[r] + e in i););
                    return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? pm[r] : "") + e
                },
                gm = function() {
                    "undefined" != typeof window && window.document && (Dp = window, Pp = Dp.document, Lp = Pp.documentElement, Np = dm("div") || {
                        style: {}
                    }, dm("div"), om = mm(om), am = om + "Origin", Np.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", kp = !!mm("perspective"), Fp = Gd.core.reverting, Up = 1)
                },
                Am = function(e) {
                    var t, n = e.ownerSVGElement,
                        i = dm("svg", n && n.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        r = e.cloneNode(!0);
                    r.style.display = "block", i.appendChild(r), Lp.appendChild(i);
                    try {
                        t = r.getBBox()
                    } catch (e) {}
                    return i.removeChild(r), Lp.removeChild(i), t
                },
                vm = function(e, t) {
                    for (var n = t.length; n--;)
                        if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
                },
                ym = function(e) {
                    var t, n;
                    try {
                        t = e.getBBox()
                    } catch (i) {
                        t = Am(e), n = 1
                    }
                    return t && (t.width || t.height) || n || (t = Am(e)), !t || t.width || t.x || t.y ? t : {
                        x: +vm(e, ["x", "cx", "x1"]) || 0,
                        y: +vm(e, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    }
                },
                _m = function(e) {
                    return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !ym(e))
                },
                xm = function(e, t) {
                    if (t) {
                        var n, i = e.style;
                        t in Qp && t !== am && (t = om), i.removeProperty ? ("ms" !== (n = t.substr(0, 2)) && "webkit" !== t.substr(0, 6) || (t = "-" + t), i.removeProperty("--" === n ? t : t.replace(Vp, "-$1").toLowerCase())) : i.removeAttribute(t)
                    }
                },
                Em = function(e, t, n, i, r, s) {
                    var o = new Bd(e._pt, t, n, 0, 1, s ? $p : Zp);
                    return e._pt = o, o.b = i, o.e = r, e._props.push(n), o
                },
                bm = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                wm = {
                    grid: 1,
                    flex: 1
                },
                Cm = function e(t, n, i, r) {
                    var s, o, a, l, c = parseFloat(i) || 0,
                        u = (i + "").trim().substr((c + "").length) || "px",
                        h = Np.style,
                        d = jp.test(n),
                        f = "svg" === t.tagName.toLowerCase(),
                        p = (f ? "client" : "offset") + (d ? "Width" : "Height"),
                        m = 100,
                        g = "px" === r,
                        A = "%" === r;
                    if (r === u || !c || bm[r] || bm[u]) return c;
                    if ("px" !== u && !g && (c = e(t, n, i, "px")), l = t.getCTM && _m(t), (A || "%" === u) && (Qp[n] || ~n.indexOf("adius"))) return s = l ? t.getBBox()[d ? "width" : "height"] : t[p], Lu(A ? c / s * m : c / 100 * s);
                    if (h[d ? "width" : "height"] = m + (g ? u : r), o = "rem" !== r && ~n.indexOf("adius") || "em" === r && t.appendChild && !f ? t : t.parentNode, l && (o = (t.ownerSVGElement || {}).parentNode), o && o !== Pp && o.appendChild || (o = Pp.body), (a = o._gsap) && A && a.width && d && a.time === Vh.time && !a.uncache) return Lu(c / a.width * m);
                    if (!A || "height" !== n && "width" !== n)(A || "%" === u) && !wm[fm(o, "display")] && (h.position = fm(t, "position")), o === t && (h.position = "static"), o.appendChild(Np), s = Np[p], o.removeChild(Np), h.position = "absolute";
                    else {
                        var v = t.style[n];
                        t.style[n] = m + r, s = t[p], v ? t.style[n] = v : xm(t, n)
                    }
                    return d && A && ((a = Ru(o)).time = Vh.time, a.width = o[p]), Lu(g ? s * c / m : s && c ? m / s * c : 0)
                },
                Sm = function(e, t, n, i) {
                    var r;
                    return Up || gm(), t in Xp && "transform" !== t && ~(t = Xp[t]).indexOf(",") && (t = t.split(",")[0]), Qp[t] && "transform" !== t ? (r = Fm(e, i), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : km(fm(e, am)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Rm[t] && Rm[t](e, t, n) || fm(e, t) || Du(e, t) || ("opacity" === t ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? Cm(e, t, r, n) + n : r
                },
                Tm = function(e, t, n, i) {
                    if (!n || "none" === n) {
                        var r = mm(t, e, 1),
                            s = r && fm(e, r, 1);
                        s && s !== n ? (t = r, n = s) : "borderColor" === t && (n = fm(e, "borderTopColor"))
                    }
                    var o, a, l, c, u, h, d, f, p, m, g, A = new Bd(this._pt, e.style, t, 0, 1, wd),
                        v = 0,
                        y = 0;
                    if (A.b = n, A.e = i, n += "", "auto" == (i += "") && (h = e.style[t], e.style[t] = i, i = fm(e, t) || i, h ? e.style[t] = h : xm(e, t)), Gh(o = [n, i]), i = o[1], l = (n = o[0]).match(lu) || [], (i.match(lu) || []).length) {
                        for (; a = lu.exec(i);) d = a[0], p = i.substring(v, a.index), u ? u = (u + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (u = 1), d !== (h = l[y++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), "=" === d.charAt(1) && (d = Nu(c, d) + g), f = parseFloat(d), m = d.substr((f + "").length), v = lu.lastIndex - m.length, m || (m = m || Qc.units[t] || g, v === i.length && (i += m, A.e += m)), g !== m && (c = Cm(e, t, h, m) || 0), A._pt = {
                            _next: A._pt,
                            p: p || 1 === y ? p : ",",
                            s: c,
                            c: f - c,
                            m: u && u < 4 || "zIndex" === t ? Math.round : 0
                        });
                        A.c = v < i.length ? i.substring(v, i.length) : ""
                    } else A.r = "display" === t && "none" === i ? $p : Zp;
                    return uu.test(i) && (A.e = 0), this._pt = A, A
                },
                Mm = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                Im = function(e) {
                    var t = e.split(" "),
                        n = t[0],
                        i = t[1] || "50%";
                    return "top" !== n && "bottom" !== n && "left" !== i && "right" !== i || (e = n, n = i, i = e), t[0] = Mm[n] || n, t[1] = Mm[i] || i, t.join(" ")
                },
                Bm = function(e, t) {
                    if (t.tween && t.tween._time === t.tween._dur) {
                        var n, i, r, s = t.t,
                            o = s.style,
                            a = t.u,
                            l = s._gsap;
                        if ("all" === a || !0 === a) o.cssText = "", i = 1;
                        else
                            for (r = (a = a.split(",")).length; --r > -1;) n = a[r], Qp[n] && (i = 1, n = "transformOrigin" === n ? am : om), xm(s, n);
                        i && (xm(s, om), l && (l.svg && s.removeAttribute("transform"), o.scale = o.rotate = o.translate = "none", Fm(s, 1), l.uncache = 1, cm(o)))
                    }
                },
                Rm = {
                    clearProps: function(e, t, n, i, r) {
                        if ("isFromStart" !== r.data) {
                            var s = e._pt = new Bd(e._pt, t, n, 0, 0, Bm);
                            return s.u = i, s.pr = -10, s.tween = r, e._props.push(n), 1
                        }
                    }
                },
                Dm = [1, 0, 0, 1, 0, 0],
                Pm = {},
                Lm = function(e) {
                    return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
                },
                Um = function(e) {
                    var t = fm(e, om);
                    return Lm(t) ? Dm : t.substr(7).match(au).map(Lu)
                },
                Nm = function(e, t) {
                    var n, i, r, s, o = e._gsap || Ru(e),
                        a = e.style,
                        l = Um(e);
                    return o.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Dm : l : (l !== Dm || e.offsetParent || e === Lp || o.svg || (r = a.display, a.display = "block", (n = e.parentNode) && (e.offsetParent || e.getBoundingClientRect().width) || (s = 1, i = e.nextElementSibling, Lp.appendChild(e)), l = Um(e), r ? a.display = r : xm(e, "display"), s && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : Lp.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
                },
                Om = function(e, t, n, i, r, s) {
                    var o, a, l, c = e._gsap,
                        u = r || Nm(e, !0),
                        h = c.xOrigin || 0,
                        d = c.yOrigin || 0,
                        f = c.xOffset || 0,
                        p = c.yOffset || 0,
                        m = u[0],
                        g = u[1],
                        A = u[2],
                        v = u[3],
                        y = u[4],
                        _ = u[5],
                        x = t.split(" "),
                        E = parseFloat(x[0]) || 0,
                        b = parseFloat(x[1]) || 0;
                    n ? u !== Dm && (a = m * v - g * A) && (l = E * (-g / a) + b * (m / a) - (m * _ - g * y) / a, E = E * (v / a) + b * (-A / a) + (A * _ - v * y) / a, b = l) : (E = (o = ym(e)).x + (~x[0].indexOf("%") ? E / 100 * o.width : E), b = o.y + (~(x[1] || x[0]).indexOf("%") ? b / 100 * o.height : b)), i || !1 !== i && c.smooth ? (y = E - h, _ = b - d, c.xOffset = f + (y * m + _ * A) - y, c.yOffset = p + (y * g + _ * v) - _) : c.xOffset = c.yOffset = 0, c.xOrigin = E, c.yOrigin = b, c.smooth = !!i, c.origin = t, c.originIsAbsolute = !!n, e.style[am] = "0px 0px", s && (Em(s, c, "xOrigin", h, E), Em(s, c, "yOrigin", d, b), Em(s, c, "xOffset", f, c.xOffset), Em(s, c, "yOffset", p, c.yOffset)), e.setAttribute("data-svg-origin", E + " " + b)
                },
                Fm = function(e, t) {
                    var n = e._gsap || new id(e);
                    if ("x" in n && !t && !n.uncache) return n;
                    var i, r, s, o, a, l, c, u, h, d, f, p, m, g, A, v, y, _, x, E, b, w, C, S, T, M, I, B, R, D, P, L, U = e.style,
                        N = n.scaleX < 0,
                        O = "px",
                        F = "deg",
                        k = getComputedStyle(e),
                        Q = fm(e, am) || "0";
                    return i = r = s = l = c = u = h = d = f = 0, o = a = 1, n.svg = !(!e.getCTM || !_m(e)), k.translate && ("none" === k.translate && "none" === k.scale && "none" === k.rotate || (U[om] = ("none" !== k.translate ? "translate3d(" + (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") + ("none" !== k.scale ? "scale(" + k.scale.split(" ").join(",") + ") " : "") + ("none" !== k[om] ? k[om] : "")), U.scale = U.rotate = U.translate = "none"), g = Nm(e, n.svg), n.svg && (n.uncache ? (T = e.getBBox(), Q = n.xOrigin - T.x + "px " + (n.yOrigin - T.y) + "px", S = "") : S = !t && e.getAttribute("data-svg-origin"), Om(e, S || Q, !!S || n.originIsAbsolute, !1 !== n.smooth, g)), p = n.xOrigin || 0, m = n.yOrigin || 0, g !== Dm && (_ = g[0], x = g[1], E = g[2], b = g[3], i = w = g[4], r = C = g[5], 6 === g.length ? (o = Math.sqrt(_ * _ + x * x), a = Math.sqrt(b * b + E * E), l = _ || x ? Gp(x, _) * zp : 0, (h = E || b ? Gp(E, b) * zp + l : 0) && (a *= Math.abs(Math.cos(h * Hp))), n.svg && (i -= p - (p * _ + m * E), r -= m - (p * x + m * b))) : (L = g[6], D = g[7], I = g[8], B = g[9], R = g[10], P = g[11], i = g[12], r = g[13], s = g[14], c = (A = Gp(L, R)) * zp, A && (S = w * (v = Math.cos(-A)) + I * (y = Math.sin(-A)), T = C * v + B * y, M = L * v + R * y, I = w * -y + I * v, B = C * -y + B * v, R = L * -y + R * v, P = D * -y + P * v, w = S, C = T, L = M), u = (A = Gp(-E, R)) * zp, A && (v = Math.cos(-A), P = b * (y = Math.sin(-A)) + P * v, _ = S = _ * v - I * y, x = T = x * v - B * y, E = M = E * v - R * y), l = (A = Gp(x, _)) * zp, A && (S = _ * (v = Math.cos(A)) + x * (y = Math.sin(A)), T = w * v + C * y, x = x * v - _ * y, C = C * v - w * y, _ = S, w = T), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), o = Lu(Math.sqrt(_ * _ + x * x + E * E)), a = Lu(Math.sqrt(C * C + L * L)), A = Gp(w, C), h = Math.abs(A) > 2e-4 ? A * zp : 0, f = P ? 1 / (P < 0 ? -P : P) : 0), n.svg && (S = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !Lm(fm(e, om)), S && e.setAttribute("transform", S))), Math.abs(h) > 90 && Math.abs(h) < 270 && (N ? (o *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), t = t || n.uncache, n.x = i - ((n.xPercent = i && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + O, n.y = r - ((n.yPercent = r && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + O, n.z = s + O, n.scaleX = Lu(o), n.scaleY = Lu(a), n.rotation = Lu(l) + F, n.rotationX = Lu(c) + F, n.rotationY = Lu(u) + F, n.skewX = h + F, n.skewY = d + F, n.transformPerspective = f + O, (n.zOrigin = parseFloat(Q.split(" ")[2]) || !t && n.zOrigin || 0) && (U[am] = km(Q)), n.xOffset = n.yOffset = 0, n.force3D = Qc.force3D, n.renderTransform = n.svg ? Wm : kp ? jm : zm, n.uncache = 0, n
                },
                km = function(e) {
                    return (e = e.split(" "))[0] + " " + e[1]
                },
                Qm = function(e, t, n) {
                    var i = Ah(t);
                    return Lu(parseFloat(t) + parseFloat(Cm(e, "x", n + "px", i))) + i
                },
                zm = function(e, t) {
                    t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, jm(e, t)
                },
                Hm = "0deg",
                Gm = "0px",
                Vm = ") ",
                jm = function(e, t) {
                    var n = t || this,
                        i = n.xPercent,
                        r = n.yPercent,
                        s = n.x,
                        o = n.y,
                        a = n.z,
                        l = n.rotation,
                        c = n.rotationY,
                        u = n.rotationX,
                        h = n.skewX,
                        d = n.skewY,
                        f = n.scaleX,
                        p = n.scaleY,
                        m = n.transformPerspective,
                        g = n.force3D,
                        A = n.target,
                        v = n.zOrigin,
                        y = "",
                        _ = "auto" === g && e && 1 !== e || !0 === g;
                    if (v && (u !== Hm || c !== Hm)) {
                        var x, E = parseFloat(c) * Hp,
                            b = Math.sin(E),
                            w = Math.cos(E);
                        E = parseFloat(u) * Hp, x = Math.cos(E), s = Qm(A, s, b * x * -v), o = Qm(A, o, -Math.sin(E) * -v), a = Qm(A, a, w * x * -v + v)
                    }
                    m !== Gm && (y += "perspective(" + m + Vm), (i || r) && (y += "translate(" + i + "%, " + r + "%) "), (_ || s !== Gm || o !== Gm || a !== Gm) && (y += a !== Gm || _ ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + Vm), l !== Hm && (y += "rotate(" + l + Vm), c !== Hm && (y += "rotateY(" + c + Vm), u !== Hm && (y += "rotateX(" + u + Vm), h === Hm && d === Hm || (y += "skew(" + h + ", " + d + Vm), 1 === f && 1 === p || (y += "scale(" + f + ", " + p + Vm), A.style[om] = y || "translate(0, 0)"
                },
                Wm = function(e, t) {
                    var n, i, r, s, o, a = t || this,
                        l = a.xPercent,
                        c = a.yPercent,
                        u = a.x,
                        h = a.y,
                        d = a.rotation,
                        f = a.skewX,
                        p = a.skewY,
                        m = a.scaleX,
                        g = a.scaleY,
                        A = a.target,
                        v = a.xOrigin,
                        y = a.yOrigin,
                        _ = a.xOffset,
                        x = a.yOffset,
                        E = a.forceCSS,
                        b = parseFloat(u),
                        w = parseFloat(h);
                    d = parseFloat(d), f = parseFloat(f), (p = parseFloat(p)) && (f += p = parseFloat(p), d += p), d || f ? (d *= Hp, f *= Hp, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - f) * -g, s = Math.cos(d - f) * g, f && (p *= Hp, o = Math.tan(f - p), r *= o = Math.sqrt(1 + o * o), s *= o, p && (o = Math.tan(p), n *= o = Math.sqrt(1 + o * o), i *= o)), n = Lu(n), i = Lu(i), r = Lu(r), s = Lu(s)) : (n = m, s = g, i = r = 0), (b && !~(u + "").indexOf("px") || w && !~(h + "").indexOf("px")) && (b = Cm(A, "x", u, "px"), w = Cm(A, "y", h, "px")), (v || y || _ || x) && (b = Lu(b + v - (v * n + y * r) + _), w = Lu(w + y - (v * i + y * s) + x)), (l || c) && (o = A.getBBox(), b = Lu(b + l / 100 * o.width), w = Lu(w + c / 100 * o.height)), o = "matrix(" + n + "," + i + "," + r + "," + s + "," + b + "," + w + ")", A.setAttribute("transform", o), E && (A.style[om] = o)
                },
                Xm = function(e, t, n, i, r) {
                    var s, o, a = 360,
                        l = Kc(r),
                        c = parseFloat(r) * (l && ~r.indexOf("rad") ? zp : 1) - i,
                        u = i + c + "deg";
                    return l && ("short" === (s = r.split("_")[1]) && (c %= a) != c % 180 && (c += c < 0 ? a : -360), "cw" === s && c < 0 ? c = (c + 36e9) % a - ~~(c / a) * a : "ccw" === s && c > 0 && (c = (c - 36e9) % a - ~~(c / a) * a)), e._pt = o = new Bd(e._pt, t, n, i, c, qp), o.e = u, o.u = "deg", e._props.push(n), o
                },
                Ym = function(e, t) {
                    for (var n in t) e[n] = t[n];
                    return e
                },
                qm = function(e, t, n) {
                    var i, r, s, o, a, l, c, u = Ym({}, n._gsap),
                        h = n.style;
                    for (r in u.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), h[om] = t, i = Fm(n, 1), xm(n, om), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[om], h[om] = t, i = Fm(n, 1), h[om] = s), Qp)(s = u[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Ah(s) !== (c = Ah(o)) ? Cm(n, r, s, c) : parseFloat(s), l = parseFloat(o), e._pt = new Bd(e._pt, i, r, a, l - a, Yp), e._pt.u = c || 0, e._props.push(r));
                    Ym(i, u)
                };
            Pu("padding,margin,Width,Radius", (function(e, t) {
                var n = "Top",
                    i = "Right",
                    r = "Bottom",
                    s = "Left",
                    o = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function(n) {
                        return t < 2 ? e + n : "border" + n + e
                    }));
                Rm[t > 1 ? "border" + e : e] = function(e, t, n, i, r) {
                    var s, a;
                    if (arguments.length < 4) return s = o.map((function(t) {
                        return Sm(e, t, n)
                    })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
                    s = (i + "").split(" "), a = {}, o.forEach((function(e, t) {
                        return a[e] = s[t] = s[t] || s[(t - 1) / 2 | 0]
                    })), e.init(t, a, r)
                }
            }));
            var Km, Jm, Zm = {
                name: "css",
                register: gm,
                targetTest: function(e) {
                    return e.style && e.nodeType
                },
                init: function(e, t, n, i, r) {
                    var s, o, a, l, c, u, h, d, f, p, m, g, A, v, y, _, x = this._props,
                        E = e.style,
                        b = n.vars.startAt;
                    for (h in Up || gm(), this.styles = this.styles || hm(e), _ = this.styles.props, this.tween = n, t)
                        if ("autoRound" !== h && (o = t[h], !Cu[h] || !ud(h, t, n, i, e, r)))
                            if (c = typeof o, u = Rm[h], "function" === c && (c = typeof(o = o.call(n, i, e, r))), "string" === c && ~o.indexOf("random(") && (o = Mh(o)), u) u(this, e, h, o, n) && (y = 1);
                            else if ("--" === h.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(h) + "").trim(), o += "", zh.lastIndex = 0, zh.test(s) || (d = Ah(s), f = Ah(o)), f ? d !== f && (s = Cm(e, h, s, f) + f) : d && (o += d), this.add(E, "setProperty", s, o, i, r, 0, 0, h), x.push(h), _.push(h, 0, E[h]);
                    else if ("undefined" !== c) {
                        if (b && h in b ? (s = "function" == typeof b[h] ? b[h].call(n, i, e, r) : b[h], Kc(s) && ~s.indexOf("random(") && (s = Mh(s)), Ah(s + "") || "auto" === s || (s += Qc.units[h] || Ah(Sm(e, h)) || ""), "=" === (s + "").charAt(1) && (s = Sm(e, h))) : s = Sm(e, h), l = parseFloat(s), (p = "string" === c && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), a = parseFloat(o), h in Xp && ("autoAlpha" === h && (1 === l && "hidden" === Sm(e, "visibility") && a && (l = 0), _.push("visibility", 0, E.visibility), Em(this, E, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== h && "transform" !== h && ~(h = Xp[h]).indexOf(",") && (h = h.split(",")[0])), m = h in Qp)
                            if (this.styles.save(h), g || ((A = e._gsap).renderTransform && !t.parseTransform || Fm(e, t.parseTransform), v = !1 !== t.smoothOrigin && A.smooth, (g = this._pt = new Bd(this._pt, E, om, 0, 1, A.renderTransform, A, 0, -1)).dep = 1), "scale" === h) this._pt = new Bd(this._pt, A, "scaleY", A.scaleY, (p ? Nu(A.scaleY, p + a) : a) - A.scaleY || 0, Yp), this._pt.u = 0, x.push("scaleY", h), h += "X";
                            else {
                                if ("transformOrigin" === h) {
                                    _.push(am, 0, E[am]), o = Im(o), A.svg ? Om(e, o, 0, v, 0, this) : ((f = parseFloat(o.split(" ")[2]) || 0) !== A.zOrigin && Em(this, A, "zOrigin", A.zOrigin, f), Em(this, E, h, km(s), km(o)));
                                    continue
                                }
                                if ("svgOrigin" === h) {
                                    Om(e, o, 1, v, 0, this);
                                    continue
                                }
                                if (h in Pm) {
                                    Xm(this, A, h, l, p ? Nu(l, p + o) : o);
                                    continue
                                }
                                if ("smoothOrigin" === h) {
                                    Em(this, A, "smooth", A.smooth, o);
                                    continue
                                }
                                if ("force3D" === h) {
                                    A[h] = o;
                                    continue
                                }
                                if ("transform" === h) {
                                    qm(this, o, e);
                                    continue
                                }
                            }
                        else h in E || (h = mm(h) || h);
                        if (m || (a || 0 === a) && (l || 0 === l) && !Wp.test(o) && h in E) a || (a = 0), (d = (s + "").substr((l + "").length)) !== (f = Ah(o) || (h in Qc.units ? Qc.units[h] : d)) && (l = Cm(e, h, s, f)), this._pt = new Bd(this._pt, m ? A : E, h, l, (p ? Nu(l, p + a) : a) - l, m || "px" !== f && "zIndex" !== h || !1 === t.autoRound ? Yp : Jp), this._pt.u = f || 0, d !== f && "%" !== f && (this._pt.b = s, this._pt.r = Kp);
                        else if (h in E) Tm.call(this, e, h, s, p ? p + o : o);
                        else if (h in e) this.add(e, h, s || e[h], p ? p + o : o, i, r);
                        else if ("parseTransform" !== h) continue;
                        m || (h in E ? _.push(h, 0, E[h]) : "function" == typeof e[h] ? _.push(h, 2, e[h]()) : _.push(h, 1, s || e[h])), x.push(h)
                    }
                    y && Id(this)
                },
                render: function(e, t) {
                    if (t.tween._time || !Fp())
                        for (var n = t._pt; n;) n.r(e, n.d), n = n._next;
                    else t.styles.revert()
                },
                get: Sm,
                aliases: Xp,
                getSetter: function(e, t, n) {
                    var i = Xp[t];
                    return i && i.indexOf(",") < 0 && (t = i), t in Qp && t !== am && (e._gsap.x || Sm(e, "x")) ? n && Op === n ? "scale" === t ? im : nm : (Op = n || {}) && ("scale" === t ? rm : sm) : e.style && !$c(e.style[t]) ? em : ~t.indexOf("-") ? tm : xd(e, t)
                },
                core: {
                    _removeProperty: xm,
                    _getMatrix: Nm
                }
            };
            Gd.utils.checkPrefix = mm, Gd.core.getStyleSaver = hm, Jm = Pu("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (Km = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
                Qp[e] = 1
            })), Pu(Km, (function(e) {
                Qc.units[e] = "deg", Pm[e] = 1
            })), Xp[Jm[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Km, Pu("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
                var t = e.split(":");
                Xp[t[1]] = Jm[t[0]]
            })), Pu("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
                Qc.units[e] = "px"
            })), Gd.registerPlugin(Zm);
            var $m = Gd.registerPlugin(Zm) || Gd;

            function eg(e) {
                return eg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, eg(e)
            }

            function tg() {
                tg = function() {
                    return t
                };
                var e, t = {},
                    n = Object.prototype,
                    i = n.hasOwnProperty,
                    r = Object.defineProperty || function(e, t, n) {
                        e[t] = n.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    o = s.iterator || "@@iterator",
                    a = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, n) {
                    return Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, n) {
                        return e[t] = n
                    }
                }

                function u(e, t, n, i) {
                    var s = t && t.prototype instanceof A ? t : A,
                        o = Object.create(s.prototype),
                        a = new B(i || []);
                    return r(o, "_invoke", {
                        value: S(e, n, a)
                    }), o
                }

                function h(e, t, n) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, n)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart",
                    f = "suspendedYield",
                    p = "executing",
                    m = "completed",
                    g = {};

                function A() {}

                function v() {}

                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }));
                var x = Object.getPrototypeOf,
                    E = x && x(x(R([])));
                E && E !== n && i.call(E, o) && (_ = E);
                var b = y.prototype = A.prototype = Object.create(_);

                function w(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function C(e, t) {
                    function n(r, s, o, a) {
                        var l = h(e[r], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                u = c.value;
                            return u && "object" == eg(u) && i.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                n("next", e, o, a)
                            }), (function(e) {
                                n("throw", e, o, a)
                            })) : t.resolve(u).then((function(e) {
                                c.value = e, o(c)
                            }), (function(e) {
                                return n("throw", e, o, a)
                            }))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(e, i) {
                            function r() {
                                return new t((function(t, r) {
                                    n(e, i, t, r)
                                }))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }

                function S(t, n, i) {
                    var r = d;
                    return function(s, o) {
                        if (r === p) throw Error("Generator is already running");
                        if (r === m) {
                            if ("throw" === s) throw o;
                            return {
                                value: e,
                                done: !0
                            }
                        }
                        for (i.method = s, i.arg = o;;) {
                            var a = i.delegate;
                            if (a) {
                                var l = T(a, i);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === i.method) i.sent = i._sent = i.arg;
                            else if ("throw" === i.method) {
                                if (r === d) throw r = m, i.arg;
                                i.dispatchException(i.arg)
                            } else "return" === i.method && i.abrupt("return", i.arg);
                            r = p;
                            var c = h(t, n, i);
                            if ("normal" === c.type) {
                                if (r = i.done ? m : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: i.done
                                }
                            }
                            "throw" === c.type && (r = m, i.method = "throw", i.arg = c.arg)
                        }
                    }
                }

                function T(t, n) {
                    var i = n.method,
                        r = t.iterator[i];
                    if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
                }

                function M(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function I(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function B(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(M, this), this.reset(!0)
                }

                function R(t) {
                    if (t || "" === t) {
                        var n = t[o];
                        if (n) return n.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var r = -1,
                                s = function n() {
                                    for (; ++r < t.length;)
                                        if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = e, n.done = !0, n
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(eg(t) + " is not iterable")
                }
                return v.prototype = y, r(b, "constructor", {
                    value: y,
                    configurable: !0
                }), r(y, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(b), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, w(C.prototype), c(C.prototype, a, (function() {
                    return this
                })), t.AsyncIterator = C, t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new C(u(e, n, i, r), s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                        return e.done ? e.value : o.next()
                    }))
                }, w(b), c(b, l, "Generator"), c(b, o, (function() {
                    return this
                })), c(b, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = Object(e),
                        n = [];
                    for (var i in t) n.push(i);
                    return n.reverse(),
                        function e() {
                            for (; n.length;) {
                                var i = n.pop();
                                if (i in t) return e.value = i, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, t.values = R, B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !t)
                            for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done) throw t;
                        var n = this;

                        function r(i, r) {
                            return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s],
                                a = o.completion;
                            if ("root" === o.tryLoc) return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc"),
                                    c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                } else {
                                    if (!c) throw Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(o)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.tryLoc === e) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    I(n)
                                }
                                return r
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = e), g
                    }
                }, t
            }

            function ng(e, t, n, i, r, s, o) {
                try {
                    var a = e[s](o),
                        l = a.value
                } catch (e) {
                    return void n(e)
                }
                a.done ? t(l) : Promise.resolve(l).then(i, r)
            }

            function ig(e) {
                var t = function(e, t) {
                    if ("object" != eg(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != eg(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == eg(t) ? t : t + ""
            }
            $m.core.Tween;
            var rg = function() {
                return function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, ig(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e(t) {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.engine = t
                }), [{
                    key: "setZoom",
                    value: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            n = t.zoom,
                            i = t.immediate,
                            r = void 0 !== i && i,
                            s = t.duration,
                            o = void 0 === s ? Wd.animation.camera.zoomDuration : s,
                            a = t.limits;
                        if ("number" != typeof n) return Promise.reject(new Error("Zoom value must be a number"));
                        a && ("number" == typeof a.min && (this.engine.controls.minZoom = a.min), "number" == typeof a.max && (this.engine.controls.maxZoom = a.max));
                        var l = Math.min(Math.max(n, this.engine.controls.minZoom), this.engine.controls.maxZoom);
                        if (this.engine.camera.zoom, this.engine.currentZoom) {
                            var c = l / Wd.controls.firstPerson.defaultZoom;
                            this.engine.currentZoom = "".concat(Math.round(10 * c) / 10, "x")
                        }
                        var u, h = this.engine.controls.smoothTime;
                        return r || (this.engine.isAnimatingCamera = !0, Ec.renderingStatus.next(!0)), !1 === r && void 0 !== o ? (this.engine.controls.smoothTime = o, u = this.engine.controls.zoomTo(l, !0).finally((function() {
                            e.engine.controls.smoothTime = h, e.engine.isAnimatingCamera = !1, e.engine.pano && e.engine.pano.mesh && e.engine.pano.mesh.geometry.updateLOD && e.engine.pano.mesh.geometry.updateLOD(e.engine.camera, e.engine.pano.mesh.position), Ec.renderingStatus.next(!1)
                        }))) : (u = this.engine.controls.zoomTo(l, !r), r || (u = u.finally((function() {
                            e.engine.isAnimatingCamera = !1, e.engine.pano && e.engine.pano.mesh && e.engine.pano.mesh.geometry.updateLOD && e.engine.pano.mesh.geometry.updateLOD(e.engine.camera, e.engine.pano.mesh.position), Ec.renderingStatus.next(!1)
                        })))), u
                    }
                }, {
                    key: "setFOV",
                    value: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            n = t.fov,
                            i = t.immediate,
                            r = void 0 !== i && i,
                            s = t.duration,
                            o = void 0 === s ? .5 : s;
                        if ("number" != typeof n) return Promise.reject(new Error("FOV value must be a number"));
                        var a = this.engine.camera.fov;
                        return new Promise((function(t) {
                            if (!0 === r) e.engine.camera.fov = n, e.engine.camera.updateProjectionMatrix(), e.engine.update(), t();
                            else {
                                var i = {
                                    value: a
                                };
                                e.engine.isAnimatingCamera = !0, $m.to(i, {
                                    value: n,
                                    duration: o,
                                    ease: "power2.inOut",
                                    onStart: function() {
                                        Ec.renderingStatus.next(!0)
                                    },
                                    onUpdate: function() {
                                        e.engine.camera.fov = i.value, e.engine.camera.updateProjectionMatrix()
                                    },
                                    onComplete: function() {
                                        e.engine.isAnimatingCamera = !1, e.engine.pano && e.engine.pano.mesh && e.engine.pano.mesh.geometry.updateLOD && e.engine.pano.mesh.geometry.updateLOD(e.engine.camera, e.engine.pano.mesh.position), Ec.renderingStatus.next(!1), t()
                                    }
                                })
                            }
                        }))
                    }
                }, {
                    key: "initControls",
                    value: function(e) {
                        var t = this;
                        if (!e) {
                            var n = {
                                Vector2: ze,
                                Vector3: gt,
                                Vector4: ut,
                                Quaternion: mt,
                                Matrix4: Wt,
                                Spherical: kl,
                                Box3: yt,
                                Sphere: Ot,
                                Raycaster: Nl,
                                MathUtils: {
                                    DEG2RAD: Sc.DEG2RAD,
                                    clamp: Sc.clamp
                                }
                            };
                            Tp.install({
                                THREE: n
                            })
                        }
                        var i = Tp.ACTION.NONE;
                        this.engine.controls = new Tp(this.engine.camera, Wd.container), this.engine.controls.mouseButtons.wheel = i, this.engine.controls.mouseButtons.middle = i, this.engine.controls.touches.two = i, this.engine.controls.touches.three = i, this.engine.controls.mouseButtons.right = i, this.engine.controls.restThreshold = 3, this.setFirstPersonParams(), this.resizeSubscription = Ec.resizeEvent.subscribe((function() {
                            t.setFirstPersonParams()
                        })), this.engine.camera.zoom = Wd.controls.firstPerson.defaultZoom, this.engine.camera.updateProjectionMatrix(), this.engine.controls.zoomTo(Wd.controls.firstPerson.defaultZoom, !1);
                        this.holdIntervalDelay = .01, this.wKey = new Rp(87, 10), this.aKey = new Rp(65, 10), this.sKey = new Rp(83, 10), this.dKey = new Rp(68, 10), this.upArrowKey = new Rp(38, 10), this.downArrowKey = new Rp(40, 10)
                    }
                }, {
                    key: "addListeners",
                    value: function() {
                        var e = this;
                        this.listeners = [{
                            eventTarget: this.aKey,
                            eventName: "holding",
                            eventFunction: function() {
                                e.engine.controls.truck(-e.holdIntervalDelay, 0, !1), e.engine.update()
                            }
                        }, {
                            eventTarget: this.dKey,
                            eventName: "holding",
                            eventFunction: function() {
                                e.engine.controls.truck(e.holdIntervalDelay, 0, !1), e.engine.update()
                            }
                        }, {
                            eventTarget: this.wKey,
                            eventName: "holding",
                            eventFunction: function() {
                                e.engine.controls.forward(e.holdIntervalDelay, !1), e.engine.update()
                            }
                        }, {
                            eventTarget: this.sKey,
                            eventName: "holding",
                            eventFunction: function() {
                                e.engine.controls.forward(-e.holdIntervalDelay, !1), e.engine.update()
                            }
                        }, {
                            eventTarget: this.upArrowKey,
                            eventName: "holding",
                            eventFunction: function() {
                                e.engine.controls.truck(0, -e.holdIntervalDelay, !1), e.engine.update()
                            }
                        }, {
                            eventTarget: this.downArrowKey,
                            eventName: "holding",
                            eventFunction: function() {
                                e.engine.controls.truck(0, e.holdIntervalDelay, !1), e.engine.update()
                            }
                        }], this.listeners.forEach((function(e) {
                            e.eventTarget.addEventListener(e.eventName, e.eventFunction)
                        }))
                    }
                }, {
                    key: "removeListeners",
                    value: function() {
                        this.listeners && Array.isArray(this.listeners) && this.listeners.forEach((function(e) {
                            e.eventTarget.removeEventListener(e.eventName, e.eventFunction)
                        })), this.resizeSubscription && (this.resizeSubscription.unsubscribe(), this.resizeSubscription = null)
                    }
                }, {
                    key: "setThirdPersonParams",
                    value: function() {
                        this.engine.controls.minZoom = Wd.controls.thirdPerson.minZoom, this.engine.controls.maxZoom = Wd.controls.thirdPerson.maxZoom, this.engine.controls.smoothTime = Wd.controls.thirdPerson.smoothTime, this.engine.controls.draggingSmoothTime = Wd.controls.thirdPerson.draggingSmoothTime, this.engine.controls.azimuthRotateSpeed = Wd.controls.thirdPerson.azimuthRotateSpeed, this.engine.controls.polarRotateSpeed = Wd.controls.thirdPerson.polarRotateSpeed, this.engine.controls.maxPolarAngle = Wd.controls.thirdPerson.maxPolarAngle, this.engine.controls.minPolarAngle = Wd.controls.thirdPerson.minPolarAngle, this.engine.controls.minAzimuthAngle = Wd.controls.thirdPerson.minAzimuthAngle, this.engine.controls.maxAzimuthAngle = Wd.controls.thirdPerson.maxAzimuthAngle, this.engine.camera.near = Wd.controls.thirdPerson.near, this.engine.camera.updateProjectionMatrix(), this.engine.controls.normalizeRotations();
                        var e = Wd.controls.thirdPerson.focalOffset,
                            t = e.x,
                            n = e.y,
                            i = e.z;
                        this.engine.controls.setFocalOffset(t, n, i), this.engine.controls.zoomTo(Wd.controls.thirdPerson.defaultZoom)
                    }
                }, {
                    key: "setFirstPersonParams",
                    value: function() {
                        this.engine.controls.smoothTime = Wd.controls.firstPerson.smoothTime, this.engine.controls.draggingSmoothTime = Wd.controls.firstPerson.draggingSmoothTime, this.engine.controls.minZoom = Wd.controls.firstPerson.minZoom, this.engine.controls.maxZoom = Wd.controls.firstPerson.maxZoom;
                        var e = window.innerWidth <= 768 ? 1.5 : 1;
                        this.engine.controls.azimuthRotateSpeed = Wd.controls.firstPerson.azimuthRotateSpeed * e, this.engine.controls.polarRotateSpeed = Wd.controls.firstPerson.polarRotateSpeed * e, this.engine.controls.maxPolarAngle = Wd.controls.firstPerson.maxPolarAngle, this.engine.controls.minPolarAngle = Wd.controls.firstPerson.minPolarAngle, this.engine.controls.minAzimuthAngle = Wd.controls.firstPerson.minAzimuthAngle, this.engine.controls.maxAzimuthAngle = Wd.controls.firstPerson.maxAzimuthAngle, this.engine.camera.near = Wd.controls.firstPerson.near, this.engine.camera.updateProjectionMatrix(), this.engine.controls.normalizeRotations();
                        var t = Wd.controls.firstPerson.focalOffset,
                            n = t.x,
                            i = t.y,
                            r = t.z;
                        this.engine.controls.setFocalOffset(n, i, r), this.engine.controls.zoomTo(Wd.controls.firstPerson.defaultZoom, !1)
                    }
                }, {
                    key: "setCamera",
                    value: (e = function(e) {
                        return function() {
                            var t = this,
                                n = arguments;
                            return new Promise((function(i, r) {
                                var s = e.apply(t, n);

                                function o(e) {
                                    ng(s, i, r, o, a, "next", e)
                                }

                                function a(e) {
                                    ng(s, i, r, o, a, "throw", e)
                                }
                                o(void 0)
                            }))
                        }
                    }(tg().mark((function e() {
                        var t, n, i, r = arguments;
                        return tg().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (t = r.length > 1 && void 0 !== r[1] ? r[1] : 45, !("number" != typeof(n = r.length > 2 && void 0 !== r[2] ? r[2] : 1) || n < 0)) {
                                        e.next = 5;
                                        break
                                    }
                                    throw new Error("Duration must be a non-negative number");
                                case 5:
                                    return i = this.setFOV({
                                        fov: t,
                                        duration: n
                                    }), e.next = 8, i;
                                case 8:
                                    return e.abrupt("return", e.sent);
                                case 9:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return e.apply(this, arguments)
                    })
                }, {
                    key: "applyCameraState",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            t = e.fov,
                            n = e.rotation,
                            i = e.sphereIndex;
                        if ("number" == typeof i && i >= 0 && this.engine.pano && this.engine.pano.panoItems[i]) {
                            var r = this.engine.pano.panoItems[i].name;
                            this.engine.pano.change(r, !0)
                        }
                        if ("number" == typeof t && (this.engine.camera.fov = t, this.engine.camera.updateProjectionMatrix()), n && "object" === eg(n)) {
                            if (this.engine.controls.getPosition(new gt), "number" == typeof n.y) {
                                var s = Sc.degToRad(n.y);
                                this.engine.controls.azimuthAngle = s
                            }
                            if ("number" == typeof n.x) {
                                var o = Math.PI / 2 - Sc.degToRad(n.x);
                                this.engine.controls.polarAngle = o
                            }
                            this.engine.controls.update(0)
                        }
                        this.engine.update()
                    }
                }, {
                    key: "applyCameraStateFromAngles",
                    value: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            n = t.fov,
                            i = t.azimuthAngle,
                            r = t.polarAngle,
                            s = t.sphereIndex;
                        "number" == typeof n && (this.engine.camera.fov = n, this.engine.camera.updateProjectionMatrix());
                        var o = !1;
                        if ("number" == typeof s && s >= 0 && this.engine.pano && this.engine.pano.panoItems[s]) {
                            var a = this.engine.pano.panoItems[s].name;
                            this.engine.pano.currentPano !== a && (o = !0, this.engine.pano.change(a, !0))
                        }
                        var l = function() {
                            "number" == typeof i && (e.engine.controls.azimuthAngle = Sc.degToRad(i)), "number" == typeof r && (e.engine.controls.polarAngle = Sc.degToRad(r)), e.engine.controls.update(0), e.engine.update()
                        };
                        o ? requestAnimationFrame((function() {
                            requestAnimationFrame((function() {
                                l()
                            }))
                        })) : l()
                    }
                }]);
                var e
            }();

            function sg(e) {
                return sg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, sg(e)
            }

            function og(e) {
                var t = function(e, t) {
                    if ("object" != sg(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != sg(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == sg(t) ? t : t + ""
            }
            var ag = function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, og(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e() {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.targetIndex = 0, this.engine = window.engine
                }), [{
                    key: "setLookAt",
                    value: function(e, t, n, i, r, s, o) {
                        var a = this,
                            l = this.engine.controls.getTarget(),
                            c = {
                                x: i,
                                y: r,
                                z: s
                            },
                            u = this.engine.controls.getPosition(),
                            h = {
                                x: e,
                                y: t,
                                z: n
                            },
                            d = $m.timeline();
                        return d.to({
                            t: 0
                        }, {
                            t: 1,
                            duration: o,
                            onStart: function() {
                                Ec.renderingStatus.next(!0)
                            },
                            onComplete: function() {
                                a.engine.controls.enabled = !0, Ec.renderingStatus.next(!1)
                            },
                            onUpdate: function() {
                                Ec.renderingStatus.next(!0);
                                var e = d.progress();
                                a.engine.controls.enabled = !1, a.engine.controls.lerpLookAt(u.x, u.y, u.z, l.x, l.y, l.z, h.x, h.y, h.z, c.x, c.y, c.z, e, !0)
                            }
                        }), this.engine.update(), d
                    }
                }]),
                lg = n(543),
                cg = n.n(lg);

            function ug(e) {
                return ug = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, ug(e)
            }

            function hg(e) {
                var t = function(e, t) {
                    if ("object" != ug(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != ug(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == ug(t) ? t : t + ""
            }
            var dg = function(e, t, n) {
                return t && function(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, hg(i.key), i)
                    }
                }(e.prototype, t), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), e
            }((function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.textures = new Of, this.allMaterials = new Map, this.transmissiveMaterials = new Set
            }), [{
                key: "setupMaterials",
                value: function(e, t) {}
            }]);

            function fg(e) {
                return fg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, fg(e)
            }

            function pg() {
                pg = function() {
                    return t
                };
                var e, t = {},
                    n = Object.prototype,
                    i = n.hasOwnProperty,
                    r = Object.defineProperty || function(e, t, n) {
                        e[t] = n.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    o = s.iterator || "@@iterator",
                    a = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, n) {
                    return Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, n) {
                        return e[t] = n
                    }
                }

                function u(e, t, n, i) {
                    var s = t && t.prototype instanceof A ? t : A,
                        o = Object.create(s.prototype),
                        a = new B(i || []);
                    return r(o, "_invoke", {
                        value: S(e, n, a)
                    }), o
                }

                function h(e, t, n) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, n)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart",
                    f = "suspendedYield",
                    p = "executing",
                    m = "completed",
                    g = {};

                function A() {}

                function v() {}

                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }));
                var x = Object.getPrototypeOf,
                    E = x && x(x(R([])));
                E && E !== n && i.call(E, o) && (_ = E);
                var b = y.prototype = A.prototype = Object.create(_);

                function w(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function C(e, t) {
                    function n(r, s, o, a) {
                        var l = h(e[r], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                u = c.value;
                            return u && "object" == fg(u) && i.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                n("next", e, o, a)
                            }), (function(e) {
                                n("throw", e, o, a)
                            })) : t.resolve(u).then((function(e) {
                                c.value = e, o(c)
                            }), (function(e) {
                                return n("throw", e, o, a)
                            }))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(e, i) {
                            function r() {
                                return new t((function(t, r) {
                                    n(e, i, t, r)
                                }))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }

                function S(t, n, i) {
                    var r = d;
                    return function(s, o) {
                        if (r === p) throw Error("Generator is already running");
                        if (r === m) {
                            if ("throw" === s) throw o;
                            return {
                                value: e,
                                done: !0
                            }
                        }
                        for (i.method = s, i.arg = o;;) {
                            var a = i.delegate;
                            if (a) {
                                var l = T(a, i);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === i.method) i.sent = i._sent = i.arg;
                            else if ("throw" === i.method) {
                                if (r === d) throw r = m, i.arg;
                                i.dispatchException(i.arg)
                            } else "return" === i.method && i.abrupt("return", i.arg);
                            r = p;
                            var c = h(t, n, i);
                            if ("normal" === c.type) {
                                if (r = i.done ? m : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: i.done
                                }
                            }
                            "throw" === c.type && (r = m, i.method = "throw", i.arg = c.arg)
                        }
                    }
                }

                function T(t, n) {
                    var i = n.method,
                        r = t.iterator[i];
                    if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
                }

                function M(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function I(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function B(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(M, this), this.reset(!0)
                }

                function R(t) {
                    if (t || "" === t) {
                        var n = t[o];
                        if (n) return n.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var r = -1,
                                s = function n() {
                                    for (; ++r < t.length;)
                                        if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = e, n.done = !0, n
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(fg(t) + " is not iterable")
                }
                return v.prototype = y, r(b, "constructor", {
                    value: y,
                    configurable: !0
                }), r(y, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(b), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, w(C.prototype), c(C.prototype, a, (function() {
                    return this
                })), t.AsyncIterator = C, t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new C(u(e, n, i, r), s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                        return e.done ? e.value : o.next()
                    }))
                }, w(b), c(b, l, "Generator"), c(b, o, (function() {
                    return this
                })), c(b, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = Object(e),
                        n = [];
                    for (var i in t) n.push(i);
                    return n.reverse(),
                        function e() {
                            for (; n.length;) {
                                var i = n.pop();
                                if (i in t) return e.value = i, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, t.values = R, B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !t)
                            for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done) throw t;
                        var n = this;

                        function r(i, r) {
                            return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s],
                                a = o.completion;
                            if ("root" === o.tryLoc) return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc"),
                                    c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                } else {
                                    if (!c) throw Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(o)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.tryLoc === e) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    I(n)
                                }
                                return r
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = e), g
                    }
                }, t
            }

            function mg(e, t, n, i, r, s, o) {
                try {
                    var a = e[s](o),
                        l = a.value
                } catch (e) {
                    return void n(e)
                }
                a.done ? t(l) : Promise.resolve(l).then(i, r)
            }

            function gg(e) {
                var t = function(e, t) {
                    if ("object" != fg(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != fg(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == fg(t) ? t : t + ""
            }

            function Ag(e, t, n) {
                return t = yg(t),
                    function(e, t) {
                        if (t && ("object" == fg(t) || "function" == typeof t)) return t;
                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                        return function(e) {
                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return e
                        }(e)
                    }(e, vg() ? Reflect.construct(t, [], yg(e).constructor) : t.apply(e, n))
            }

            function vg() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (e) {}
                return (vg = function() {
                    return !!e
                })()
            }

            function yg(e) {
                return yg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }, yg(e)
            }

            function _g(e, t) {
                return _g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                }, _g(e, t)
            }
            var xg = function(e) {
                    function t(e) {
                        var n;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (n = Ag(this, t)).textures = new Of, n.materials = new dg, n.engine = e, n
                    }
                    return function(e, t) {
                            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                            e.prototype = Object.create(t && t.prototype, {
                                constructor: {
                                    value: e,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), Object.defineProperty(e, "prototype", {
                                writable: !1
                            }), t && _g(e, t)
                        }(t, e),
                        function(e, t, n) {
                            return t && function(e, t) {
                                for (var n = 0; n < t.length; n++) {
                                    var i = t[n];
                                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, gg(i.key), i)
                                }
                            }(e.prototype, t), Object.defineProperty(e, "prototype", {
                                writable: !1
                            }), e
                        }(t, [{
                            key: "load",
                            value: (n = function(e) {
                                return function() {
                                    var t = this,
                                        n = arguments;
                                    return new Promise((function(i, r) {
                                        var s = e.apply(t, n);

                                        function o(e) {
                                            mg(s, i, r, o, a, "next", e)
                                        }

                                        function a(e) {
                                            mg(s, i, r, o, a, "throw", e)
                                        }
                                        o(void 0)
                                    }))
                                }
                            }(pg().mark((function e(t) {
                                return pg().wrap((function(e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return e.abrupt("return");
                                        case 1:
                                        case "end":
                                            return e.stop()
                                    }
                                }), e)
                            }))), function(e) {
                                return n.apply(this, arguments)
                            })
                        }, {
                            key: "setup",
                            value: function(e) {
                                e && (this.group = new xo, this.group.name = "Scene children", this.add(this.group), this.engine.scene.add(this), this.name = "Scene parent"), e && (this.group.scale.set(Wd.models.samara.scale.x, Wd.models.samara.scale.y, Wd.models.samara.scale.z), this.group.rotation.y = Wd.models.samara.rotation)
                            }
                        }, {
                            key: "getAssets",
                            value: function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ec.complectation.value.layout;
                                return this["".concat(e, "_assets")]
                            }
                        }, {
                            key: "computeBoundingBox",
                            value: function(e) {
                                return (new yt).setFromObject(e)
                            }
                        }, {
                            key: "centerModels",
                            value: function(e) {
                                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                    r = (new yt).setFromObject(e).getCenter(new gt);
                                e.position.x += this.engine.scene.position.x - r.x + t, e.position.y += this.engine.scene.position.y - r.y + n, e.position.z += this.engine.scene.position.z - r.z + i
                            }
                        }]);
                    var n
                }(xo),
                Eg = function(e) {
                    return e && "number" == typeof e.length && "function" != typeof e
                };

            function bg(e) {
                return ql(null == e ? void 0 : e.then)
            }

            function wg(e) {
                return ql(e[fc])
            }

            function Cg(e) {
                return Symbol.asyncIterator && ql(null == e ? void 0 : e[Symbol.asyncIterator])
            }

            function Sg(e) {
                return new TypeError("You provided " + (null !== e && "object" == typeof e ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")
            }
            var Tg = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";

            function Mg(e) {
                return ql(null == e ? void 0 : e[Tg])
            }

            function Ig(e) {
                return function(e, t, n) {
                    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                    var i, r = n.apply(e, t || []),
                        s = [];
                    return i = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype), o("next"), o("throw"), o("return", (function(e) {
                        return function(t) {
                            return Promise.resolve(t).then(e, c)
                        }
                    })), i[Symbol.asyncIterator] = function() {
                        return this
                    }, i;

                    function o(e, t) {
                        r[e] && (i[e] = function(t) {
                            return new Promise((function(n, i) {
                                s.push([e, t, n, i]) > 1 || a(e, t)
                            }))
                        }, t && (i[e] = t(i[e])))
                    }

                    function a(e, t) {
                        try {
                            ! function(e) {
                                e.value instanceof Yl ? Promise.resolve(e.value.v).then(l, c) : u(s[0][2], e)
                            }(r[e](t))
                        } catch (e) {
                            u(s[0][3], e)
                        }
                    }

                    function l(e) {
                        a("next", e)
                    }

                    function c(e) {
                        a("throw", e)
                    }

                    function u(e, t) {
                        e(t), s.shift(), s.length && a(s[0][0], s[0][1])
                    }
                }(this, arguments, (function() {
                    var t, n, i;
                    return Vl(this, (function(r) {
                        switch (r.label) {
                            case 0:
                                t = e.getReader(), r.label = 1;
                            case 1:
                                r.trys.push([1, , 9, 10]), r.label = 2;
                            case 2:
                                return [4, Yl(t.read())];
                            case 3:
                                return n = r.sent(), i = n.value, n.done ? [4, Yl(void 0)] : [3, 5];
                            case 4:
                                return [2, r.sent()];
                            case 5:
                                return [4, Yl(i)];
                            case 6:
                                return [4, r.sent()];
                            case 7:
                                return r.sent(), [3, 2];
                            case 8:
                                return [3, 10];
                            case 9:
                                return t.releaseLock(), [7];
                            case 10:
                                return [2]
                        }
                    }))
                }))
            }

            function Bg(e) {
                return ql(null == e ? void 0 : e.getReader)
            }

            function Rg(e) {
                if (e instanceof mc) return e;
                if (null != e) {
                    if (wg(e)) return r = e, new mc((function(e) {
                        var t = r[fc]();
                        if (ql(t.subscribe)) return t.subscribe(e);
                        throw new TypeError("Provided object does not correctly implement Symbol.observable")
                    }));
                    if (Eg(e)) return i = e, new mc((function(e) {
                        for (var t = 0; t < i.length && !e.closed; t++) e.next(i[t]);
                        e.complete()
                    }));
                    if (bg(e)) return n = e, new mc((function(e) {
                        n.then((function(t) {
                            e.closed || (e.next(t), e.complete())
                        }), (function(t) {
                            return e.error(t)
                        })).then(null, sc)
                    }));
                    if (Cg(e)) return Dg(e);
                    if (Mg(e)) return t = e, new mc((function(e) {
                        var n, i;
                        try {
                            for (var r = jl(t), s = r.next(); !s.done; s = r.next()) {
                                var o = s.value;
                                if (e.next(o), e.closed) return
                            }
                        } catch (e) {
                            n = {
                                error: e
                            }
                        } finally {
                            try {
                                s && !s.done && (i = r.return) && i.call(r)
                            } finally {
                                if (n) throw n.error
                            }
                        }
                        e.complete()
                    }));
                    if (Bg(e)) return Dg(Ig(e))
                }
                var t, n, i, r;
                throw Sg(e)
            }

            function Dg(e) {
                return new mc((function(t) {
                    (function(e, t) {
                        var n, i, r, s;
                        return function(e, t, n, i) {
                            return new(n || (n = Promise))((function(t, r) {
                                function s(e) {
                                    try {
                                        a(i.next(e))
                                    } catch (e) {
                                        r(e)
                                    }
                                }

                                function o(e) {
                                    try {
                                        a(i.throw(e))
                                    } catch (e) {
                                        r(e)
                                    }
                                }

                                function a(e) {
                                    var i;
                                    e.done ? t(e.value) : (i = e.value, i instanceof n ? i : new n((function(e) {
                                        e(i)
                                    }))).then(s, o)
                                }
                                a((i = i.apply(e, [])).next())
                            }))
                        }(this, 0, void 0, (function() {
                            var o, a;
                            return Vl(this, (function(l) {
                                switch (l.label) {
                                    case 0:
                                        l.trys.push([0, 5, 6, 11]), n = function(e) {
                                            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                                            var t, n = e[Symbol.asyncIterator];
                                            return n ? n.call(e) : (e = jl(e), t = {}, i("next"), i("throw"), i("return"), t[Symbol.asyncIterator] = function() {
                                                return this
                                            }, t);

                                            function i(n) {
                                                t[n] = e[n] && function(t) {
                                                    return new Promise((function(i, r) {
                                                        ! function(e, t, n, i) {
                                                            Promise.resolve(i).then((function(t) {
                                                                e({
                                                                    value: t,
                                                                    done: n
                                                                })
                                                            }), t)
                                                        }(i, r, (t = e[n](t)).done, t.value)
                                                    }))
                                                }
                                            }
                                        }(e), l.label = 1;
                                    case 1:
                                        return [4, n.next()];
                                    case 2:
                                        if ((i = l.sent()).done) return [3, 4];
                                        if (o = i.value, t.next(o), t.closed) return [2];
                                        l.label = 3;
                                    case 3:
                                        return [3, 1];
                                    case 4:
                                        return [3, 11];
                                    case 5:
                                        return a = l.sent(), r = {
                                            error: a
                                        }, [3, 11];
                                    case 6:
                                        return l.trys.push([6, , 9, 10]), i && !i.done && (s = n.return) ? [4, s.call(n)] : [3, 8];
                                    case 7:
                                        l.sent(), l.label = 8;
                                    case 8:
                                        return [3, 10];
                                    case 9:
                                        if (r) throw r.error;
                                        return [7];
                                    case 10:
                                        return [7];
                                    case 11:
                                        return t.complete(), [2]
                                }
                            }))
                        }))
                    })(e, t).catch((function(e) {
                        return t.error(e)
                    }))
                }))
            }

            function Pg(e) {
                return function(t) {
                    if (function(e) {
                            return ql(null == e ? void 0 : e.lift)
                        }(t)) return t.lift((function(t) {
                        try {
                            return e(t, this)
                        } catch (e) {
                            this.error(e)
                        }
                    }));
                    throw new TypeError("Unable to lift unknown Observable type")
                }
            }

            function Lg(e, t, n, i, r) {
                return new Ug(e, t, n, i, r)
            }
            var Ug = function(e) {
                function t(t, n, i, r, s, o) {
                    var a = e.call(this, t) || this;
                    return a.onFinalize = s, a.shouldUnsubscribe = o, a._next = n ? function(e) {
                        try {
                            n(e)
                        } catch (e) {
                            t.error(e)
                        }
                    } : e.prototype._next, a._error = r ? function(e) {
                        try {
                            r(e)
                        } catch (e) {
                            t.error(e)
                        } finally {
                            this.unsubscribe()
                        }
                    } : e.prototype._error, a._complete = i ? function() {
                        try {
                            i()
                        } catch (e) {
                            t.error(e)
                        } finally {
                            this.unsubscribe()
                        }
                    } : e.prototype._complete, a
                }
                return Gl(t, e), t.prototype.unsubscribe = function() {
                    var t;
                    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                        var n = this.closed;
                        e.prototype.unsubscribe.call(this), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this))
                    }
                }, t
            }(lc);

            function Ng(e, t) {
                return Pg((function(n, i) {
                    var r = 0;
                    n.subscribe(Lg(i, (function(n) {
                        i.next(e.call(t, n, r++))
                    })))
                }))
            }

            function Og(e, t, n, i, r) {
                void 0 === i && (i = 0), void 0 === r && (r = !1);
                var s = t.schedule((function() {
                    n(), r ? e.add(this.schedule(null, i)) : this.unsubscribe()
                }), i);
                if (e.add(s), !r) return s
            }

            function Fg(e, t, n) {
                return void 0 === n && (n = 1 / 0), ql(t) ? Fg((function(n, i) {
                    return Ng((function(e, r) {
                        return t(n, e, i, r)
                    }))(Rg(e(n, i)))
                }), n) : ("number" == typeof t && (n = t), Pg((function(t, i) {
                    return function(e, t, n, i, r, s, o, a) {
                        var l = [],
                            c = 0,
                            u = 0,
                            h = !1,
                            d = function() {
                                !h || l.length || c || t.complete()
                            },
                            f = function(e) {
                                return c < i ? p(e) : l.push(e)
                            },
                            p = function(e) {
                                c++;
                                var r = !1;
                                Rg(n(e, u++)).subscribe(Lg(t, (function(e) {
                                    t.next(e)
                                }), (function() {
                                    r = !0
                                }), void 0, (function() {
                                    if (r) try {
                                        c--;
                                        for (var e = function() {
                                                var e = l.shift();
                                                p(e)
                                            }; l.length && c < i;) e();
                                        d()
                                    } catch (e) {
                                        t.error(e)
                                    }
                                })))
                            };
                        return e.subscribe(Lg(t, f, (function() {
                                h = !0, d()
                            }))),
                            function() {}
                    }(t, i, e, n)
                })))
            }
            var kg = Array.isArray;
            var Qg = ["addListener", "removeListener"],
                zg = ["addEventListener", "removeEventListener"],
                Hg = ["on", "off"];

            function Gg(e, t, n, i) {
                if (ql(n) && (i = n, n = void 0), i) return Gg(e, t, n).pipe(function(e) {
                    return Ng((function(t) {
                        return function(e, t) {
                            return kg(t) ? e.apply(void 0, Xl([], Wl(t))) : e(t)
                        }(e, t)
                    }))
                }(i));
                var r = Wl(function(e) {
                        return ql(e.addEventListener) && ql(e.removeEventListener)
                    }(e) ? zg.map((function(i) {
                        return function(r) {
                            return e[i](t, r, n)
                        }
                    })) : function(e) {
                        return ql(e.addListener) && ql(e.removeListener)
                    }(e) ? Qg.map(Vg(e, t)) : function(e) {
                        return ql(e.on) && ql(e.off)
                    }(e) ? Hg.map(Vg(e, t)) : [], 2),
                    s = r[0],
                    o = r[1];
                if (!s && Eg(e)) return Fg((function(e) {
                    return Gg(e, t, n)
                }))(Rg(e));
                if (!s) throw new TypeError("Invalid event target");
                return new mc((function(e) {
                    var t = function() {
                        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                        return e.next(1 < t.length ? t : t[0])
                    };
                    return s(t),
                        function() {
                            return o(t)
                        }
                }))
            }

            function Vg(e, t) {
                return function(n) {
                    return function(i) {
                        return e[n](t, i)
                    }
                }
            }
            var jg = function(e) {
                    function t(t, n) {
                        return e.call(this) || this
                    }
                    return Gl(t, e), t.prototype.schedule = function(e, t) {
                        return this
                    }, t
                }($l),
                Wg = {
                    setInterval: function(e, t) {
                        for (var n = [], i = 2; i < arguments.length; i++) n[i - 2] = arguments[i];
                        var r = Wg.delegate;
                        return (null == r ? void 0 : r.setInterval) ? r.setInterval.apply(r, Xl([e, t], Wl(n))) : setInterval.apply(void 0, Xl([e, t], Wl(n)))
                    },
                    clearInterval: function(e) {
                        return clearInterval(e)
                    },
                    delegate: void 0
                },
                Xg = function(e) {
                    function t(t, n) {
                        var i = e.call(this, t, n) || this;
                        return i.scheduler = t, i.work = n, i.pending = !1, i
                    }
                    return Gl(t, e), t.prototype.schedule = function(e, t) {
                        var n;
                        if (void 0 === t && (t = 0), this.closed) return this;
                        this.state = e;
                        var i = this.id,
                            r = this.scheduler;
                        return null != i && (this.id = this.recycleAsyncId(r, i, t)), this.pending = !0, this.delay = t, this.id = null !== (n = this.id) && void 0 !== n ? n : this.requestAsyncId(r, this.id, t), this
                    }, t.prototype.requestAsyncId = function(e, t, n) {
                        return void 0 === n && (n = 0), Wg.setInterval(e.flush.bind(e, this), n)
                    }, t.prototype.recycleAsyncId = function(e, t, n) {
                        if (void 0 === n && (n = 0), null != n && this.delay === n && !1 === this.pending) return t;
                        null != t && Wg.clearInterval(t)
                    }, t.prototype.execute = function(e, t) {
                        if (this.closed) return new Error("executing a cancelled action");
                        this.pending = !1;
                        var n = this._execute(e, t);
                        if (n) return n;
                        !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
                    }, t.prototype._execute = function(e, t) {
                        var n, i = !1;
                        try {
                            this.work(e)
                        } catch (e) {
                            i = !0, n = e || new Error("Scheduled action threw falsy error")
                        }
                        if (i) return this.unsubscribe(), n
                    }, t.prototype.unsubscribe = function() {
                        if (!this.closed) {
                            var t = this.id,
                                n = this.scheduler,
                                i = n.actions;
                            this.work = this.state = this.scheduler = null, this.pending = !1, Zl(i, this), null != t && (this.id = this.recycleAsyncId(n, t, null)), this.delay = null, e.prototype.unsubscribe.call(this)
                        }
                    }, t
                }(jg),
                Yg = function() {
                    return Date.now()
                },
                qg = function() {
                    function e(t, n) {
                        void 0 === n && (n = e.now), this.schedulerActionCtor = t, this.now = n
                    }
                    return e.prototype.schedule = function(e, t, n) {
                        return void 0 === t && (t = 0), new this.schedulerActionCtor(this, e).schedule(n, t)
                    }, e.now = Yg, e
                }(),
                Kg = function(e) {
                    function t(t, n) {
                        void 0 === n && (n = qg.now);
                        var i = e.call(this, t, n) || this;
                        return i.actions = [], i._active = !1, i
                    }
                    return Gl(t, e), t.prototype.flush = function(e) {
                        var t = this.actions;
                        if (this._active) t.push(e);
                        else {
                            var n;
                            this._active = !0;
                            do {
                                if (n = e.execute(e.state, e.delay)) break
                            } while (e = t.shift());
                            if (this._active = !1, n) {
                                for (; e = t.shift();) e.unsubscribe();
                                throw n
                            }
                        }
                    }, t
                }(qg),
                Jg = new Kg(Xg);

            function Zg(e, t, n) {
                return void 0 === e && (e = 0), void 0 === n && (n = Jg), new mc((function(t) {
                    var i, r = (i = e) instanceof Date && !isNaN(i) ? +e - n.now() : e;
                    r < 0 && (r = 0);
                    var s = 0;
                    return n.schedule((function() {
                        t.closed || (t.next(s++), t.complete())
                    }), r)
                }))
            }

            function $g(e) {
                return void 0 === e && (e = 1 / 0), Fg(pc, e)
            }
            var eA = new mc((function(e) {
                return e.complete()
            }));

            function tA(e) {
                return e[e.length - 1]
            }

            function nA(e) {
                return function(e) {
                    return e && ql(e.schedule)
                }(tA(e)) ? e.pop() : void 0
            }

            function iA(e, t) {
                return void 0 === t && (t = 0), Pg((function(n, i) {
                    n.subscribe(Lg(i, (function(n) {
                        return Og(i, e, (function() {
                            return i.next(n)
                        }), t)
                    }), (function() {
                        return Og(i, e, (function() {
                            return i.complete()
                        }), t)
                    }), (function(n) {
                        return Og(i, e, (function() {
                            return i.error(n)
                        }), t)
                    })))
                }))
            }

            function rA(e, t) {
                return void 0 === t && (t = 0), Pg((function(n, i) {
                    i.add(e.schedule((function() {
                        return n.subscribe(i)
                    }), t))
                }))
            }

            function sA(e, t) {
                if (!e) throw new Error("Iterable cannot be null");
                return new mc((function(n) {
                    Og(n, t, (function() {
                        var i = e[Symbol.asyncIterator]();
                        Og(n, t, (function() {
                            i.next().then((function(e) {
                                e.done ? n.complete() : n.next(e.value)
                            }))
                        }), 0, !0)
                    }))
                }))
            }

            function oA(e, t) {
                return t ? function(e, t) {
                    if (null != e) {
                        if (wg(e)) return function(e, t) {
                            return Rg(e).pipe(rA(t), iA(t))
                        }(e, t);
                        if (Eg(e)) return function(e, t) {
                            return new mc((function(n) {
                                var i = 0;
                                return t.schedule((function() {
                                    i === e.length ? n.complete() : (n.next(e[i++]), n.closed || this.schedule())
                                }))
                            }))
                        }(e, t);
                        if (bg(e)) return function(e, t) {
                            return Rg(e).pipe(rA(t), iA(t))
                        }(e, t);
                        if (Cg(e)) return sA(e, t);
                        if (Mg(e)) return function(e, t) {
                            return new mc((function(n) {
                                var i;
                                return Og(n, t, (function() {
                                        i = e[Tg](), Og(n, t, (function() {
                                            var e, t, r;
                                            try {
                                                t = (e = i.next()).value, r = e.done
                                            } catch (e) {
                                                return void n.error(e)
                                            }
                                            r ? n.complete() : n.next(t)
                                        }), 0, !0)
                                    })),
                                    function() {
                                        return ql(null == i ? void 0 : i.return) && i.return()
                                    }
                            }))
                        }(e, t);
                        if (Bg(e)) return function(e, t) {
                            return sA(Ig(e), t)
                        }(e, t)
                    }
                    throw Sg(e)
                }(e, t) : Rg(e)
            }

            function aA() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                var n = nA(e),
                    i = function(e, t) {
                        return "number" == typeof tA(e) ? e.pop() : 1 / 0
                    }(e),
                    r = e;
                return r.length ? 1 === r.length ? Rg(r[0]) : $g(i)(oA(r, n)) : eA
            }

            function lA() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                return $g(1)(oA(e, nA(e)))
            }

            function cA(e) {
                return Ng((function() {
                    return e
                }))
            }

            function uA(e) {
                return uA = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, uA(e)
            }

            function hA(e) {
                return function(e) {
                    if (Array.isArray(e)) return dA(e)
                }(e) || function(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                }(e) || function(e, t) {
                    if (e) {
                        if ("string" == typeof e) return dA(e, t);
                        var n = {}.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? dA(e, t) : void 0
                    }
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function dA(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function fA() {
                fA = function() {
                    return t
                };
                var e, t = {},
                    n = Object.prototype,
                    i = n.hasOwnProperty,
                    r = Object.defineProperty || function(e, t, n) {
                        e[t] = n.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    o = s.iterator || "@@iterator",
                    a = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, n) {
                    return Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, n) {
                        return e[t] = n
                    }
                }

                function u(e, t, n, i) {
                    var s = t && t.prototype instanceof A ? t : A,
                        o = Object.create(s.prototype),
                        a = new B(i || []);
                    return r(o, "_invoke", {
                        value: S(e, n, a)
                    }), o
                }

                function h(e, t, n) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, n)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart",
                    f = "suspendedYield",
                    p = "executing",
                    m = "completed",
                    g = {};

                function A() {}

                function v() {}

                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }));
                var x = Object.getPrototypeOf,
                    E = x && x(x(R([])));
                E && E !== n && i.call(E, o) && (_ = E);
                var b = y.prototype = A.prototype = Object.create(_);

                function w(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function C(e, t) {
                    function n(r, s, o, a) {
                        var l = h(e[r], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                u = c.value;
                            return u && "object" == uA(u) && i.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                n("next", e, o, a)
                            }), (function(e) {
                                n("throw", e, o, a)
                            })) : t.resolve(u).then((function(e) {
                                c.value = e, o(c)
                            }), (function(e) {
                                return n("throw", e, o, a)
                            }))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(e, i) {
                            function r() {
                                return new t((function(t, r) {
                                    n(e, i, t, r)
                                }))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }

                function S(t, n, i) {
                    var r = d;
                    return function(s, o) {
                        if (r === p) throw Error("Generator is already running");
                        if (r === m) {
                            if ("throw" === s) throw o;
                            return {
                                value: e,
                                done: !0
                            }
                        }
                        for (i.method = s, i.arg = o;;) {
                            var a = i.delegate;
                            if (a) {
                                var l = T(a, i);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === i.method) i.sent = i._sent = i.arg;
                            else if ("throw" === i.method) {
                                if (r === d) throw r = m, i.arg;
                                i.dispatchException(i.arg)
                            } else "return" === i.method && i.abrupt("return", i.arg);
                            r = p;
                            var c = h(t, n, i);
                            if ("normal" === c.type) {
                                if (r = i.done ? m : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: i.done
                                }
                            }
                            "throw" === c.type && (r = m, i.method = "throw", i.arg = c.arg)
                        }
                    }
                }

                function T(t, n) {
                    var i = n.method,
                        r = t.iterator[i];
                    if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
                }

                function M(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function I(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function B(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(M, this), this.reset(!0)
                }

                function R(t) {
                    if (t || "" === t) {
                        var n = t[o];
                        if (n) return n.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var r = -1,
                                s = function n() {
                                    for (; ++r < t.length;)
                                        if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = e, n.done = !0, n
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(uA(t) + " is not iterable")
                }
                return v.prototype = y, r(b, "constructor", {
                    value: y,
                    configurable: !0
                }), r(y, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(b), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, w(C.prototype), c(C.prototype, a, (function() {
                    return this
                })), t.AsyncIterator = C, t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new C(u(e, n, i, r), s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                        return e.done ? e.value : o.next()
                    }))
                }, w(b), c(b, l, "Generator"), c(b, o, (function() {
                    return this
                })), c(b, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = Object(e),
                        n = [];
                    for (var i in t) n.push(i);
                    return n.reverse(),
                        function e() {
                            for (; n.length;) {
                                var i = n.pop();
                                if (i in t) return e.value = i, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, t.values = R, B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !t)
                            for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done) throw t;
                        var n = this;

                        function r(i, r) {
                            return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s],
                                a = o.completion;
                            if ("root" === o.tryLoc) return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc"),
                                    c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                } else {
                                    if (!c) throw Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(o)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.tryLoc === e) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    I(n)
                                }
                                return r
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = e), g
                    }
                }, t
            }

            function pA(e, t, n, i, r, s, o) {
                try {
                    var a = e[s](o),
                        l = a.value
                } catch (e) {
                    return void n(e)
                }
                a.done ? t(l) : Promise.resolve(l).then(i, r)
            }

            function mA(e) {
                return function() {
                    var t = this,
                        n = arguments;
                    return new Promise((function(i, r) {
                        var s = e.apply(t, n);

                        function o(e) {
                            pA(s, i, r, o, a, "next", e)
                        }

                        function a(e) {
                            pA(s, i, r, o, a, "throw", e)
                        }
                        o(void 0)
                    }))
                }
            }

            function gA(e) {
                var t = function(e, t) {
                    if ("object" != uA(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != uA(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == uA(t) ? t : t + ""
            }
            var AA = function() {
                return function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, gA(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e(t) {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.engine = t, this.initialAsset = Ec.complectation.value.layout, this.promises = new Map, this.isDestroyed = !1
                }), [{
                    key: "loadAndSetup",
                    value: (n = mA(fA().mark((function e() {
                        var t;
                        return fA().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return t = Promise.all([this.engine.models.load(), this.engine.textures.load()]), e.next = 3, t;
                                case 3:
                                    this.engine && this.engine.models && this.engine.models.setup(!0);
                                case 4:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return n.apply(this, arguments)
                    })
                }, {
                    key: "loadAndSetupRest",
                    value: (t = mA(fA().mark((function e() {
                        var t, n = this;
                        return fA().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return t = Promise.all([this.engine.textures.load(!0), this.engine.models.load(!0)]), Wd.models.samara.assetsArray.forEach((function(e) {
                                        n.promises.has(e.name) || e.name === n.initialAsset || n.promises.set(e.name, new Promise((function(t) {
                                            Promise.all([e.modelPromise].concat(hA(e.texturesPromises))).then(function() {
                                                var i = mA(fA().mark((function i(r) {
                                                    return fA().wrap((function(i) {
                                                        for (;;) switch (i.prev = i.next) {
                                                            case 0:
                                                                if (!n.isDestroyed && n.engine && n.engine.models) {
                                                                    i.next = 3;
                                                                    break
                                                                }
                                                                return i.abrupt("return");
                                                            case 3:
                                                                return i.next = 5, e.modelPromise;
                                                            case 5:
                                                                i.t0 = i.sent, n.engine.models["".concat(e.name, "_assets")] = [i.t0], n.engine.models.setup(), t(r);
                                                            case 9:
                                                            case "end":
                                                                return i.stop()
                                                        }
                                                    }), i)
                                                })));
                                                return function(e) {
                                                    return i.apply(this, arguments)
                                                }
                                            }())
                                        })))
                                    })), e.next = 4, t;
                                case 4:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return t.apply(this, arguments)
                    })
                }, {
                    key: "checkAssetLoadedAndSetupComplete",
                    value: (e = mA(fA().mark((function e(t) {
                        var n;
                        return fA().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return Ec.modelLoadingIndicator.next({
                                        isLoading: !0,
                                        name: t
                                    }), n = this.promises.get(t), e.next = 4, n;
                                case 4:
                                    Ec.modelLoadingIndicator.next({
                                        isLoading: !1
                                    });
                                case 5:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function(t) {
                        return e.apply(this, arguments)
                    })
                }, {
                    key: "destroy",
                    value: function() {
                        this.isDestroyed = !0, this.promises.clear()
                    }
                }]);
                var e, t, n
            }();

            function vA(e) {
                return vA = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, vA(e)
            }

            function yA(e, t, n) {
                return (t = xA(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function _A(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function xA(e) {
                var t = function(e, t) {
                    if ("object" != vA(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, t);
                        if ("object" != vA(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e, "string");
                return "symbol" == vA(t) ? t : t + ""
            }
            var EA = function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, xA(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e() {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e)
                }), [{
                    key: "checkSomeOptionInIncludeAdded",
                    value: function(e, t) {
                        var n, i = !1,
                            r = function(e, t) {
                                var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                if (!n) {
                                    if (Array.isArray(e) || (n = function(e, t) {
                                            if (e) {
                                                if ("string" == typeof e) return _A(e, t);
                                                var n = {}.toString.call(e).slice(8, -1);
                                                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _A(e, t) : void 0
                                            }
                                        }(e)) || t) {
                                        n && (e = n);
                                        var i = 0,
                                            r = function() {};
                                        return {
                                            s: r,
                                            n: function() {
                                                return i >= e.length ? {
                                                    done: !0
                                                } : {
                                                    done: !1,
                                                    value: e[i++]
                                                }
                                            },
                                            e: function(e) {
                                                throw e
                                            },
                                            f: r
                                        }
                                    }
                                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                }
                                var s, o = !0,
                                    a = !1;
                                return {
                                    s: function() {
                                        n = n.call(e)
                                    },
                                    n: function() {
                                        var e = n.next();
                                        return o = e.done, e
                                    },
                                    e: function(e) {
                                        a = !0, s = e
                                    },
                                    f: function() {
                                        try {
                                            o || null == n.return || n.return()
                                        } finally {
                                            if (a) throw s
                                        }
                                    }
                                }
                            }(e.layouts);
                        try {
                            for (r.s(); !(n = r.n()).done;) {
                                var s = n.value;
                                if (this.checkOptionAdded(s, t, !0)) {
                                    i = !0;
                                    break
                                }
                            }
                        } catch (e) {
                            r.e(e)
                        } finally {
                            r.f()
                        }
                        return i
                    }
                }, {
                    key: "checkOptionAdded",
                    value: function(e, t, n) {
                        return e = cg().isString(e) && !n ? yA({}, t.toLowerCase(), e) : cg().isString(e) && n ? {
                            layout: e
                        } : yA({}, t.toLowerCase(), e.name), cg().some([Ec.complectation.value], e)
                    }
                }, {
                    key: "setOption",
                    value: function(e) {
                        var t = Ec.complectation.value,
                            n = Object.assign(t, e);
                        n.changedValue = Object.keys(e)[0], Ec.complectation.next(n)
                    }
                }]),
                bA = .001,
                wA = (() => {
                    const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                        t = new Float32Array([0, 0, 2, 0, 0, 2]),
                        n = new si;
                    return n.setAttribute("position", new Yn(e, 3)), n.setAttribute("uv", new Yn(t, 2)), n
                })(),
                CA = class e {
                    static get fullscreenGeometry() {
                        return wA
                    }
                    constructor(e = "Pass", t = new Ro, n = new Ci) {
                        this.name = e, this.renderer = null, this.scene = t, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
                    }
                    get renderToScreen() {
                        return !this.rtt
                    }
                    set renderToScreen(e) {
                        if (this.rtt === e) {
                            const t = this.fullscreenMaterial;
                            null !== t && (t.needsUpdate = !0), this.rtt = !e
                        }
                    }
                    set mainScene(e) {}
                    set mainCamera(e) {}
                    setRenderer(e) {
                        this.renderer = e
                    }
                    isEnabled() {
                        return this.enabled
                    }
                    setEnabled(e) {
                        this.enabled = e
                    }
                    get fullscreenMaterial() {
                        return null !== this.screen ? this.screen.material : null
                    }
                    set fullscreenMaterial(t) {
                        let n = this.screen;
                        null !== n ? n.material = t : (n = new Ai(e.fullscreenGeometry, t), n.frustumCulled = !1, null === this.scene && (this.scene = new Ro), this.scene.add(n), this.screen = n)
                    }
                    getFullscreenMaterial() {
                        return this.fullscreenMaterial
                    }
                    setFullscreenMaterial(e) {
                        this.fullscreenMaterial = e
                    }
                    getDepthTexture() {
                        return null
                    }
                    setDepthTexture(e, t = 3200) {}
                    render(e, t, n, i, r) {
                        throw new Error("Render method not implemented!")
                    }
                    setSize(e, t) {}
                    initialize(e, t, n) {}
                    dispose() {
                        for (const t of Object.keys(this)) {
                            const n = this[t];
                            (n instanceof dt || n instanceof Hn || n instanceof ct || n instanceof e) && this[t].dispose()
                        }
                        null !== this.fullscreenMaterial && this.fullscreenMaterial.dispose()
                    }
                },
                SA = class extends CA {
                    constructor() {
                        super("ClearMaskPass", null, null), this.needsSwap = !1
                    }
                    render(e, t, n, i, r) {
                        const s = e.state.buffers.stencil;
                        s.setLocked(!1), s.setTest(!1)
                    }
                },
                TA = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
                MA = class extends wi {
                    constructor() {
                        super({
                            name: "CopyMaterial",
                            uniforms: {
                                inputBuffer: new Ll(null),
                                opacity: new Ll(1)
                            },
                            blending: 0,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}",
                            vertexShader: TA
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    getOpacity(e) {
                        return this.uniforms.opacity.value
                    }
                    setOpacity(e) {
                        this.uniforms.opacity.value = e
                    }
                },
                IA = class extends CA {
                    constructor(e, t = !0) {
                        super("CopyPass"), this.fullscreenMaterial = new MA, this.needsSwap = !1, this.renderTarget = e, void 0 === e && (this.renderTarget = new dt(1, 1, {
                            minFilter: f,
                            magFilter: f,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = t
                    }
                    get resize() {
                        return this.autoResize
                    }
                    set resize(e) {
                        this.autoResize = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    setAutoResizeEnabled(e) {
                        this.autoResize = e
                    }
                    render(e, t, n, i, r) {
                        this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        this.autoResize && this.renderTarget.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        void 0 !== n && (this.renderTarget.texture.type = n, n !== A ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : null !== e && e.outputColorSpace === _e && (this.renderTarget.texture.colorSpace = _e))
                    }
                },
                BA = new kn,
                RA = class extends CA {
                    constructor(e = !0, t = !0, n = !1) {
                        super("ClearPass", null, null), this.needsSwap = !1, this.color = e, this.depth = t, this.stencil = n, this.overrideClearColor = null, this.overrideClearAlpha = -1
                    }
                    setClearFlags(e, t, n) {
                        this.color = e, this.depth = t, this.stencil = n
                    }
                    getOverrideClearColor() {
                        return this.overrideClearColor
                    }
                    setOverrideClearColor(e) {
                        this.overrideClearColor = e
                    }
                    getOverrideClearAlpha() {
                        return this.overrideClearAlpha
                    }
                    setOverrideClearAlpha(e) {
                        this.overrideClearAlpha = e
                    }
                    render(e, t, n, i, r) {
                        const s = this.overrideClearColor,
                            o = this.overrideClearAlpha,
                            a = e.getClearAlpha(),
                            l = null !== s,
                            c = o >= 0;
                        l ? (e.getClearColor(BA), e.setClearColor(s, c ? o : a)) : c && e.setClearAlpha(o), e.setRenderTarget(this.renderToScreen ? null : t), e.clear(this.color, this.depth, this.stencil), l ? e.setClearColor(BA, a) : c && e.setClearAlpha(a)
                    }
                },
                DA = class extends CA {
                    constructor(e, t) {
                        super("MaskPass", e, t), this.needsSwap = !1, this.clearPass = new RA(!1, !1, !0), this.inverse = !1
                    }
                    set mainScene(e) {
                        this.scene = e
                    }
                    set mainCamera(e) {
                        this.camera = e
                    }
                    get inverted() {
                        return this.inverse
                    }
                    set inverted(e) {
                        this.inverse = e
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(e) {
                        this.clearPass.enabled = e
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    render(e, t, n, i, r) {
                        const s = e.getContext(),
                            o = e.state.buffers,
                            a = this.scene,
                            l = this.camera,
                            c = this.clearPass,
                            u = this.inverted ? 0 : 1,
                            h = 1 - u;
                        o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.stencil.setFunc(s.ALWAYS, u, 4294967295), o.stencil.setClear(h), o.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(e, null) : (c.render(e, t), c.render(e, n))), this.renderToScreen ? (e.setRenderTarget(null), e.render(a, l)) : (e.setRenderTarget(t), e.render(a, l), e.setRenderTarget(n), e.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(s.EQUAL, 1, 4294967295), o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.stencil.setLocked(!0)
                    }
                },
                PA = {
                    FRAGMENT_HEAD: "FRAGMENT_HEAD",
                    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
                    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
                    VERTEX_HEAD: "VERTEX_HEAD",
                    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
                },
                LA = !1,
                UA = class {
                    constructor(e = null) {
                        this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(e), this.meshCount = 0, this.replaceMaterial = e => {
                            if (e.isMesh) {
                                let t;
                                if (e.material.flatShading) switch (e.material.side) {
                                    case 2:
                                        t = this.materialsFlatShadedDoubleSide;
                                        break;
                                    case 1:
                                        t = this.materialsFlatShadedBackSide;
                                        break;
                                    default:
                                        t = this.materialsFlatShaded
                                } else switch (e.material.side) {
                                    case 2:
                                        t = this.materialsDoubleSide;
                                        break;
                                    case 1:
                                        t = this.materialsBackSide;
                                        break;
                                    default:
                                        t = this.materials
                                }
                                this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount
                            }
                        }
                    }
                    cloneMaterial(e) {
                        if (!(e instanceof wi)) return e.clone();
                        const t = e.uniforms,
                            n = new Map;
                        for (const e in t) {
                            const i = t[e].value;
                            i.isRenderTargetTexture && (t[e].value = null, n.set(e, i))
                        }
                        const i = e.clone();
                        for (const e of n) t[e[0]].value = e[1], i.uniforms[e[0]].value = e[1];
                        return i
                    }
                    setMaterial(e) {
                        if (this.disposeMaterials(), this.material = e, null !== e) {
                            const t = this.materials = [this.cloneMaterial(e), this.cloneMaterial(e), this.cloneMaterial(e)];
                            for (const n of t) n.uniforms = Object.assign({}, e.uniforms), n.side = 0;
                            t[2].skinning = !0, this.materialsBackSide = t.map((t => {
                                const n = this.cloneMaterial(t);
                                return n.uniforms = Object.assign({}, e.uniforms), n.side = 1, n
                            })), this.materialsDoubleSide = t.map((t => {
                                const n = this.cloneMaterial(t);
                                return n.uniforms = Object.assign({}, e.uniforms), n.side = 2, n
                            })), this.materialsFlatShaded = t.map((t => {
                                const n = this.cloneMaterial(t);
                                return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n
                            })), this.materialsFlatShadedBackSide = t.map((t => {
                                const n = this.cloneMaterial(t);
                                return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n.side = 1, n
                            })), this.materialsFlatShadedDoubleSide = t.map((t => {
                                const n = this.cloneMaterial(t);
                                return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n.side = 2, n
                            }))
                        }
                    }
                    render(e, t, n) {
                        const i = e.shadowMap.enabled;
                        if (e.shadowMap.enabled = !1, LA) {
                            const i = this.originalMaterials;
                            this.meshCount = 0, t.traverse(this.replaceMaterial), e.render(t, n);
                            for (const e of i) e[0].material = e[1];
                            this.meshCount !== i.size && i.clear()
                        } else {
                            const i = t.overrideMaterial;
                            t.overrideMaterial = this.material, e.render(t, n), t.overrideMaterial = i
                        }
                        e.shadowMap.enabled = i
                    }
                    disposeMaterials() {
                        if (null !== this.material) {
                            const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                            for (const t of e) t.dispose()
                        }
                    }
                    dispose() {
                        this.originalMaterials.clear(), this.disposeMaterials()
                    }
                    static get workaroundEnabled() {
                        return LA
                    }
                    static set workaroundEnabled(e) {
                        LA = e
                    }
                },
                NA = -1,
                OA = class extends Ie {
                    constructor(e, t = -1, n = -1, i = 1) {
                        super(), this.resizable = e, this.baseSize = new ze(1, 1), this.preferredSize = new ze(t, n), this.target = this.preferredSize, this.s = i, this.effectiveSize = new ze, this.addEventListener("change", (() => this.updateEffectiveSize())), this.updateEffectiveSize()
                    }
                    updateEffectiveSize() {
                        const e = this.baseSize,
                            t = this.preferredSize,
                            n = this.effectiveSize,
                            i = this.scale;
                        t.width !== NA ? n.width = t.width : t.height !== NA ? n.width = Math.round(t.height * (e.width / Math.max(e.height, 1))) : n.width = Math.round(e.width * i), t.height !== NA ? n.height = t.height : t.width !== NA ? n.height = Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : n.height = Math.round(e.height * i)
                    }
                    get width() {
                        return this.effectiveSize.width
                    }
                    set width(e) {
                        this.preferredWidth = e
                    }
                    get height() {
                        return this.effectiveSize.height
                    }
                    set height(e) {
                        this.preferredHeight = e
                    }
                    getWidth() {
                        return this.width
                    }
                    getHeight() {
                        return this.height
                    }
                    get scale() {
                        return this.s
                    }
                    set scale(e) {
                        this.s !== e && (this.s = e, this.preferredSize.setScalar(NA), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getScale() {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    get baseWidth() {
                        return this.baseSize.width
                    }
                    set baseWidth(e) {
                        this.baseSize.width !== e && (this.baseSize.width = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseWidth() {
                        return this.baseWidth
                    }
                    setBaseWidth(e) {
                        this.baseWidth = e
                    }
                    get baseHeight() {
                        return this.baseSize.height
                    }
                    set baseHeight(e) {
                        this.baseSize.height !== e && (this.baseSize.height = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseHeight() {
                        return this.baseHeight
                    }
                    setBaseHeight(e) {
                        this.baseHeight = e
                    }
                    setBaseSize(e, t) {
                        this.baseSize.width === e && this.baseSize.height === t || (this.baseSize.set(e, t), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    get preferredWidth() {
                        return this.preferredSize.width
                    }
                    set preferredWidth(e) {
                        this.preferredSize.width !== e && (this.preferredSize.width = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredWidth() {
                        return this.preferredWidth
                    }
                    setPreferredWidth(e) {
                        this.preferredWidth = e
                    }
                    get preferredHeight() {
                        return this.preferredSize.height
                    }
                    set preferredHeight(e) {
                        this.preferredSize.height !== e && (this.preferredSize.height = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredHeight() {
                        return this.preferredHeight
                    }
                    setPreferredHeight(e) {
                        this.preferredHeight = e
                    }
                    setPreferredSize(e, t) {
                        this.preferredSize.width === e && this.preferredSize.height === t || (this.preferredSize.set(e, t), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    copy(e) {
                        this.s = e.scale, this.baseSize.set(e.baseWidth, e.baseHeight), this.preferredSize.set(e.preferredWidth, e.preferredHeight), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)
                    }
                    static get AUTO_SIZE() {
                        return NA
                    }
                },
                FA = new class {
                    constructor(e = 0) {
                        this.nextId = e
                    }
                    getNextId() {
                        return this.nextId++
                    }
                    reset(e = 0) {
                        return this.nextId = e, this
                    }
                }(2),
                kA = class extends Set {
                    constructor(e, t = FA.getNextId()) {
                        super(), this.exclusive = !1, this._layer = t, (this._layer < 1 || this._layer > 31) && (FA.reset(2), this._layer = FA.getNextId()), void 0 !== e && this.set(e)
                    }
                    get layer() {
                        return this._layer
                    }
                    set layer(e) {
                        const t = this._layer;
                        for (const n of this) n.layers.disable(t), n.layers.enable(e);
                        this._layer = e
                    }
                    getLayer() {
                        return this.layer
                    }
                    setLayer(e) {
                        this.layer = e
                    }
                    isExclusive() {
                        return this.exclusive
                    }
                    setExclusive(e) {
                        this.exclusive = e
                    }
                    clear() {
                        const e = this.layer;
                        for (const t of this) t.layers.disable(e);
                        return super.clear()
                    }
                    set(e) {
                        this.clear();
                        for (const t of e) this.add(t);
                        return this
                    }
                    indexOf(e) {
                        return this.has(e) ? 0 : -1
                    }
                    add(e) {
                        return this.exclusive ? e.layers.set(this.layer) : e.layers.enable(this.layer), super.add(e)
                    }
                    delete(e) {
                        return this.has(e) && e.layers.disable(this.layer), super.delete(e)
                    }
                    toggle(e) {
                        let t;
                        return this.has(e) ? (this.delete(e), t = !1) : (this.add(e), t = !0), t
                    }
                    setVisible(e) {
                        for (const t of this) e ? t.layers.enable(0) : t.layers.disable(0);
                        return this
                    }
                },
                QA = new Map([
                    [0, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"],
                    [1, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"],
                    [2, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"],
                    [3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [4, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"],
                    [5, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"],
                    [6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"],
                    [7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"],
                    [8, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"],
                    [9, null],
                    [10, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"],
                    [11, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}"],
                    [12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"],
                    [13, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [14, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"],
                    [15, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"],
                    [16, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"],
                    [17, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"],
                    [18, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"],
                    [19, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"],
                    [20, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [21, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"],
                    [22, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"],
                    [23, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"],
                    [24, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"],
                    [25, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"],
                    [26, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}"],
                    [27, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [28, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}"],
                    [29, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"],
                    [30, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"],
                    [31, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"],
                    [32, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}"]
                ]),
                zA = class extends Ie {
                    constructor(e, t = 1) {
                        super(), this._blendFunction = e, this.opacity = new Ll(t)
                    }
                    getOpacity() {
                        return this.opacity.value
                    }
                    setOpacity(e) {
                        this.opacity.value = e
                    }
                    get blendFunction() {
                        return this._blendFunction
                    }
                    set blendFunction(e) {
                        this._blendFunction = e, this.dispatchEvent({
                            type: "change"
                        })
                    }
                    getBlendFunction() {
                        return this.blendFunction
                    }
                    setBlendFunction(e) {
                        this.blendFunction = e
                    }
                    getShaderCode() {
                        return QA.get(this.blendFunction)
                    }
                },
                HA = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])],
                GA = class extends wi {
                    constructor(e = new ut) {
                        super({
                            name: "KawaseBlurMaterial",
                            uniforms: {
                                inputBuffer: new Ll(null),
                                texelSize: new Ll(new ut),
                                scale: new Ll(1),
                                kernel: new Ll(0)
                            },
                            blending: 0,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}",
                            vertexShader: "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                        }), this.setTexelSize(e.x, e.y), this.kernelSize = 2
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.inputBuffer = e
                    }
                    get kernelSequence() {
                        return HA[this.kernelSize]
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(e) {
                        this.uniforms.scale.value = e
                    }
                    getScale() {
                        return this.uniforms.scale.value
                    }
                    setScale(e) {
                        this.uniforms.scale.value = e
                    }
                    getKernel() {
                        return null
                    }
                    get kernel() {
                        return this.uniforms.kernel.value
                    }
                    set kernel(e) {
                        this.uniforms.kernel.value = e
                    }
                    setKernel(e) {
                        this.kernel = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t, .5 * e, .5 * t)
                    }
                    setSize(e, t) {
                        const n = 1 / e,
                            i = 1 / t;
                        this.uniforms.texelSize.value.set(n, i, .5 * n, .5 * i)
                    }
                },
                VA = class extends CA {
                    constructor({
                        kernelSize: e = 2,
                        resolutionScale: t = .5,
                        width: n = OA.AUTO_SIZE,
                        height: i = OA.AUTO_SIZE,
                        resolutionX: r = n,
                        resolutionY: s = i
                    } = {}) {
                        super("KawaseBlurPass"), this.renderTargetA = new dt(1, 1, {
                            depthBuffer: !1
                        }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
                        const o = this.resolution = new OA(this, r, s, t);
                        o.addEventListener("change", (e => this.setSize(o.baseWidth, o.baseHeight))), this._blurMaterial = new GA, this._blurMaterial.kernelSize = e, this.copyMaterial = new MA
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get blurMaterial() {
                        return this._blurMaterial
                    }
                    set blurMaterial(e) {
                        this._blurMaterial = e
                    }
                    get dithering() {
                        return this.copyMaterial.dithering
                    }
                    set dithering(e) {
                        this.copyMaterial.dithering = e
                    }
                    get kernelSize() {
                        return this.blurMaterial.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurMaterial.kernelSize = e
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get scale() {
                        return this.blurMaterial.scale
                    }
                    set scale(e) {
                        this.blurMaterial.scale = e
                    }
                    getScale() {
                        return this.blurMaterial.scale
                    }
                    setScale(e) {
                        this.blurMaterial.scale = e
                    }
                    getKernelSize() {
                        return this.kernelSize
                    }
                    setKernelSize(e) {
                        this.kernelSize = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, r) {
                        const s = this.scene,
                            o = this.camera,
                            a = this.renderTargetA,
                            l = this.renderTargetB,
                            c = this.blurMaterial,
                            u = c.kernelSequence;
                        let h = t;
                        this.fullscreenMaterial = c;
                        for (let t = 0, n = u.length; t < n; ++t) {
                            const n = 1 & t ? l : a;
                            c.kernel = u[t], c.inputBuffer = h.texture, e.setRenderTarget(n), e.render(s, o), h = n
                        }
                        this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = h.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, o)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width,
                            r = n.height;
                        this.renderTargetA.setSize(i, r), this.renderTargetB.setSize(i, r), this.blurMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        void 0 !== n && (this.renderTargetA.texture.type = n, this.renderTargetB.texture.type = n, n !== A ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : null !== e && e.outputColorSpace === _e && (this.renderTargetA.texture.colorSpace = _e, this.renderTargetB.texture.colorSpace = _e))
                    }
                    static get AUTO_SIZE() {
                        return OA.AUTO_SIZE
                    }
                },
                jA = class extends wi {
                    constructor(t = !1, n = null) {
                        super({
                            name: "LuminanceMaterial",
                            defines: {
                                THREE_REVISION: e.replace(/\D+/g, "")
                            },
                            uniforms: {
                                inputBuffer: new Ll(null),
                                threshold: new Ll(0),
                                smoothing: new Ll(1),
                                range: new Ll(null)
                            },
                            blending: 0,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}",
                            vertexShader: TA
                        }), this.colorOutput = t, this.luminanceRange = n
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get threshold() {
                        return this.uniforms.threshold.value
                    }
                    set threshold(e) {
                        this.smoothing > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = e
                    }
                    getThreshold() {
                        return this.threshold
                    }
                    setThreshold(e) {
                        this.threshold = e
                    }
                    get smoothing() {
                        return this.uniforms.smoothing.value
                    }
                    set smoothing(e) {
                        this.threshold > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = e
                    }
                    getSmoothingFactor() {
                        return this.smoothing
                    }
                    setSmoothingFactor(e) {
                        this.smoothing = e
                    }
                    get useThreshold() {
                        return this.threshold > 0 || this.smoothing > 0
                    }
                    set useThreshold(e) {}
                    get colorOutput() {
                        return void 0 !== this.defines.COLOR
                    }
                    set colorOutput(e) {
                        e ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0
                    }
                    isColorOutputEnabled(e) {
                        return this.colorOutput
                    }
                    setColorOutputEnabled(e) {
                        this.colorOutput = e
                    }
                    get useRange() {
                        return null !== this.luminanceRange
                    }
                    set useRange(e) {
                        this.luminanceRange = null
                    }
                    get luminanceRange() {
                        return this.uniforms.range.value
                    }
                    set luminanceRange(e) {
                        null !== e ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = e, this.needsUpdate = !0
                    }
                    getLuminanceRange() {
                        return this.luminanceRange
                    }
                    setLuminanceRange(e) {
                        this.luminanceRange = e
                    }
                },
                WA = class extends CA {
                    constructor({
                        renderTarget: e,
                        luminanceRange: t,
                        colorOutput: n,
                        resolutionScale: i = 1,
                        width: r = OA.AUTO_SIZE,
                        height: s = OA.AUTO_SIZE,
                        resolutionX: o = r,
                        resolutionY: a = s
                    } = {}) {
                        super("LuminancePass"), this.fullscreenMaterial = new jA(n, t), this.needsSwap = !1, this.renderTarget = e, void 0 === this.renderTarget && (this.renderTarget = new dt(1, 1, {
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "LuminancePass.Target");
                        const l = this.resolution = new OA(this, o, a, i);
                        l.addEventListener("change", (e => this.setSize(l.baseWidth, l.baseHeight)))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    render(e, t, n, i, r) {
                        this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height)
                    }
                    initialize(e, t, n) {
                        void 0 !== n && n !== A && (this.renderTarget.texture.type = n, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                },
                XA = class extends Ie {
                    constructor(e, t, {
                        attributes: n = 0,
                        blendFunction: i = 23,
                        defines: r = new Map,
                        uniforms: s = new Map,
                        extensions: o = null,
                        vertexShader: a = null
                    } = {}) {
                        super(), this.name = e, this.renderer = null, this.attributes = n, this.fragmentShader = t, this.vertexShader = a, this.defines = r, this.uniforms = s, this.extensions = o, this.blendMode = new zA(i), this.blendMode.addEventListener("change", (e => this.setChanged())), this._inputColorSpace = xe, this._outputColorSpace = ye
                    }
                    get inputColorSpace() {
                        return this._inputColorSpace
                    }
                    set inputColorSpace(e) {
                        this._inputColorSpace = e, this.setChanged()
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(e) {
                        this._outputColorSpace = e, this.setChanged()
                    }
                    set mainScene(e) {}
                    set mainCamera(e) {}
                    getName() {
                        return this.name
                    }
                    setRenderer(e) {
                        this.renderer = e
                    }
                    getDefines() {
                        return this.defines
                    }
                    getUniforms() {
                        return this.uniforms
                    }
                    getExtensions() {
                        return this.extensions
                    }
                    getBlendMode() {
                        return this.blendMode
                    }
                    getAttributes() {
                        return this.attributes
                    }
                    setAttributes(e) {
                        this.attributes = e, this.setChanged()
                    }
                    getFragmentShader() {
                        return this.fragmentShader
                    }
                    setFragmentShader(e) {
                        this.fragmentShader = e, this.setChanged()
                    }
                    getVertexShader() {
                        return this.vertexShader
                    }
                    setVertexShader(e) {
                        this.vertexShader = e, this.setChanged()
                    }
                    setChanged() {
                        this.dispatchEvent({
                            type: "change"
                        })
                    }
                    setDepthTexture(e, t = 3200) {}
                    update(e, t, n) {}
                    setSize(e, t) {}
                    initialize(e, t, n) {}
                    dispose() {
                        for (const e of Object.keys(this)) {
                            const t = this[e];
                            (t instanceof dt || t instanceof Hn || t instanceof ct || t instanceof CA) && this[e].dispose()
                        }
                    }
                },
                YA = class extends XA {
                    constructor({
                        blendFunction: e = 30
                    } = {}) {
                        super("FXAAEffect", "#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ONE_OVER_TWELVE 0.08333333333333333\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}", {
                            vertexShader: "varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}",
                            blendFunction: e,
                            defines: new Map([
                                ["EDGE_THRESHOLD_MIN", "0.0312"],
                                ["EDGE_THRESHOLD_MAX", "0.125"],
                                ["SUBPIXEL_QUALITY", "0.75"],
                                ["SAMPLES", "12"]
                            ])
                        })
                    }
                    get minEdgeThreshold() {
                        return Number(this.defines.get("EDGE_THRESHOLD_MIN"))
                    }
                    set minEdgeThreshold(e) {
                        this.defines.set("EDGE_THRESHOLD_MIN", e.toFixed(12)), this.setChanged()
                    }
                    get maxEdgeThreshold() {
                        return Number(this.defines.get("EDGE_THRESHOLD_MAX"))
                    }
                    set maxEdgeThreshold(e) {
                        this.defines.set("EDGE_THRESHOLD_MAX", e.toFixed(12)), this.setChanged()
                    }
                    get subpixelQuality() {
                        return Number(this.defines.get("SUBPIXEL_QUALITY"))
                    }
                    set subpixelQuality(e) {
                        this.defines.set("SUBPIXEL_QUALITY", e.toFixed(12)), this.setChanged()
                    }
                    get samples() {
                        return Number(this.defines.get("SAMPLES"))
                    }
                    set samples(e) {
                        this.defines.set("SAMPLES", e.toFixed(0)), this.setChanged()
                    }
                },
                qA = class extends CA {
                    constructor(e, t, n = null) {
                        super("RenderPass", e, t), this.needsSwap = !1, this.clearPass = new RA, this.overrideMaterialManager = null === n ? null : new UA(n), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null
                    }
                    set mainScene(e) {
                        this.scene = e
                    }
                    set mainCamera(e) {
                        this.camera = e
                    }
                    get renderToScreen() {
                        return super.renderToScreen
                    }
                    set renderToScreen(e) {
                        super.renderToScreen = e, this.clearPass.renderToScreen = e
                    }
                    get overrideMaterial() {
                        const e = this.overrideMaterialManager;
                        return null !== e ? e.material : null
                    }
                    set overrideMaterial(e) {
                        const t = this.overrideMaterialManager;
                        null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new UA(e) : null !== t && (t.dispose(), this.overrideMaterialManager = null)
                    }
                    getOverrideMaterial() {
                        return this.overrideMaterial
                    }
                    setOverrideMaterial(e) {
                        this.overrideMaterial = e
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(e) {
                        this.clearPass.enabled = e
                    }
                    getSelection() {
                        return this.selection
                    }
                    setSelection(e) {
                        this.selection = e
                    }
                    isBackgroundDisabled() {
                        return this.ignoreBackground
                    }
                    setBackgroundDisabled(e) {
                        this.ignoreBackground = e
                    }
                    isShadowMapDisabled() {
                        return this.skipShadowMapUpdate
                    }
                    setShadowMapDisabled(e) {
                        this.skipShadowMapUpdate = e
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    render(e, t, n, i, r) {
                        const s = this.scene,
                            o = this.camera,
                            a = this.selection,
                            l = o.layers.mask,
                            c = s.background,
                            u = e.shadowMap.autoUpdate,
                            h = this.renderToScreen ? null : t;
                        null !== a && o.layers.set(a.getLayer()), this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1), (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (s.background = null), this.clearPass.enabled && this.clearPass.render(e, t), e.setRenderTarget(h), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, s, o) : e.render(s, o), o.layers.mask = l, s.background = c, e.shadowMap.autoUpdate = u
                    }
                },
                KA = class extends GA {
                    constructor({
                        kernelSize: e = 2,
                        offset: t = 0,
                        rotation: n = 0,
                        focusArea: i = .4,
                        feather: r = .3
                    } = {}) {
                        super(), this.fragmentShader = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}", this.vertexShader = "uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}", this.kernelSize = e, this.uniforms.aspect = new Ll(1), this.uniforms.rotation = new Ll(new ze), this.uniforms.maskParams = new Ll(new ut), this._offset = t, this._focusArea = i, this._feather = r, this.rotation = n, this.updateParams()
                    }
                    updateParams() {
                        const e = this.uniforms.maskParams.value,
                            t = Math.max(this.focusArea, 0),
                            n = Math.max(t - this.feather, 0);
                        e.set(this.offset - t, this.offset - n, this.offset + t, this.offset + n)
                    }
                    get rotation() {
                        return Math.acos(this.uniforms.rotation.value.x)
                    }
                    set rotation(e) {
                        this.uniforms.rotation.value.set(Math.cos(e), Math.sin(e))
                    }
                    get offset() {
                        return this._offset
                    }
                    set offset(e) {
                        this._offset = e, this.updateParams()
                    }
                    get focusArea() {
                        return this._focusArea
                    }
                    set focusArea(e) {
                        this._focusArea = e, this.updateParams()
                    }
                    get feather() {
                        return this._feather
                    }
                    set feather(e) {
                        this._feather = e, this.updateParams()
                    }
                    setSize(e, t) {
                        super.setSize(e, t), this.uniforms.aspect.value = e / t
                    }
                },
                JA = class extends VA {
                    constructor({
                        offset: e = 0,
                        rotation: t = 0,
                        focusArea: n = .4,
                        feather: i = .3,
                        kernelSize: r = 2,
                        resolutionScale: s = .5,
                        resolutionX: o = OA.AUTO_SIZE,
                        resolutionY: a = OA.AUTO_SIZE
                    } = {}) {
                        super({
                            kernelSize: r,
                            resolutionScale: s,
                            resolutionX: o,
                            resolutionY: a
                        }), this.blurMaterial = new KA({
                            kernelSize: r,
                            offset: e,
                            rotation: t,
                            focusArea: n,
                            feather: i
                        })
                    }
                },
                ZA = class extends XA {
                    constructor({
                        blendFunction: e,
                        offset: t = 0,
                        rotation: n = 0,
                        focusArea: i = .4,
                        feather: r = .3,
                        kernelSize: s = 2,
                        resolutionScale: o = .5,
                        resolutionX: a = OA.AUTO_SIZE,
                        resolutionY: l = OA.AUTO_SIZE
                    } = {}) {
                        super("TiltShiftEffect", "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}", {
                            vertexShader: "uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}",
                            blendFunction: e,
                            uniforms: new Map([
                                ["rotation", new Ll(new ze)],
                                ["maskParams", new Ll(new ze)],
                                ["map", new Ll(null)]
                            ])
                        }), this._offset = t, this._focusArea = i, this._feather = r, this.renderTarget = new dt(1, 1, {
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "TiltShift.Target", this.uniforms.get("map").value = this.renderTarget.texture, this.blurPass = new JA({
                            kernelSize: s,
                            resolutionScale: o,
                            resolutionX: a,
                            resolutionY: l,
                            offset: t,
                            rotation: n,
                            focusArea: i,
                            feather: r
                        });
                        const c = this.resolution = new OA(this, a, l, o);
                        c.addEventListener("change", (e => this.setSize(c.baseWidth, c.baseHeight))), this.rotation = n, this.updateParams()
                    }
                    updateParams() {
                        const e = this.uniforms.get("maskParams").value,
                            t = Math.max(this.focusArea - this.feather, 0);
                        e.set(this.offset - t, this.offset + t)
                    }
                    get rotation() {
                        return Math.acos(this.uniforms.get("rotation").value.x)
                    }
                    set rotation(e) {
                        this.uniforms.get("rotation").value.set(Math.cos(e), Math.sin(e)), this.blurPass.blurMaterial.rotation = e
                    }
                    get offset() {
                        return this._offset
                    }
                    set offset(e) {
                        this._offset = e, this.blurPass.blurMaterial.offset = e, this.updateParams()
                    }
                    get focusArea() {
                        return this._focusArea
                    }
                    set focusArea(e) {
                        this._focusArea = e, this.blurPass.blurMaterial.focusArea = e, this.updateParams()
                    }
                    get feather() {
                        return this._feather
                    }
                    set feather(e) {
                        this._feather = e, this.blurPass.blurMaterial.feather = e, this.updateParams()
                    }
                    get bias() {
                        return 0
                    }
                    set bias(e) {}
                    update(e, t, n) {
                        this.blurPass.render(e, t, this.renderTarget)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height), this.blurPass.resolution.copy(n)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, n), void 0 !== n && (this.renderTarget.texture.type = n, null !== e && e.outputColorSpace === _e && (this.renderTarget.texture.colorSpace = _e))
                    }
                },
                $A = class extends wi {
                    constructor() {
                        super({
                            name: "AdaptiveLuminanceMaterial",
                            defines: {
                                MIP_LEVEL_1X1: "0.0"
                            },
                            uniforms: {
                                luminanceBuffer0: new Ll(null),
                                luminanceBuffer1: new Ll(null),
                                minLuminance: new Ll(.01),
                                deltaTime: new Ll(0),
                                tau: new Ll(1)
                            },
                            extensions: {
                                shaderTextureLOD: !0
                            },
                            blending: 0,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}",
                            vertexShader: TA
                        })
                    }
                    set luminanceBuffer0(e) {
                        this.uniforms.luminanceBuffer0.value = e
                    }
                    setLuminanceBuffer0(e) {
                        this.uniforms.luminanceBuffer0.value = e
                    }
                    set luminanceBuffer1(e) {
                        this.uniforms.luminanceBuffer1.value = e
                    }
                    setLuminanceBuffer1(e) {
                        this.uniforms.luminanceBuffer1.value = e
                    }
                    set mipLevel1x1(e) {
                        this.defines.MIP_LEVEL_1X1 = e.toFixed(1), this.needsUpdate = !0
                    }
                    setMipLevel1x1(e) {
                        this.mipLevel1x1 = e
                    }
                    set deltaTime(e) {
                        this.uniforms.deltaTime.value = e
                    }
                    setDeltaTime(e) {
                        this.uniforms.deltaTime.value = e
                    }
                    get minLuminance() {
                        return this.uniforms.minLuminance.value
                    }
                    set minLuminance(e) {
                        this.uniforms.minLuminance.value = e
                    }
                    getMinLuminance() {
                        return this.uniforms.minLuminance.value
                    }
                    setMinLuminance(e) {
                        this.uniforms.minLuminance.value = e
                    }
                    get adaptationRate() {
                        return this.uniforms.tau.value
                    }
                    set adaptationRate(e) {
                        this.uniforms.tau.value = e
                    }
                    getAdaptationRate() {
                        return this.uniforms.tau.value
                    }
                    setAdaptationRate(e) {
                        this.uniforms.tau.value = e
                    }
                },
                ev = class extends CA {
                    constructor(e, {
                        minLuminance: t = .01,
                        adaptationRate: n = 1
                    } = {}) {
                        super("AdaptiveLuminancePass"), this.fullscreenMaterial = new $A, this.needsSwap = !1, this.renderTargetPrevious = new dt(1, 1, {
                            minFilter: h,
                            magFilter: h,
                            depthBuffer: !1
                        }), this.renderTargetPrevious.texture.name = "Luminance.Previous";
                        const i = this.fullscreenMaterial;
                        i.luminanceBuffer0 = this.renderTargetPrevious.texture, i.luminanceBuffer1 = e, i.minLuminance = t, i.adaptationRate = n, this.renderTargetAdapted = this.renderTargetPrevious.clone(), this.renderTargetAdapted.texture.name = "Luminance.Adapted", this.copyPass = new IA(this.renderTargetPrevious, !1)
                    }
                    get texture() {
                        return this.renderTargetAdapted.texture
                    }
                    getTexture() {
                        return this.renderTargetAdapted.texture
                    }
                    set mipLevel1x1(e) {
                        this.fullscreenMaterial.mipLevel1x1 = e
                    }
                    get adaptationRate() {
                        return this.fullscreenMaterial.adaptationRate
                    }
                    set adaptationRate(e) {
                        this.fullscreenMaterial.adaptationRate = e
                    }
                    render(e, t, n, i, r) {
                        this.fullscreenMaterial.deltaTime = i, e.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted), e.render(this.scene, this.camera), this.copyPass.render(e, this.renderTargetAdapted)
                    }
                },
                tv = class extends XA {
                    constructor({
                        blendFunction: e = 30,
                        adaptive: t = !1,
                        mode: n = (t ? 3 : 7),
                        resolution: i = 256,
                        maxLuminance: r = 4,
                        whitePoint: s = r,
                        middleGrey: o = .6,
                        minLuminance: a = .01,
                        averageLuminance: l = 1,
                        adaptationRate: c = 1
                    } = {}) {
                        super("ToneMappingEffect", "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}", {
                            blendFunction: e,
                            uniforms: new Map([
                                ["luminanceBuffer", new Ll(null)],
                                ["maxLuminance", new Ll(r)],
                                ["whitePoint", new Ll(s)],
                                ["middleGrey", new Ll(o)],
                                ["averageLuminance", new Ll(l)]
                            ])
                        }), this.renderTargetLuminance = new dt(1, 1, {
                            minFilter: m,
                            depthBuffer: !1
                        }), this.renderTargetLuminance.texture.generateMipmaps = !0, this.renderTargetLuminance.texture.name = "Luminance", this.luminancePass = new WA({
                            renderTarget: this.renderTargetLuminance
                        }), this.adaptiveLuminancePass = new ev(this.luminancePass.texture, {
                            minLuminance: a,
                            adaptationRate: c
                        }), this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture, this.resolution = i, this.mode = n
                    }
                    get mode() {
                        return Number(this.defines.get("TONE_MAPPING_MODE"))
                    }
                    set mode(t) {
                        if (this.mode === t) return;
                        const n = e.replace(/\D+/g, "") >= 168 ? "CineonToneMapping(texel)" : "OptimizedCineonToneMapping(texel)";
                        switch (this.defines.clear(), this.defines.set("TONE_MAPPING_MODE", t.toFixed(0)), t) {
                            case 0:
                                this.defines.set("toneMapping(texel)", "LinearToneMapping(texel)");
                                break;
                            case 1:
                                this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
                                break;
                            case 5:
                            case 5:
                                this.defines.set("toneMapping(texel)", n);
                                break;
                            case 6:
                                this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
                                break;
                            case 7:
                                this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)");
                                break;
                            case 8:
                                this.defines.set("toneMapping(texel)", "NeutralToneMapping(texel)");
                                break;
                            default:
                                this.defines.set("toneMapping(texel)", "texel")
                        }
                        this.adaptiveLuminancePass.enabled = 3 === t, this.setChanged()
                    }
                    getMode() {
                        return this.mode
                    }
                    setMode(e) {
                        this.mode = e
                    }
                    get whitePoint() {
                        return this.uniforms.get("whitePoint").value
                    }
                    set whitePoint(e) {
                        this.uniforms.get("whitePoint").value = e
                    }
                    get middleGrey() {
                        return this.uniforms.get("middleGrey").value
                    }
                    set middleGrey(e) {
                        this.uniforms.get("middleGrey").value = e
                    }
                    get averageLuminance() {
                        return this.uniforms.get("averageLuminance").value
                    }
                    set averageLuminance(e) {
                        this.uniforms.get("averageLuminance").value = e
                    }
                    get adaptiveLuminanceMaterial() {
                        return this.adaptiveLuminancePass.fullscreenMaterial
                    }
                    getAdaptiveLuminanceMaterial() {
                        return this.adaptiveLuminanceMaterial
                    }
                    get resolution() {
                        return this.luminancePass.resolution.width
                    }
                    set resolution(e) {
                        const t = Math.max(0, Math.ceil(Math.log2(e))),
                            n = Math.pow(2, t);
                        this.luminancePass.resolution.setPreferredSize(n, n), this.adaptiveLuminanceMaterial.mipLevel1x1 = t
                    }
                    getResolution() {
                        return this.resolution
                    }
                    setResolution(e) {
                        this.resolution = e
                    }
                    get adaptive() {
                        return 3 === this.mode
                    }
                    set adaptive(e) {
                        this.mode = e ? 3 : 2
                    }
                    get adaptationRate() {
                        return this.adaptiveLuminanceMaterial.adaptationRate
                    }
                    set adaptationRate(e) {
                        this.adaptiveLuminanceMaterial.adaptationRate = e
                    }
                    get distinction() {
                        return 1
                    }
                    set distinction(e) {}
                    update(e, t, n) {
                        this.adaptiveLuminancePass.enabled && (this.luminancePass.render(e, t), this.adaptiveLuminancePass.render(e, null, null, n))
                    }
                    initialize(e, t, n) {
                        this.adaptiveLuminancePass.initialize(e, t, n)
                    }
                },
                nv = class extends wi {
                    constructor(t, n, i, r, s = !1) {
                        super({
                            name: "EffectMaterial",
                            defines: {
                                THREE_REVISION: e.replace(/\D+/g, ""),
                                DEPTH_PACKING: "0",
                                ENCODE_OUTPUT: "1"
                            },
                            uniforms: {
                                inputBuffer: new Ll(null),
                                depthBuffer: new Ll(null),
                                resolution: new Ll(new ze),
                                texelSize: new Ll(new ze),
                                cameraNear: new Ll(.3),
                                cameraFar: new Ll(1e3),
                                aspect: new Ll(1),
                                time: new Ll(0)
                            },
                            blending: 0,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            dithering: s
                        }), t && this.setShaderParts(t), n && this.setDefines(n), i && this.setUniforms(i), this.copyCameraSettings(r)
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get depthBuffer() {
                        return this.uniforms.depthBuffer.value
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    get depthPacking() {
                        return Number(this.defines.DEPTH_PACKING)
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t = 3200) {
                        this.depthBuffer = e, this.depthPacking = t
                    }
                    setShaderData(e) {
                        this.setShaderParts(e.shaderParts), this.setDefines(e.defines), this.setUniforms(e.uniforms), this.setExtensions(e.extensions)
                    }
                    setShaderParts(e) {
                        return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}".replace(PA.FRAGMENT_HEAD, e.get(PA.FRAGMENT_HEAD) || "").replace(PA.FRAGMENT_MAIN_UV, e.get(PA.FRAGMENT_MAIN_UV) || "").replace(PA.FRAGMENT_MAIN_IMAGE, e.get(PA.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}".replace(PA.VERTEX_HEAD, e.get(PA.VERTEX_HEAD) || "").replace(PA.VERTEX_MAIN_SUPPORT, e.get(PA.VERTEX_MAIN_SUPPORT) || ""), this.needsUpdate = !0, this
                    }
                    setDefines(e) {
                        for (const t of e.entries()) this.defines[t[0]] = t[1];
                        return this.needsUpdate = !0, this
                    }
                    setUniforms(e) {
                        for (const t of e.entries()) this.uniforms[t[0]] = t[1];
                        return this
                    }
                    setExtensions(e) {
                        this.extensions = {};
                        for (const t of e) this.extensions[t] = !0;
                        return this
                    }
                    get encodeOutput() {
                        return void 0 !== this.defines.ENCODE_OUTPUT
                    }
                    set encodeOutput(e) {
                        this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
                    }
                    isOutputEncodingEnabled(e) {
                        return this.encodeOutput
                    }
                    setOutputEncodingEnabled(e) {
                        this.encodeOutput = e
                    }
                    get time() {
                        return this.uniforms.time.value
                    }
                    set time(e) {
                        this.uniforms.time.value = e
                    }
                    setDeltaTime(e) {
                        this.uniforms.time.value += e
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof Ii ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                    }
                    setSize(e, t) {
                        const n = this.uniforms;
                        n.resolution.value.set(e, t), n.texelSize.value.set(1 / e, 1 / t), n.aspect.value = e / t
                    }
                    static get Section() {
                        return PA
                    }
                };

            function iv(e, t, n) {
                for (const i of t) {
                    const t = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1),
                        r = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
                    for (const e of n.entries()) null !== e[1] && n.set(e[0], e[1].replace(r, t))
                }
            }

            function rv(e, t, n) {
                let i = t.getFragmentShader(),
                    r = t.getVertexShader();
                const s = void 0 !== i && /mainImage/.test(i),
                    o = void 0 !== i && /mainUv/.test(i);
                if (n.attributes |= t.getAttributes(), void 0 === i) throw new Error(`Missing fragment shader (${t.name})`);
                if (o && 2 & n.attributes) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);
                if (!s && !o) throw new Error(`Could not find mainImage or mainUv function (${t.name})`);
                {
                    const a = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
                        l = n.shaderParts;
                    let c = l.get(PA.FRAGMENT_HEAD) || "",
                        u = l.get(PA.FRAGMENT_MAIN_UV) || "",
                        h = l.get(PA.FRAGMENT_MAIN_IMAGE) || "",
                        d = l.get(PA.VERTEX_HEAD) || "",
                        f = l.get(PA.VERTEX_MAIN_SUPPORT) || "";
                    const p = new Set,
                        m = new Set;
                    if (o && (u += `\t${e}MainUv(UV);\n`, n.uvTransformation = !0), null !== r && /mainSupport/.test(r)) {
                        const t = /mainSupport *\([\w\s]*?uv\s*?\)/.test(r);
                        f += `\t${e}MainSupport(`, f += t ? "vUv);\n" : ");\n";
                        for (const e of r.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                            for (const t of e[1].split(/\s*,\s*/)) n.varyings.add(t), p.add(t), m.add(t);
                        for (const e of r.matchAll(a)) m.add(e[1])
                    }
                    for (const e of i.matchAll(a)) m.add(e[1]);
                    for (const e of t.defines.keys()) m.add(e.replace(/\([\w\s,]*\)/g, ""));
                    for (const e of t.uniforms.keys()) m.add(e);
                    m.delete("while"), m.delete("for"), m.delete("if"), t.uniforms.forEach(((t, i) => n.uniforms.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))), t.defines.forEach(((t, i) => n.defines.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)));
                    const g = new Map([
                        ["fragment", i],
                        ["vertex", r]
                    ]);
                    iv(e, m, n.defines), iv(e, m, g), i = g.get("fragment"), r = g.get("vertex");
                    const A = t.blendMode;
                    if (n.blendModes.set(A.blendFunction, A), s) {
                        null !== t.inputColorSpace && t.inputColorSpace !== n.colorSpace && (h += t.inputColorSpace === _e ? "color0 = sRGBTransferOETF(color0);\n\t" : "color0 = sRGBToLinear(color0);\n\t"), t.outputColorSpace !== ye ? n.colorSpace = t.outputColorSpace : null !== t.inputColorSpace && (n.colorSpace = t.inputColorSpace);
                        const r = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
                        h += `${e}MainImage(color0, UV, `, 1 & n.attributes && r.test(i) && (h += "depth, ", n.readDepth = !0), h += "color1);\n\t";
                        const s = e + "BlendOpacity";
                        n.uniforms.set(s, A.opacity), h += `color0 = blend${A.blendFunction}(color0, color1, ${s});\n\n\t`, c += `uniform float ${s};\n\n`
                    }
                    if (c += i + "\n", null !== r && (d += r + "\n"), l.set(PA.FRAGMENT_HEAD, c), l.set(PA.FRAGMENT_MAIN_UV, u), l.set(PA.FRAGMENT_MAIN_IMAGE, h), l.set(PA.VERTEX_HEAD, d), l.set(PA.VERTEX_MAIN_SUPPORT, f), null !== t.extensions)
                        for (const e of t.extensions) n.extensions.add(e)
                }
            }
            var sv = class extends CA {
                    constructor(e, ...t) {
                        super("EffectPass"), this.fullscreenMaterial = new nv(null, null, null, e), this.listener = e => this.handleEvent(e), this.effects = [], this.setEffects(t), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1
                    }
                    set mainScene(e) {
                        for (const t of this.effects) t.mainScene = e
                    }
                    set mainCamera(e) {
                        this.fullscreenMaterial.copyCameraSettings(e);
                        for (const t of this.effects) t.mainCamera = e
                    }
                    get encodeOutput() {
                        return this.fullscreenMaterial.encodeOutput
                    }
                    set encodeOutput(e) {
                        this.fullscreenMaterial.encodeOutput = e
                    }
                    get dithering() {
                        return this.fullscreenMaterial.dithering
                    }
                    set dithering(e) {
                        const t = this.fullscreenMaterial;
                        t.dithering = e, t.needsUpdate = !0
                    }
                    setEffects(e) {
                        for (const e of this.effects) e.removeEventListener("change", this.listener);
                        this.effects = e.sort(((e, t) => t.attributes - e.attributes));
                        for (const e of this.effects) e.addEventListener("change", this.listener)
                    }
                    updateMaterial() {
                        const e = new class {
                            constructor() {
                                this.shaderParts = new Map([
                                    [PA.FRAGMENT_HEAD, null],
                                    [PA.FRAGMENT_MAIN_UV, null],
                                    [PA.FRAGMENT_MAIN_IMAGE, null],
                                    [PA.VERTEX_HEAD, null],
                                    [PA.VERTEX_MAIN_SUPPORT, null]
                                ]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = 0, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = xe
                            }
                        };
                        let t = 0;
                        for (const n of this.effects)
                            if (9 === n.blendMode.blendFunction) e.attributes |= 1 & n.getAttributes();
                            else {
                                if (e.attributes & n.getAttributes() & 2) throw new Error(`Convolution effects cannot be merged (${n.name})`);
                                rv("e" + t++, n, e)
                            } let n = e.shaderParts.get(PA.FRAGMENT_HEAD),
                            i = e.shaderParts.get(PA.FRAGMENT_MAIN_IMAGE),
                            r = e.shaderParts.get(PA.FRAGMENT_MAIN_UV);
                        const s = /\bblend\b/g;
                        for (const t of e.blendModes.values()) n += t.getShaderCode().replace(s, `blend${t.blendFunction}`) + "\n";
                        1 & e.attributes ? (e.readDepth && (i = "float depth = readDepth(UV);\n\n\t" + i), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1, e.colorSpace === _e && (i += "color0 = sRGBToLinear(color0);\n\t"), e.uvTransformation ? (r = "vec2 transformedUv = vUv;\n" + r, e.defines.set("UV", "transformedUv")) : e.defines.set("UV", "vUv"), e.shaderParts.set(PA.FRAGMENT_HEAD, n), e.shaderParts.set(PA.FRAGMENT_MAIN_IMAGE, i), e.shaderParts.set(PA.FRAGMENT_MAIN_UV, r);
                        for (const [t, n] of e.shaderParts) null !== n && e.shaderParts.set(t, n.trim().replace(/^#/, "\n#"));
                        this.skipRendering = 0 === t, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(e)
                    }
                    recompile() {
                        this.updateMaterial()
                    }
                    getDepthTexture() {
                        return this.fullscreenMaterial.depthBuffer
                    }
                    setDepthTexture(e, t = 3200) {
                        this.fullscreenMaterial.depthBuffer = e, this.fullscreenMaterial.depthPacking = t;
                        for (const n of this.effects) n.setDepthTexture(e, t)
                    }
                    render(e, t, n, i, r) {
                        for (const n of this.effects) n.update(e, t, i);
                        if (!this.skipRendering || this.renderToScreen) {
                            const r = this.fullscreenMaterial;
                            r.inputBuffer = t.texture, r.time += i * this.timeScale, e.setRenderTarget(this.renderToScreen ? null : n), e.render(this.scene, this.camera)
                        }
                    }
                    setSize(e, t) {
                        this.fullscreenMaterial.setSize(e, t);
                        for (const n of this.effects) n.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.renderer = e;
                        for (const i of this.effects) i.initialize(e, t, n);
                        this.updateMaterial(), void 0 !== n && n !== A && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                    dispose() {
                        super.dispose();
                        for (const e of this.effects) e.removeEventListener("change", this.listener), e.dispose()
                    }
                    handleEvent(e) {
                        "change" === e.type && this.recompile()
                    }
                },
                ov = class extends CA {
                    constructor(e, t, {
                        renderTarget: n,
                        resolutionScale: i = 1,
                        width: r = OA.AUTO_SIZE,
                        height: s = OA.AUTO_SIZE,
                        resolutionX: o = r,
                        resolutionY: a = s
                    } = {}) {
                        super("NormalPass"), this.needsSwap = !1, this.renderPass = new qA(e, t, new Pa);
                        const l = this.renderPass;
                        l.ignoreBackground = !0, l.skipShadowMapUpdate = !0;
                        const c = l.getClearPass();
                        c.overrideClearColor = new kn(7829503), c.overrideClearAlpha = 1, this.renderTarget = n, void 0 === this.renderTarget && (this.renderTarget = new dt(1, 1, {
                            minFilter: h,
                            magFilter: h
                        }), this.renderTarget.texture.name = "NormalPass.Target");
                        const u = this.resolution = new OA(this, o, a, i);
                        u.addEventListener("change", (e => this.setSize(u.baseWidth, u.baseHeight)))
                    }
                    set mainScene(e) {
                        this.renderPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.renderPass.mainCamera = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, r) {
                        const s = this.renderToScreen ? null : this.renderTarget;
                        this.renderPass.render(e, s, s)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height)
                    }
                };
            const av = e => {
                    const t = [e],
                        n = [];
                    for (; 0 !== t.length;) {
                        const e = t.shift();
                        e.material && n.push(e);
                        for (const n of e.children) n.visible && t.push(n)
                    }
                    return n
                },
                lv = (e, t, n, i, r) => {
                    t[n] !== e[n] && (e[n] = t[n], e.uniforms[n].value = t[n], t[n] ? (e.defines[i] = "", "USE_NORMALMAP" === i && (e.defines.TANGENTSPACE_NORMALMAP = "")) : delete e.defines[i], e.needsUpdate = !0)
                },
                cv = e => {
                    let t = e.material.uniforms.prevBoneTexture.value;
                    if (t && t.image.width === e.skeleton.boneTexture.width) t = e.material.uniforms.prevBoneTexture.value, t.image.data.set(e.skeleton.boneTexture.image.data);
                    else {
                        var n;
                        null == (n = t) || n.dispose();
                        const i = e.skeleton.boneTexture.image.data.slice(),
                            r = e.skeleton.boneTexture.image.width;
                        t = new Wo(i, r, r, I, b), e.material.uniforms.prevBoneTexture.value = t, t.needsUpdate = !0
                    }
                },
                uv = (e, t) => {
                    var n;
                    null != (n = e.skeleton) && n.boneTexture && (e.material.uniforms.boneTexture.value = e.skeleton.boneTexture, "USE_SKINNING" in e.material.defines || (e.material.defines.USE_SKINNING = "", e.material.defines.BONE_TEXTURE = "", e.material.needsUpdate = !0)), e.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld), e.material.uniforms.velocityMatrix.value.multiplyMatrices(t.projectionMatrix, e.modelViewMatrix)
                },
                hv = (e, t) => {
                    var n;
                    e.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(t.projectionMatrix, e.modelViewMatrix), null != (n = e.skeleton) && n.boneTexture && cv(e)
                },
                dv = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function fv(e) {
                return e.replace(dv, pv)
            }

            function pv(e, t, n, i) {
                let r = "";
                for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return r
            }
            const mv = e => {
                    var t;
                    return null == (t = e.material.fragmentShader) ? void 0 : t.includes("float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );")
                },
                gv = (e, t = e.material) => t.visible && t.depthWrite && t.depthTest && (!t.transparent || t.opacity > 0) && !mv(e),
                Av = ["vertexTangent", "vertexColors", "vertexAlphas", "vertexUvs", "uvsVertexOnly", "supportsVertexTextures", "instancing", "instancingColor", "side", "flatShading", "skinning", "doubleSided", "flipSided"],
                vv = (e, t) => {
                    for (const n of Av) t[n] = e[n]
                };
            var yv = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
            class _v extends CA {
                constructor(e = 1) {
                    super("CopyPass"), this.needsSwap = !1, this.renderTarget = new Ql(1, 1, 1, {
                        depthBuffer: !1
                    }), this.setTextureCount(e)
                }
                setTextureCount(e) {
                    var t;
                    let n = "",
                        i = "";
                    for (let t = 0; t < e; t++) n += `\n\t\t\t\tuniform sampler2D inputTexture${t};\n\t\t\t\tlayout(location = ${t}) out vec4 gOutput${t};\n\t\t\t`, i += `gOutput${t} = textureLod(inputTexture${t}, vUv, 0.);`;
                    null == (t = this.fullscreenMaterial) || t.dispose(), this.fullscreenMaterial = new wi({
                        fragmentShader: `\n            varying vec2 vUv;\n\t\t\t\n\t\t\t${n}\n\n            void main() {\n\t\t\t\t${i}\n            }\n            `,
                        vertexShader: yv,
                        glslVersion: Se,
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        toneMapped: !1
                    });
                    for (let t = 0; t < e; t++)
                        if (this.fullscreenMaterial.uniforms["inputTexture" + t] = new Ll(null), t >= this.renderTarget.texture.length) {
                            const e = this.renderTarget.texture[0].clone();
                            e.isRenderTargetTexture = !0, this.renderTarget.texture.push(e)
                        }
                }
                setSize(e, t) {
                    this.renderTarget.setSize(e, t)
                }
                render(e) {
                    e.setRenderTarget(this.renderTarget), e.render(this.scene, this.camera)
                }
            }
            class xv extends wi {
                constructor(e = 1, t = "") {
                    let n = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D velocityTexture;uniform sampler2D depthTexture;uniform sampler2D lastDepthTexture;uniform float blend;uniform float neighborhoodClampIntensity;uniform bool constantBlend;uniform bool fullAccumulate;uniform vec2 invTexSize;uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;uniform vec3 cameraPos;uniform mat4 prevViewMatrix;uniform mat4 prevCameraMatrixWorld;uniform mat4 prevProjectionMatrix;uniform mat4 prevProjectionMatrixInverse;uniform bool reset;uniform float delta;\n#define EPSILON 0.00001\n#include <packing>\n#include <reproject>\nvoid main(){getDepthAndDilatedUVOffset(depthTexture,vUv,depth,dilatedDepth,depthTexel);if(dot(depthTexel.rgb,depthTexel.rgb)==0.0){\n#ifdef neighborhoodClamp\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){gOutput[i]=textureLod(inputTexture[i],vUv,0.0);}\n#pragma unroll_loop_end\n#else\ndiscard;\n#endif\nreturn;}vec2 dilatedUv=vUv+dilatedUvOffset;edgeStrength=computeEdgeStrength(depth,invTexSize);vec4 inputTexel[textureCount];vec4 accumulatedTexel[textureCount];bool textureSampledThisFrame[textureCount];\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){inputTexel[i]=textureLod(inputTexture[i],vUv,0.0);doColorTransform[i]=luminance(inputTexel[i].rgb)>0.0;textureSampledThisFrame[i]=inputTexel[i].r>=0.;if(textureSampledThisFrame[i]){transformColor(inputTexel[i].rgb);}else{inputTexel[i].rgb=vec3(0.0);}texIndex++;}\n#pragma unroll_loop_end\ntexIndex=0;velocityTexel=textureLod(velocityTexture,vUv,0.0);didMove=dot(velocityTexel.xy,velocityTexel.xy)>0.000000001;\n#ifdef dilation\nvec2 octahedronEncodedNormal=textureLod(velocityTexture,dilatedUv,0.0).ba;\n#else\nvec2 octahedronEncodedNormal=velocityTexel.ba;\n#endif\nvec3 worldNormal=Decode(octahedronEncodedNormal);vec3 worldPos=screenSpaceToWorldSpace(vUv,depth,cameraMatrixWorld,projectionMatrixInverse);vec2 reprojectedUvDiffuse=vec2(-10.0);vec2 reprojectedUvSpecular[textureCount];vec2 reprojectedUv;bool reprojectHitPoint;\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){reprojectHitPoint=reprojectSpecular[i]&&inputTexel[i].a>0.0;if(reprojectHitPoint){reprojectedUvSpecular[i]=getReprojectedUV(depth,worldPos,worldNormal,inputTexel[i].a);}else{reprojectedUvSpecular[i]=vec2(-1.0);}if(reprojectedUvDiffuse.x==-10.0&&reprojectedUvSpecular[i].x<0.0){reprojectedUvDiffuse=getReprojectedUV(depth,worldPos,worldNormal,0.0);}reprojectedUv=reprojectedUvSpecular[i].x>=0.0 ? reprojectedUvSpecular[i]: reprojectedUvDiffuse;if(reprojectedUv.x<0.0){accumulatedTexel[i]=vec4(inputTexel[i].rgb,0.0);}else{accumulatedTexel[i]=sampleReprojectedTexture(accumulatedTexture[i],reprojectedUv);transformColor(accumulatedTexel[i].rgb);if(textureSampledThisFrame[i]){accumulatedTexel[i].a++;if(neighborhoodClamp[i]){vec3 clampedColor=accumulatedTexel[i].rgb;clampNeighborhood(inputTexture[i],clampedColor,inputTexel[i].rgb);accumulatedTexel[i].rgb=mix(accumulatedTexel[i].rgb,clampedColor,neighborhoodClampIntensity);}}else{inputTexel[i].rgb=accumulatedTexel[i].rgb;}}texIndex++;}\n#pragma unroll_loop_end\ntexIndex=0;float m=1.-delta/(1./60.);float fpsAdjustedBlend=blend+max(0.,(1.-blend)*m);float maxValue=(fullAccumulate&&!didMove)? 1.0 : fpsAdjustedBlend;vec3 outputColor;float temporalReprojectMix;\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){if(constantBlend){temporalReprojectMix=accumulatedTexel[i].a==0.0 ? 0.0 : fpsAdjustedBlend;}else{temporalReprojectMix=fpsAdjustedBlend;if(reset)accumulatedTexel[i].a=0.0;temporalReprojectMix=min(1.-1./(accumulatedTexel[i].a+1.0),maxValue);}outputColor=mix(inputTexel[i].rgb,accumulatedTexel[i].rgb,temporalReprojectMix);undoColorTransform(outputColor);gOutput[i]=vec4(outputColor,accumulatedTexel[i].a);texIndex++;}\n#pragma unroll_loop_end\n#ifdef useTemporalReprojectCustomComposeShader\ntemporalReprojectCustomComposeShader\n#endif\n}".replace("#include <reproject>", "#define GLSLIFY 1\nvec4 velocityTexel;float dilatedDepth;vec2 dilatedUvOffset;int texIndex;bool didMove;vec4 depthTexel;float depth;float edgeStrength;\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nvec3 screenSpaceToWorldSpace(const vec2 uv,const float depth,mat4 curMatrixWorld,const mat4 projMatrixInverse){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=projMatrixInverse*ndc;vec4 view=curMatrixWorld*(clip/clip.w);return view.xyz;}vec2 viewSpaceToScreenSpace(const vec3 position,const mat4 projMatrix){vec4 projectedCoord=projMatrix*vec4(position,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;return projectedCoord.xy;}bool doColorTransform[textureCount];\n#ifdef logTransform\nvoid transformColor(inout vec3 color){if(!doColorTransform[texIndex])return;float lum=luminance(color);float diff=min(1.0,lum-0.99);if(diff>0.0){color=vec3(diff*0.1);return;}color=log(max(color,vec3(EPSILON)));}void undoColorTransform(inout vec3 color){if(!doColorTransform[texIndex])return;color=exp(color);}\n#else\n#define transformColor\n#define undoColorTransform\n#endif\nvoid getNeighborhoodAABB(const sampler2D tex,inout vec3 minNeighborColor,inout vec3 maxNeighborColor){for(int x=-neighborhoodClampRadius;x<=neighborhoodClampRadius;x++){for(int y=-neighborhoodClampRadius;y<=neighborhoodClampRadius;y++){if(x!=0||y!=0){vec2 offset=vec2(x,y)*invTexSize;vec2 neighborUv=vUv+offset;vec4 neighborTexel=textureLod(tex,neighborUv,0.0);transformColor(neighborTexel.rgb);minNeighborColor=min(neighborTexel.rgb,minNeighborColor);maxNeighborColor=max(neighborTexel.rgb,maxNeighborColor);}}}}void clampNeighborhood(const sampler2D tex,inout vec3 color,const vec3 inputColor){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;getNeighborhoodAABB(tex,minNeighborColor,maxNeighborColor);color=clamp(color,minNeighborColor,maxNeighborColor);}\n#ifdef dilation\nvoid getDilatedDepthUVOffset(const sampler2D tex,const vec2 centerUv,out float depth,out float dilatedDepth,out vec4 closestDepthTexel){float closestDepth=0.0;for(int x=-1;x<=1;x++){for(int y=-1;y<=1;y++){vec2 offset=vec2(x,y)*invTexSize;vec2 neighborUv=centerUv+offset;vec4 neighborDepthTexel=textureLod(tex,neighborUv,0.0);float neighborDepth=unpackRGBAToDepth(neighborDepthTexel);if(x==0&&y==0)depth=neighborDepth;if(neighborDepth>closestDepth){closestDepth=neighborDepth;closestDepthTexel=neighborDepthTexel;dilatedUvOffset=offset;}}}dilatedDepth=closestDepth;}\n#endif\nvoid getDepthAndDilatedUVOffset(sampler2D depthTex,vec2 uv,out float depth,out float dilatedDepth,out vec4 depthTexel){\n#ifdef dilation\ngetDilatedDepthUVOffset(depthTex,uv,depth,dilatedDepth,depthTexel);\n#else\ndepthTexel=textureLod(depthTex,uv,0.);depth=unpackRGBAToDepth(depthTexel);dilatedDepth=depth;\n#endif\n}bool planeDistanceDisocclusionCheck(const vec3 worldPos,const vec3 lastWorldPos,const vec3 worldNormal,const float worldDistFactor){if(abs(dot(worldNormal,worldPos))==0.0)return false;vec3 toCurrent=worldPos-lastWorldPos;float distToPlane=abs(dot(toCurrent,worldNormal));return distToPlane>depthDistance*worldDistFactor;}bool worldDistanceDisocclusionCheck(const vec3 worldPos,const vec3 lastWorldPos,const float worldDistFactor){return distance(worldPos,lastWorldPos)>worldDistance*worldDistFactor;}bool validateReprojectedUV(const vec2 reprojectedUv,const vec3 worldPos,const vec3 worldNormal){if(reprojectedUv.x>1.0||reprojectedUv.x<0.0||reprojectedUv.y>1.0||reprojectedUv.y<0.0)return false;vec3 dilatedWorldPos=worldPos;vec3 lastWorldPos;float dilatedLastDepth,lastDepth;vec4 lastDepthTexel;vec2 dilatedReprojectedUv;\n#ifdef dilation\ndilatedWorldPos=screenSpaceToWorldSpace(vUv+dilatedUvOffset,dilatedDepth,cameraMatrixWorld,projectionMatrixInverse);getDepthAndDilatedUVOffset(lastDepthTexture,reprojectedUv,lastDepth,dilatedLastDepth,lastDepthTexel);dilatedReprojectedUv=reprojectedUv+dilatedUvOffset;\n#else\nlastDepthTexel=textureLod(lastDepthTexture,reprojectedUv,0.);lastDepth=unpackRGBAToDepth(lastDepthTexel);dilatedLastDepth=lastDepth;dilatedReprojectedUv=reprojectedUv;\n#endif\nlastWorldPos=screenSpaceToWorldSpace(dilatedReprojectedUv,dilatedLastDepth,prevCameraMatrixWorld,prevProjectionMatrixInverse);float worldDistFactor=clamp((50.0+distance(dilatedWorldPos,cameraPos))/100.,0.25,1.);if(worldDistanceDisocclusionCheck(dilatedWorldPos,lastWorldPos,worldDistFactor))return false;return!planeDistanceDisocclusionCheck(dilatedWorldPos,lastWorldPos,worldNormal,worldDistFactor);}vec2 reprojectHitPoint(const vec3 rayOrig,const float rayLength,const float depth){vec3 cameraRay=normalize(rayOrig-cameraPos);float cameraRayLength=distance(rayOrig,cameraPos);vec3 parallaxHitPoint=cameraPos+cameraRay*(cameraRayLength+rayLength);vec4 reprojectedParallaxHitPoint=prevViewMatrix*vec4(parallaxHitPoint,1.0);vec2 hitPointUv=viewSpaceToScreenSpace(reprojectedParallaxHitPoint.xyz,prevProjectionMatrix);return hitPointUv;}vec2 getReprojectedUV(const float depth,const vec3 worldPos,const vec3 worldNormal,const float rayLength){if(rayLength!=0.0){vec2 reprojectedUv=reprojectHitPoint(worldPos,rayLength,depth);if(validateReprojectedUV(reprojectedUv,worldPos,worldNormal)){return reprojectedUv;}return vec2(-1.);}vec2 reprojectedUv=vUv-velocityTexel.rg;if(validateReprojectedUV(reprojectedUv,worldPos,worldNormal)){return reprojectedUv;}return vec2(-1.);}vec4 SampleTextureCatmullRom(const sampler2D tex,const vec2 uv,const vec2 texSize){vec2 samplePos=uv*texSize;vec2 texPos1=floor(samplePos-0.5f)+0.5f;vec2 f=samplePos-texPos1;vec2 w0=f*(-0.5f+f*(1.0f-0.5f*f));vec2 w1=1.0f+f*f*(-2.5f+1.5f*f);vec2 w2=f*(0.5f+f*(2.0f-1.5f*f));vec2 w3=f*f*(-0.5f+0.5f*f);vec2 w12=w1+w2;vec2 offset12=w2/(w1+w2);vec2 texPos0=texPos1-1.;vec2 texPos3=texPos1+2.;vec2 texPos12=texPos1+offset12;texPos0/=texSize;texPos3/=texSize;texPos12/=texSize;vec4 result=vec4(0.0);result+=textureLod(tex,vec2(texPos0.x,texPos0.y),0.0f)*w0.x*w0.y;result+=textureLod(tex,vec2(texPos12.x,texPos0.y),0.0f)*w12.x*w0.y;result+=textureLod(tex,vec2(texPos3.x,texPos0.y),0.0f)*w3.x*w0.y;result+=textureLod(tex,vec2(texPos0.x,texPos12.y),0.0f)*w0.x*w12.y;result+=textureLod(tex,vec2(texPos12.x,texPos12.y),0.0f)*w12.x*w12.y;result+=textureLod(tex,vec2(texPos3.x,texPos12.y),0.0f)*w3.x*w12.y;result+=textureLod(tex,vec2(texPos0.x,texPos3.y),0.0f)*w0.x*w3.y;result+=textureLod(tex,vec2(texPos12.x,texPos3.y),0.0f)*w12.x*w3.y;result+=textureLod(tex,vec2(texPos3.x,texPos3.y),0.0f)*w3.x*w3.y;result=max(result,vec4(0.));return result;}vec2 sampleBlocky(vec2 p){vec2 d=vec2(dFdx(p.x),dFdy(p.y))/invTexSize;p/=invTexSize;vec2 fA=p-0.5*d,iA=floor(fA);vec2 fB=p+0.5*d,iB=floor(fB);return(iA+(iB-iA)*(fB-iB)/d+0.5)*invTexSize;}float computeEdgeStrength(float unpackedDepth,vec2 texelSize){float depthX=unpackRGBAToDepth(textureLod(depthTexture,vUv+vec2(texelSize.x,0.0),0.0))-unpackRGBAToDepth(textureLod(depthTexture,vUv-vec2(texelSize.x,0.0),0.0));float depthY=unpackRGBAToDepth(textureLod(depthTexture,vUv+vec2(0.0,texelSize.y),0.0))-unpackRGBAToDepth(textureLod(depthTexture,vUv-vec2(0.0,texelSize.y),0.0));float gradientMagnitude=sqrt(depthX*depthX+depthY*depthY);float edgeStrength=min(100000.*gradientMagnitude/(unpackedDepth+0.001),1.);return edgeStrength*edgeStrength;}float computeEdgeStrengthFast(float unpackedDepth){float depthX=dFdx(unpackedDepth);float depthY=dFdy(unpackedDepth);float edgeStrength=depthX*depthX+depthY*depthY;return min(1.,pow(pow(edgeStrength,0.25)*500.,4.));}vec4 sampleReprojectedTexture(const sampler2D tex,const vec2 reprojectedUv){vec4 catmull=SampleTextureCatmullRom(tex,reprojectedUv,1.0/invTexSize);vec4 blocky=SampleTextureCatmullRom(tex,sampleBlocky(reprojectedUv),1.0/invTexSize);vec4 reprojectedTexel=mix(catmull,blocky,edgeStrength);reprojectedTexel.a=min(catmull.a,blocky.a);return reprojectedTexel;}vec2 OctWrap(vec2 v){vec2 w=1.0-abs(v.yx);if(v.x<0.0)w.x=-w.x;if(v.y<0.0)w.y=-w.y;return w;}vec2 Encode(vec3 n){n/=(abs(n.x)+abs(n.y)+abs(n.z));n.xy=n.z>0.0 ? n.xy : OctWrap(n.xy);n.xy=n.xy*0.5+0.5;return n.xy;}vec3 Decode(vec2 f){f=f*2.0-1.0;vec3 n=vec3(f.x,f.y,1.0-abs(f.x)-abs(f.y));float t=max(-n.z,0.0);n.x+=n.x>=0.0 ?-t : t;n.y+=n.y>=0.0 ?-t : t;return normalize(n);}");
                    "string" == typeof t && (n = n.replace("temporalReprojectCustomComposeShader", t));
                    let i = "";
                    for (let t = 0; t < e; t++) i += `\n\t\t\t\tuniform sampler2D inputTexture${t};\n\t\t\t\tuniform sampler2D accumulatedTexture${t};\n\n\t\t\t\tlayout(location = ${t}) out vec4 gOutput${t};\n\t\t\t`;
                    n = i + n.replaceAll("textureCount", e), n = fv(n);
                    const r = n.matchAll(/inputTexture\[\s*[0-9]+\s*]/g);
                    for (const [e] of r) {
                        const t = e.replace(/[^0-9]/g, "");
                        n = n.replace(e, "inputTexture" + t)
                    }
                    const s = n.matchAll(/accumulatedTexture\[\s*[0-9]+\s*]/g);
                    for (const [e] of s) {
                        const t = e.replace(/[^0-9]/g, "");
                        n = n.replace(e, "accumulatedTexture" + t)
                    }
                    const o = n.matchAll(/gOutput\[\s*[0-9]+\s*]/g);
                    for (const [e] of o) {
                        const t = e.replace(/[^0-9]/g, "");
                        n = n.replace(e, "gOutput" + t)
                    }
                    super({
                        type: "TemporalReprojectMaterial",
                        uniforms: {
                            velocityTexture: new Ll(null),
                            depthTexture: new Ll(null),
                            lastDepthTexture: new Ll(null),
                            blend: new Ll(0),
                            neighborhoodClampIntensity: new Ll(0),
                            constantBlend: new Ll(!1),
                            fullAccumulate: new Ll(!1),
                            reset: new Ll(!1),
                            delta: new Ll(0),
                            invTexSize: new Ll(new ze),
                            projectionMatrix: new Ll(new Wt),
                            projectionMatrixInverse: new Ll(new Wt),
                            cameraMatrixWorld: new Ll(new Wt),
                            viewMatrix: new Ll(new Wt),
                            prevViewMatrix: new Ll(new Wt),
                            prevCameraMatrixWorld: new Ll(new Wt),
                            prevProjectionMatrix: new Ll(new Wt),
                            prevProjectionMatrixInverse: new Ll(new Wt),
                            cameraPos: new Ll(new gt)
                        },
                        vertexShader: yv,
                        fragmentShader: n,
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        toneMapped: !1,
                        glslVersion: Se
                    });
                    for (let t = 0; t < e; t++) this.uniforms["inputTexture" + t] = new Ll(null), this.uniforms["accumulatedTexture" + t] = new Ll(null);
                    "string" == typeof t && (this.defines.useTemporalReprojectCustomComposeShader = "")
                }
            }
            const Ev = 1.1127756842787055,
                bv = {
                    blend: .9,
                    dilation: !1,
                    constantBlend: !1,
                    fullAccumulate: !1,
                    neighborhoodClamp: !1,
                    neighborhoodClampRadius: 1,
                    neighborhoodClampIntensity: 1,
                    logTransform: !1,
                    depthDistance: .25,
                    worldDistance: .375,
                    reprojectSpecular: !1,
                    temporalReprojectCustomComposeShader: null,
                    renderTarget: null
                },
                wv = new Wt,
                Cv = new Wt;
            class Sv extends CA {
                constructor(e, t, n, i = 1, r = bv) {
                    super("TemporalReprojectPass"), this.needsSwap = !1, this.clock = new Cl, this.r2Sequence = [], this.pointsIndex = 0, this.lastCameraTransform = {
                        position: new gt,
                        quaternion: new mt
                    }, this._scene = e, this._camera = t, this.textureCount = i, r = {
                        ...bv,
                        ...r
                    }, this.renderTarget = new Ql(1, 1, i, {
                        minFilter: f,
                        magFilter: f,
                        type: w,
                        depthBuffer: !1
                    }), this.renderTarget.texture.map(((e, t) => e.name = "TemporalReprojectPass.accumulatedTexture" + t)), this.fullscreenMaterial = new xv(i, r.temporalReprojectCustomComposeShader), this.fullscreenMaterial.defines.textureCount = i, r.dilation && (this.fullscreenMaterial.defines.dilation = ""), r.neighborhoodClamp && (this.fullscreenMaterial.defines.neighborhoodClamp = ""), r.logTransform && (this.fullscreenMaterial.defines.logTransform = ""), this.fullscreenMaterial.defines.neighborhoodClampRadius = parseInt(r.neighborhoodClampRadius), this.fullscreenMaterial.defines.depthDistance = r.depthDistance.toPrecision(5), this.fullscreenMaterial.defines.worldDistance = r.worldDistance.toPrecision(5), this.fullscreenMaterial.uniforms.blend.value = r.blend, this.fullscreenMaterial.uniforms.constantBlend.value = r.constantBlend, this.fullscreenMaterial.uniforms.fullAccumulate.value = r.fullAccumulate, this.fullscreenMaterial.uniforms.neighborhoodClampIntensity.value = r.neighborhoodClampIntensity, this.fullscreenMaterial.uniforms.projectionMatrix.value = t.projectionMatrix.clone(), this.fullscreenMaterial.uniforms.projectionMatrixInverse.value = t.projectionMatrixInverse.clone(), this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = t.matrixWorld, this.fullscreenMaterial.uniforms.viewMatrix.value = t.matrixWorldInverse, this.fullscreenMaterial.uniforms.cameraPos.value = t.position, this.fullscreenMaterial.uniforms.prevViewMatrix.value = t.matrixWorldInverse.clone(), this.fullscreenMaterial.uniforms.prevCameraMatrixWorld.value = t.matrixWorld.clone(), this.fullscreenMaterial.uniforms.prevProjectionMatrix.value = t.projectionMatrix.clone(), this.fullscreenMaterial.uniforms.prevProjectionMatrixInverse.value = t.projectionMatrixInverse.clone(), this.copyPass = new _v(i);
                    for (let e = 0; e < i; e++) {
                        const t = this.copyPass.renderTarget.texture[e];
                        t.type = w, t.minFilter = f, t.magFilter = f, t.needsUpdate = !0
                    }
                    this.fullscreenMaterial.uniforms.velocityTexture.value = n.texture, this.fullscreenMaterial.uniforms.depthTexture.value = n.depthTexture;
                    for (const e of ["reprojectSpecular", "neighborhoodClamp"]) {
                        let t = r[e];
                        "array" != typeof t && (t = Array(i).fill(t)), this.fullscreenMaterial.defines[e] = `bool[](${t.join(", ")})`
                    }
                    this.options = r, this.velocityDepthNormalPass = n
                }
                setTextures(e) {
                    Array.isArray(e) || (e = [e]);
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        this.fullscreenMaterial.uniforms["inputTexture" + t] = new Ll(n)
                    }
                }
                dispose() {
                    super.dispose(), this.renderTarget.dispose(), this.copyPass.dispose(), this.fullscreenMaterial.dispose()
                }
                setSize(e, t) {
                    this.renderTarget.setSize(e, t), this.copyPass.setSize(e, t), this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / e, 1 / t)
                }
                get texture() {
                    return this.renderTarget.texture[0]
                }
                reset() {
                    this.fullscreenMaterial.uniforms.reset.value = !0
                }
                render(e) {
                    const t = Math.min(.1, this.clock.getDelta());
                    this.fullscreenMaterial.uniforms.delta.value = t, wv.copy(this._camera.projectionMatrix), Cv.copy(this._camera.projectionMatrixInverse), this._camera.view && (this._camera.view.enabled = !1), this._camera.updateProjectionMatrix(), this.fullscreenMaterial.uniforms.projectionMatrix.value.copy(this._camera.projectionMatrix), this.fullscreenMaterial.uniforms.projectionMatrixInverse.value.copy(this._camera.projectionMatrixInverse), this.fullscreenMaterial.uniforms.lastDepthTexture.value = this.velocityDepthNormalPass.lastDepthTexture, this._camera.view && (this._camera.view.enabled = !0), this._camera.projectionMatrix.copy(wv), this._camera.projectionMatrixInverse.copy(Cv), e.setRenderTarget(this.renderTarget), e.render(this.scene, this.camera), this.fullscreenMaterial.uniforms.reset.value = !1;
                    for (let e = 0; e < this.textureCount; e++) this.copyPass.fullscreenMaterial.uniforms["inputTexture" + e].value = this.renderTarget.texture[e], this.fullscreenMaterial.uniforms["accumulatedTexture" + e].value = this.copyPass.renderTarget.texture[e];
                    this.copyPass.render(e), this.fullscreenMaterial.uniforms.prevCameraMatrixWorld.value.copy(this._camera.matrixWorld), this.fullscreenMaterial.uniforms.prevViewMatrix.value.copy(this._camera.matrixWorldInverse), this.fullscreenMaterial.uniforms.prevProjectionMatrix.value.copy(this.fullscreenMaterial.uniforms.projectionMatrix.value), this.fullscreenMaterial.uniforms.prevProjectionMatrixInverse.value.copy(this.fullscreenMaterial.uniforms.projectionMatrixInverse.value)
                }
                jitter(e = 1) {
                    this.unjitter(), 0 === this.r2Sequence.length && (this.r2Sequence = (e => {
                        const t = [];
                        for (let e = 0; e < 256; e++) t.push([(Ev + .7548776662466927 * e) % 1, (Ev + .5698402909980532 * e) % 1]);
                        return t
                    })().map((([e, t]) => [e - .5, t - .5]))), this.pointsIndex = (this.pointsIndex + 1) % this.r2Sequence.length;
                    const [t, n] = this.r2Sequence[this.pointsIndex], {
                        width: i,
                        height: r
                    } = this.renderTarget;
                    this._camera.setViewOffset && this._camera.setViewOffset(i, r, t * e, n * e, i, r)
                }
                unjitter() {
                    this._camera.clearViewOffset && this._camera.clearViewOffset()
                }
            }
            const Tv = {
                blend: .8,
                constantBlend: !0,
                dilation: !0,
                logTransform: !1,
                neighborhoodClampRadius: 2,
                depthDistance: 10,
                worldDistance: 5,
                neighborhoodClamp: !0
            };
            class Mv extends XA {
                constructor(e, t, n, i = Tv) {
                    super("TRAAEffect", "#define GLSLIFY 1\nuniform sampler2D inputTexture;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 accumulatedTexel=textureLod(inputTexture,vUv,0.);outputColor=vec4(accumulatedTexel.rgb,1.);}", {
                        type: "FinalTRAAEffectMaterial",
                        uniforms: new Map([
                            ["inputTexture", new Ll(null)]
                        ])
                    }), this._scene = e, this._camera = t, i = {
                        ...Tv,
                        ...i
                    }, this.temporalReprojectPass = new Sv(e, t, n, 1, i), this.uniforms.get("inputTexture").value = this.temporalReprojectPass.texture, this.setSize(i.width, i.height)
                }
                setSize(e, t) {
                    this.temporalReprojectPass.setSize(e, t)
                }
                dispose() {
                    super.dispose(), this.temporalReprojectPass.dispose()
                }
                update(e, t) {
                    this.temporalReprojectPass.unjitter(), this.unjitteredProjectionMatrix = this._camera.projectionMatrix.clone(), this._camera.projectionMatrix.copy(this.unjitteredProjectionMatrix);
                    const n = av(this._scene).filter((e => mv(e)));
                    for (const t of n) {
                        const n = e.properties.get(t.material);
                        if (null == n || !n.programs) continue;
                        const i = Array.from(n.programs.values())[0].getUniforms();
                        if (!i._patchedProjectionMatrix) {
                            const e = i.setValue.bind(i);
                            i._oldSetValue = e, i.setValue = (t, n, i, ...r) => {
                                "projectionMatrix" === n && (i = this.unjitteredProjectionMatrix), e(t, n, i, ...r)
                            }, i._patchedProjectionMatrix = !0
                        }
                        cancelAnimationFrame(i._destroyPatchRAF), cancelAnimationFrame(i._destroyPatchRAF2), i._destroyPatchRAF = requestAnimationFrame((() => {
                            i._destroyPatchRAF2 = requestAnimationFrame((() => {
                                i.setValue = i._oldSetValue, delete i._oldSetValue, delete i._patchedProjectionMatrix
                            }))
                        }))
                    }
                    this.temporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = t.texture, this.temporalReprojectPass.jitter(), this.temporalReprojectPass.render(e)
                }
            }
            Mv.DefaultOptions = Tv;
            const Iv = {
                    moment: !1,
                    depth: !1,
                    normal: !1,
                    roughness: !1,
                    diffuse: !0,
                    roughnessDependent: !1,
                    basicVariance: 5e-4,
                    denoiseCustomComposeShader: "",
                    denoiseCustomComposeShaderFunctions: ""
                },
                Bv = [
                    ["moment", "", "useMoment"],
                    ["depth", "depthPhi", "useDepth"],
                    ["normal", "normalPhi", "useNormal"],
                    ["roughness", "roughnessPhi", "useRoughness"]
                ];
            class Rv extends CA {
                constructor(e, t = [], n = Iv) {
                    super("DenoisePass"), this.iterations = 1, Array.isArray(t) || (t = [t]), n = {
                        ...Iv,
                        ...n
                    }, this.options = n, this.fullscreenMaterial = new wi({
                        fragmentShader: "",
                        vertexShader: yv,
                        uniforms: {
                            depthTexture: new Ll(null),
                            normalTexture: new Ll(null),
                            momentTexture: new Ll(null),
                            invTexSize: new Ll(new ze),
                            horizontal: new Ll(!0),
                            blurHorizontal: new Ll(!0),
                            denoiseKernel: new Ll(1),
                            denoiseDiffuse: new Ll(1),
                            denoise: new Ll([0]),
                            depthPhi: new Ll(1),
                            normalPhi: new Ll(1),
                            roughnessPhi: new Ll(1),
                            stepSize: new Ll(1),
                            isFirstIteration: new Ll(!1),
                            isLastIteration: new Ll(!1),
                            viewMatrix: new Ll(e.matrixWorldInverse),
                            projectionMatrix: new Ll(e.projectionMatrix),
                            cameraMatrixWorld: new Ll(e.matrixWorld),
                            projectionMatrixInverse: new Ll(e.projectionMatrixInverse)
                        },
                        glslVersion: Se,
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        toneMapped: !1
                    });
                    const i = {
                        type: w,
                        depthBuffer: !1
                    };
                    this.renderTargetA = new Ql(1, 1, t.length, i), this.renderTargetB = new Ql(1, 1, t.length, i), "boolean" == typeof n.roughnessDependent && (n.roughnessDependent = Array(t.length).fill(n.roughnessDependent)), this.fullscreenMaterial.defines.roughnessDependent = `bool[](${n.roughnessDependent.join(", ")})`, "number" == typeof n.basicVariance && (n.basicVariance = Array(t.length).fill(n.basicVariance)), this.fullscreenMaterial.defines.basicVariance = `float[](${n.basicVariance.map((e=>e.toPrecision(5))).join(", ")})`, this.setTextures(t)
                }
                setTextures(e) {
                    Array.isArray(e) || (e = [e]), this.textures = e;
                    let t = "",
                        n = "";
                    for (let e = 0; e < this.textures.length; e++) t += `layout(location = ${e}) out vec4 gTexture${e};\n`, t += `uniform sampler2D inputTexture${e};\n`, n += `gTexture${e} = vec4(denoisedColor[${e}], sumVariance[${e}]);\n`;
                    let i = t + "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D depthTexture;uniform sampler2D normalTexture;uniform sampler2D momentTexture;uniform vec2 invTexSize;uniform bool horizontal;uniform bool blurHorizontal;uniform float denoise[textureCount];uniform float depthPhi;uniform float normalPhi;uniform float roughnessPhi;uniform float denoiseKernel;uniform float stepSize;uniform mat4 projectionMatrixInverse;uniform mat4 projectionMatrix;uniform mat4 cameraMatrixWorld;uniform bool isFirstIteration;uniform bool isLastIteration;\n#include <packing>\n#define EPSILON 0.00001\n#define M_PI 3.1415926535897932384626433832795\n#define PI M_PI\n#define luminance(a) dot(a, vec3(0.2125, 0.7154, 0.0721))\n#include <denoiseCustomComposeShaderFunctions>\nvec3 screenSpaceToWorldSpace(const vec2 uv,const float depth,const mat4 curMatrixWorld){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=projectionMatrixInverse*ndc;vec4 view=curMatrixWorld*(clip/clip.w);return view.xyz;}float distToPlane(const vec3 worldPos,const vec3 neighborWorldPos,const vec3 worldNormal){vec3 toCurrent=worldPos-neighborWorldPos;float distToPlane=abs(dot(toCurrent,worldNormal));return distToPlane;}float getDisocclusionBoostVariance(float visibleFrames){\n#ifdef useTemporalReprojectTextures\nreturn max(0.,-pow(visibleFrames,2.0)+50.0);\n#else\nreturn 0.;\n#endif\n}void tap(const vec2 neighborVec,const vec2 pixelStepOffset,const vec3 normal,const float depth,const float roughness,const vec3 worldPos,const float luma[textureCount],const float colorPhi[textureCount],inout vec3 denoisedColor[textureCount],inout float totalWeight[textureCount],inout float sumVariance[textureCount],inout float variance[textureCount]){vec2 fullNeighborUv=neighborVec*pixelStepOffset;vec2 neighborUvNearest=vUv+fullNeighborUv;vec2 bilinearOffset=neighborVec.y>0. ? invTexSize :-invTexSize;vec2 neighborUv=vUv+fullNeighborUv+bilinearOffset*0.5;vec2 neighborUvRoughness=vUv+fullNeighborUv*(roughness<0.15 ? roughness/0.15 : 1.)+bilinearOffset*0.5;float basicWeight=1.0;\n#ifdef useDepth\nvec4 neighborDepthTexel=textureLod(depthTexture,neighborUvNearest,0.);\n#ifdef RGBA_DEPTH_PACKING\nfloat neighborDepth=unpackRGBAToDepth(neighborDepthTexel);\n#else\nfloat neighborDepth=neighborDepthTexel.r;\n#endif\nvec3 neighborWorldPos=screenSpaceToWorldSpace(neighborUvNearest,neighborDepth,cameraMatrixWorld);\n#ifdef useNormal\nfloat depthDiff=1.-distToPlane(worldPos,neighborWorldPos,normal);\n#else\nfloat depthDiff=1.-abs(depth-neighborDepth);\n#endif\nfloat depthSimilarity=max(depthDiff/depthPhi,0.);basicWeight*=depthSimilarity;\n#endif\n#if defined(useNormal) || defined(useRoughness)\nvec4 neighborNormalTexel=textureLod(normalTexture,neighborUvNearest,0.);\n#endif\n#ifdef useNormal\nvec3 neighborNormal=neighborNormalTexel.xyz;float normalDiff=dot(neighborNormal,normal);float normalSimilarity=pow(max(0.,normalDiff),normalPhi);basicWeight*=normalSimilarity;\n#endif\n#ifdef useRoughness\nfloat neighborRoughness=neighborNormalTexel.a;neighborRoughness*=neighborRoughness;float roughnessDiff=abs(roughness-neighborRoughness);float roughnessSimilarity=exp(-roughnessDiff*roughnessPhi);basicWeight*=roughnessSimilarity;\n#endif\nvec4 neighborInputTexel[textureCount];vec3 neighborColor;float neighborLuma,lumaDiff,lumaSimilarity,disocclusionBoost;float weight[textureCount];\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){neighborInputTexel[i]=textureLod(inputTexture[i],roughnessDependent[i]? neighborUvRoughness : neighborUv,0.);neighborColor=neighborInputTexel[i].rgb;neighborLuma=luminance(neighborColor);lumaDiff=abs(luma[i]-neighborLuma);lumaSimilarity=max(1.0-lumaDiff/colorPhi[i],0.0);weight[i]=min(basicWeight*lumaSimilarity,1.0);disocclusionBoost=variance[i]/1000.;weight[i]=mix(weight[i],1.,disocclusionBoost);denoisedColor[i]+=neighborColor*weight[i];totalWeight[i]+=weight[i];}\n#pragma unroll_loop_end\nif(isFirstIteration){\n#ifdef useMoment\nvec4 neighborMoment=textureLod(momentTexture,neighborUvNearest,0.);neighborInputTexel[0].a=neighborMoment.g-neighborMoment.r*neighborMoment.r;\n#if momentTextureCount > 1\nneighborInputTexel[1].a=neighborMoment.a-neighborMoment.b*neighborMoment.b;\n#endif\n#else\nfor(int i=0;i<textureCount;i++){neighborInputTexel[i].a=getDisocclusionBoostVariance(neighborInputTexel[i].a);}\n#endif\n}\n#pragma unroll_loop_start\nfor(int i=0;i<momentTextureCount;i++){\n#ifndef useMoment\nif(isFirstIteration)neighborInputTexel[i].a=1.0;\n#endif\nsumVariance[i]+=weight[i]*weight[i]*neighborInputTexel[i].a;}\n#pragma unroll_loop_end\n}void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.);if(depthTexel.r>0.9999||dot(depthTexel.rgb,depthTexel.rgb)==0.){discard;return;}vec3 worldPos;float depth;\n#ifdef useDepth\n#ifdef RGBA_DEPTH_PACKING\ndepth=unpackRGBAToDepth(depthTexel);\n#else\ndepth=depthTexel.r;\n#endif\nworldPos=screenSpaceToWorldSpace(vUv,depth,cameraMatrixWorld);\n#endif\nvec3 normal;float roughness;\n#ifdef useNormal\nvec4 normalTexel=textureLod(normalTexture,vUv,0.);normal=normalTexel.xyz;\n#endif\n#ifdef useRoughness\nroughness=normalTexel.a;roughness*=roughness;\n#endif\nvec3 denoisedColor[textureCount];float sumVariance[textureCount];float variance[textureCount];\n#ifdef doDenoise\nvec4 texel[textureCount];float luma[textureCount];float totalWeight[textureCount];float colorPhi[textureCount];\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){totalWeight[i]=1.0;texel[i]=textureLod(inputTexture[i],vUv,0.);denoisedColor[i]=texel[i].rgb;luma[i]=luminance(texel[i].rgb);}\n#pragma unroll_loop_end\nif(isFirstIteration){\n#ifdef useMoment\nvec4 moment=textureLod(momentTexture,vUv,0.);texel[0].a=max(0.0,moment.g-moment.r*moment.r);\n#if momentTextureCount > 1\ntexel[1].a=max(0.0,moment.a-moment.b*moment.b);\n#endif\n#else\nfor(int i=0;i<textureCount;i++){texel[i].a=getDisocclusionBoostVariance(texel[i].a);}\n#endif\n}\n#pragma unroll_loop_start\nfor(int i=0;i<momentTextureCount;i++){variance[i]=min(1000.,texel[i].a);sumVariance[i]=texel[i].a;if(roughnessDependent[i]){colorPhi[i]=denoise[i]*sqrt(basicVariance[i]*roughness+sumVariance[i]);}else{colorPhi[i]=denoise[i]*sqrt(basicVariance[i]+sumVariance[i]);}}\n#pragma unroll_loop_end\nvec2 pixelStepOffset=invTexSize*stepSize;if(blurHorizontal){for(float i=-denoiseKernel;i<=denoiseKernel;i++){if(i!=0.){vec2 neighborVec=horizontal ? vec2(i,0.): vec2(0.,i);tap(neighborVec,pixelStepOffset,normal,depth,roughness,worldPos,luma,colorPhi,denoisedColor,totalWeight,sumVariance,variance);}}}else{for(float i=-denoiseKernel;i<=denoiseKernel;i++){if(i!=0.){vec2 neighborVec=horizontal ? vec2(-i,-i): vec2(i,-i);tap(neighborVec,pixelStepOffset,normal,depth,roughness,worldPos,luma,colorPhi,denoisedColor,totalWeight,sumVariance,variance);}}}\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){sumVariance[i]/=totalWeight[i]*totalWeight[i];denoisedColor[i]/=totalWeight[i];}\n#pragma unroll_loop_end\n#else\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){denoisedColor[i]=textureLod(inputTexture[i],vUv,0.).rgb;}\n#pragma unroll_loop_end\n#endif\nif(isLastIteration){\n#include <denoiseCustomComposeShader>\n}\n#include <outputShader>\n}".replace("#include <denoiseCustomComposeShaderFunctions>", this.options.denoiseCustomComposeShaderFunctions).replace("#include <denoiseCustomComposeShader>", this.options.denoiseCustomComposeShader).replace("#include <outputShader>", n).replaceAll("textureCount", this.textures.length).replaceAll("momentTextureCount", Math.min(this.textures.length, 2));
                    i = fv(i);
                    const r = i.matchAll(/inputTexture\[\s*[0-9]+\s*]/g);
                    for (const [e] of r) {
                        const t = e.replace(/[^0-9]/g, "");
                        i = i.replace(e, "inputTexture" + t)
                    }
                    delete this.fullscreenMaterial.defines.useTemporalReprojectTextures;
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        this.fullscreenMaterial.uniforms["inputTexture" + t] = new Ll(n), n.name.includes("TemporalReprojectPass.accumulatedTexture") && (this.fullscreenMaterial.defines.useTemporalReprojectTextures = "")
                    }
                    this.fullscreenMaterial.fragmentShader = i, this.fullscreenMaterial.needsUpdate = !0
                }
                setDepthTexture(e) {
                    this.fullscreenMaterial.uniforms.depthTexture.value = e, (e.type === A ? ve : 3200) === ve ? this.fullscreenMaterial.defines.RGBA_DEPTH_PACKING = "" : delete this.fullscreenMaterial.defines.RGBA_DEPTH_PACKING, this.options.depth = !0
                }
                setNormalTexture(e, {
                    useRoughnessInAlphaChannel: t = !1
                } = {}) {
                    this.fullscreenMaterial.uniforms.normalTexture.value = e, this.options.normal = !0, this.options.roughness = t
                }
                setMomentTexture(e) {
                    this.fullscreenMaterial.uniforms.momentTexture.value = e, this.options.moment = !0
                }
                setSize(e, t) {
                    this.renderTargetA.setSize(e, t), this.renderTargetB.setSize(e, t), this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / e, 1 / t)
                }
                dispose() {
                    super.dispose(), this.renderTargetA.dispose(), this.renderTargetB.dispose()
                }
                keepEdgeStoppingDefinesUpdated() {
                    for (const [t, n, i] of Bv) {
                        var e;
                        const r = this.options[t] && ("" === n || (null == (e = this.fullscreenMaterial.uniforms[n]) ? void 0 : e.value) > .001);
                        r !== i in this.fullscreenMaterial.defines && (r ? this.fullscreenMaterial.defines[i] = "" : delete this.fullscreenMaterial.defines[i], this.fullscreenMaterial.needsUpdate = !0)
                    }
                }
                render(e) {
                    this.keepEdgeStoppingDefinesUpdated();
                    const t = this.fullscreenMaterial.uniforms.denoiseKernel.value;
                    if (this.iterations > 0) {
                        "doDenoise" in this.fullscreenMaterial.defines || (this.fullscreenMaterial.defines.doDenoise = "", this.fullscreenMaterial.needsUpdate = !0);
                        for (let t = 0; t < 2 * this.iterations; t++) {
                            const n = t % 2 == 0,
                                i = 2 ** ~~(t / 2),
                                r = Math.log2(i) % 2 == 0;
                            this.fullscreenMaterial.uniforms.horizontal.value = n, this.fullscreenMaterial.uniforms.blurHorizontal.value = r, this.fullscreenMaterial.uniforms.stepSize.value = i, this.fullscreenMaterial.uniforms.isFirstIteration.value = 0 === t, this.fullscreenMaterial.uniforms.isLastIteration.value = t === 2 * this.iterations - 1;
                            const s = n ? this.renderTargetA : this.renderTargetB;
                            for (let e = 0; e < this.textures.length; e++) this.fullscreenMaterial.uniforms["inputTexture" + e].value = n ? 0 === t ? this.textures[e] : this.renderTargetB.texture[e] : this.renderTargetA.texture[e];
                            e.setRenderTarget(s), e.render(this.scene, this.camera)
                        }
                    } else "doDenoise" in this.fullscreenMaterial.defines && (delete this.fullscreenMaterial.defines.doDenoise, this.fullscreenMaterial.needsUpdate = !0), e.setRenderTarget(this.renderTargetB), e.render(this.scene, this.camera), this.fullscreenMaterial.uniforms.denoiseKernel.value = t;
                    for (let e = 0; e < this.textures.length; e++) this.fullscreenMaterial.uniforms["inputTexture" + e].value = this.textures[e]
                }
                get texture() {
                    return this.renderTargetB.texture[0]
                }
            }
            const Dv = {
                fullAccumulate: !0,
                temporalReprojectCustomComposeShader: "#define GLSLIFY 1\nvec4 moment;if(!reset&&reprojectedUvDiffuse.x>=0.0){vec4 historyMoment=sampleReprojectedTexture(lastMomentTexture,reprojectedUvDiffuse);moment.r=luminance(gOutput[0].rgb);moment.g=moment.r*moment.r;\n#if textureCount > 1\nmoment.b=luminance(gOutput[1].rgb);moment.a=moment.b*moment.b;\n#endif\ngMoment=mix(moment,historyMoment,0.8);}else{moment.rg=vec2(0.,1000.);moment.ba=vec2(0.,1000.);gMoment=moment;return;}"
            };
            class Pv extends Sv {
                constructor(e, t, n, i = 1, r = Dv) {
                    super(e, t, n, i, r = {
                        ...Dv,
                        ...r
                    }), this.momentTexture = this.renderTarget.texture[0].clone(), this.momentTexture.isRenderTargetTexture = !0, this.momentTexture.type = b, this.momentTexture.minFilter = h, this.momentTexture.magFilter = h, this.momentTexture.needsUpdate = !0, this.renderTarget.texture.push(this.momentTexture);
                    const s = `\n\t\tlayout(location = ${i}) out vec4 gMoment;\n\n\t\tuniform sampler2D lastMomentTexture;\n\t\t`;
                    this.fullscreenMaterial.fragmentShader = s + this.fullscreenMaterial.fragmentShader, this.fullscreenMaterial.uniforms = {
                        ...this.fullscreenMaterial.uniforms,
                        lastMomentTexture: new Ll(null)
                    };
                    const o = i + 1;
                    this.copyPass.setTextureCount(o), this.copyPass.fullscreenMaterial.uniforms["inputTexture" + (o - 1)].value = this.momentTexture;
                    const a = this.copyPass.renderTarget.texture[o - 1];
                    a.type = b, a.minFilter = f, a.magFilter = f, a.needsUpdate = !0, this.fullscreenMaterial.uniforms.lastMomentTexture.value = a, this.fullscreenMaterial.defines.momentTextureCount = Math.min(2, i)
                }
            }
            class Lv {
                constructor(e, t, n, i = 1, r = {}) {
                    this.svgfTemporalReprojectPass = new Pv(e, t, n, i, r);
                    const s = this.svgfTemporalReprojectPass.renderTarget.texture.slice(0, i);
                    this.denoisePass = new Rv(t, s, r), this.denoisePass.setMomentTexture(this.svgfTemporalReprojectPass.momentTexture), this.setNonJitteredDepthTexture(n.depthTexture)
                }
                get texture() {
                    return this.denoisePass.texture
                }
                setGBuffers(e, t) {
                    this.setJitteredGBuffers(e, t), this.setNonJitteredGBuffers(e, t)
                }
                setJitteredGBuffers(e, t, {
                    useRoughnessInAlphaChannel: n = !1
                } = {}) {
                    this.denoisePass.setDepthTexture(e), this.denoisePass.setNormalTexture(t, {
                        useRoughnessInAlphaChannel: n
                    })
                }
                setNonJitteredDepthTexture(e) {
                    this.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.depthTexture.value = e
                }
                setVelocityTexture(e) {
                    this.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.velocityTexture.value = e
                }
                setSize(e, t) {
                    this.denoisePass.setSize(e, t), this.svgfTemporalReprojectPass.setSize(e, t)
                }
                dispose() {
                    this.denoisePass.dispose(), this.svgfTemporalReprojectPass.dispose()
                }
                render(e) {
                    this.svgfTemporalReprojectPass.render(e), this.denoisePass.render(e)
                }
            }
            class Uv extends CA {
                constructor() {
                    super("CubeToEquirectEnvPass"), this.renderTarget = new dt(1, 1, {
                        depthBuffer: !1,
                        type: b
                    }), this.fullscreenMaterial = new wi({
                        fragmentShader: "\n            varying vec2 vUv;\n\t\t\tuniform samplerCube cubeMap;\n\n\t\t\t#define M_PI 3.1415926535897932384626433832795\n\t\t\t\n\t\t\t// source: https://github.com/spite/CubemapToEquirectangular/blob/master/src/CubemapToEquirectangular.js\n            void main() {\n\t\t\t\tfloat longitude = vUv.x * 2. * M_PI - M_PI + M_PI / 2.;\n\t\t\t\tfloat latitude = vUv.y * M_PI;\n\n\t\t\t\tvec3 dir = vec3(\n\t\t\t\t\t- sin( longitude ) * sin( latitude ),\n\t\t\t\t\tcos( latitude ),\n\t\t\t\t\t- cos( longitude ) * sin( latitude )\n\t\t\t\t);\n\n\t\t\t\tdir.y = -dir.y;\n\n\t\t\t\tgl_FragColor = textureCube( cubeMap, dir );\n            }\n            ",
                        vertexShader: yv,
                        uniforms: {
                            cubeMap: {
                                value: null
                            }
                        },
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        toneMapped: !1
                    })
                }
                dispose() {
                    this.renderTarget.dispose()
                }
                generateEquirectEnvMap(e, t, n = null, i = null, r = 4096) {
                    if (null === n && null === i) {
                        const e = t.source.data[0].width;
                        n = 2 ** Math.ceil(Math.log2(2 * e * 3 ** .5)), i = 2 ** Math.ceil(Math.log2(e * 3 ** .5))
                    }
                    n > r && (n = r, i = r / 2), this.renderTarget.setSize(n, i), this.fullscreenMaterial.uniforms.cubeMap.value = t;
                    const {
                        renderTarget: s
                    } = this;
                    e.setRenderTarget(s), e.render(this.scene, this.camera);
                    const a = new Float32Array(n * i * 4);
                    e.readRenderTargetPixels(s, 0, 0, n, i, a);
                    const l = new Wo(a, n, i, I, b);
                    return l.wrapS = c, l.wrapT = c, l.minFilter = g, l.magFilter = g, l.needsUpdate = !0, l.mapping = o, l
                }
            }
            class Nv extends wi {
                constructor() {
                    super({
                        type: "MRTMaterial",
                        defines: {
                            USE_UV: "",
                            TEMPORAL_RESOLVE: ""
                        },
                        uniforms: {
                            color: new Ll(new kn),
                            emissive: new Ll(new kn),
                            map: new Ll(null),
                            roughnessMap: new Ll(null),
                            metalnessMap: new Ll(null),
                            emissiveMap: new Ll(null),
                            alphaMap: new Ll(null),
                            normalMap: new Ll(null),
                            normalScale: new Ll(new ze(1, 1)),
                            roughness: new Ll(0),
                            metalness: new Ll(0),
                            emissiveIntensity: new Ll(0),
                            uvTransform: new Ll(new He),
                            boneTexture: new Ll(null),
                            blueNoiseTexture: new Ll(null),
                            blueNoiseRepeat: new Ll(new ze(1, 1)),
                            texSize: new Ll(new ze(1, 1)),
                            frame: new Ll(0)
                        },
                        vertexShader: "\n                varying vec2 vHighPrecisionZW;\n\n                #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                \n                #include <common>\n                #include <uv_pars_vertex>\n                #include <displacementmap_pars_vertex>\n                #include <normal_pars_vertex>\n                #include <morphtarget_pars_vertex>\n                #include <logdepthbuf_pars_vertex>\n                #include <clipping_planes_pars_vertex>\n                #include <skinning_pars_vertex>\n                #include <color_pars_vertex>\n\n                varying vec2 screenUv;\n\n                void main() {\n                    #include <uv_vertex>\n                    \n                    #include <skinbase_vertex>\n                    #include <beginnormal_vertex>\n                    #include <skinnormal_vertex>\n                    #include <defaultnormal_vertex>\n\n                    #include <morphnormal_vertex>\n                    #include <normal_vertex>\n                    #include <begin_vertex>\n                    #include <morphtarget_vertex>\n\n                    #include <skinning_vertex>\n\n                    #include <displacementmap_vertex>\n                    #include <project_vertex>\n                    #include <logdepthbuf_vertex>\n                    #include <clipping_planes_vertex>\n\n                    #include <color_vertex>\n                    \n                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                        vViewPosition = - mvPosition.xyz;\n                    #endif\n\n                    screenUv = gl_Position.xy * 0.5 + 0.5;\n\n                    vHighPrecisionZW = gl_Position.zw;\n                }\n            ",
                        fragmentShader: "\n                #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                #include <packing>\n                #include <uv_pars_fragment>\n                #include <normal_pars_fragment>\n                #include <bumpmap_pars_fragment>\n                #include <normalmap_pars_fragment>\n                #include <logdepthbuf_pars_fragment>\n                #include <clipping_planes_pars_fragment>\n                #include <color_pars_fragment>\n                #include <alphamap_pars_fragment>\n                \n                layout(location = 0) out vec4 gDepth;\n                layout(location = 1) out vec4 gNormal;\n                layout(location = 2) out vec4 gDiffuse;\n                layout(location = 3) out vec4 gEmissive;\n\n                #include <map_pars_fragment>\n                uniform vec3 color;\n\n                varying vec2 vHighPrecisionZW;\n\n                #include <metalnessmap_pars_fragment>\n                uniform float metalness;\n\n                #include <roughnessmap_pars_fragment>\n                uniform float roughness;\n\n                #include <emissivemap_pars_fragment>\n                uniform vec3 emissive;\n                uniform float emissiveIntensity;\n\n#ifdef USE_ALPHAMAP\n                uniform sampler2D blueNoiseTexture;\n                uniform vec2 blueNoiseRepeat;\n                uniform vec2 texSize;\n                uniform int frame;\n\n                varying vec2 screenUv;\n\n                const float g = 1.6180339887498948482;\n                const float a1 = 1.0 / g;\n\n                // reference: https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n                float r1(float n) {\n                    // 7th harmonious number\n                    return fract(1.1127756842787055 + a1 * n);\n                }\n\n                const vec4 hn = vec4(0.618033988749895, 0.3247179572447458, 0.2207440846057596, 0.1673039782614187);\n\n                vec4 sampleBlueNoise(vec2 uv, int seed) {\n                    vec2 size = uv * texSize;\n                    vec2 blueNoiseSize = texSize / blueNoiseRepeat;\n                    float blueNoiseIndex = floor(floor(size.y / blueNoiseSize.y) * blueNoiseRepeat.x) + floor(size.x / blueNoiseSize.x);\n\n                    // get the offset of this pixel's blue noise tile\n                    int blueNoiseTileOffset = int(r1(blueNoiseIndex + 1.0) * 65536.);\n\n                    vec2 blueNoiseUv = uv * blueNoiseRepeat;\n\n                    // fetch blue noise for this pixel\n                    vec4 blueNoise = textureLod(blueNoiseTexture, blueNoiseUv, 0.);\n\n                    // animate blue noise\n                    blueNoise = fract(blueNoise + hn * float(seed + blueNoiseTileOffset));\n\n                    blueNoise.r = (blueNoise.r > 0.5 ? 1.0 - blueNoise.r : blueNoise.r) * 2.0;\n                    blueNoise.g = (blueNoise.g > 0.5 ? 1.0 - blueNoise.g : blueNoise.g) * 2.0;\n                    blueNoise.b = (blueNoise.b > 0.5 ? 1.0 - blueNoise.b : blueNoise.b) * 2.0;\n                    blueNoise.a = (blueNoise.a > 0.5 ? 1.0 - blueNoise.a : blueNoise.a) * 2.0;\n\n                    return blueNoise;\n                }\n#endif\n\n                void main() {\n                    // !todo: properly implement alpha hashing\n                    // #ifdef USE_ALPHAMAP\n                    // float alpha = textureLod( alphaMap, vUv, 0. ).g;\n\n                    // float alphaThreshold = sampleBlueNoise(screenUv, frame).a;\n                    // if(alpha < alphaThreshold){\n                    //     discard;\n                    //     return;\n                    // }metalnessnor\n                    // #endif\n\n                    //! todo: find better solution\n                    #define vMapUv vUv\n                    #define vMetalnessMapUv vUv\n                    #define vRoughnessMapUv vUv\n                    #define vNormalMapUv vUv\n                    #define vEmissiveMapUv vUv\n\n                    #include <clipping_planes_fragment>\n                    #include <logdepthbuf_fragment>\n                    #include <normal_fragment_begin>\n                    #include <normal_fragment_maps>\n\n                    float roughnessFactor = roughness;\n                    bool isDeselected = roughness > 10.0e9;\n                    \n                    if(isDeselected){\n                        roughnessFactor = 1.;\n                        gNormal = vec4(0.);\n                    }else{\n                        #ifdef USE_ROUGHNESSMAP\n                            vec4 texelRoughness = textureLod( roughnessMap, vUv, 0. );\n                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n                            roughnessFactor *= texelRoughness.g;\n                        #endif\n\n                        // roughness of 1.0 is reserved for deselected meshes\n                        roughnessFactor = min(0.99, roughnessFactor);\n\n                        vec3 worldNormal = normalize((vec4(normal, 1.) * viewMatrix).xyz);\n                        gNormal = vec4( worldNormal, roughnessFactor );\n                    }\n                    \n\n                    if(isDeselected){\n                        discard;\n                        return;\n                    }\n\n                    float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n                    vec4 depthColor = packDepthToRGBA( fragCoordZ );\n                    gDepth = depthColor;\n\n                    #include <metalnessmap_fragment>\n\n                    vec4 diffuseColor = vec4(color, metalnessFactor);\n\n                    #include <map_fragment>\n                    #include <color_fragment>\n\n                    gDiffuse = diffuseColor;\n\n                    vec3 totalEmissiveRadiance = emissive * emissiveIntensity;\n                    #include <emissivemap_fragment>\n                    \n                    gEmissive = vec4(totalEmissiveRadiance, 0.);\n                }\n            ",
                        glslVersion: Se,
                        toneMapped: !1,
                        alphaTest: !1,
                        fog: !1,
                        lights: !1
                    }), this.normalMapType = 0, this.normalScale = new ze(1, 1)
                }
            }
            var Ov = "#define GLSLIFY 1\nconst float g=1.6180339887498948482;const float a1=1.0/g;float r1(float n){return fract(1.1127756842787055+a1*n);}const vec4 hn=vec4(0.618033988749895,0.3247179572447458,0.2207440846057596,0.1673039782614187);vec4 sampleBlueNoise(sampler2D texture,int seed,vec2 repeat,vec2 texSize){vec2 size=vUv*texSize;vec2 blueNoiseSize=texSize/repeat;float blueNoiseIndex=floor(floor(size.y/blueNoiseSize.y)*repeat.x)+floor(size.x/blueNoiseSize.x);vec2 blueNoiseUv=vUv*repeat;vec4 blueNoise=textureLod(texture,blueNoiseUv,0.);if(seed!=0){blueNoise=fract(blueNoise+hn*float(seed));blueNoise.r=(blueNoise.r>0.5 ? 1.0-blueNoise.r : blueNoise.r)*2.0;blueNoise.g=(blueNoise.g>0.5 ? 1.0-blueNoise.g : blueNoise.g)*2.0;blueNoise.b=(blueNoise.b>0.5 ? 1.0-blueNoise.b : blueNoise.b)*2.0;blueNoise.a=(blueNoise.a>0.5 ? 1.0-blueNoise.a : blueNoise.a)*2.0;}return blueNoise;}";
            const Fv = new Blob(["onmessage = " + (({
                    data: {
                        width: e,
                        height: t,
                        isFloatType: n,
                        flipY: i,
                        data: r
                    }
                }) => {
                    const s = function() {
                        const e = new ArrayBuffer(4),
                            t = new Float32Array(e),
                            n = new Uint32Array(e),
                            i = new Uint32Array(512),
                            r = new Uint32Array(512);
                        for (let e = 0; e < 256; ++e) {
                            const t = e - 127;
                            t < -27 ? (i[e] = 0, i[256 | e] = 32768, r[e] = 24, r[256 | e] = 24) : t < -14 ? (i[e] = 1024 >> -t - 14, i[256 | e] = 1024 >> -t - 14 | 32768, r[e] = -t - 1, r[256 | e] = -t - 1) : t <= 15 ? (i[e] = t + 15 << 10, i[256 | e] = t + 15 << 10 | 32768, r[e] = 13, r[256 | e] = 13) : t < 128 ? (i[e] = 31744, i[256 | e] = 64512, r[e] = 24, r[256 | e] = 24) : (i[e] = 31744, i[256 | e] = 64512, r[e] = 13, r[256 | e] = 13)
                        }
                        const s = new Uint32Array(2048),
                            o = new Uint32Array(64),
                            a = new Uint32Array(64);
                        for (let e = 1; e < 1024; ++e) {
                            let t = e << 13,
                                n = 0;
                            for (; !(8388608 & t);) t <<= 1, n -= 8388608;
                            t &= -8388609, n += 947912704, s[e] = t | n
                        }
                        for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + (e - 1024 << 13);
                        for (let e = 1; e < 31; ++e) o[e] = e << 23;
                        o[31] = 1199570944, o[32] = 2147483648;
                        for (let e = 33; e < 63; ++e) o[e] = 2147483648 + (e - 32 << 23);
                        o[63] = 3347054592;
                        for (let e = 1; e < 64; ++e) 32 !== e && (a[e] = 1024);
                        return {
                            floatView: t,
                            uint32View: n,
                            baseTable: i,
                            shiftTable: r,
                            mantissaTable: s,
                            exponentTable: o,
                            offsetTable: a
                        }
                    }();

                    function o(e) {
                        const t = e >> 10;
                        return s.uint32View[0] = s.mantissaTable[s.offsetTable[t] + (1023 & e)] + s.exponentTable[t], s.floatView[0]
                    }

                    function a(e, t, n) {
                        return .2126 * e + .7152 * t + .0722 * n
                    }
                    const l = (e, t, n = 0, i = e.length) => {
                        let r = n,
                            s = n + i - 1;
                        for (; r < s;) {
                            const n = r + s >> 1;
                            e[n] < t ? r = n + 1 : s = n
                        }
                        return r - n
                    };
                    if (!n) {
                        const e = new Float32Array(r.length);
                        for (const t in r) e[t] = o(r[t]);
                        r = e
                    }
                    const c = new Float32Array(t),
                        u = new Float32Array(e * t),
                        h = ((e, t, n, i, r, s) => {
                            if (i)
                                for (let i = 0, r = n - 1; i <= r; i++)
                                    for (let n = 0, s = 4 * t; n < s; n += 4) {
                                        const t = i * s + n,
                                            o = (r - i) * s + n;
                                        e[o] = e[t], e[o + 1] = e[t + 1], e[o + 2] = e[t + 2], e[o + 3] = e[t + 3]
                                    }
                            const o = new Float32Array(t * n),
                                c = new Float32Array(t * n),
                                u = new Float32Array(n),
                                h = new Float32Array(n);
                            let d = 0,
                                f = 0;
                            for (let i = 0; i < n; i++) {
                                let n = 0;
                                for (let r = 0; r < t; r++) {
                                    const s = i * t + r,
                                        l = a(e[4 * s + 0], e[4 * s + 1], e[4 * s + 2]);
                                    n += l, d += l, o[s] = l, c[s] = n
                                }
                                if (0 !== n)
                                    for (let e = i * t, r = i * t + t; e < r; e++) o[e] /= n, c[e] /= n;
                                f += n, u[i] = n, h[i] = f
                            }
                            if (0 !== f)
                                for (let e = 0, t = u.length; e < t; e++) u[e] /= f, h[e] /= f;
                            for (let e = 0; e < n; e++) {
                                const t = l(h, (e + 1) / n);
                                r[e] = (t + .5) / n
                            }
                            for (let e = 0; e < n; e++)
                                for (let n = 0; n < t; n++) {
                                    const i = e * t + n,
                                        r = l(c, (n + 1) / t, e * t, t);
                                    s[i] = (r + .5) / t
                                }
                            return d
                        })(r, e, t, i, c, u);
                    n ? postMessage({
                        totalSumValue: h,
                        marginalDataArray: c,
                        conditionalDataArray: u
                    }) : postMessage({
                        data: r,
                        totalSumValue: h,
                        marginalDataArray: c,
                        conditionalDataArray: u
                    })
                })], {
                    type: "application/javascript"
                }),
                kv = URL.createObjectURL(Fv);
            class Qv {
                constructor() {
                    const e = new Wo(new Float32Array([1, 1, 1, 1]), 1, 1);
                    e.type = b, e.format = I, e.minFilter = f, e.magFilter = f, e.wrapS = l, e.wrapT = l, e.generateMipmaps = !1, e.needsUpdate = !0;
                    const t = new Wo(new Float32Array([0, 1]), 1, 2);
                    t.type = b, t.format = P, t.minFilter = f, t.magFilter = f, t.generateMipmaps = !1, t.needsUpdate = !0;
                    const n = new Wo(new Float32Array([0, 0, 1, 1]), 2, 2);
                    n.type = b, n.format = P, n.minFilter = f, n.magFilter = f, n.generateMipmaps = !1, n.needsUpdate = !0, this.map = e, this.marginalWeights = t, this.conditionalWeights = n, this.totalSumWhole = 1, this.totalSumDecimal = 0, this.size = new ze
                }
                dispose() {
                    this.marginalWeights.dispose(), this.conditionalWeights.dispose(), this.map.dispose()
                }
                updateFrom(e) {
                    e = e.clone();
                    const {
                        width: t,
                        height: n,
                        data: i
                    } = e.image, {
                        type: r
                    } = e;
                    return this.size.set(t, n), new Promise((s => {
                        var o;
                        null == (o = this.worker) || o.terminate(), this.worker = new Worker(kv), this.worker.postMessage({
                            width: t,
                            height: n,
                            isFloatType: r === b,
                            flipY: e.flipY,
                            data: i
                        }), this.worker.onmessage = ({
                            data: {
                                data: i,
                                totalSumValue: r,
                                marginalDataArray: o,
                                conditionalDataArray: a
                            }
                        }) => {
                            this.dispose();
                            const {
                                marginalWeights: l,
                                conditionalWeights: c
                            } = this;
                            l.image = {
                                width: n,
                                height: 1,
                                data: o
                            }, l.needsUpdate = !0, c.image = {
                                width: t,
                                height: n,
                                data: a
                            }, c.needsUpdate = !0;
                            const u = ~~r,
                                h = r - u;
                            this.totalSumWhole = u, this.totalSumDecimal = h, i && (e.source = new ot({
                                ...e.image
                            }), e.image = {
                                width: t,
                                height: n,
                                data: i
                            }, e.type = b), this.map = e, this.worker = null, s(e)
                        }
                    }))
                }
            }
            class zv extends wi {
                constructor() {
                    super({
                        type: "SSGIMaterial",
                        uniforms: {
                            directLightTexture: new Ll(null),
                            accumulatedTexture: new Ll(null),
                            normalTexture: new Ll(null),
                            depthTexture: new Ll(null),
                            diffuseTexture: new Ll(null),
                            emissiveTexture: new Ll(null),
                            velocityTexture: new Ll(null),
                            blueNoiseTexture: new Ll(null),
                            backSideDepthTexture: new Ll(null),
                            projectionMatrix: new Ll(new Wt),
                            inverseProjectionMatrix: new Ll(new Wt),
                            cameraMatrixWorld: new Ll(new Wt),
                            viewMatrix: new Ll(new Wt),
                            cameraNear: new Ll(0),
                            cameraFar: new Ll(0),
                            rayDistance: new Ll(0),
                            thickness: new Ll(0),
                            frame: new Ll(0),
                            envBlur: new Ll(0),
                            maxRoughness: new Ll(0),
                            maxEnvMapMipLevel: new Ll(0),
                            envMapInfo: {
                                value: new Qv
                            },
                            envMapPosition: new Ll(new gt),
                            envMapSize: new Ll(new gt),
                            viewMatrix: new Ll(new Wt),
                            texSize: new Ll(new ze),
                            blueNoiseRepeat: new Ll(new ze)
                        },
                        defines: {
                            steps: 20,
                            refineSteps: 5,
                            spp: 1,
                            directLightMultiplier: 1,
                            CUBEUV_TEXEL_WIDTH: 0,
                            CUBEUV_TEXEL_HEIGHT: 0,
                            CUBEUV_MAX_MIP: 0,
                            vWorldPosition: "worldPos"
                        },
                        fragmentShader: "#define GLSLIFY 1\n#if !defined(diffuseOnly) && !defined(specularOnly)\nlayout(location=0)out vec4 gDiffuse;layout(location=1)out vec4 gSpecular;\n#else\n#ifdef diffuseOnly\nlayout(location=0)out vec4 gDiffuse;\n#else\nlayout(location=0)out vec4 gSpecular;\n#endif\n#endif\nvarying vec2 vUv;uniform sampler2D directLightTexture;uniform sampler2D accumulatedTexture;uniform sampler2D normalTexture;uniform sampler2D depthTexture;uniform sampler2D diffuseTexture;uniform sampler2D emissiveTexture;uniform sampler2D blueNoiseTexture;uniform sampler2D velocityTexture;\n#ifdef autoThickness\nuniform sampler2D backSideDepthTexture;\n#endif\nuniform mat4 projectionMatrix;uniform mat4 inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float maxEnvMapMipLevel;uniform float rayDistance;uniform float maxRoughness;uniform float thickness;uniform float envBlur;uniform int frame;uniform vec2 texSize;uniform vec2 blueNoiseRepeat;struct EquirectHdrInfo{sampler2D marginalWeights;sampler2D conditionalWeights;sampler2D map;vec2 size;float totalSumWhole;float totalSumDecimal;};uniform EquirectHdrInfo envMapInfo;\n#define INVALID_RAY_COORDS vec2(-1.0);\n#define EPSILON 0.00001\n#define ONE_MINUS_EPSILON 1.0 - EPSILON\nfloat nearMinusFar;float nearMulFar;float farMinusNear;vec2 invTexSize;\n#include <packing>\n#include <sampleBlueNoise>\n#include <ssgi_utils>\nvec2 RayMarch(inout vec3 dir,inout vec3 hitPos);vec2 BinarySearch(inout vec3 dir,inout vec3 hitPos);float fastGetViewZ(const float depth);vec3 doSample(const vec3 viewPos,const vec3 viewDir,const vec3 viewNormal,const vec3 worldPosition,const float metalness,const float roughness,const bool isDiffuseSample,const bool isEnvMisSample,const float NoV,const float NoL,const float NoH,const float LoH,const float VoH,const vec2 random,inout vec3 l,inout vec3 hitPos,out bool isMissedRay,out vec3 brdf,out float pdf);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.0);if(dot(depthTexel.rgb,depthTexel.rgb)==0.){discard;return;}vec4 normalTexel=textureLod(normalTexture,vUv,0.0);float roughness=normalTexel.a;if(roughness==1.0||roughness>maxRoughness){discard;return;}invTexSize=1./texSize;roughness=clamp(roughness*roughness,0.0001,1.0);nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;float unpackedDepth=unpackRGBAToDepth(depthTexel);float depth=fastGetViewZ(unpackedDepth);vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 worldNormal=normalTexel.xyz;vec3 viewNormal=normalize((vec4(worldNormal,0.)*cameraMatrixWorld).xyz);vec3 worldPos=vec4(vec4(viewPos,1.)*viewMatrix).xyz;vec4 diffuseTexel=textureLod(diffuseTexture,vUv,0.);vec3 diffuse=diffuseTexel.rgb;float metalness=diffuseTexel.a;vec3 n=viewNormal;vec3 v=-viewDir;float NoV=max(EPSILON,dot(n,v));vec3 V=(vec4(v,0.)*viewMatrix).xyz;vec3 N=worldNormal;vec4 blueNoise;vec3 H,l,h,F,T,B,envMisDir,gi;vec3 diffuseGI,specularGI,brdf,hitPos;Onb(N,T,B);V=ToLocal(T,B,N,V);vec3 f0=mix(vec3(0.04),diffuse,metalness);float NoL,NoH,LoH,VoH,diffW,specW,invW,pdf,envPdf,diffuseSamples,specularSamples,envMisProbability,envMisMultiplier;bool isDiffuseSample,isEnvMisSample,isMissedRay;int sampleCounter=0;\n#pragma unroll_loop_start\nfor(int i=0;i<spp;i++){blueNoise=sampleBlueNoise(blueNoiseTexture,frame+sampleCounter++,blueNoiseRepeat,texSize);H=SampleGGXVNDF(V,roughness,roughness,blueNoise.r,blueNoise.g);if(H.z<0.0)H=-H;l=normalize(reflect(-V,H));l=ToWorld(T,B,N,l);l=(vec4(l,0.)*cameraMatrixWorld).xyz;l=normalize(l);h=normalize(v+l);NoL=clamp(dot(n,l),EPSILON,ONE_MINUS_EPSILON);NoH=clamp(dot(n,h),EPSILON,ONE_MINUS_EPSILON);LoH=clamp(dot(l,h),EPSILON,ONE_MINUS_EPSILON);VoH=clamp(dot(v,h),EPSILON,ONE_MINUS_EPSILON);\n#if !defined(diffuseOnly) && !defined(specularOnly)\nF=F_Schlick(f0,VoH);diffW=(1.-metalness)*luminance(diffuse);specW=luminance(F);diffW=max(diffW,EPSILON);specW=max(specW,EPSILON);invW=1./(diffW+specW);diffW*=invW;specW*=invW;isDiffuseSample=blueNoise.b<diffW;\n#else\n#ifdef diffuseOnly\nisDiffuseSample=true;\n#else\nisDiffuseSample=false;\n#endif\n#endif\nenvMisDir=vec3(0.0);\n#ifdef importanceSampling\nenvPdf=sampleEquirectProbability(envMapInfo,blueNoise.rg,envMisDir);envMisDir=normalize((vec4(envMisDir,0.)*cameraMatrixWorld).xyz);envMisProbability=0.25+dot(envMisDir,viewNormal)*0.5;isEnvMisSample=blueNoise.a<envMisProbability;envMisMultiplier=1./(1.-envMisProbability);if(isEnvMisSample){envPdf/=1.-envMisProbability;}else{envPdf=0.0001;}\n#else\nenvPdf=0.0;envMisMultiplier=1.;\n#endif\nif(isDiffuseSample){if(isEnvMisSample){l=envMisDir;}else{l=cosineSampleHemisphere(viewNormal,blueNoise.rg);}h=normalize(v+l);NoL=clamp(dot(n,l),EPSILON,ONE_MINUS_EPSILON);NoH=clamp(dot(n,h),EPSILON,ONE_MINUS_EPSILON);LoH=clamp(dot(l,h),EPSILON,ONE_MINUS_EPSILON);VoH=clamp(dot(v,h),EPSILON,ONE_MINUS_EPSILON);gi=doSample(viewPos,viewDir,viewNormal,worldPos,metalness,roughness,isDiffuseSample,isEnvMisSample,NoV,NoL,NoH,LoH,VoH,blueNoise.rg,l,hitPos,isMissedRay,brdf,pdf);gi*=brdf;if(isEnvMisSample){gi*=misHeuristic(envPdf,pdf);gi/=envPdf;}else{gi/=pdf;gi*=envMisMultiplier;}diffuseSamples++;diffuseGI=mix(diffuseGI,gi,1./diffuseSamples);}else{isEnvMisSample=isEnvMisSample&&roughness>=0.025;if(isEnvMisSample){l=envMisDir;h=normalize(v+l);NoL=clamp(dot(n,l),EPSILON,ONE_MINUS_EPSILON);NoH=clamp(dot(n,h),EPSILON,ONE_MINUS_EPSILON);LoH=clamp(dot(l,h),EPSILON,ONE_MINUS_EPSILON);VoH=clamp(dot(v,h),EPSILON,ONE_MINUS_EPSILON);}gi=doSample(viewPos,viewDir,viewNormal,worldPos,metalness,roughness,isDiffuseSample,isEnvMisSample,NoV,NoL,NoH,LoH,VoH,blueNoise.rg,l,hitPos,isMissedRay,brdf,pdf);gi*=brdf;if(isEnvMisSample){gi*=misHeuristic(envPdf,pdf);gi/=envPdf;}else{gi/=pdf;gi*=envMisMultiplier;}specularSamples++;specularGI=mix(specularGI,gi,1./specularSamples);}}\n#pragma unroll_loop_end\nroughness=sqrt(roughness);\n#ifndef specularOnly\nif(diffuseSamples==0.0)diffuseGI=vec3(-1.0);gDiffuse=vec4(diffuseGI,roughness);\n#endif\n#ifndef diffuseOnly\nfloat rayLength=0.0;if(!isMissedRay&&roughness<0.375&&getCurvature(viewNormal,depth)<0.0005){vec3 hitPosWS=(vec4(hitPos,1.)*viewMatrix).xyz;rayLength=distance(worldPos,hitPosWS);}if(specularSamples==0.0)specularGI=vec3(-1.0);gSpecular=vec4(specularGI,rayLength);\n#endif\n}vec3 doSample(const vec3 viewPos,const vec3 viewDir,const vec3 viewNormal,const vec3 worldPosition,const float metalness,const float roughness,const bool isDiffuseSample,const bool isEnvMisSample,const float NoV,const float NoL,const float NoH,const float LoH,const float VoH,const vec2 random,inout vec3 l,inout vec3 hitPos,out bool isMissedRay,out vec3 brdf,out float pdf){float cosTheta=max(0.0,dot(viewNormal,l));if(isDiffuseSample){vec3 diffuseBrdf=vec3(evalDisneyDiffuse(NoL,NoV,LoH,roughness,metalness));pdf=NoL/M_PI;pdf=max(EPSILON,pdf);brdf=diffuseBrdf;}else{vec3 specularBrdf=evalDisneySpecular(roughness,NoH,NoV,NoL);pdf=GGXVNDFPdf(NoH,NoV,roughness);pdf=max(EPSILON,pdf);brdf=specularBrdf;}brdf*=cosTheta;hitPos=viewPos;\n#if steps == 0\nhitPos+=l;vec2 coords=viewSpaceToScreenSpace(hitPos);\n#else\nvec2 coords=RayMarch(l,hitPos);\n#endif\nbool allowMissedRays=false;\n#ifdef missedRays\nallowMissedRays=true;\n#endif\nisMissedRay=coords.x==-1.0;vec3 envMapSample=vec3(0.);if(isMissedRay||allowMissedRays){\n#ifdef USE_ENVMAP\nvec3 reflectedWS=normalize((vec4(l,0.)*viewMatrix).xyz);\n#ifdef BOX_PROJECTED_ENV_MAP\nreflectedWS=parallaxCorrectNormal(reflectedWS.xyz,envMapSize,envMapPosition,worldPosition);reflectedWS=normalize(reflectedWS.xyz);\n#endif\nfloat mip=envBlur*maxEnvMapMipLevel;if(!isDiffuseSample&&roughness<0.15)mip*=roughness/0.15;envMapSample=sampleEquirectEnvMapColor(reflectedWS,envMapInfo.map,mip);float maxEnvLum=isEnvMisSample ? 50.0 : 5.0;if(maxEnvLum!=0.0){float envLum=luminance(envMapSample);if(envLum>maxEnvLum){envMapSample*=maxEnvLum/envLum;}}return envMapSample;\n#else\nreturn vec3(0.0);\n#endif\n}vec4 velocity=textureLod(velocityTexture,coords.xy,0.0);vec2 reprojectedUv=coords.xy-velocity.xy;vec3 SSGI;if(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){vec4 emissiveTexel=textureLod(emissiveTexture,coords.xy,0.);vec3 emissiveColor=emissiveTexel.rgb*10.;vec3 reprojectedGI=getTexel(accumulatedTexture,reprojectedUv,0.).rgb;SSGI=reprojectedGI+emissiveColor;\n#ifdef useDirectLight\nSSGI+=textureLod(directLightTexture,coords.xy,0.).rgb*directLightMultiplier;\n#endif\n}else{SSGI=textureLod(directLightTexture,vUv,0.).rgb;}if(allowMissedRays){float ssgiLum=luminance(SSGI);float envLum=luminance(envMapSample);if(envLum>ssgiLum)SSGI=envMapSample;}return SSGI;}vec2 RayMarch(inout vec3 dir,inout vec3 hitPos){float rayHitDepthDifference;dir*=rayDistance/float(steps);vec2 uv;for(int i=1;i<steps;i++){float m=exp(pow(float(i)/4.0,0.05))-2.0;hitPos+=dir*min(m,1.);if(hitPos.z>0.0)return INVALID_RAY_COORDS;uv=viewSpaceToScreenSpace(hitPos);\n#ifndef missedRays\nif(uv.x<0.||uv.y<0.||uv.x>1.||uv.y>1.)return INVALID_RAY_COORDS;\n#endif\nfloat unpackedDepth=unpackRGBAToDepth(textureLod(depthTexture,uv,0.0));float depth=fastGetViewZ(unpackedDepth);\n#ifdef autoThickness\nfloat unpackedBackSideDepth=unpackRGBAToDepth(textureLod(backSideDepthTexture,uv,0.0));float backSideDepth=fastGetViewZ(unpackedBackSideDepth);float currentThickness=max(abs(depth-backSideDepth),thickness);\n#else\nfloat currentThickness=thickness;\n#endif\nrayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<currentThickness){\n#if refineSteps == 0\nreturn uv;\n#else\nreturn BinarySearch(dir,hitPos);\n#endif\n}}\n#ifndef missedRays\nreturn INVALID_RAY_COORDS;\n#endif\nreturn uv;}vec2 BinarySearch(inout vec3 dir,inout vec3 hitPos){float rayHitDepthDifference;vec2 uv;dir*=0.5;hitPos-=dir;for(int i=0;i<refineSteps;i++){uv=viewSpaceToScreenSpace(hitPos);float unpackedDepth=unpackRGBAToDepth(textureLod(depthTexture,uv,0.0));float depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;hitPos+=rayHitDepthDifference>0.0 ?-dir : dir;}uv=viewSpaceToScreenSpace(hitPos);return uv;}float fastGetViewZ(const float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\n#else\nreturn depth*nearMinusFar-cameraNear;\n#endif\n}".replace("#include <ssgi_utils>", "#define GLSLIFY 1\n#define PI M_PI\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nvec4 getTexel(const sampler2D tex,vec2 p,const float mip){p=p/invTexSize+0.5;vec2 i=floor(p);vec2 f=p-i;f=f*f*f*(f*(f*6.0-15.0)+10.0);p=i+f;p=(p-0.5)*invTexSize;return textureLod(tex,p,mip);}float getViewZ(const float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}\n#ifdef PERSPECTIVE_CAMERA\nvec3 getViewPosition(const float depth){float clipW=projectionMatrix[2][3]*depth+projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}\n#else\nvec3 getViewPosition(const float depth){float z=getViewZ(depth);vec4 clipPosition=vec4(vUv*2.0-1.0,z,1.0);clipPosition*=clipPosition.z;return(inverseProjectionMatrix*clipPosition).xyz;}\n#endif\nvec2 viewSpaceToScreenSpace(const vec3 position){vec4 projectedCoord=projectionMatrix*vec4(position,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;return projectedCoord.xy;}\n#ifdef BOX_PROJECTED_ENV_MAP\nuniform vec3 envMapSize;uniform vec3 envMapPosition;vec3 parallaxCorrectNormal(const vec3 v,const vec3 cubeSize,const vec3 cubePos,const vec3 worldPosition){vec3 nDir=normalize(v);vec3 rbmax=(.5*cubeSize+cubePos-worldPosition)/nDir;vec3 rbmin=(-.5*cubeSize+cubePos-worldPosition)/nDir;vec3 rbminmax;rbminmax.x=(nDir.x>0.)? rbmax.x : rbmin.x;rbminmax.y=(nDir.y>0.)? rbmax.y : rbmin.y;rbminmax.z=(nDir.z>0.)? rbmax.z : rbmin.z;float correction=min(min(rbminmax.x,rbminmax.y),rbminmax.z);vec3 boxIntersection=worldPosition+nDir*correction;return boxIntersection-cubePos;}\n#endif\n#define M_PI 3.1415926535897932384626433832795\nvec2 equirectDirectionToUv(const vec3 direction){vec2 uv=vec2(atan(direction.z,direction.x),acos(direction.y));uv/=vec2(2.0*M_PI,M_PI);uv.x+=0.5;uv.y=1.0-uv.y;return uv;}vec3 equirectUvToDirection(vec2 uv){uv.x-=0.5;uv.y=1.0-uv.y;float theta=uv.x*2.0*PI;float phi=uv.y*PI;float sinPhi=sin(phi);return vec3(sinPhi*cos(theta),cos(phi),sinPhi*sin(theta));}vec3 sampleEquirectEnvMapColor(const vec3 direction,const sampler2D map,const float lod){return getTexel(map,equirectDirectionToUv(direction),lod).rgb;}mat3 getBasisFromNormal(const vec3 normal){vec3 other;if(abs(normal.x)>0.5){other=vec3(0.0,1.0,0.0);}else{other=vec3(1.0,0.0,0.0);}vec3 ortho=normalize(cross(normal,other));vec3 ortho2=normalize(cross(normal,ortho));return mat3(ortho2,ortho,normal);}vec3 F_Schlick(const vec3 f0,const float theta){return f0+(1.-f0)*pow(1.0-theta,5.);}float F_Schlick(const float f0,const float f90,const float theta){return f0+(f90-f0)*pow(1.0-theta,5.0);}float D_GTR(const float roughness,const float NoH,const float k){float a2=pow(roughness,2.);return a2/(PI*pow((NoH*NoH)*(a2*a2-1.)+1.,k));}float SmithG(const float NDotV,const float alphaG){float a=alphaG*alphaG;float b=NDotV*NDotV;return(2.0*NDotV)/(NDotV+sqrt(a+b-a*b));}float GGXVNDFPdf(const float NoH,const float NoV,const float roughness){float D=D_GTR(roughness,NoH,2.);float G1=SmithG(NoV,roughness*roughness);return(D*G1)/max(0.00001,4.0f*NoV);}float GeometryTerm(const float NoL,const float NoV,const float roughness){float a2=roughness*roughness;float G1=SmithG(NoV,a2);float G2=SmithG(NoL,a2);return G1*G2;}float evalDisneyDiffuse(const float NoL,const float NoV,const float LoH,const float roughness,const float metalness){float FD90=0.5+2.*roughness*pow(LoH,2.);float a=F_Schlick(1.,FD90,NoL);float b=F_Schlick(1.,FD90,NoV);return(a*b/PI)*(1.-metalness);}vec3 evalDisneySpecular(const float roughness,const float NoH,const float NoV,const float NoL){float D=D_GTR(roughness,NoH,2.);float G=GeometryTerm(NoL,NoV,pow(0.5+roughness*.5,2.));vec3 spec=vec3(D*G/(4.*NoL*NoV));return spec;}vec3 SampleGGXVNDF(const vec3 V,const float ax,const float ay,const float r1,const float r2){vec3 Vh=normalize(vec3(ax*V.x,ay*V.y,V.z));float lensq=Vh.x*Vh.x+Vh.y*Vh.y;vec3 T1=lensq>0. ? vec3(-Vh.y,Vh.x,0.)*inversesqrt(lensq): vec3(1.,0.,0.);vec3 T2=cross(Vh,T1);float r=sqrt(r1);float phi=2.0*PI*r2;float t1=r*cos(phi);float t2=r*sin(phi);float s=0.5*(1.0+Vh.z);t2=(1.0-s)*sqrt(1.0-t1*t1)+s*t2;vec3 Nh=t1*T1+t2*T2+sqrt(max(0.0,1.0-t1*t1-t2*t2))*Vh;return normalize(vec3(ax*Nh.x,ay*Nh.y,max(0.0,Nh.z)));}void Onb(const vec3 N,inout vec3 T,inout vec3 B){vec3 up=abs(N.z)<0.9999999 ? vec3(0,0,1): vec3(1,0,0);T=normalize(cross(up,N));B=cross(N,T);}vec3 ToLocal(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return vec3(dot(V,X),dot(V,Y),dot(V,Z));}vec3 ToWorld(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return V.x*X+V.y*Y+V.z*Z;}vec3 cosineSampleHemisphere(const vec3 n,const vec2 u){float r=sqrt(u.x);float theta=2.0*PI*u.y;vec3 b=normalize(cross(n,vec3(0.0,1.0,1.0)));vec3 t=cross(b,n);return normalize(r*sin(theta)*b+sqrt(1.0-u.x)*n+r*cos(theta)*t);}float equirectDirectionPdf(vec3 direction){vec2 uv=equirectDirectionToUv(direction);float theta=uv.y*PI;float sinTheta=sin(theta);if(sinTheta==0.0){return 0.0;}return 1.0/(2.0*PI*PI*sinTheta);}float sampleEquirectProbability(EquirectHdrInfo info,vec2 r,out vec3 direction){float v=textureLod(info.marginalWeights,vec2(r.x,0.0),0.).x;float u=textureLod(info.conditionalWeights,vec2(r.y,v),0.).x;vec2 uv=vec2(u,v);vec3 derivedDirection=equirectUvToDirection(uv);direction=derivedDirection;vec3 color=texture(info.map,uv).rgb;float totalSum=info.totalSumWhole+info.totalSumDecimal;float lum=luminance(color);float pdf=lum/totalSum;return info.size.x*info.size.y*pdf;}float misHeuristic(float a,float b){float aa=a*a;float bb=b*b;return aa/(aa+bb);}float getCurvature(const vec3 n,const float depth){vec3 dx=dFdx(n);vec3 dy=dFdy(n);vec3 xneg=n-dx;vec3 xpos=n+dx;vec3 yneg=n-dy;vec3 ypos=n+dy;float curvature=(cross(xneg,xpos).y-cross(yneg,ypos).x)*4.0/depth;return curvature;}").replace("#include <sampleBlueNoise>", Ov),
                        vertexShader: yv,
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        toneMapped: !1,
                        glslVersion: Se
                    })
                }
            }
            const Hv = new kn(0),
                Gv = new ho({
                    depthPacking: ve,
                    side: 1
                });
            class Vv extends CA {
                constructor(e, t) {
                    super("BackSideDepthPass"), this._scene = e, this._camera = t, this.renderTarget = new dt(1, 1, {
                        minFilter: h,
                        magFilter: h
                    })
                }
                setSize(e, t) {
                    this.renderTarget.setSize(e, t)
                }
                dispose() {
                    super.dispose(), this.renderTarget.dispose()
                }
                render(e) {
                    const {
                        background: t
                    } = this._scene;
                    this._scene.background = Hv, this._scene.overrideMaterial = Gv, e.setRenderTarget(this.renderTarget), e.render(this._scene, this._camera), this._scene.background = t, this._scene.overrideMaterial = null
                }
            }
            var jv = "data:image/png;base64,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";
            const Wv = new kn(0);
            class Xv extends CA {
                constructor(e, t) {
                    super("SSGIPass"), this.needsSwap = !1, this.defaultFragmentShader = "", this.frame = 0, this.cachedMaterials = new WeakMap, this.visibleMeshes = [], this.ssgiEffect = e, this._scene = e._scene, this._camera = e._camera, this.fullscreenMaterial = new zv, this.defaultFragmentShader = this.fullscreenMaterial.fragmentShader;
                    const n = t.diffuseOnly || t.specularOnly ? 1 : 2;
                    this.renderTarget = new Ql(1, 1, n, {
                        type: w,
                        depthBuffer: !1
                    }), this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld, this.fullscreenMaterial.uniforms.viewMatrix.value = this._camera.matrixWorldInverse, this.fullscreenMaterial.uniforms.projectionMatrix.value = this._camera.projectionMatrix, this.fullscreenMaterial.uniforms.inverseProjectionMatrix.value = this._camera.projectionMatrixInverse, e._camera.isPerspectiveCamera && (this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = ""), t.diffuseOnly && (this.fullscreenMaterial.defines.diffuseOnly = ""), t.specularOnly && (this.fullscreenMaterial.defines.specularOnly = ""), this.initMRTRenderTarget()
                }
                initialize(e, ...t) {
                    super.initialize(e, ...t), (new al).load(jv, (e => {
                        e.minFilter = h, e.magFilter = h, e.wrapS = l, e.wrapT = l, e.colorSpace = ye, this.fullscreenMaterial.uniforms.blueNoiseTexture.value = e
                    }))
                }
                get texture() {
                    return this.renderTarget.texture[0]
                }
                get specularTexture() {
                    const e = "specularOnly" in this.fullscreenMaterial.defines ? 0 : 1;
                    return this.renderTarget.texture[e]
                }
                initMRTRenderTarget() {
                    this.gBuffersRenderTarget = new Ql(1, 1, 4, {
                        minFilter: h,
                        magFilter: h
                    }), this.gBuffersRenderTarget.depthTexture = new Cr(1, 1), this.gBuffersRenderTarget.depthTexture.type = b, this.backSideDepthPass = new Vv(this._scene, this._camera), this.depthTexture = this.gBuffersRenderTarget.texture[0], this.normalTexture = this.gBuffersRenderTarget.texture[1], this.diffuseTexture = this.gBuffersRenderTarget.texture[2], this.emissiveTexture = this.gBuffersRenderTarget.texture[3], this.diffuseTexture.minFilter = f, this.diffuseTexture.magFilter = f, this.diffuseTexture.colorSpace = _e, this.diffuseTexture.needsUpdate = !0, this.emissiveTexture.minFilter = f, this.emissiveTexture.magFilter = f, this.emissiveTexture.type = w, this.emissiveTexture.needsUpdate = !0, this.normalTexture.type = w, this.normalTexture.needsUpdate = !0, this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture, this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture, this.fullscreenMaterial.uniforms.diffuseTexture.value = this.diffuseTexture, this.fullscreenMaterial.uniforms.emissiveTexture.value = this.emissiveTexture, this.fullscreenMaterial.uniforms.backSideDepthTexture.value = this.backSideDepthPass.renderTarget.texture
                }
                setSize(e, t) {
                    this.renderTarget.setSize(e * this.ssgiEffect.resolutionScale, t * this.ssgiEffect.resolutionScale), this.gBuffersRenderTarget.setSize(e, t), this.backSideDepthPass.setSize(e, t), this.fullscreenMaterial.uniforms.texSize.value.set(this.renderTarget.width, this.renderTarget.height)
                }
                dispose() {
                    super.dispose(), this.renderTarget.dispose(), this.gBuffersRenderTarget.dispose(), this.backSideDepthPass.dispose(), this.fullscreenMaterial.dispose(), this.normalTexture = null, this.depthTexture = null, this.diffuseTexture = null, this.emissiveTexture = null
                }
                setMRTMaterialInScene() {
                    this.visibleMeshes = av(this._scene);
                    for (const r of this.visibleMeshes) {
                        var e, t, n;
                        const s = r.material;
                        let [o, a] = this.cachedMaterials.get(r) || [];
                        if (s !== o) {
                            var i;
                            a && a.dispose(), a = new Nv, vv(s, a), a.uniforms.normalScale.value = s.normalScale, null != (i = r.skeleton) && i.boneTexture && (a.defines.USE_SKINNING = "", a.defines.BONE_TEXTURE = "", a.uniforms.boneTexture.value = r.skeleton.boneTexture, a.needsUpdate = !0);
                            const e = Object.keys(s).find((e => {
                                const t = s[e];
                                return t instanceof ct && t.matrix
                            }));
                            e && (a.uniforms.uvTransform.value = s[e].matrix), this.cachedMaterials.set(r, [s, a])
                        }
                        s.emissive && (a.uniforms.emissive.value = s.emissive), s.color && (a.uniforms.color.value = s.color), lv(a, s, "normalMap", "USE_NORMALMAP"), lv(a, s, "roughnessMap", "USE_ROUGHNESSMAP"), lv(a, s, "metalnessMap", "USE_\tMETALNESSMAP"), lv(a, s, "map", "USE_MAP"), lv(a, s, "emissiveMap", "USE_EMISSIVEMAP"), lv(a, s, "alphaMap", "USE_ALPHAMAP");
                        const l = this.fullscreenMaterial.uniforms.blueNoiseTexture.value;
                        if (l) {
                            const {
                                width: e,
                                height: t
                            } = l.source.data;
                            a.uniforms.blueNoiseTexture.value = l, a.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / e, this.renderTarget.height / t)
                        }
                        a.uniforms.texSize.value.set(this.renderTarget.width, this.renderTarget.height), a.uniforms.frame.value = this.frame, r.visible = gv(r, s);
                        const c = null !== (e = s.roughness) && void 0 !== e ? e : 1;
                        a.uniforms.roughness.value = 0 === this.ssgiEffect.selection.size || this.ssgiEffect.selection.has(r) ? c : 1e11, a.uniforms.metalness.value = null !== (t = r.material.metalness) && void 0 !== t ? t : 0, a.uniforms.emissiveIntensity.value = null !== (n = r.material.emissiveIntensity) && void 0 !== n ? n : 0, r.material = a
                    }
                }
                unsetMRTMaterialInScene() {
                    for (const e of this.visibleMeshes) {
                        e.visible = !0;
                        const [t] = this.cachedMaterials.get(e);
                        e.material = t
                    }
                }
                render(e) {
                    this.frame = (this.frame + this.ssgiEffect.spp) % 65536;
                    const {
                        background: t
                    } = this._scene;
                    this._scene.background = Wv, this.setMRTMaterialInScene(), e.setRenderTarget(this.gBuffersRenderTarget), e.render(this._scene, this._camera), this.unsetMRTMaterialInScene(), this.ssgiEffect.autoThickness && this.backSideDepthPass.render(e), this.fullscreenMaterial.uniforms.frame.value = this.frame, this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near, this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far, this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse), this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssgiEffect.svgf.denoisePass.texture;
                    const n = this.fullscreenMaterial.uniforms.blueNoiseTexture.value;
                    if (n) {
                        const {
                            width: e,
                            height: t
                        } = n.source.data;
                        this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / e, this.renderTarget.height / t)
                    }
                    e.setRenderTarget(this.renderTarget), e.render(this.scene, this.camera), this._scene.background = t
                }
            }
            const Yv = {
                    distance: 10,
                    thickness: 10,
                    autoThickness: !1,
                    maxRoughness: 1,
                    blend: .9,
                    denoiseIterations: 1,
                    denoiseKernel: 2,
                    denoiseDiffuse: 10,
                    denoiseSpecular: 10,
                    depthPhi: 2,
                    normalPhi: 50,
                    roughnessPhi: 1,
                    envBlur: .5,
                    importanceSampling: !0,
                    directLightMultiplier: 1,
                    steps: 20,
                    refineSteps: 5,
                    spp: 1,
                    resolutionScale: 1,
                    missedRays: !1
                },
                {
                    render: qv
                } = qA.prototype,
                Kv = (() => {
                    if (Vi.envmap_physical_pars_fragment.includes("iblIrradianceDisabled") || (Vi.envmap_physical_pars_fragment = Vi.envmap_physical_pars_fragment.replace("vec3 getIBLIrradiance( const in vec3 normal ) {", "\n\t\t\tuniform bool iblIrradianceDisabled;\n\t\t\n\t\t\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t\t if(iblIrradianceDisabled) return vec3(0.);\n\t\t\t")), "iblIrradianceDisabled" in Wi.physical.uniforms) return Wi.physical.uniforms.iblIrradianceDisabled;
                    const e = {
                        value: !1
                    };
                    Wi.physical.uniforms.iblIrradianceDisabled = e;
                    const {
                        clone: t
                    } = bi;
                    return bi.clone = n => {
                        const i = t(n);
                        return "iblIrradianceDisabled" in n && (i.iblIrradianceDisabled = e), i
                    }, e
                })(),
                Jv = (() => {
                    if (Vi.envmap_physical_pars_fragment.includes("iblRadianceDisabled") || (Vi.envmap_physical_pars_fragment = Vi.envmap_physical_pars_fragment.replace("vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {", "\n\t\tuniform bool iblRadianceDisabled;\n\t\n\t\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t if(iblRadianceDisabled) return vec3(0.);\n\t\t")), "iblRadianceDisabled" in Wi.physical.uniforms) return Wi.physical.uniforms.iblRadianceDisabled;
                    const e = {
                        value: !1
                    };
                    Wi.physical.uniforms.iblRadianceDisabled = e;
                    const {
                        clone: t
                    } = bi;
                    return bi.clone = n => {
                        const i = t(n);
                        return "iblRadianceDisabled" in n && (i.iblRadianceDisabled = e), i
                    }, e
                })();
            (class extends XA {
                constructor(e, t, n, i = Yv) {
                    if (i = {
                            ...Yv,
                            ...i
                        }, super("SSGIEffect", "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D sceneTexture;uniform sampler2D depthTexture;uniform int toneMapping;\n#include <tonemapping_pars_fragment>\n#pragma tonemapping_pars_fragment\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 depthTexel=textureLod(depthTexture,uv,0.);vec3 ssgiClr;if(dot(depthTexel.rgb,depthTexel.rgb)==0.){ssgiClr=textureLod(sceneTexture,uv,0.).rgb;}else{ssgiClr=textureLod(inputTexture,uv,0.).rgb;switch(toneMapping){case 1:ssgiClr=LinearToneMapping(ssgiClr);break;case 2:ssgiClr=ReinhardToneMapping(ssgiClr);break;case 3:ssgiClr=OptimizedCineonToneMapping(ssgiClr);break;case 4:ssgiClr=ACESFilmicToneMapping(ssgiClr);break;case 5:ssgiClr=CustomToneMapping(ssgiClr);break;}ssgiClr*=toneMappingExposure;}outputColor=vec4(ssgiClr,1.0);}", {
                            type: "FinalSSGIMaterial",
                            uniforms: new Map([
                                ["inputTexture", new Ll(null)],
                                ["sceneTexture", new Ll(null)],
                                ["depthTexture", new Ll(null)],
                                ["toneMapping", new Ll(0)]
                            ])
                        }), this.selection = new kA, this.isUsingRenderPass = !0, !(t instanceof Ii)) throw new Error(this.constructor.name + " doesn't support cameras of type '" + t.constructor.name + "' yet. Only cameras of type 'PerspectiveCamera' are supported.");
                    let r;
                    this._scene = e, this._camera = t, i.diffuseOnly ? (r = "ssdgi", i.reprojectSpecular = !1, i.roughnessDependent = !1, i.basicVariance = 25e-5, i.neighborhoodClamp = !1) : i.specularOnly ? (r = "ssr", i.reprojectSpecular = !0, i.roughnessDependent = !0, i.basicVariance = 25e-5, i.neighborhoodClamp = !0) : (r = "ssgi", i.reprojectSpecular = [!1, !0], i.neighborhoodClamp = [!1, !0], i.roughnessDependent = [!1, !0], i.basicVariance = [25e-5, 25e-5]), i.neighborhoodClampRadius = 2, i.neighborhoodClampIntensity = .5;
                    const s = i.diffuseOnly || i.specularOnly ? 1 : 2;
                    i = {
                        ...i,
                        denoiseCustomComposeShader: "#define GLSLIFY 1\nvec3 viewNormal=(vec4(normal,0.)*cameraMatrixWorld).xyz;roughness*=roughness;vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 T,B;vec3 n=viewNormal;vec3 v=viewDir;vec3 V=(vec4(v,0.)*viewMatrix).xyz;vec3 N=normal;Onb(N,T,B);V=ToLocal(T,B,N,V);vec3 H=SampleGGXVNDF(V,roughness,roughness,0.25,0.25);if(H.z<0.0)H=-H;vec3 l=normalize(reflect(-V,H));l=ToWorld(T,B,N,l);l=(vec4(l,1.)*cameraMatrixWorld).xyz;l=normalize(l);if(dot(viewNormal,l)<0.)l=-l;vec3 h=normalize(v+l);float VoH=max(EPSILON,dot(v,h));VoH=pow(VoH,0.875);vec4 diffuseTexel=textureLod(diffuseTexture,vUv,0.);vec3 diffuse=diffuseTexel.rgb;float metalness=diffuseTexel.a;vec3 f0=mix(vec3(0.04),diffuse,metalness);vec3 F=F_Schlick(f0,VoH);vec3 directLight=textureLod(directLightTexture,vUv,0.).rgb;\n#ifdef ssgi\nvec3 diffuseLightingColor=denoisedColor[0];vec3 diffuseComponent=diffuse*(1.-metalness)*(1.-F)*diffuseLightingColor;vec3 specularLightingColor=denoisedColor[1];vec3 specularComponent=specularLightingColor*F;denoisedColor[0]=diffuseComponent+specularComponent;\n#endif\n#ifdef ssdgi\nvec3 diffuseLightingColor=denoisedColor[0];vec3 diffuseComponent=diffuse*(1.-metalness)*(1.-F)*diffuseLightingColor;denoisedColor[0]=diffuseComponent;\n#endif\n#ifdef ssr\nvec3 specularLightingColor=denoisedColor[0];vec3 specularComponent=specularLightingColor*F;denoisedColor[0]=specularComponent;\n#endif\n#ifdef useDirectLight\ndenoisedColor[0]+=directLight;\n#endif\n",
                        denoiseCustomComposeShaderFunctions: "#define GLSLIFY 1\nuniform sampler2D diffuseTexture;uniform sampler2D directLightTexture;vec3 getViewPosition(const float depth){float clipW=projectionMatrix[2][3]*depth+projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(projectionMatrixInverse*clipPosition).xyz;}vec3 F_Schlick(const vec3 f0,const float theta){return f0+(1.-f0)*pow(1.0-theta,5.);}vec3 SampleGGXVNDF(const vec3 V,const float ax,const float ay,const float r1,const float r2){vec3 Vh=normalize(vec3(ax*V.x,ay*V.y,V.z));float lensq=Vh.x*Vh.x+Vh.y*Vh.y;vec3 T1=lensq>0. ? vec3(-Vh.y,Vh.x,0.)*inversesqrt(lensq): vec3(1.,0.,0.);vec3 T2=cross(Vh,T1);float r=sqrt(r1);float phi=2.0*PI*r2;float t1=r*cos(phi);float t2=r*sin(phi);float s=0.5*(1.0+Vh.z);t2=(1.0-s)*sqrt(1.0-t1*t1)+s*t2;vec3 Nh=t1*T1+t2*T2+sqrt(max(0.0,1.0-t1*t1-t2*t2))*Vh;return normalize(vec3(ax*Nh.x,ay*Nh.y,max(0.0,Nh.z)));}void Onb(const vec3 N,inout vec3 T,inout vec3 B){vec3 up=abs(N.z)<0.9999999 ? vec3(0,0,1): vec3(1,0,0);T=normalize(cross(up,N));B=cross(N,T);}vec3 ToLocal(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return vec3(dot(V,X),dot(V,Y),dot(V,Z));}vec3 ToWorld(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return V.x*X+V.y*Y+V.z*Z;}"
                    }, this.svgf = new Lv(e, t, n, s, i), "ssgi" === r ? this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader = this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader.replace("accumulatedTexel[ 1 ].rgb = clampedColor;", "\n\t\t\t\t\t\tfloat roughness = inputTexel[ 0 ].a;\n\t\t\t\t\t\taccumulatedTexel[ 1 ].rgb = mix(accumulatedTexel[ 1 ].rgb, clampedColor, 1. - sqrt(roughness));\n\t\t\t\t\t\t") : "ssr" === r && (this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader = this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader.replace("accumulatedTexel[ 0 ].rgb = clampedColor;", "\n\t\t\t\t\taccumulatedTexel[ 0 ].rgb = mix(accumulatedTexel[ 0 ].rgb, clampedColor, 0.5);\n\t\t\t\t\t")), this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.needsUpdate = !0, this.ssgiPass = new Xv(this, i), i.diffuseOnly ? this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = this.ssgiPass.texture : i.specularOnly ? this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = this.ssgiPass.specularTexture : (this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = this.ssgiPass.texture, this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture1.value = this.ssgiPass.specularTexture), this.svgf.setJitteredGBuffers(this.ssgiPass.depthTexture, this.ssgiPass.normalTexture, {
                        useRoughnessInAlphaChannel: !0
                    }), this.svgf.denoisePass.fullscreenMaterial.uniforms = {
                        ...this.svgf.denoisePass.fullscreenMaterial.uniforms,
                        diffuseTexture: new Ll(null),
                        directLightTexture: new Ll(null)
                    }, this.svgf.denoisePass.fullscreenMaterial.defines[r] = "", this.svgf.denoisePass.fullscreenMaterial.uniforms.diffuseTexture.value = this.ssgiPass.diffuseTexture, this.lastSize = {
                        width: i.width,
                        height: i.height,
                        resolutionScale: i.resolutionScale
                    }, this.sceneRenderTarget = new dt(1, 1, {
                        colorSpace: _e
                    }), this.renderPass = new qA(this._scene, this._camera), this.renderPass.renderToScreen = !1, this.setSize(i.width, i.height);
                    const o = this,
                        a = this.renderPass;
                    qA.prototype.render = function(...e) {
                        if (this !== a) {
                            const e = o.isUsingRenderPass;
                            o.isUsingRenderPass = !0, e != o.isUsingRenderPass && o.updateUsingRenderPass()
                        }
                        qv.call(this, ...e)
                    }, this.makeOptionsReactive(i)
                }
                updateUsingRenderPass() {
                    this.isUsingRenderPass ? (this.ssgiPass.fullscreenMaterial.defines.useDirectLight = "", this.svgf.denoisePass.fullscreenMaterial.defines.useDirectLight = "") : (delete this.ssgiPass.fullscreenMaterial.defines.useDirectLight, delete this.svgf.denoisePass.fullscreenMaterial.defines.useDirectLight), this.ssgiPass.fullscreenMaterial.needsUpdate = !0, this.svgf.denoisePass.fullscreenMaterial.needsUpdate = !0
                }
                makeOptionsReactive(e) {
                    let t = !1;
                    const n = this.ssgiPass.fullscreenMaterial.uniforms,
                        i = Object.keys(n),
                        r = this.svgf.svgfTemporalReprojectPass;
                    for (const s of Object.keys(e)) Object.defineProperty(this, s, {
                        get: () => e[s],
                        set(o) {
                            if (e[s] !== o || !t) switch (e[s] = o, s) {
                                case "denoiseIterations":
                                    this.svgf.denoisePass.iterations = o;
                                    break;
                                case "denoiseDiffuse":
                                    this.svgf.denoisePass.fullscreenMaterial.uniforms.denoise.value[0] = o;
                                    break;
                                case "denoiseSpecular":
                                    this.svgf.denoisePass.fullscreenMaterial.uniforms.denoise.value[1] = o;
                                    break;
                                case "denoiseKernel":
                                case "depthPhi":
                                case "normalPhi":
                                case "roughnessPhi":
                                    this.svgf.denoisePass.fullscreenMaterial.uniforms[s].value = o;
                                    break;
                                case "resolutionScale":
                                    this.setSize(this.lastSize.width, this.lastSize.height), r.reset();
                                    break;
                                case "spp":
                                    this.ssgiPass.fullscreenMaterial.fragmentShader = this.ssgiPass.defaultFragmentShader.replaceAll("spp", o), 1 !== o && (this.ssgiPass.fullscreenMaterial.fragmentShader = fv(this.ssgiPass.fullscreenMaterial.fragmentShader.replace("#pragma unroll_loop_start", "").replace("#pragma unroll_loop_end", ""))), this.ssgiPass.fullscreenMaterial.needsUpdate = t, r.reset();
                                    break;
                                case "steps":
                                case "refineSteps":
                                    this.ssgiPass.fullscreenMaterial.defines[s] = parseInt(o), this.ssgiPass.fullscreenMaterial.needsUpdate = t, r.reset();
                                    break;
                                case "directLightMultiplier":
                                    this.ssgiPass.fullscreenMaterial.defines[s] = o.toPrecision(5), this.ssgiPass.fullscreenMaterial.needsUpdate = t, r.reset();
                                    break;
                                case "importanceSampling":
                                case "missedRays":
                                case "autoThickness":
                                    o ? this.ssgiPass.fullscreenMaterial.defines[s] = "" : delete this.ssgiPass.fullscreenMaterial.defines[s], this.ssgiPass.fullscreenMaterial.needsUpdate = t, r.reset();
                                    break;
                                case "blend":
                                    this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms[s].value = o, r.reset();
                                    break;
                                case "distance":
                                    n.rayDistance.value = o, r.reset();
                                    break;
                                default:
                                    i.includes(s) && (n[s].value = o, r.reset())
                            }
                        }
                    }), this[s] = e[s];
                    t = !0
                }
                initialize(e, ...t) {
                    super.initialize(e, ...t), this.ssgiPass.initialize(e, ...t)
                }
                setSize(e, t, n = !1) {
                    var i;
                    void 0 === e && void 0 === t || (n || e !== this.lastSize.width || t !== this.lastSize.height || this.resolutionScale !== this.lastSize.resolutionScale) && (this.ssgiPass.setSize(e, t), this.svgf.setSize(e, t), this.sceneRenderTarget.setSize(e, t), null == (i = this.cubeToEquirectEnvPass) || i.setSize(e, t), this.lastSize = {
                        width: e,
                        height: t,
                        resolutionScale: this.resolutionScale
                    })
                }
                dispose() {
                    var e;
                    super.dispose(), this.ssgiPass.dispose(), this.svgf.dispose(), null == (e = this.cubeToEquirectEnvPass) || e.dispose(), qA.prototype.render = qv
                }
                keepEnvMapUpdated(e) {
                    const t = this.ssgiPass.fullscreenMaterial;
                    let n = this._scene.environment;
                    if (n) {
                        if (t.uniforms.envMapInfo.value.mapUuid !== n.uuid) {
                            n.isCubeTexture && (this.cubeToEquirectEnvPass || (this.cubeToEquirectEnvPass = new Uv), n = this.cubeToEquirectEnvPass.generateEquirectEnvMap(e, n), n.uuid = this._scene.environment.uuid), n.generateMipmaps || (n.generateMipmaps = !0, n.minFilter = g, n.magFilter = g, n.needsUpdate = !0), t.uniforms.envMapInfo.value.mapUuid = n.uuid;
                            const i = (e => {
                                const {
                                    width: t,
                                    height: n
                                } = e.image;
                                return Math.floor(Math.log2(Math.max(t, n))) + 1
                            })(n);
                            t.uniforms.maxEnvMapMipLevel.value = i, t.uniforms.envMapInfo.value.map = n, t.defines.USE_ENVMAP = "", delete t.defines.importanceSampling, this.importanceSampling ? t.uniforms.envMapInfo.value.updateFrom(n, e).then((() => {
                                t.defines.importanceSampling = "", t.needsUpdate = !0
                            })) : t.uniforms.envMapInfo.value.map = n, this.svgf.svgfTemporalReprojectPass.reset(), t.needsUpdate = !0
                        }
                    } else "USE_ENVMAP" in t.defines && (delete t.defines.USE_ENVMAP, delete t.defines.importanceSampling, t.needsUpdate = !0)
                }
                update(e, t) {
                    this.keepEnvMapUpdated(e);
                    const n = this.isUsingRenderPass ? t : this.sceneRenderTarget,
                        i = [];
                    if (!this.isUsingRenderPass) {
                        const t = [];
                        for (const e of av(this._scene)) {
                            if (e.isScene) return;
                            e.visible = !gv(e), e.visible ? i.push(e) : t.push(e)
                        }
                        this.renderPass.render(e, this.sceneRenderTarget);
                        for (const e of t) e.visible = !0;
                        for (const e of i) e.visible = !1
                    }
                    this.ssgiPass.fullscreenMaterial.uniforms.directLightTexture.value = n.texture, this.svgf.denoisePass.fullscreenMaterial.uniforms.directLightTexture.value = n.texture, this.ssgiPass.render(e), this.svgf.render(e), this.uniforms.get("inputTexture").value = this.svgf.texture, this.uniforms.get("sceneTexture").value = n.texture, this.uniforms.get("depthTexture").value = this.ssgiPass.depthTexture, this.uniforms.get("toneMapping").value = e.toneMapping;
                    for (const e of i) e.visible = !0;
                    const r = !this.diffuseOnly && !this.specularOnly;
                    Kv.value = r || !0 === this.diffuseOnly, Jv.value = r || 1 == this.specularOnly, cancelAnimationFrame(this.rAF2), cancelAnimationFrame(this.rAF), cancelAnimationFrame(this.usingRenderPassRAF), this.rAF = requestAnimationFrame((() => {
                        this.rAF2 = requestAnimationFrame((() => {
                            Kv.value = !1, Jv.value = !1
                        }))
                    })), this.usingRenderPassRAF = requestAnimationFrame((() => {
                        const e = this.isUsingRenderPass;
                        this.isUsingRenderPass = !1, e != this.isUsingRenderPass && this.updateUsingRenderPass()
                    }))
                }
            }).DefaultOptions = Yv;
            const Zv = {
                intensity: 1,
                jitter: 1,
                samples: 16
            };
            class $v extends XA {
                constructor(e, t = Zv) {
                    t = {
                        ...Zv,
                        ...t
                    }, super("MotionBlurEffect", "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D velocityTexture;uniform sampler2D blueNoiseTexture;uniform ivec2 blueNoiseSize;uniform vec2 texSize;uniform float intensity;uniform float jitter;uniform float deltaTime;uniform int frame;uvec4 s0,s1;ivec2 pixel;void rng_initialize(vec2 p,int frame){pixel=ivec2(p);s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y));s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585);}void pcg4d(inout uvec4 v){v=v*1664525u+1013904223u;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z;v=v ^(v>>16u);v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z;}ivec2 shift2(){pcg4d(s1);return(pixel+ivec2(s1.xy % 0x0fffffffu))% blueNoiseSize;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 velocity=textureLod(velocityTexture,vUv,0.0);if(dot(velocity.xyz,velocity.xyz)==0.0){outputColor=inputColor;return;}velocity.xy*=intensity;rng_initialize(vUv*texSize,frame);vec2 blueNoise=texelFetch(blueNoiseTexture,shift2(),0).rg-0.5;vec2 jitterOffset=jitter*velocity.xy*blueNoise;float frameSpeed=(1./100.)/deltaTime;vec2 startUv=vUv+(jitterOffset-velocity.xy*0.5)*frameSpeed;vec2 endUv=vUv+(jitterOffset+velocity.xy*0.5)*frameSpeed;startUv=max(vec2(0.),startUv);endUv=min(vec2(1.),endUv);vec3 motionBlurredColor;for(float i=0.0;i<=samplesFloat;i++){vec2 reprojectedUv=mix(startUv,endUv,i/samplesFloat);vec3 neighborColor=textureLod(inputTexture,reprojectedUv,0.0).rgb;motionBlurredColor+=neighborColor;}motionBlurredColor/=samplesFloat;outputColor=vec4(motionBlurredColor,inputColor.a);}", {
                        type: "MotionBlurMaterial",
                        uniforms: new Map([
                            ["inputTexture", new Ll(null)],
                            ["velocityTexture", new Ll(e.texture)],
                            ["blueNoiseTexture", new Ll(null)],
                            ["blueNoiseSize", new Ll(new ze)],
                            ["texSize", new Ll(new ze)],
                            ["intensity", new Ll(1)],
                            ["jitter", new Ll(1)],
                            ["frame", new Ll(0)],
                            ["deltaTime", new Ll(0)]
                        ]),
                        defines: new Map([
                            ["samples", t.samples.toFixed(0)],
                            ["samplesFloat", t.samples.toFixed(0) + ".0"]
                        ])
                    }), this.pointsIndex = 0, this.makeOptionsReactive(t)
                }
                makeOptionsReactive(e) {
                    for (const t of Object.keys(e)) Object.defineProperty(this, t, {
                        get: () => e[t],
                        set(n) {
                            switch (e[t] = n, t) {
                                case "intensity":
                                case "jitter":
                                    this.uniforms.get(t).value = n
                            }
                        }
                    }), this[t] = e[t]
                }
                initialize(e, ...t) {
                    super.initialize(e, ...t), (new al).load(jv, (e => {
                        e.minFilter = h, e.magFilter = h, e.wrapS = l, e.wrapT = l, e.colorSpace = ye, this.uniforms.get("blueNoiseTexture").value = e
                    }))
                }
                update(e, t, n) {
                    this.uniforms.get("inputTexture").value = t.texture, this.uniforms.get("deltaTime").value = Math.max(.001, n);
                    const i = e.info.render.frame % 65536;
                    this.uniforms.get("frame").value = i, this.uniforms.get("texSize").value.set(window.innerWidth, window.innerHeight);
                    const r = this.uniforms.get("blueNoiseTexture").value;
                    if (r) {
                        const {
                            width: e,
                            height: t
                        } = r.source.data;
                        this.uniforms.get("blueNoiseSize").value.set(e, t)
                    }
                }
            }
            const ey = `\n#define MAX_BONES 64\n                    \n${Vi.skinning_pars_vertex}\n\n\t\t#ifdef USE_SKINNING\n\t\t#ifdef BONE_TEXTURE\n\t\t\tuniform sampler2D prevBoneTexture;\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tfloat j = i * 4.0;\n\t\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\t\ty = dy * ( y + 0.5 );\n\t\t\t\tvec4 v1 = textureLod( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ), 0. );\n\t\t\t\tvec4 v2 = textureLod( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ), 0. );\n\t\t\t\tvec4 v3 = textureLod( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ), 0. );\n\t\t\t\tvec4 v4 = textureLod( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ), 0. );\n\t\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#else\n\t\t\tuniform mat4 prevBoneMatrices[ MAX_BONES ];\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tmat4 bone = prevBoneMatrices[ int(i) ];\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#endif\n\t\t#endif\n\n\nuniform mat4 velocityMatrix;\nuniform mat4 prevVelocityMatrix;\nvarying vec4 prevPosition;\nvarying vec4 newPosition;\n\n#ifdef renderDepth\nvarying vec2 vHighPrecisionZW;\n#endif\n`,
                ty = `\n// Get the current vertex position\ntransformed = vec3( position );\n${Vi.skinning_vertex}\nnewPosition = velocityMatrix * vec4( transformed, 1.0 );\n\n// Get the previous vertex position\ntransformed = vec3( position );\n${Vi.skinbase_vertex.replace(/mat4 /g,"").replace(/getBoneMatrix/g,"getPrevBoneMatrix")}\n${Vi.skinning_vertex.replace(/vec4 /g,"")}\nprevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );\n\ngl_Position = newPosition;\n\n#ifdef renderDepth\nvHighPrecisionZW = gl_Position.zw;\n#endif\n`,
                ny = {
                    prevVelocityMatrix: {
                        value: new Wt
                    },
                    velocityMatrix: {
                        value: new Wt
                    },
                    prevBoneTexture: {
                        value: null
                    },
                    boneTexture: {
                        value: null
                    },
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new ze
                    },
                    uvTransform: {
                        value: new He
                    }
                };
            class iy extends wi {
                constructor() {
                    super({
                        uniforms: bi.clone(ny),
                        glslVersion: Se,
                        vertexShader: `\n\t\t\t\t\t#include <common>\n\t\t\t\t\t#include <uv_pars_vertex>\n\t\t\t\t\t#include <displacementmap_pars_vertex>\n\t\t\t\t\t#include <normal_pars_vertex>\n\t\t\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\t\t#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\t\t\t\t\t\tvarying vec3 vViewPosition;\n\t\t\t\t\t#endif\n\t\t\t\t\t\n                    ${ey}\n        \n                    void main() {\n\t\t\t\t\t\tvec3 transformed;\n\n\t\t\t\t\t\t#include <uv_vertex>\n\n\t\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t\t\t#include <skinnormal_vertex>\n\t\t\t\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t\t\t\t#include <morphnormal_vertex>\n\t\t\t\t\t\t#include <normal_vertex>\n\t\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t\t#include <displacementmap_vertex>\n\t\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t\t#include <clipping_planes_vertex>\n\n\t\t\t\t\t\t${ty}\n\n\t\t\t\t\t\t#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\t\t\t\t\t\t\tvViewPosition = - mvPosition.xyz;\n\t\t\t\t\t\t#endif\n\n                    }`,
                        fragmentShader: `\n\t\t\t\t\t#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\t\t\t\t\t\tvarying vec3 vViewPosition;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef renderDepth\n\t\t\t\t\tlayout(location = 0) out vec4 gDepth;\n\t\t\t\t\tlayout(location = 1) out vec4 gVelocity;\n\t\t\t\t\t#else\n\t\t\t\t\t#define gVelocity gl_FragColor\n\t\t\t\t\t#endif\n\n\t\t\t\t\t\nvarying vec4 prevPosition;\nvarying vec4 newPosition;\n\n#ifdef renderDepth\nvarying vec2 vHighPrecisionZW;\n#endif\n\n\t\t\t\t\t#include <packing>\n\n\t\t\t\t\t#include <uv_pars_fragment>\n\t\t\t\t\t#include <normal_pars_fragment>\n\n\t\t\t\t\t// source: https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\n\t\t\t\t\tvec2 OctWrap( vec2 v ) {\n\t\t\t\t\t\tvec2 w = 1.0 - abs( v.yx );\n\t\t\t\t\t\tif (v.x < 0.0) w.x = -w.x;\n\t\t\t\t\t\tif (v.y < 0.0) w.y = -w.y;\n\t\t\t\t\t\treturn w;\n\t\t\t\t\t}\n\n\t\t\t\t\tvec2 Encode( vec3 n ) {\n\t\t\t\t\t\tn /= ( abs( n.x ) + abs( n.y ) + abs( n.z ) );\n\t\t\t\t\t\tn.xy = n.z > 0.0 ? n.xy : OctWrap( n.xy );\n\t\t\t\t\t\tn.xy = n.xy * 0.5 + 0.5;\n\t\t\t\t\t\treturn n.xy;\n\t\t\t\t\t}\n\n                    void main() {\n\t\t\t\t\t\t#include <normal_fragment_begin>\n                    \t#include <normal_fragment_maps>\n\n\t\t\t\t\t\t${"\nvec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;\nvec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;\n\nvec2 vel = pos1 - pos0;\n\n#ifdef renderDepth\nfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n#endif\n\ngl_FragColor = vec4(vel.x, vel.y, 0., 0.);\n".replaceAll("gl_FragColor","gVelocity")}\n\t\t\t\t\t\tvec3 worldNormal = normalize((vec4(normal, 0.) * viewMatrix).xyz);\n\t\t\t\t\t\tgVelocity.ba = Encode(worldNormal);\n\n\t\t\t\t\t\t#ifdef renderDepth\n\t\t\t\t\t\tgDepth = packDepthToRGBA(fragCoordZ);\n\t\t\t\t\t\t#endif\n                    }`
                    }), this.isVelocityMaterial = !0
                }
            }
            const ry = new kn(0),
                sy = new ze,
                oy = new Wt,
                ay = new Wt;
            class ly extends CA {
                constructor(e, t, n = !0) {
                    if (super("velocityDepthNormalPass"), this.cachedMaterials = new WeakMap, this.visibleMeshes = [], this.needsSwap = !1, !(t instanceof Ii)) throw new Error(this.constructor.name + " doesn't support cameras of type '" + t.constructor.name + "' yet. Only cameras of type 'PerspectiveCamera' are supported.");
                    this._scene = e, this._camera = t;
                    const i = n ? 2 : 1;
                    this.renderTarget = new Ql(1, 1, i, {
                        minFilter: h,
                        magFilter: h
                    }), this.renderTarget.depthTexture = new Cr(1, 1), this.renderTarget.depthTexture.type = b, n && (this.renderTarget.texture[0].type = A, this.renderTarget.texture[0].needsUpdate = !0, this.renderTarget.texture[1].type = b, this.renderTarget.texture[1].needsUpdate = !0), this.renderDepth = n
                }
                setVelocityDepthNormalMaterialInScene() {
                    this.visibleMeshes = av(this._scene);
                    for (const t of this.visibleMeshes) {
                        const n = t.material;
                        let [i, r] = this.cachedMaterials.get(t) || [];
                        var e;
                        n !== i && (r = new iy, vv(n, r), t.material = r, null != (e = t.skeleton) && e.boneTexture && cv(t), this.cachedMaterials.set(t, [n, r])), t.material = r, t.visible = gv(t, n), this.renderDepth && (r.defines.renderDepth = "");
                        const s = n.map || n.normalMap || n.roughnessMap || n.metalnessMap;
                        s && (r.uniforms.uvTransform.value = s.matrix), uv(t, this._camera)
                    }
                }
                unsetVelocityDepthNormalMaterialInScene() {
                    for (const e of this.visibleMeshes) e.visible = !0, hv(e, this._camera), e.material = this.cachedMaterials.get(e)[0]
                }
                setSize(e, t) {
                    var n;
                    this.renderTarget.setSize(e, t), null == (n = this.lastDepthTexture) || n.dispose(), this.lastDepthTexture = new Sa(e, t, I), this.lastDepthTexture.minFilter = h, this.lastDepthTexture.magFilter = h
                }
                dispose() {
                    super.dispose(), this.renderTarget.dispose()
                }
                get texture() {
                    return Array.isArray(this.renderTarget.texture) ? this.renderTarget.texture[1] : this.renderTarget.texture
                }
                get depthTexture() {
                    return this.renderTarget.texture[0]
                }
                render(e) {
                    oy.copy(this._camera.projectionMatrix), ay.copy(this._camera.projectionMatrixInverse), this._camera.view && (this._camera.view.enabled = !1), this._camera.updateProjectionMatrix(), this._camera.updateMatrixWorld(), this.setVelocityDepthNormalMaterialInScene();
                    const {
                        background: t
                    } = this._scene;
                    this._scene.background = ry, e.setRenderTarget(this.renderTarget), e.copyFramebufferToTexture(sy, this.lastDepthTexture), e.render(this._scene, this._camera), this._scene.background = t, this.unsetVelocityDepthNormalMaterialInScene(), this._camera.view && (this._camera.view.enabled = !0), this._camera.projectionMatrix.copy(oy), this._camera.projectionMatrixInverse.copy(ay)
                }
            }
            const cy = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D depthTexture;uniform sampler2D normalTexture;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;uniform float lumaPhi;uniform float depthPhi;uniform float normalPhi;uniform sampler2D blueNoiseTexture;uniform vec2 blueNoiseRepeat;uniform int index;uniform vec2 resolution;\n#include <common>\n#include <sampleBlueNoise>\nvec3 getWorldPos(float depth,vec2 coord){float z=depth*2.0-1.0;vec4 clipSpacePosition=vec4(coord*2.0-1.0,z,1.0);vec4 viewSpacePosition=projectionMatrixInverse*clipSpacePosition;vec4 worldSpacePosition=cameraMatrixWorld*viewSpacePosition;worldSpacePosition.xyz/=worldSpacePosition.w;return worldSpacePosition.xyz;}\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nvec3 getNormal(vec2 uv,vec4 texel){\n#ifdef NORMAL_IN_RGB\nreturn texel.rgb;\n#else\nreturn normalize(textureLod(normalTexture,uv,0.).xyz*2.0-1.0);\n#endif\n}float distToPlane(const vec3 worldPos,const vec3 neighborWorldPos,const vec3 worldNormal){vec3 toCurrent=worldPos-neighborWorldPos;float distToPlane=abs(dot(toCurrent,worldNormal));return distToPlane;}void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.);if(depthTexel.r==1.0||dot(depthTexel.rgb,depthTexel.rgb)==0.){discard;return;}vec4 texel=textureLod(inputTexture,vUv,0.0);vec3 normal=getNormal(vUv,texel);\n#ifdef NORMAL_IN_RGB\nfloat denoised=texel.a;float center=texel.a;\n#else\nvec3 denoised=texel.rgb;float center=texel.rgb;\n#endif\nfloat depth=depthTexel.x;vec3 worldPos=getWorldPos(depth,vUv);float totalWeight=1.0;vec4 blueNoise=sampleBlueNoise(blueNoiseTexture,0,blueNoiseRepeat,resolution);float angle=blueNoise[index];float s=sin(angle),c=cos(angle);mat2 rotationMatrix=mat2(c,-s,s,c);for(int i=0;i<samples;i++){vec2 offset=rotationMatrix*poissonDisk[i];vec2 neighborUv=vUv+offset;vec4 neighborTexel=textureLod(inputTexture,neighborUv,0.0);vec3 neighborNormal=getNormal(neighborUv,neighborTexel);float neighborColor=neighborTexel.a;float sampleDepth=textureLod(depthTexture,neighborUv,0.0).x;vec3 worldPosSample=getWorldPos(sampleDepth,neighborUv);float tangentPlaneDist=abs(dot(worldPos-worldPosSample,normal));float normalDiff=dot(normal,neighborNormal);float normalSimilarity=pow(max(normalDiff,0.),normalPhi);\n#ifdef NORMAL_IN_RGB\nfloat lumaDiff=abs(neighborColor-center);\n#else\nfloat lumaDiff=abs(luminance(neighborColor)-luminance(center));\n#endif\nfloat lumaSimilarity=max(1.0-lumaDiff/lumaPhi,0.0);float depthDiff=1.-distToPlane(worldPos,worldPosSample,normal);float depthSimilarity=max(depthDiff/depthPhi,0.);float w=lumaSimilarity*depthSimilarity*normalSimilarity;denoised+=w*neighborColor;totalWeight+=w;}if(totalWeight>0.)denoised/=totalWeight;\n#ifdef NORMAL_IN_RGB\ngl_FragColor=vec4(normal,denoised);\n#else\ngl_FragColor=vec4(denoised,1.);\n#endif\n}".replace("#include <sampleBlueNoise>", Ov),
                uy = {
                    iterations: 1,
                    radius: 8,
                    rings: 5.625,
                    lumaPhi: 10,
                    depthPhi: 2,
                    normalPhi: 3.25,
                    samples: 16,
                    normalTexture: null
                };
            class hy extends CA {
                constructor(e, t, n, i = uy) {
                    super("PoissionBlurPass"), this.iterations = uy.iterations, this.index = 0, i = {
                        ...uy,
                        ...i
                    }, this.inputTexture = t, this.fullscreenMaterial = new wi({
                        fragmentShader: cy,
                        vertexShader: yv,
                        uniforms: {
                            depthTexture: {
                                value: null
                            },
                            inputTexture: {
                                value: null
                            },
                            projectionMatrixInverse: {
                                value: new Wt
                            },
                            cameraMatrixWorld: {
                                value: new Wt
                            },
                            lumaPhi: {
                                value: 5
                            },
                            depthPhi: {
                                value: 5
                            },
                            normalPhi: {
                                value: 5
                            },
                            resolution: {
                                value: new ze
                            },
                            blueNoiseTexture: {
                                value: null
                            },
                            index: {
                                value: 0
                            },
                            blueNoiseRepeat: {
                                value: new ze
                            }
                        }
                    });
                    const r = {
                        type: w,
                        depthBuffer: !1
                    };
                    this.renderTargetA = new dt(1, 1, r), this.renderTargetB = new dt(1, 1, r);
                    const {
                        uniforms: s
                    } = this.fullscreenMaterial;
                    s.inputTexture.value = this.inputTexture, s.depthTexture.value = n, s.projectionMatrixInverse.value = e.projectionMatrixInverse, s.cameraMatrixWorld.value = e.matrixWorld, s.depthPhi.value = i.depthPhi, s.normalPhi.value = i.normalPhi, i.normalTexture ? s.normalTexture.value = i.normalTexture : this.fullscreenMaterial.defines.NORMAL_IN_RGB = "";
                    for (const e of ["radius", "rings", "samples"]) Object.defineProperty(this, e, {
                        get: () => i[e],
                        set: t => {
                            i[e] = t, this.setSize(this.renderTargetA.width, this.renderTargetA.height)
                        }
                    });
                    (new al).load(jv, (e => {
                        e.minFilter = h, e.magFilter = h, e.wrapS = l, e.wrapT = l, e.colorSpace = ye, this.fullscreenMaterial.uniforms.blueNoiseTexture.value = e
                    }))
                }
                setSize(e, t) {
                    this.renderTargetA.setSize(e, t), this.renderTargetB.setSize(e, t), this.fullscreenMaterial.uniforms.resolution.value.set(e, t);
                    const n = function(e, t, n, i) {
                            const r = 2 * Math.PI * t / e,
                                s = 1 / e,
                                o = s,
                                a = [];
                            let l = s,
                                c = 0;
                            for (let t = 0; t < e; t++) {
                                const e = new ze(Math.cos(c), Math.sin(c)).multiplyScalar(Math.pow(l, .75)).multiply(i).multiplyScalar(n);
                                a.push(e), l += o, c += r
                            }
                            return a
                        }(this.samples, this.rings, this.radius, new ze(1 / e, 1 / t)),
                        i = `const int samples = ${this.samples};\n`,
                        r = function(e) {
                            const t = e.length;
                            let n = "const vec2 poissonDisk[samples] = vec2[samples](\n";
                            for (let i = 0; i < t; i++) {
                                const r = e[i];
                                n += `    vec2(${r.x}, ${r.y})`, i < t - 1 && (n += ","), n += "\n"
                            }
                            return n += ");", n
                        }(n);
                    this.fullscreenMaterial.fragmentShader = i + r + "\n" + cy, this.fullscreenMaterial.needsUpdate = !0
                }
                get texture() {
                    return this.renderTargetB.texture
                }
                render(e) {
                    this.fullscreenMaterial.uniforms.index.value = 0;
                    const t = this.fullscreenMaterial.uniforms.blueNoiseTexture.value;
                    if (t) {
                        const {
                            width: e,
                            height: n
                        } = t.source.data;
                        this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTargetA.width / e, this.renderTargetA.height / n)
                    }
                    for (let t = 0; t < 2 * this.iterations; t++) {
                        const n = t % 2 == 0,
                            i = n ? this.renderTargetB : this.renderTargetA;
                        this.fullscreenMaterial.uniforms.inputTexture.value = 0 === t ? this.inputTexture : i.texture;
                        const r = n ? this.renderTargetA : this.renderTargetB;
                        e.setRenderTarget(r), e.render(this.scene, this.camera), this.fullscreenMaterial.uniforms.index.value = (this.fullscreenMaterial.uniforms.index.value + 1) % 4
                    }
                }
            }
            hy.DefaultOptions = uy;
            const dy = {
                resolutionScale: 1,
                spp: 8,
                distance: 2,
                distancePower: 1,
                power: 2,
                bias: 40,
                thickness: .075,
                color: new kn("black"),
                useNormalPass: !1,
                velocityDepthNormalPass: null,
                normalTexture: null,
                ...hy.DefaultOptions
            };

            function fy(e) {
                return fy = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, fy(e)
            }

            function py(e, t, n) {
                return t && function(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, my(i.key), i)
                    }
                }(e.prototype, t), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), e
            }

            function my(e) {
                var t = function(e, t) {
                    if ("object" != fy(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != fy(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == fy(t) ? t : t + ""
            }

            function gy(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }

            function Ay() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (e) {}
                return (Ay = function() {
                    return !!e
                })()
            }

            function vy(e) {
                return vy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }, vy(e)
            }

            function yy(e, t) {
                return yy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                }, yy(e, t)
            }(class extends XA {
                constructor(e, t, n, i, r = dy) {
                    if (super("AOEffect", "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D depthTexture;uniform float power;uniform vec3 color;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float unpackedDepth=textureLod(depthTexture,uv,0.).r;float ao=unpackedDepth>0.9999 ? 1.0 : textureLod(inputTexture,uv,0.0).a;ao=pow(ao,power);vec3 aoColor=mix(color,vec3(1.),ao);aoColor*=inputColor.rgb;outputColor=vec4(aoColor,inputColor.a);}", {
                            type: "FinalAOMaterial",
                            uniforms: new Map([
                                ["inputTexture", new Ll(null)],
                                ["depthTexture", new Ll(null)],
                                ["power", new Ll(0)],
                                ["color", new Ll(new kn("black"))]
                            ])
                        }), this.lastSize = {
                            width: 0,
                            height: 0,
                            resolutionScale: 0
                        }, this.composer = e, this.aoPass = i, r = {
                            ...dy,
                            ...r
                        }, e.depthTexture || e.createDepthTexture(), this.aoPass.fullscreenMaterial.uniforms.depthTexture.value = e.depthTexture, this.uniforms.get("depthTexture").value = e.depthTexture, r.useNormalPass || r.normalTexture) {
                        var s;
                        r.useNormalPass && (this.normalPass = new ov(n, t));
                        const e = null !== (s = r.normalTexture) && void 0 !== s ? s : this.normalPass.texture;
                        this.aoPass.fullscreenMaterial.uniforms.normalTexture.value = e, this.aoPass.fullscreenMaterial.defines.useNormalTexture = ""
                    }
                    this.poissionDenoisePass = new hy(t, this.aoPass.texture, e.depthTexture), this.makeOptionsReactive(r)
                }
                makeOptionsReactive(e) {
                    for (const t of Object.keys(e)) Object.defineProperty(this, t, {
                        get: () => e[t],
                        set(n) {
                            if (null != n) switch (e[t] = n, t) {
                                case "spp":
                                    this.aoPass.fullscreenMaterial.defines.spp = n.toFixed(0), this.aoPass.fullscreenMaterial.needsUpdate = !0;
                                    break;
                                case "distance":
                                    this.aoPass.fullscreenMaterial.uniforms.aoDistance.value = n;
                                    break;
                                case "resolutionScale":
                                    this.setSize(this.lastSize.width, this.lastSize.height);
                                    break;
                                case "power":
                                    this.uniforms.get("power").value = n;
                                    break;
                                case "color":
                                    this.uniforms.get("color").value.copy(new kn(n));
                                    break;
                                case "iterations":
                                case "radius":
                                case "rings":
                                case "samples":
                                    this.poissionDenoisePass[t] = n;
                                    break;
                                case "lumaPhi":
                                case "depthPhi":
                                case "normalPhi":
                                    this.poissionDenoisePass.fullscreenMaterial.uniforms[t].value = Math.max(n, 1e-4);
                                    break;
                                default:
                                    t in this.aoPass.fullscreenMaterial.uniforms && (this.aoPass.fullscreenMaterial.uniforms[t].value = n)
                            }
                        },
                        configurable: !0
                    }), this[t] = e[t]
                }
                setSize(e, t) {
                    var n;
                    void 0 !== e && void 0 !== t && (e === this.lastSize.width && t === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale || (null == (n = this.normalPass) || n.setSize(e, t), this.aoPass.setSize(e * this.resolutionScale, t * this.resolutionScale), this.poissionDenoisePass.setSize(e, t), this.lastSize = {
                        width: e,
                        height: t,
                        resolutionScale: this.resolutionScale
                    }))
                }
                update(e) {
                    var t;
                    const n = this.composer.passes.some((e => {
                        var t;
                        return e.enabled && !e.skipRendering && (null == (t = e.effects) ? void 0 : t.some((e => e instanceof Mv)))
                    }));
                    n && !("animatedNoise" in this.aoPass.fullscreenMaterial.defines) ? (this.aoPass.fullscreenMaterial.defines.animatedNoise = "", this.aoPass.fullscreenMaterial.needsUpdate = !0) : !n && "animatedNoise" in this.aoPass.fullscreenMaterial.defines && (delete this.aoPass.fullscreenMaterial.defines.animatedNoise, this.aoPass.fullscreenMaterial.needsUpdate = !0), this.iterations > 0 ? this.uniforms.get("inputTexture").value = this.poissionDenoisePass.texture : this.uniforms.get("inputTexture").value = this.aoPass.texture, null == (t = this.normalPass) || t.render(e), this.aoPass.render(e), this.poissionDenoisePass.render(e)
                }
            }).DefaultOptions = dy;
            var _y = function(e) {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            n = e.blendFunction,
                            i = void 0 === n ? 21 : n,
                            r = e.intensity,
                            s = void 0 === r ? .9 : r,
                            o = e.gamma,
                            a = void 0 === o ? 2.4 : o;
                        return gy(this, t),
                            function(e, t, n) {
                                return t = vy(t),
                                    function(e, t) {
                                        if (t && ("object" == fy(t) || "function" == typeof t)) return t;
                                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                                        return function(e) {
                                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                            return e
                                        }(e)
                                    }(e, Ay() ? Reflect.construct(t, n || [], vy(e).constructor) : t.apply(e, n))
                            }(this, t, ["WarmColorEffect", "\n      uniform float intensity;\n      uniform float gamma;\n      void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec3 warmColor = vec3(1.0, 0.8, 0.6); // Adjust this color for 4000K\n        vec3 warmedColor = mix(inputColor.rgb, inputColor.rgb * warmColor, intensity);\n        vec3 gammaCorrected = pow(warmedColor, vec3(1.0 / gamma));\n        outputColor = vec4(gammaCorrected, inputColor.a);\n      }\n    ", {
                                blendFunction: i,
                                uniforms: new Map([
                                    ["intensity", {
                                        value: s
                                    }],
                                    ["gamma", {
                                        value: a
                                    }]
                                ])
                            }])
                    }
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), t && yy(e, t)
                    }(t, e), py(t)
                }(XA),
                xy = py((function e(t) {
                    gy(this, e), this.engine = t
                }), [{
                    key: "init",
                    value: function() {
                        var e, t = this;
                        this.composer = new class {
                            constructor(e = null, {
                                depthBuffer: t = !0,
                                stencilBuffer: n = !1,
                                multisampling: i = 0,
                                frameBufferType: r
                            } = {}) {
                                this.renderer = null, this.inputBuffer = this.createBuffer(t, n, r, i), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new IA, this.depthTexture = null, this.passes = [], this.timer = new class {
                                    constructor() {
                                        this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1
                                    }
                                    get autoReset() {
                                        return this._autoReset
                                    }
                                    set autoReset(e) {
                                        "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = e)
                                    }
                                    get delta() {
                                        return this._delta * bA
                                    }
                                    get fixedDelta() {
                                        return this._fixedDelta * bA
                                    }
                                    set fixedDelta(e) {
                                        this._fixedDelta = 1e3 * e
                                    }
                                    get elapsed() {
                                        return this._elapsed * bA
                                    }
                                    update(e) {
                                        this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (void 0 !== e ? e : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta
                                    }
                                    reset() {
                                        this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime
                                    }
                                    getDelta() {
                                        return this.delta
                                    }
                                    getElapsed() {
                                        return this.elapsed
                                    }
                                    handleEvent(e) {
                                        document.hidden || (this.currentTime = performance.now() - this.startTime)
                                    }
                                    dispose() {
                                        this.autoReset = !1
                                    }
                                }, this.autoRenderToScreen = !0, this.setRenderer(e)
                            }
                            get multisampling() {
                                return this.inputBuffer.samples || 0
                            }
                            set multisampling(e) {
                                const t = this.inputBuffer,
                                    n = this.multisampling;
                                n > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
                            }
                            getTimer() {
                                return this.timer
                            }
                            getRenderer() {
                                return this.renderer
                            }
                            setRenderer(e) {
                                if (this.renderer = e, null !== e) {
                                    const t = e.getSize(new ze),
                                        n = e.getContext().getContextAttributes().alpha,
                                        i = this.inputBuffer.texture.type;
                                    i === A && e.outputColorSpace === _e && (this.inputBuffer.texture.colorSpace = _e, this.outputBuffer.texture.colorSpace = _e, this.inputBuffer.dispose(), this.outputBuffer.dispose()), e.autoClear = !1, this.setSize(t.width, t.height);
                                    for (const t of this.passes) t.initialize(e, n, i)
                                }
                            }
                            replaceRenderer(e, t = !0) {
                                const n = this.renderer,
                                    i = n.domElement.parentNode;
                                return this.setRenderer(e), t && null !== i && (i.removeChild(n.domElement), i.appendChild(e.domElement)), n
                            }
                            createDepthTexture() {
                                const e = this.depthTexture = new Cr;
                                return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = D, e.type = T) : e.type = E, e
                            }
                            deleteDepthTexture() {
                                if (null !== this.depthTexture) {
                                    this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
                                    for (const e of this.passes) e.setDepthTexture(null)
                                }
                            }
                            createBuffer(e, t, n, i) {
                                const r = this.renderer,
                                    s = null === r ? new ze : r.getDrawingBufferSize(new ze),
                                    o = {
                                        minFilter: f,
                                        magFilter: f,
                                        stencilBuffer: t,
                                        depthBuffer: e,
                                        type: n
                                    },
                                    a = new dt(s.width, s.height, o);
                                return i > 0 && (a.ignoreDepthForMultisampleCopy = !1, a.samples = i), n === A && null !== r && r.outputColorSpace === _e && (a.texture.colorSpace = _e), a.texture.name = "EffectComposer.Buffer", a.texture.generateMipmaps = !1, a
                            }
                            setMainScene(e) {
                                for (const t of this.passes) t.mainScene = e
                            }
                            setMainCamera(e) {
                                for (const t of this.passes) t.mainCamera = e
                            }
                            addPass(e, t) {
                                const n = this.passes,
                                    i = this.renderer,
                                    r = i.getDrawingBufferSize(new ze),
                                    s = i.getContext().getContextAttributes().alpha,
                                    o = this.inputBuffer.texture.type;
                                if (e.setRenderer(i), e.setSize(r.width, r.height), e.initialize(i, s, o), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), e.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== t ? n.splice(t, 0, e) : n.push(e), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), e.needsDepthTexture || null !== this.depthTexture)
                                    if (null === this.depthTexture) {
                                        const t = this.createDepthTexture();
                                        for (e of n) e.setDepthTexture(t)
                                    } else e.setDepthTexture(this.depthTexture)
                            }
                            removePass(e) {
                                const t = this.passes,
                                    n = t.indexOf(e);
                                if (-1 !== n && t.splice(n, 1).length > 0) {
                                    if (null !== this.depthTexture) {
                                        const n = (e, t) => e || t.needsDepthTexture;
                                        t.reduce(n, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture())
                                    }
                                    this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1, t.length > 0 && (t[t.length - 1].renderToScreen = !0))
                                }
                            }
                            removeAllPasses() {
                                const e = this.passes;
                                this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1), this.passes = [])
                            }
                            render(e) {
                                const t = this.renderer,
                                    n = this.copyPass;
                                let i, r, s, o = this.inputBuffer,
                                    a = this.outputBuffer,
                                    l = !1;
                                void 0 === e && (this.timer.update(), e = this.timer.getDelta());
                                for (const c of this.passes) c.enabled && (c.render(t, o, a, e, l), c.needsSwap && (l && (n.renderToScreen = c.renderToScreen, i = t.getContext(), r = t.state.buffers.stencil, r.setFunc(i.NOTEQUAL, 1, 4294967295), n.render(t, o, a, e, l), r.setFunc(i.EQUAL, 1, 4294967295)), s = o, o = a, a = s), c instanceof DA ? l = !0 : c instanceof SA && (l = !1))
                            }
                            setSize(e, t, n) {
                                const i = this.renderer,
                                    r = i.getSize(new ze);
                                void 0 !== e && void 0 !== t || (e = r.width, t = r.height), r.width === e && r.height === t || i.setSize(e, t, n);
                                const s = i.getDrawingBufferSize(new ze);
                                this.inputBuffer.setSize(s.width, s.height), this.outputBuffer.setSize(s.width, s.height);
                                for (const e of this.passes) e.setSize(s.width, s.height)
                            }
                            reset() {
                                this.dispose(), this.autoRenderToScreen = !0
                            }
                            dispose() {
                                for (const e of this.passes) e.dispose();
                                this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose(), CA.fullscreenGeometry.dispose()
                            }
                        }(this.engine.renderer, {
                            multisampling: Wd.postProcessing.antialias.multisampling,
                            frameBufferType: void 0
                        }), this.composer.outputColorSpace = this.engine.renderer.outputColorSpace, this.renderPass = new qA(this.engine.scene, this.engine.camera), this.velocityPass = new ly(this.engine.scene, this.engine.camera), this.motionBlur = new $v(this.velocityPass), this.motionBlur.intensity = 5, this.motionBlur.jitter = .1, this.tiltShiftEffect = new ZA({
                            focusArea: .4,
                            feather: .3,
                            offset: .05
                        }), this.toneMappingEffect = new tv({
                            mode: tv.REINHARD,
                            resolution: 256,
                            whitePoint: 1.5,
                            middleGrey: .6,
                            minLuminance: .01,
                            averageLuminance: .01,
                            adaptationRate: 1
                        }), this.warmColorEffect = new _y;
                        var n = [];
                        null !== (e = Wd.postProcessing.fxaa) && void 0 !== e && e.enabled && (this.fxaaEffect = new YA({
                            blendFunction: 23,
                            threshold: Wd.postProcessing.fxaa.threshold || .063
                        }), n.push(this.fxaaEffect)), this.effectPass = function(e, t, n) {
                            if (Ay()) return Reflect.construct.apply(null, arguments);
                            var i = [null];
                            return i.push.apply(i, t), new(e.bind.apply(e, i))
                        }(sv, [this.engine.camera].concat(n)), this.allPasses = [this.renderPass, this.effectPass], this.allPasses.forEach((function(e) {
                            t.composer.addPass(e)
                        }))
                    }
                }, {
                    key: "render",
                    value: function() {
                        this.composer.render()
                    }
                }, {
                    key: "setDebugMode",
                    value: function(e) {}
                }, {
                    key: "destroy",
                    value: function() {
                        this.composer && (this.composer.dispose(), this.composer = null), this.renderPass && (this.renderPass = null), this.velocityPass && (this.velocityPass = null), this.effectPass && (this.effectPass = null), this.motionBlur && (this.motionBlur.dispose(), this.motionBlur = null), this.toneMappingEffect && (this.toneMappingEffect.dispose(), this.toneMappingEffect = null), this.warmColorEffect && (this.warmColorEffect.dispose(), this.warmColorEffect = null), this.n8aoPass && (this.n8aoPass.dispose(), this.n8aoPass = null)
                    }
                }]);

            function Ey(e) {
                return Ey = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, Ey(e)
            }

            function by(e) {
                var t = function(e, t) {
                    if ("object" != Ey(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != Ey(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == Ey(t) ? t : t + ""
            }

            function wy(e, t, n) {
                return t = Ty(t),
                    function(e, t) {
                        if (t && ("object" == Ey(t) || "function" == typeof t)) return t;
                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                        return function(e) {
                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return e
                        }(e)
                    }(e, Cy() ? Reflect.construct(t, [], Ty(e).constructor) : t.apply(e, n))
            }

            function Cy() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (e) {}
                return (Cy = function() {
                    return !!e
                })()
            }

            function Sy() {
                return Sy = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, n) {
                    var i = function(e, t) {
                        for (; !{}.hasOwnProperty.call(e, t) && null !== (e = Ty(e)););
                        return e
                    }(e, t);
                    if (i) {
                        var r = Object.getOwnPropertyDescriptor(i, t);
                        return r.get ? r.get.call(arguments.length < 3 ? e : n) : r.value
                    }
                }, Sy.apply(null, arguments)
            }

            function Ty(e) {
                return Ty = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }, Ty(e)
            }

            function My(e, t) {
                return My = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                }, My(e, t)
            }
            var Iy = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), (e = wy(this, t)).type = "AdaptivePanoramaGeometry", e.radius = n.radius || 30, e.projection = n.projection || "equirectangular", e.baseTessellation = n.baseTessellation || 128, e.maxTessellation = n.maxTessellation || 768, e.adaptiveLOD = !1 !== n.adaptiveLOD, e.lodLevels = [{
                        distance: 0,
                        tessellation: e.maxTessellation
                    }, {
                        distance: 10,
                        tessellation: 512
                    }, {
                        distance: 20,
                        tessellation: 256
                    }, {
                        distance: 30,
                        tessellation: e.baseTessellation
                    }], e.createGeometry(e.baseTessellation), e
                }
                return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), t && My(e, t)
                    }(t, e),
                    function(e, t, n) {
                        return t && function(e, t) {
                            for (var n = 0; n < t.length; n++) {
                                var i = t[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, by(i.key), i)
                            }
                        }(e.prototype, t), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), e
                    }(t, [{
                        key: "createGeometry",
                        value: function(e) {
                            "equirectangular" === this.projection ? this.createSphereGeometry(e) : "cubemap" === this.projection && this.createCubemapGeometry(e)
                        }
                    }, {
                        key: "createSphereGeometry",
                        value: function(e) {
                            var t = e,
                                n = Math.floor(e / 2),
                                i = new Ba(this.radius, t, n);
                            i.scale(-1, 1, 1), this.setIndex(i.index), this.setAttribute("position", i.getAttribute("position")), this.setAttribute("normal", i.getAttribute("normal")), this.setAttribute("uv", i.getAttribute("uv")), this.currentTessellation = e
                        }
                    }, {
                        key: "createCubemapGeometry",
                        value: function(e) {
                            var t = 2 * this.radius,
                                n = Math.floor(e / 6),
                                i = new yi(t, t, t, n, n, n);
                            i.scale(-1, -1, -1);
                            for (var r = i.getAttribute("uv"), s = i.getAttribute("position"), o = new Float32Array(2 * r.count), a = 0; a < s.count; a++) {
                                var l = s.getX(a),
                                    c = s.getY(a),
                                    u = s.getZ(a),
                                    h = Math.abs(l),
                                    d = Math.abs(c),
                                    f = Math.abs(u),
                                    p = void 0,
                                    m = void 0;
                                h >= d && h >= f ? (p = .5 * (u / h + 1), m = .5 * (c / h + 1)) : d >= h && d >= f ? (p = .5 * (l / d + 1), m = .5 * (u / d + 1)) : (p = .5 * (l / f + 1), m = .5 * (c / f + 1)), o[2 * a] = p, o[2 * a + 1] = m
                            }
                            i.setAttribute("uv", new Jn(o, 2)), this.setIndex(i.index), this.setAttribute("position", i.getAttribute("position")), this.setAttribute("normal", i.getAttribute("normal")), this.setAttribute("uv", i.getAttribute("uv")), this.currentTessellation = e
                        }
                    }, {
                        key: "updateLOD",
                        value: function(e, t) {
                            if (this.adaptiveLOD) {
                                for (var n = e.position.distanceTo(t), i = this.baseTessellation, r = 0; r < this.lodLevels.length; r++)
                                    if (n <= this.lodLevels[r].distance) {
                                        i = this.lodLevels[r].tessellation;
                                        break
                                    } var s = Qe.clamp(90 / e.fov, .5, 2);
                                i = Math.floor(i * s), i = Qe.clamp(i, this.baseTessellation, this.maxTessellation), Math.abs(i - this.currentTessellation) > 64 && (this.createGeometry(i), this.needsUpdate = !0)
                            }
                        }
                    }, {
                        key: "setProjection",
                        value: function(e) {
                            e !== this.projection && (this.projection = e, this.createGeometry(this.currentTessellation || this.baseTessellation), this.needsUpdate = !0)
                        }
                    }, {
                        key: "setLODLevels",
                        value: function(e) {
                            this.lodLevels = e.sort((function(e, t) {
                                return e.distance - t.distance
                            }))
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            ! function(e, t, n, i) {
                                var r = Sy(Ty(e.prototype), "dispose", n);
                                return "function" == typeof r ? function(e) {
                                    return r.apply(n, e)
                                } : r
                            }(t, 0, this)([])
                        }
                    }])
            }(si);

            function By(e) {
                return By = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, By(e)
            }

            function Ry(e) {
                var t = function(e, t) {
                    if ("object" != By(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != By(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == By(t) ? t : t + ""
            }
            var Dy = function(e, t, n) {
                return t && function(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, Ry(i.key), i)
                    }
                }(e.prototype, t), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), e
            }((function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.engine = t, this.init(), this.hoveredHotspot = null, this.targetQuaternion = new mt
            }), [{
                key: "init",
                value: function() {
                    try {
                        var e = new Gi(Wd.cursor.size, Wd.cursor.size),
                            t = new Gn({
                                color: new kn(Number("0x".concat(Wd.cursor.color))),
                                side: 2,
                                map: this.engine.textures.getTexture("Cursor.png"),
                                transparent: !0,
                                opacity: .2,
                                depthWrite: !1,
                                depthTest: !1
                            });
                        this.pin = new Ai(e, t), this.pin.visible = !1, this.pin.renderOrder = 15, this.pin.name = "pin", this.pin.scale.setScalar(3), this.engine.scene.add(this.pin)
                    } catch (e) {
                        var n = new Gi(Wd.cursor.size, Wd.cursor.size),
                            i = new Gn({
                                color: new kn(Number("0x".concat(Wd.cursor.color))),
                                side: 2,
                                map: this.engine.textures.getTexture("Cursor.png"),
                                transparent: !0,
                                opacity: .2,
                                depthWrite: !1,
                                depthTest: !1
                            });
                        this.pin = new Ai(n, i), this.pin.visible = !1, this.pin.renderOrder = 15, this.pin.name = "pin", this.pin.scale.setScalar(3), this.engine.scene.add(this.pin)
                    }
                    this.raycaster = new Nl, this.mouseHelper = new Ai(new yi(1, 1, 10), new Pa), this.mouseHelper.visible = !1, this.intersection = {
                        intersects: !1,
                        point: new gt,
                        normal: new gt
                    }, this.intersects = [], this.mouse = new gt
                }
            }, {
                key: "cursorPosition",
                get: function() {
                    return new ze(this.mouse.x, this.mouse.y)
                }
            }, {
                key: "onMove",
                value: function(e) {
                    var t = this.engine.container.getBoundingClientRect(),
                        n = t.left,
                        i = t.top,
                        r = e.clientX - n,
                        s = e.clientY - i;
                    this.mouse.x = r / this.engine.container.clientWidth * 2 - 1, this.mouse.y = -s / this.engine.container.clientHeight * 2 + 1, this.raycaster.setFromCamera(this.mouse, this.engine.camera);
                    var o = this.engine.meshes.filter((function(e) {
                        return e.material && e.material.opacity > .2
                    }));
                    if (this.raycaster.intersectObjects(o, !1, this.intersects), this.intersects.length > 0) {
                        this.intersects.sort((function(e, t) {
                            return e.object.name.includes("Hotspot") && !t.object.name.includes("Hotspot") ? -1 : !e.object.name.includes("Hotspot") && t.object.name.includes("Hotspot") ? 1 : 0
                        }));
                        var a = this.intersects[0];
                        if (a.object.visible && a.object.name.includes("Hotspot")) this.pin.visible = !1, If.isMobile || this.engine.container.classList.add("cursor-pointer"), this.hoveredHotspot !== a.object && (this.hoveredHotspot && this.animateHotspotOpacity(this.hoveredHotspot, Wd.hotspot.opacity), this.hoveredHotspot = a.object, this.animateHotspotOpacity(this.hoveredHotspot, Wd.hotspot.hoverOpacity));
                        else {
                            If.isMobile || (this.pin.visible = !0, this.engine.container.style.cursor = "auto", this.engine.container.classList.remove("cursor-pointer"));
                            var l = a.point;
                            if (this.mouseHelper.position.copy(l), this.intersection.point.copy(l), a.face) {
                                var c = a.face.normal.clone();
                                c.transformDirection(a.object.matrixWorld), c.add(a.point), this.intersection.normal.copy(a.face.normal), this.mouseHelper.lookAt(c)
                            }
                            this.pin.position.copy(this.intersection.point), this.targetQuaternion.setFromEuler(this.mouseHelper.rotation), this.intersection.intersects = !0, this.hoveredHotspot && (this.animateHotspotOpacity(this.hoveredHotspot, Wd.hotspot.opacity), this.hoveredHotspot = null)
                        }
                        this.intersects.length = 0
                    } else this.intersection.intersects = !1, this.pin.visible = !1, this.engine.controls.enabled = !0, this.hoveredHotspot && (this.animateHotspotOpacity(this.hoveredHotspot, Wd.hotspot.opacity), this.hoveredHotspot = null)
                }
            }, {
                key: "animateHotspotOpacity",
                value: function(e, t) {
                    $m.to(e.material, {
                        opacity: t,
                        duration: Wd.hotspot.hoverTransitionTime,
                        ease: "power2.out"
                    })
                }
            }, {
                key: "update",
                value: function(e) {
                    this.pin && this.targetQuaternion && this.pin.quaternion.slerp(this.targetQuaternion, Wd.cursor.lerpFactor)
                }
            }, {
                key: "onClick",
                value: function(e) {
                    if (this.raycaster.intersectObjects(this.engine.meshes, !1, this.intersects), this.intersects.length > 0) {
                        var t = this.intersects.find((function(e) {
                            return e.object.name.includes("Hotspot") && e.object.visible
                        }));
                        if (t) {
                            var n = this.engine.pano.panoItems.find((function(e) {
                                return t.object.name.includes(e.name)
                            }));
                            n && n.name !== this.engine.pano.currentPano && this.engine.pano.change(n.name)
                        } else this.findClosestHotspot(this.intersects[0].point)
                    }
                }
            }, {
                key: "findClosestHotspot",
                value: function(e) {
                    var t = this.engine.camera.position,
                        n = new gt(0, 0, -1).applyQuaternion(this.engine.camera.quaternion),
                        i = this.engine.meshes.filter((function(e) {
                            return e.name.includes("Hotspot") && e.visible
                        })),
                        r = null,
                        s = 1 / 0;
                    if (i.forEach((function(i) {
                            var o = (new gt).subVectors(i.position, t).normalize(),
                                a = n.dot(o);
                            if (a > 0) {
                                var l = (new gt).subVectors(e, t).normalize().dot(o);
                                if (l > .5) {
                                    var c = t.x - i.position.x,
                                        u = t.y - i.position.y,
                                        h = t.z - i.position.z,
                                        d = (a + l) / 2,
                                        f = Math.sqrt(c * c + u * u + h * h) * (1 - .5 * d);
                                    f < s && (s = f, r = i)
                                }
                            }
                        })), r) {
                        var o = this.engine.pano.panoItems.find((function(e) {
                            return r.name.includes(e.name)
                        }));
                        o && o.name !== this.engine.pano.currentPano && this.engine.pano.change(o.name)
                    }
                }
            }, {
                key: "destroy",
                value: function() {
                    this.pin && this.engine.scene && (this.engine.scene.remove(this.pin), this.pin.geometry && this.pin.geometry.dispose(), this.pin.material && (this.pin.material.map && this.pin.material.map.dispose(), this.pin.material.dispose()), this.pin = null)
                }
            }]);

            function Py(e) {
                return Py = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, Py(e)
            }

            function Ly() {
                Ly = function() {
                    return t
                };
                var e, t = {},
                    n = Object.prototype,
                    i = n.hasOwnProperty,
                    r = Object.defineProperty || function(e, t, n) {
                        e[t] = n.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    o = s.iterator || "@@iterator",
                    a = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, n) {
                    return Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, n) {
                        return e[t] = n
                    }
                }

                function u(e, t, n, i) {
                    var s = t && t.prototype instanceof A ? t : A,
                        o = Object.create(s.prototype),
                        a = new B(i || []);
                    return r(o, "_invoke", {
                        value: S(e, n, a)
                    }), o
                }

                function h(e, t, n) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, n)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart",
                    f = "suspendedYield",
                    p = "executing",
                    m = "completed",
                    g = {};

                function A() {}

                function v() {}

                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }));
                var x = Object.getPrototypeOf,
                    E = x && x(x(R([])));
                E && E !== n && i.call(E, o) && (_ = E);
                var b = y.prototype = A.prototype = Object.create(_);

                function w(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function C(e, t) {
                    function n(r, s, o, a) {
                        var l = h(e[r], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                u = c.value;
                            return u && "object" == Py(u) && i.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                n("next", e, o, a)
                            }), (function(e) {
                                n("throw", e, o, a)
                            })) : t.resolve(u).then((function(e) {
                                c.value = e, o(c)
                            }), (function(e) {
                                return n("throw", e, o, a)
                            }))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(e, i) {
                            function r() {
                                return new t((function(t, r) {
                                    n(e, i, t, r)
                                }))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }

                function S(t, n, i) {
                    var r = d;
                    return function(s, o) {
                        if (r === p) throw Error("Generator is already running");
                        if (r === m) {
                            if ("throw" === s) throw o;
                            return {
                                value: e,
                                done: !0
                            }
                        }
                        for (i.method = s, i.arg = o;;) {
                            var a = i.delegate;
                            if (a) {
                                var l = T(a, i);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === i.method) i.sent = i._sent = i.arg;
                            else if ("throw" === i.method) {
                                if (r === d) throw r = m, i.arg;
                                i.dispatchException(i.arg)
                            } else "return" === i.method && i.abrupt("return", i.arg);
                            r = p;
                            var c = h(t, n, i);
                            if ("normal" === c.type) {
                                if (r = i.done ? m : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: i.done
                                }
                            }
                            "throw" === c.type && (r = m, i.method = "throw", i.arg = c.arg)
                        }
                    }
                }

                function T(t, n) {
                    var i = n.method,
                        r = t.iterator[i];
                    if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
                }

                function M(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function I(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function B(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(M, this), this.reset(!0)
                }

                function R(t) {
                    if (t || "" === t) {
                        var n = t[o];
                        if (n) return n.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var r = -1,
                                s = function n() {
                                    for (; ++r < t.length;)
                                        if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = e, n.done = !0, n
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(Py(t) + " is not iterable")
                }
                return v.prototype = y, r(b, "constructor", {
                    value: y,
                    configurable: !0
                }), r(y, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(b), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, w(C.prototype), c(C.prototype, a, (function() {
                    return this
                })), t.AsyncIterator = C, t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new C(u(e, n, i, r), s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                        return e.done ? e.value : o.next()
                    }))
                }, w(b), c(b, l, "Generator"), c(b, o, (function() {
                    return this
                })), c(b, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = Object(e),
                        n = [];
                    for (var i in t) n.push(i);
                    return n.reverse(),
                        function e() {
                            for (; n.length;) {
                                var i = n.pop();
                                if (i in t) return e.value = i, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, t.values = R, B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !t)
                            for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done) throw t;
                        var n = this;

                        function r(i, r) {
                            return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s],
                                a = o.completion;
                            if ("root" === o.tryLoc) return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc"),
                                    c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                } else {
                                    if (!c) throw Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(o)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.tryLoc === e) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    I(n)
                                }
                                return r
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = e), g
                    }
                }, t
            }

            function Uy(e, t, n, i, r, s, o) {
                try {
                    var a = e[s](o),
                        l = a.value
                } catch (e) {
                    return void n(e)
                }
                a.done ? t(l) : Promise.resolve(l).then(i, r)
            }

            function Ny(e) {
                var t = function(e, t) {
                    if ("object" != Py(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != Py(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == Py(t) ? t : t + ""
            }
            var Oy = function() {
                return function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, Ny(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e(t) {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.engine = t, this.setup()
                }), [{
                    key: "setup",
                    value: (e = function(e) {
                        return function() {
                            var t = this,
                                n = arguments;
                            return new Promise((function(i, r) {
                                var s = e.apply(t, n);

                                function o(e) {
                                    Uy(s, i, r, o, a, "next", e)
                                }

                                function a(e) {
                                    Uy(s, i, r, o, a, "throw", e)
                                }
                                o(void 0)
                            }))
                        }
                    }(Ly().mark((function e() {
                        var t = this;
                        return Ly().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    this.vector = new gt, this.engine.pano.panoItems.forEach((function(e) {
                                        if (e.position) {
                                            var n = new Ai(new Gi(Wd.hotspot.size, Wd.hotspot.size), new Gn({
                                                name: "Hotspot",
                                                map: t.engine.textures.getTexture("Hotspot.png"),
                                                transparent: !0,
                                                opacity: Wd.hotspot.opacity,
                                                color: 16250864
                                            }));
                                            n.rotation.x = -Math.PI / 2, n.position.copy(e.position), n.position.y = t.engine.pano.groundLevel, n.scale.setScalar(3.25), n.renderOrder = 0, n.name = "Hotspot_".concat(e.name), t.engine.scene.add(n), t.engine.meshes.push(n)
                                        }
                                    })), this.infospots = [], this.engine.pano.infospots.forEach((function(e) {
                                        var n = new _n;
                                        n.position.copy(e.position), n.name = "Infospot_".concat(e.name), n._bubbleText = e.bubbleText, t.infospots.push(n), t.engine.scene.add(n)
                                    }));
                                case 4:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return e.apply(this, arguments)
                    })
                }, {
                    key: "update",
                    value: function() {
                        var e, t = this;
                        this.infospots && null !== (e = this.engine) && void 0 !== e && e.camera && this.infospots.forEach((function(e) {
                            if (e.htmlEl && t.engine.container) {
                                var n = t.engine.container.clientWidth,
                                    i = t.engine.container.clientHeight;
                                e.updateWorldMatrix(!0, !1), e.getWorldPosition(t.vector), t.vector.project(t.engine.camera);
                                var r = (.5 * t.vector.x + .5) * n,
                                    s = (-.5 * t.vector.y + .5) * i;
                                t.vector.z > .995 || !e.visible ? e.htmlEl.style.display = "none" : e.htmlEl.style.display = "block", e.htmlEl.style.left = "".concat(r - e.htmlEl.clientWidth / 2, "px"), e.htmlEl.style.top = "".concat(s - e.htmlEl.clientHeight / 2, "px")
                            }
                        }))
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        var e, t, n = this;
                        null === (e = this.engine.pano.panoItems) || void 0 === e || e.forEach((function(e) {
                            var t = n.engine.scene.getObjectByName("Hotspot_".concat(e.name));
                            if (t) {
                                n.engine.scene.remove(t), t.geometry && t.geometry.dispose(), t.material && (t.material.map && t.material.map.dispose(), t.material.dispose());
                                var i = n.engine.meshes.indexOf(t);
                                i > -1 && n.engine.meshes.splice(i, 1)
                            }
                        })), null === (t = this.infospots) || void 0 === t || t.forEach((function(e) {
                            e.htmlEl && (e.htmlEl.remove(), e.htmlEl = null), n.engine.scene.remove(e)
                        }))
                    }
                }]);
                var e
            }();

            function Fy(e, t) {
                if (0 === t) return e;
                if (2 === t || 1 === t) {
                    let n = e.getIndex();
                    if (null === n) {
                        const t = [],
                            i = e.getAttribute("position");
                        if (void 0 === i) return e;
                        for (let e = 0; e < i.count; e++) t.push(e);
                        e.setIndex(t), n = e.getIndex()
                    }
                    const i = n.count - 2,
                        r = [];
                    if (2 === t)
                        for (let e = 1; e <= i; e++) r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
                    else
                        for (let e = 0; e < i; e++) e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
                    r.length;
                    const s = e.clone();
                    return s.setIndex(r), s.clearGroups(), s
                }
                return e
            }

            function ky() {
                let e = {};
                return {
                    get: function(t) {
                        return e[t]
                    },
                    add: function(t, n) {
                        e[t] = n
                    },
                    remove: function(t) {
                        delete e[t]
                    },
                    removeAll: function() {
                        e = {}
                    }
                }
            }
            const Qy = "KHR_binary_glTF",
                zy = "KHR_draco_mesh_compression",
                Hy = "KHR_lights_punctual",
                Gy = "KHR_materials_clearcoat",
                Vy = "KHR_materials_dispersion",
                jy = "KHR_materials_ior",
                Wy = "KHR_materials_sheen",
                Xy = "KHR_materials_specular",
                Yy = "KHR_materials_transmission",
                qy = "KHR_materials_iridescence",
                Ky = "KHR_materials_anisotropy",
                Jy = "KHR_materials_unlit",
                Zy = "KHR_materials_volume",
                $y = "KHR_texture_basisu",
                e_ = "KHR_texture_transform",
                t_ = "KHR_mesh_quantization",
                n_ = "KHR_materials_emissive_strength",
                i_ = "EXT_materials_bump",
                r_ = "EXT_texture_webp",
                s_ = "EXT_texture_avif",
                o_ = "EXT_meshopt_compression",
                a_ = "EXT_mesh_gpu_instancing";
            class l_ {
                constructor(e) {
                    this.parser = e, this.name = Hy, this.cache = {
                        refs: {},
                        uses: {}
                    }
                }
                _markDefs() {
                    const e = this.parser,
                        t = this.parser.json.nodes || [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                    }
                }
                _loadLight(e) {
                    const t = this.parser,
                        n = "light:" + e;
                    let i = t.cache.get(n);
                    if (i) return i;
                    const r = t.json,
                        s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                    let o;
                    const a = new kn(16777215);
                    void 0 !== s.color && a.setRGB(s.color[0], s.color[1], s.color[2], xe);
                    const l = void 0 !== s.range ? s.range : 0;
                    switch (s.type) {
                        case "directional":
                            o = new xl(a), o.target.position.set(0, 0, -1), o.add(o.target);
                            break;
                        case "point":
                            o = new yl(a), o.distance = l;
                            break;
                        case "spot":
                            o = new pl(a), o.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, o.angle = s.spot.outerConeAngle, o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                            break;
                        default:
                            throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                    }
                    return o.position.set(0, 0, 0), o.decay = 2, G_(o, s), void 0 !== s.intensity && (o.intensity = s.intensity), o.name = t.createUniqueName(s.name || "light_" + e), i = Promise.resolve(o), t.cache.add(n, i), i
                }
                getDependency(e, t) {
                    if ("light" === e) return this._loadLight(t)
                }
                createNodeAttachment(e) {
                    const t = this,
                        n = this.parser,
                        i = n.json.nodes[e],
                        r = (i.extensions && i.extensions[this.name] || {}).light;
                    return void 0 === r ? null : this._loadLight(r).then((function(e) {
                        return n._getNodeRef(t.cache, r, e)
                    }))
                }
            }
            class c_ {
                constructor() {
                    this.name = Jy
                }
                getMaterialType() {
                    return Gn
                }
                extendParams(e, t, n) {
                    const i = [];
                    e.color = new kn(1, 1, 1), e.opacity = 1;
                    const r = t.pbrMetallicRoughness;
                    if (r) {
                        if (Array.isArray(r.baseColorFactor)) {
                            const t = r.baseColorFactor;
                            e.color.setRGB(t[0], t[1], t[2], xe), e.opacity = t[3]
                        }
                        void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, _e))
                    }
                    return Promise.all(i)
                }
            }
            class u_ {
                constructor(e) {
                    this.parser = e, this.name = n_
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const i = n.extensions[this.name].emissiveStrength;
                    return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve()
                }
            }
            class h_ {
                constructor(e) {
                    this.parser = e, this.name = Gy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                        const e = s.clearcoatNormalTexture.scale;
                        t.clearcoatNormalScale = new ze(e, e)
                    }
                    return Promise.all(r)
                }
            }
            class d_ {
                constructor(e) {
                    this.parser = e, this.name = Vy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const i = n.extensions[this.name];
                    return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0, Promise.resolve()
                }
            }
            class f_ {
                constructor(e) {
                    this.parser = e, this.name = qy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(r)
                }
            }
            class p_ {
                constructor(e) {
                    this.parser = e, this.name = Wy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [];
                    t.sheenColor = new kn(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                    const s = i.extensions[this.name];
                    if (void 0 !== s.sheenColorFactor) {
                        const e = s.sheenColorFactor;
                        t.sheenColor.setRGB(e[0], e[1], e[2], xe)
                    }
                    return void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, _e)), void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(r)
                }
            }
            class m_ {
                constructor(e) {
                    this.parser = e, this.name = Yy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r)
                }
            }
            class g_ {
                constructor(e) {
                    this.parser = e, this.name = Zy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 1 / 0;
                    const o = s.attenuationColor || [1, 1, 1];
                    return t.attenuationColor = (new kn).setRGB(o[0], o[1], o[2], xe), Promise.all(r)
                }
            }
            class A_ {
                constructor(e) {
                    this.parser = e, this.name = jy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const i = n.extensions[this.name];
                    return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
                }
            }
            class v_ {
                constructor(e) {
                    this.parser = e, this.name = Xy
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
                    const o = s.specularColorFactor || [1, 1, 1];
                    return t.specularColor = (new kn).setRGB(o[0], o[1], o[2], xe), void 0 !== s.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture, _e)), Promise.all(r)
                }
            }
            class y_ {
                constructor(e) {
                    this.parser = e, this.name = i_
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    return t.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1, void 0 !== s.bumpTexture && r.push(n.assignTexture(t, "bumpMap", s.bumpTexture)), Promise.all(r)
                }
            }
            class __ {
                constructor(e) {
                    this.parser = e, this.name = Ky
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? Da : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    return void 0 !== s.anisotropyStrength && (t.anisotropy = s.anisotropyStrength), void 0 !== s.anisotropyRotation && (t.anisotropyRotation = s.anisotropyRotation), void 0 !== s.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", s.anisotropyTexture)), Promise.all(r)
                }
            }
            class x_ {
                constructor(e) {
                    this.parser = e, this.name = $y
                }
                loadTexture(e) {
                    const t = this.parser,
                        n = t.json,
                        i = n.textures[e];
                    if (!i.extensions || !i.extensions[this.name]) return null;
                    const r = i.extensions[this.name],
                        s = t.options.ktx2Loader;
                    if (!s) {
                        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                        return null
                    }
                    return t.loadTextureImage(e, r.source, s)
                }
            }
            class E_ {
                constructor(e) {
                    this.parser = e, this.name = r_, this.isSupported = null
                }
                loadTexture(e) {
                    const t = this.name,
                        n = this.parser,
                        i = n.json,
                        r = i.textures[e];
                    if (!r.extensions || !r.extensions[t]) return null;
                    const s = r.extensions[t],
                        o = i.images[s.source];
                    let a = n.textureLoader;
                    if (o.uri) {
                        const e = n.options.manager.getHandler(o.uri);
                        null !== e && (a = e)
                    }
                    return this.detectSupport().then((function(r) {
                        if (r) return n.loadTextureImage(e, s.source, a);
                        if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                        return n.loadTexture(e)
                    }))
                }
                detectSupport() {
                    return this.isSupported || (this.isSupported = new Promise((function(e) {
                        const t = new Image;
                        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                            e(1 === t.height)
                        }
                    }))), this.isSupported
                }
            }
            class b_ {
                constructor(e) {
                    this.parser = e, this.name = s_, this.isSupported = null
                }
                loadTexture(e) {
                    const t = this.name,
                        n = this.parser,
                        i = n.json,
                        r = i.textures[e];
                    if (!r.extensions || !r.extensions[t]) return null;
                    const s = r.extensions[t],
                        o = i.images[s.source];
                    let a = n.textureLoader;
                    if (o.uri) {
                        const e = n.options.manager.getHandler(o.uri);
                        null !== e && (a = e)
                    }
                    return this.detectSupport().then((function(r) {
                        if (r) return n.loadTextureImage(e, s.source, a);
                        if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                        return n.loadTexture(e)
                    }))
                }
                detectSupport() {
                    return this.isSupported || (this.isSupported = new Promise((function(e) {
                        const t = new Image;
                        t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                            e(1 === t.height)
                        }
                    }))), this.isSupported
                }
            }
            class w_ {
                constructor(e) {
                    this.name = o_, this.parser = e
                }
                loadBufferView(e) {
                    const t = this.parser.json,
                        n = t.bufferViews[e];
                    if (n.extensions && n.extensions[this.name]) {
                        const e = n.extensions[this.name],
                            i = this.parser.getDependency("buffer", e.buffer),
                            r = this.parser.options.meshoptDecoder;
                        if (!r || !r.supported) {
                            if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                            return null
                        }
                        return i.then((function(t) {
                            const n = e.byteOffset || 0,
                                i = e.byteLength || 0,
                                s = e.count,
                                o = e.byteStride,
                                a = new Uint8Array(t, n, i);
                            return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, o, a, e.mode, e.filter).then((function(e) {
                                return e.buffer
                            })) : r.ready.then((function() {
                                const t = new ArrayBuffer(s * o);
                                return r.decodeGltfBuffer(new Uint8Array(t), s, o, a, e.mode, e.filter), t
                            }))
                        }))
                    }
                    return null
                }
            }
            class C_ {
                constructor(e) {
                    this.name = a_, this.parser = e
                }
                createNodeMesh(e) {
                    const t = this.parser.json,
                        n = t.nodes[e];
                    if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                    const i = t.meshes[n.mesh];
                    for (const e of i.primitives)
                        if (e.mode !== L_.TRIANGLES && e.mode !== L_.TRIANGLE_STRIP && e.mode !== L_.TRIANGLE_FAN && void 0 !== e.mode) return null;
                    const r = n.extensions[this.name].attributes,
                        s = [],
                        o = {};
                    for (const e in r) s.push(this.parser.getDependency("accessor", r[e]).then((t => (o[e] = t, o[e]))));
                    return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(e)), Promise.all(s).then((e => {
                        const t = e.pop(),
                            n = t.isGroup ? t.children : [t],
                            i = e[0].count,
                            r = [];
                        for (const e of n) {
                            const t = new Wt,
                                n = new gt,
                                s = new mt,
                                a = new gt(1, 1, 1),
                                l = new ra(e.geometry, e.material, i);
                            for (let e = 0; e < i; e++) o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, e), o.ROTATION && s.fromBufferAttribute(o.ROTATION, e), o.SCALE && a.fromBufferAttribute(o.SCALE, e), l.setMatrixAt(e, t.compose(n, s, a));
                            for (const t in o)
                                if ("_COLOR_0" === t) {
                                    const e = o[t];
                                    l.instanceColor = new Ko(e.array, e.itemSize, e.normalized)
                                } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, o[t]);
                            _n.prototype.copy.call(l, e), this.parser.assignFinalMaterial(l), r.push(l)
                        }
                        return t.isGroup ? (t.clear(), t.add(...r), t) : r[0]
                    })))
                }
            }
            const S_ = "glTF";
            class T_ {
                constructor(e) {
                    this.name = Qy, this.content = null, this.body = null;
                    const t = new DataView(e, 0, 12),
                        n = new TextDecoder;
                    if (this.header = {
                            magic: n.decode(new Uint8Array(e.slice(0, 4))),
                            version: t.getUint32(4, !0),
                            length: t.getUint32(8, !0)
                        }, this.header.magic !== S_) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                    const i = this.header.length - 12,
                        r = new DataView(e, 12);
                    let s = 0;
                    for (; s < i;) {
                        const t = r.getUint32(s, !0);
                        s += 4;
                        const i = r.getUint32(s, !0);
                        if (s += 4, 1313821514 === i) {
                            const i = new Uint8Array(e, 12 + s, t);
                            this.content = n.decode(i)
                        } else if (5130562 === i) {
                            const n = 12 + s;
                            this.body = e.slice(n, n + t)
                        }
                        s += t
                    }
                    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                }
            }
            class M_ {
                constructor(e, t) {
                    if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    this.name = zy, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
                }
                decodePrimitive(e, t) {
                    const n = this.json,
                        i = this.dracoLoader,
                        r = e.extensions[this.name].bufferView,
                        s = e.extensions[this.name].attributes,
                        o = {},
                        a = {},
                        l = {};
                    for (const e in s) {
                        const t = k_[e] || e.toLowerCase();
                        o[t] = s[e]
                    }
                    for (const t in e.attributes) {
                        const i = k_[t] || t.toLowerCase();
                        if (void 0 !== s[t]) {
                            const r = n.accessors[e.attributes[t]],
                                s = U_[r.componentType];
                            l[i] = s.name, a[i] = !0 === r.normalized
                        }
                    }
                    return t.getDependency("bufferView", r).then((function(e) {
                        return new Promise((function(t, n) {
                            i.decodeDracoFile(e, (function(e) {
                                for (const t in e.attributes) {
                                    const n = e.attributes[t],
                                        i = a[t];
                                    void 0 !== i && (n.normalized = i)
                                }
                                t(e)
                            }), o, l, xe, n)
                        }))
                    }))
                }
            }
            class I_ {
                constructor() {
                    this.name = e_
                }
                extendTexture(e, t) {
                    return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e
                }
            }
            class B_ {
                constructor() {
                    this.name = t_
                }
            }
            class R_ extends Fa {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = e * i * 3 + i;
                    for (let e = 0; e !== i; e++) t[e] = n[r + e];
                    return t
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = 2 * o,
                        l = 3 * o,
                        c = i - t,
                        u = (n - t) / c,
                        h = u * u,
                        d = h * u,
                        f = e * l,
                        p = f - l,
                        m = -2 * d + 3 * h,
                        g = d - h,
                        A = 1 - m,
                        v = g - h + u;
                    for (let e = 0; e !== o; e++) {
                        const t = s[p + e + o],
                            n = s[p + e + a] * c,
                            i = s[f + e + o],
                            l = s[f + e] * c;
                        r[e] = A * t + v * n + m * i + g * l
                    }
                    return r
                }
            }
            const D_ = new mt;
            class P_ extends R_ {
                interpolate_(e, t, n, i) {
                    const r = super.interpolate_(e, t, n, i);
                    return D_.fromArray(r).normalize().toArray(r), r
                }
            }
            const L_ = {
                    POINTS: 0,
                    LINES: 1,
                    LINE_LOOP: 2,
                    LINE_STRIP: 3,
                    TRIANGLES: 4,
                    TRIANGLE_STRIP: 5,
                    TRIANGLE_FAN: 6
                },
                U_ = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                },
                N_ = {
                    9728: h,
                    9729: f,
                    9984: 1004,
                    9985: p,
                    9986: d,
                    9987: m
                },
                O_ = {
                    33071: c,
                    33648: u,
                    10497: l
                },
                F_ = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                },
                k_ = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv1",
                    TEXCOORD_2: "uv2",
                    TEXCOORD_3: "uv3",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                },
                Q_ = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                },
                z_ = {
                    CUBICSPLINE: void 0,
                    LINEAR: ge,
                    STEP: me
                };

            function H_(e, t, n) {
                for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
            }

            function G_(e, t) {
                void 0 !== t.extras && "object" == typeof t.extras && Object.assign(e.userData, t.extras)
            }

            function V_(e, t) {
                if (e.updateMorphTargets(), void 0 !== t.weights)
                    for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
                if (t.extras && Array.isArray(t.extras.targetNames)) {
                    const n = t.extras.targetNames;
                    if (e.morphTargetInfluences.length === n.length) {
                        e.morphTargetDictionary = {};
                        for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
                    }
                }
            }

            function j_(e) {
                let t;
                const n = e.extensions && e.extensions[zy];
                if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + W_(n.attributes) : e.indices + ":" + W_(e.attributes) + ":" + e.mode, void 0 !== e.targets)
                    for (let n = 0, i = e.targets.length; n < i; n++) t += ":" + W_(e.targets[n]);
                return t
            }

            function W_(e) {
                let t = "";
                const n = Object.keys(e).sort();
                for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
                return t
            }

            function X_(e) {
                switch (e) {
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                }
            }
            const Y_ = new Wt;
            class q_ {
                constructor(e = {}, t = {}) {
                    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new ky, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                        refs: {},
                        uses: {}
                    }, this.cameraCache = {
                        refs: {},
                        uses: {}
                    }, this.lightCache = {
                        refs: {},
                        uses: {}
                    }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                    let n = !1,
                        i = -1,
                        r = !1,
                        s = -1;
                    if ("undefined" != typeof navigator) {
                        const e = navigator.userAgent;
                        n = !0 === /^((?!chrome|android).)*safari/i.test(e);
                        const t = e.match(/Version\/(\d+)/);
                        i = n && t ? parseInt(t[1], 10) : -1, r = e.indexOf("Firefox") > -1, s = r ? e.match(/Firefox\/([0-9]+)\./)[1] : -1
                    }
                    "undefined" == typeof createImageBitmap || n && i < 17 || r && s < 98 ? this.textureLoader = new al(this.options.manager) : this.textureLoader = new wl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new rl(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                }
                setExtensions(e) {
                    this.extensions = e
                }
                setPlugins(e) {
                    this.plugins = e
                }
                parse(e, t) {
                    const n = this,
                        i = this.json,
                        r = this.extensions;
                    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function(e) {
                        return e._markDefs && e._markDefs()
                    })), Promise.all(this._invokeAll((function(e) {
                        return e.beforeRoot && e.beforeRoot()
                    }))).then((function() {
                        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                    })).then((function(t) {
                        const s = {
                            scene: t[0][i.scene || 0],
                            scenes: t[0],
                            animations: t[1],
                            cameras: t[2],
                            asset: i.asset,
                            parser: n,
                            userData: {}
                        };
                        return H_(r, s, i), G_(s, i), Promise.all(n._invokeAll((function(e) {
                            return e.afterRoot && e.afterRoot(s)
                        }))).then((function() {
                            for (const e of s.scenes) e.updateMatrixWorld();
                            e(s)
                        }))
                    })).catch(t)
                }
                _markDefs() {
                    const e = this.json.nodes || [],
                        t = this.json.skins || [],
                        n = this.json.meshes || [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n].joints;
                        for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0
                    }
                    for (let t = 0, i = e.length; t < i; t++) {
                        const i = e[t];
                        void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                    }
                }
                _addNodeRef(e, t) {
                    void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
                }
                _getNodeRef(e, t, n) {
                    if (e.refs[t] <= 1) return n;
                    const i = n.clone(),
                        r = (e, t) => {
                            const n = this.associations.get(e);
                            null != n && this.associations.set(t, n);
                            for (const [n, i] of e.children.entries()) r(i, t.children[n])
                        };
                    return r(n, i), i.name += "_instance_" + e.uses[t]++, i
                }
                _invokeOne(e) {
                    const t = Object.values(this.plugins);
                    t.push(this);
                    for (let n = 0; n < t.length; n++) {
                        const i = e(t[n]);
                        if (i) return i
                    }
                    return null
                }
                _invokeAll(e) {
                    const t = Object.values(this.plugins);
                    t.unshift(this);
                    const n = [];
                    for (let i = 0; i < t.length; i++) {
                        const r = e(t[i]);
                        r && n.push(r)
                    }
                    return n
                }
                getDependency(e, t) {
                    const n = e + ":" + t;
                    let i = this.cache.get(n);
                    if (!i) {
                        switch (e) {
                            case "scene":
                                i = this.loadScene(t);
                                break;
                            case "node":
                                i = this._invokeOne((function(e) {
                                    return e.loadNode && e.loadNode(t)
                                }));
                                break;
                            case "mesh":
                                i = this._invokeOne((function(e) {
                                    return e.loadMesh && e.loadMesh(t)
                                }));
                                break;
                            case "accessor":
                                i = this.loadAccessor(t);
                                break;
                            case "bufferView":
                                i = this._invokeOne((function(e) {
                                    return e.loadBufferView && e.loadBufferView(t)
                                }));
                                break;
                            case "buffer":
                                i = this.loadBuffer(t);
                                break;
                            case "material":
                                i = this._invokeOne((function(e) {
                                    return e.loadMaterial && e.loadMaterial(t)
                                }));
                                break;
                            case "texture":
                                i = this._invokeOne((function(e) {
                                    return e.loadTexture && e.loadTexture(t)
                                }));
                                break;
                            case "skin":
                                i = this.loadSkin(t);
                                break;
                            case "animation":
                                i = this._invokeOne((function(e) {
                                    return e.loadAnimation && e.loadAnimation(t)
                                }));
                                break;
                            case "camera":
                                i = this.loadCamera(t);
                                break;
                            default:
                                if (i = this._invokeOne((function(n) {
                                        return n != this && n.getDependency && n.getDependency(e, t)
                                    })), !i) throw new Error("Unknown type: " + e)
                        }
                        this.cache.add(n, i)
                    }
                    return i
                }
                getDependencies(e) {
                    let t = this.cache.get(e);
                    if (!t) {
                        const n = this,
                            i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                        t = Promise.all(i.map((function(t, i) {
                            return n.getDependency(e, i)
                        }))), this.cache.add(e, t)
                    }
                    return t
                }
                loadBuffer(e) {
                    const t = this.json.buffers[e],
                        n = this.fileLoader;
                    if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                    if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Qy].body);
                    const i = this.options;
                    return new Promise((function(e, r) {
                        n.load(bl.resolveURL(t.uri, i.path), e, void 0, (function() {
                            r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                        }))
                    }))
                }
                loadBufferView(e) {
                    const t = this.json.bufferViews[e];
                    return this.getDependency("buffer", t.buffer).then((function(e) {
                        const n = t.byteLength || 0,
                            i = t.byteOffset || 0;
                        return e.slice(i, i + n)
                    }))
                }
                loadAccessor(e) {
                    const t = this,
                        n = this.json,
                        i = this.json.accessors[e];
                    if (void 0 === i.bufferView && void 0 === i.sparse) {
                        const e = F_[i.type],
                            t = U_[i.componentType],
                            n = !0 === i.normalized,
                            r = new t(i.count * e);
                        return Promise.resolve(new Yn(r, e, n))
                    }
                    const r = [];
                    return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(e) {
                        const r = e[0],
                            s = F_[i.type],
                            o = U_[i.componentType],
                            a = o.BYTES_PER_ELEMENT,
                            l = a * s,
                            c = i.byteOffset || 0,
                            u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                            h = !0 === i.normalized;
                        let d, f;
                        if (u && u !== l) {
                            const e = Math.floor(c / u),
                                n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                            let l = t.cache.get(n);
                            l || (d = new o(r, e * u, i.count * u / a), l = new Do(d, u / a), t.cache.add(n, l)), f = new Lo(l, s, c % u / a, h)
                        } else d = null === r ? new o(i.count * s) : new o(r, c, i.count * s), f = new Yn(d, s, h);
                        if (void 0 !== i.sparse) {
                            const t = F_.SCALAR,
                                n = U_[i.sparse.indices.componentType],
                                a = i.sparse.indices.byteOffset || 0,
                                l = i.sparse.values.byteOffset || 0,
                                c = new n(e[1], a, i.sparse.count * t),
                                u = new o(e[2], l, i.sparse.count * s);
                            null !== r && (f = new Yn(f.array.slice(), f.itemSize, f.normalized)), f.normalized = !1;
                            for (let e = 0, t = c.length; e < t; e++) {
                                const t = c[e];
                                if (f.setX(t, u[e * s]), s >= 2 && f.setY(t, u[e * s + 1]), s >= 3 && f.setZ(t, u[e * s + 2]), s >= 4 && f.setW(t, u[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                            }
                            f.normalized = h
                        }
                        return f
                    }))
                }
                loadTexture(e) {
                    const t = this.json,
                        n = this.options,
                        i = t.textures[e].source,
                        r = t.images[i];
                    let s = this.textureLoader;
                    if (r.uri) {
                        const e = n.manager.getHandler(r.uri);
                        null !== e && (s = e)
                    }
                    return this.loadTextureImage(e, i, s)
                }
                loadTextureImage(e, t, n) {
                    const i = this,
                        r = this.json,
                        s = r.textures[e],
                        o = r.images[t],
                        a = (o.uri || o.bufferView) + ":" + s.sampler;
                    if (this.textureCache[a]) return this.textureCache[a];
                    const c = this.loadImageSource(t, n).then((function(t) {
                        t.flipY = !1, t.name = s.name || o.name || "", "" === t.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (t.name = o.uri);
                        const n = (r.samplers || {})[s.sampler] || {};
                        return t.magFilter = N_[n.magFilter] || f, t.minFilter = N_[n.minFilter] || m, t.wrapS = O_[n.wrapS] || l, t.wrapT = O_[n.wrapT] || l, t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== h && t.minFilter !== f, i.associations.set(t, {
                            textures: e
                        }), t
                    })).catch((function() {
                        return null
                    }));
                    return this.textureCache[a] = c, c
                }
                loadImageSource(e, t) {
                    const n = this.json,
                        i = this.options;
                    if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
                    const r = n.images[e],
                        s = self.URL || self.webkitURL;
                    let o = r.uri || "",
                        a = !1;
                    if (void 0 !== r.bufferView) o = this.getDependency("bufferView", r.bufferView).then((function(e) {
                        a = !0;
                        const t = new Blob([e], {
                            type: r.mimeType
                        });
                        return o = s.createObjectURL(t), o
                    }));
                    else if (void 0 === r.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                    const l = Promise.resolve(o).then((function(e) {
                        return new Promise((function(n, r) {
                            let s = n;
                            !0 === t.isImageBitmapLoader && (s = function(e) {
                                const t = new ct(e);
                                t.needsUpdate = !0, n(t)
                            }), t.load(bl.resolveURL(e, i.path), s, void 0, r)
                        }))
                    })).then((function(e) {
                        var t;
                        return !0 === a && s.revokeObjectURL(o), G_(e, r), e.userData.mimeType = r.mimeType || ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"), e
                    })).catch((function(e) {
                        throw e
                    }));
                    return this.sourceCache[e] = l, l
                }
                assignTexture(e, t, n, i) {
                    const r = this;
                    return this.getDependency("texture", n.index).then((function(s) {
                        if (!s) return null;
                        if (void 0 !== n.texCoord && n.texCoord > 0 && ((s = s.clone()).channel = n.texCoord), r.extensions[e_]) {
                            const e = void 0 !== n.extensions ? n.extensions[e_] : void 0;
                            if (e) {
                                const t = r.associations.get(s);
                                s = r.extensions[e_].extendTexture(s, e), r.associations.set(s, t)
                            }
                        }
                        return void 0 !== i && (s.colorSpace = i), e[t] = s, s
                    }))
                }
                assignFinalMaterial(e) {
                    const t = e.geometry;
                    let n = e.material;
                    const i = void 0 === t.attributes.tangent,
                        r = void 0 !== t.attributes.color,
                        s = void 0 === t.attributes.normal;
                    if (e.isPoints) {
                        const e = "PointsMaterial:" + n.uuid;
                        let t = this.cache.get(e);
                        t || (t = new ya, Hn.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
                    } else if (e.isLine) {
                        const e = "LineBasicMaterial:" + n.uuid;
                        let t = this.cache.get(e);
                        t || (t = new sa, Hn.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t
                    }
                    if (i || r || s) {
                        let e = "ClonedMaterial:" + n.uuid + ":";
                        i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), s && (e += "flat-shading:");
                        let t = this.cache.get(e);
                        t || (t = n.clone(), r && (t.vertexColors = !0), s && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
                    }
                    e.material = n
                }
                getMaterialType() {
                    return Ra
                }
                loadMaterial(e) {
                    const t = this,
                        n = this.json,
                        i = this.extensions,
                        r = n.materials[e];
                    let s;
                    const o = {},
                        a = [];
                    if ((r.extensions || {})[Jy]) {
                        const e = i[Jy];
                        s = e.getMaterialType(), a.push(e.extendParams(o, r, t))
                    } else {
                        const n = r.pbrMetallicRoughness || {};
                        if (o.color = new kn(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) {
                            const e = n.baseColorFactor;
                            o.color.setRGB(e[0], e[1], e[2], xe), o.opacity = e[3]
                        }
                        void 0 !== n.baseColorTexture && a.push(t.assignTexture(o, "map", n.baseColorTexture, _e)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (a.push(t.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), a.push(t.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function(t) {
                            return t.getMaterialType && t.getMaterialType(e)
                        })), a.push(Promise.all(this._invokeAll((function(t) {
                            return t.extendMaterialParams && t.extendMaterialParams(e, o)
                        }))))
                    }!0 === r.doubleSided && (o.side = 2);
                    const l = r.alphaMode || "OPAQUE";
                    if ("BLEND" === l ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, "MASK" === l && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Gn && (a.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new ze(1, 1), void 0 !== r.normalTexture.scale)) {
                        const e = r.normalTexture.scale;
                        o.normalScale.set(e, e)
                    }
                    if (void 0 !== r.occlusionTexture && s !== Gn && (a.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Gn) {
                        const e = r.emissiveFactor;
                        o.emissive = (new kn).setRGB(e[0], e[1], e[2], xe)
                    }
                    return void 0 !== r.emissiveTexture && s !== Gn && a.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, _e)), Promise.all(a).then((function() {
                        const n = new s(o);
                        return r.name && (n.name = r.name), G_(n, r), t.associations.set(n, {
                            materials: e
                        }), r.extensions && H_(i, n, r), n
                    }))
                }
                createUniqueName(e) {
                    const t = Pl.sanitizeNodeName(e || "");
                    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
                }
                loadGeometries(e) {
                    const t = this,
                        n = this.extensions,
                        i = this.primitiveCache;

                    function r(e) {
                        return n[zy].decodePrimitive(e, t).then((function(n) {
                            return K_(n, e, t)
                        }))
                    }
                    const s = [];
                    for (let n = 0, o = e.length; n < o; n++) {
                        const o = e[n],
                            a = j_(o),
                            l = i[a];
                        if (l) s.push(l.promise);
                        else {
                            let e;
                            e = o.extensions && o.extensions[zy] ? r(o) : K_(new si, o, t), i[a] = {
                                primitive: o,
                                promise: e
                            }, s.push(e)
                        }
                    }
                    return Promise.all(s)
                }
                loadMesh(e) {
                    const t = this,
                        n = this.json,
                        i = this.extensions,
                        r = n.meshes[e],
                        s = r.primitives,
                        o = [];
                    for (let e = 0, t = s.length; e < t; e++) {
                        const t = void 0 === s[e].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new Ra({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: 0
                        })), a.DefaultMaterial) : this.getDependency("material", s[e].material);
                        o.push(t)
                    }
                    var a;
                    return o.push(t.loadGeometries(s)), Promise.all(o).then((function(n) {
                        const o = n.slice(0, n.length - 1),
                            a = n[n.length - 1],
                            l = [];
                        for (let n = 0, c = a.length; n < c; n++) {
                            const c = a[n],
                                u = s[n];
                            let h;
                            const d = o[n];
                            if (u.mode === L_.TRIANGLES || u.mode === L_.TRIANGLE_STRIP || u.mode === L_.TRIANGLE_FAN || void 0 === u.mode) h = !0 === r.isSkinnedMesh ? new Vo(c, d) : new Ai(c, d), !0 === h.isSkinnedMesh && h.normalizeSkinWeights(), u.mode === L_.TRIANGLE_STRIP ? h.geometry = Fy(h.geometry, 1) : u.mode === L_.TRIANGLE_FAN && (h.geometry = Fy(h.geometry, 2));
                            else if (u.mode === L_.LINES) h = new Aa(c, d);
                            else if (u.mode === L_.LINE_STRIP) h = new fa(c, d);
                            else if (u.mode === L_.LINE_LOOP) h = new va(c, d);
                            else {
                                if (u.mode !== L_.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                                h = new wa(c, d)
                            }
                            Object.keys(h.geometry.morphAttributes).length > 0 && V_(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), G_(h, r), u.extensions && H_(i, h, u), t.assignFinalMaterial(h), l.push(h)
                        }
                        for (let n = 0, i = l.length; n < i; n++) t.associations.set(l[n], {
                            meshes: e,
                            primitives: n
                        });
                        if (1 === l.length) return r.extensions && H_(i, l[0], r), l[0];
                        const c = new xo;
                        r.extensions && H_(i, c, r), t.associations.set(c, {
                            meshes: e
                        });
                        for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                        return c
                    }))
                }
                loadCamera(e) {
                    let t;
                    const n = this.json.cameras[e],
                        i = n[n.type];
                    if (i) return "perspective" === n.type ? t = new Ii(Qe.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new nr(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), G_(t, n), Promise.resolve(t)
                }
                loadSkin(e) {
                    const t = this.json.skins[e],
                        n = [];
                    for (let e = 0, i = t.joints.length; e < i; e++) n.push(this._loadNodeShallow(t.joints[e]));
                    return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function(e) {
                        const t = e.pop(),
                            n = e,
                            i = [],
                            r = [];
                        for (let e = 0, s = n.length; e < s; e++) {
                            const s = n[e];
                            if (s) {
                                i.push(s);
                                const n = new Wt;
                                null !== t && n.fromArray(t.array, 16 * e), r.push(n)
                            }
                        }
                        return new qo(i, r)
                    }))
                }
                loadAnimation(e) {
                    const t = this.json,
                        n = this,
                        i = t.animations[e],
                        r = i.name ? i.name : "animation_" + e,
                        s = [],
                        o = [],
                        a = [],
                        l = [],
                        c = [];
                    for (let e = 0, t = i.channels.length; e < t; e++) {
                        const t = i.channels[e],
                            n = i.samplers[t.sampler],
                            r = t.target,
                            u = r.node,
                            h = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
                            d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                        void 0 !== r.node && (s.push(this.getDependency("node", u)), o.push(this.getDependency("accessor", h)), a.push(this.getDependency("accessor", d)), l.push(n), c.push(r))
                    }
                    return Promise.all([Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c)]).then((function(e) {
                        const t = e[0],
                            i = e[1],
                            s = e[2],
                            o = e[3],
                            a = e[4],
                            l = [];
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = t[e],
                                c = i[e],
                                u = s[e],
                                h = o[e],
                                d = a[e];
                            if (void 0 === r) continue;
                            r.updateMatrix && r.updateMatrix();
                            const f = n._createAnimationTracks(r, c, u, h, d);
                            if (f)
                                for (let e = 0; e < f.length; e++) l.push(f[e])
                        }
                        return new Ka(r, void 0, l)
                    }))
                }
                createNodeMesh(e) {
                    const t = this.json,
                        n = this,
                        i = t.nodes[e];
                    return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                        const t = n._getNodeRef(n.meshCache, i.mesh, e);
                        return void 0 !== i.weights && t.traverse((function(e) {
                            if (e.isMesh)
                                for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
                        })), t
                    }))
                }
                loadNode(e) {
                    const t = this,
                        n = this.json.nodes[e],
                        i = t._loadNodeShallow(e),
                        r = [],
                        s = n.children || [];
                    for (let e = 0, n = s.length; e < n; e++) r.push(t.getDependency("node", s[e]));
                    const o = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                    return Promise.all([i, Promise.all(r), o]).then((function(e) {
                        const t = e[0],
                            n = e[1],
                            i = e[2];
                        null !== i && t.traverse((function(e) {
                            e.isSkinnedMesh && e.bind(i, Y_)
                        }));
                        for (let e = 0, i = n.length; e < i; e++) t.add(n[e]);
                        return t
                    }))
                }
                _loadNodeShallow(e) {
                    const t = this.json,
                        n = this.extensions,
                        i = this;
                    if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
                    const r = t.nodes[e],
                        s = r.name ? i.createUniqueName(r.name) : "",
                        o = [],
                        a = i._invokeOne((function(t) {
                            return t.createNodeMesh && t.createNodeMesh(e)
                        }));
                    return a && o.push(a), void 0 !== r.camera && o.push(i.getDependency("camera", r.camera).then((function(e) {
                        return i._getNodeRef(i.cameraCache, r.camera, e)
                    }))), i._invokeAll((function(t) {
                        return t.createNodeAttachment && t.createNodeAttachment(e)
                    })).forEach((function(e) {
                        o.push(e)
                    })), this.nodeCache[e] = Promise.all(o).then((function(t) {
                        let o;
                        if (o = !0 === r.isBone ? new jo : t.length > 1 ? new xo : 1 === t.length ? t[0] : new _n, o !== t[0])
                            for (let e = 0, n = t.length; e < n; e++) o.add(t[e]);
                        if (r.name && (o.userData.name = r.name, o.name = s), G_(o, r), r.extensions && H_(n, o, r), void 0 !== r.matrix) {
                            const e = new Wt;
                            e.fromArray(r.matrix), o.applyMatrix4(e)
                        } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale);
                        return i.associations.has(o) || i.associations.set(o, {}), i.associations.get(o).nodes = e, o
                    })), this.nodeCache[e]
                }
                loadScene(e) {
                    const t = this.extensions,
                        n = this.json.scenes[e],
                        i = this,
                        r = new xo;
                    n.name && (r.name = i.createUniqueName(n.name)), G_(r, n), n.extensions && H_(t, r, n);
                    const s = n.nodes || [],
                        o = [];
                    for (let e = 0, t = s.length; e < t; e++) o.push(i.getDependency("node", s[e]));
                    return Promise.all(o).then((function(e) {
                        for (let t = 0, n = e.length; t < n; t++) r.add(e[t]);
                        return i.associations = (e => {
                            const t = new Map;
                            for (const [e, n] of i.associations)(e instanceof Hn || e instanceof ct) && t.set(e, n);
                            return e.traverse((e => {
                                const n = i.associations.get(e);
                                null != n && t.set(e, n)
                            })), t
                        })(r), r
                    }))
                }
                _createAnimationTracks(e, t, n, i, r) {
                    const s = [],
                        o = e.name ? e.name : e.uuid,
                        a = [];
                    let l;
                    switch (Q_[r.path] === Q_.weights ? e.traverse((function(e) {
                            e.morphTargetInfluences && a.push(e.name ? e.name : e.uuid)
                        })) : a.push(o), Q_[r.path]) {
                        case Q_.weights:
                            l = ja;
                            break;
                        case Q_.rotation:
                            l = Xa;
                            break;
                        case Q_.position:
                        case Q_.scale:
                            l = qa;
                            break;
                        default:
                            l = 1 === n.itemSize ? ja : qa
                    }
                    const c = void 0 !== i.interpolation ? z_[i.interpolation] : ge,
                        u = this._getArrayFromAccessor(n);
                    for (let e = 0, n = a.length; e < n; e++) {
                        const n = new l(a[e] + "." + Q_[r.path], t.array, u, c);
                        "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n), s.push(n)
                    }
                    return s
                }
                _getArrayFromAccessor(e) {
                    let t = e.array;
                    if (e.normalized) {
                        const e = X_(t.constructor),
                            n = new Float32Array(t.length);
                        for (let i = 0, r = t.length; i < r; i++) n[i] = t[i] * e;
                        t = n
                    }
                    return t
                }
                _createCubicSplineTrackInterpolant(e) {
                    e.createInterpolant = function(e) {
                        return new(this instanceof Xa ? P_ : R_)(this.times, this.values, this.getValueSize() / 3, e)
                    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
                }
            }

            function K_(e, t, n) {
                const i = t.attributes,
                    r = [];

                function s(t, i) {
                    return n.getDependency("accessor", t).then((function(t) {
                        e.setAttribute(i, t)
                    }))
                }
                for (const t in i) {
                    const n = k_[t] || t.toLowerCase();
                    n in e.attributes || r.push(s(i[t], n))
                }
                if (void 0 !== t.indices && !e.index) {
                    const i = n.getDependency("accessor", t.indices).then((function(t) {
                        e.setIndex(t)
                    }));
                    r.push(i)
                }
                return qe.workingColorSpace, G_(e, t),
                    function(e, t, n) {
                        const i = t.attributes,
                            r = new yt;
                        if (void 0 === i.POSITION) return;
                        {
                            const e = n.json.accessors[i.POSITION],
                                t = e.min,
                                s = e.max;
                            if (void 0 === t || void 0 === s) return;
                            if (r.set(new gt(t[0], t[1], t[2]), new gt(s[0], s[1], s[2])), e.normalized) {
                                const t = X_(U_[e.componentType]);
                                r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                            }
                        }
                        const s = t.targets;
                        if (void 0 !== s) {
                            const e = new gt,
                                t = new gt;
                            for (let i = 0, r = s.length; i < r; i++) {
                                const r = s[i];
                                if (void 0 !== r.POSITION) {
                                    const i = n.json.accessors[r.POSITION],
                                        s = i.min,
                                        o = i.max;
                                    if (void 0 !== s && void 0 !== o) {
                                        if (t.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), i.normalized) {
                                            const e = X_(U_[i.componentType]);
                                            t.multiplyScalar(e)
                                        }
                                        e.max(t)
                                    }
                                }
                            }
                            r.expandByVector(e)
                        }
                        e.boundingBox = r;
                        const o = new Ot;
                        r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = o
                    }(e, t, n), Promise.all(r).then((function() {
                        return void 0 !== t.targets ? function(e, t, n) {
                            let i = !1,
                                r = !1,
                                s = !1;
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (s = !0), i && r && s) break
                            }
                            if (!i && !r && !s) return Promise.resolve(e);
                            const o = [],
                                a = [],
                                l = [];
                            for (let c = 0, u = t.length; c < u; c++) {
                                const u = t[c];
                                if (i) {
                                    const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                                    o.push(t)
                                }
                                if (r) {
                                    const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                                    a.push(t)
                                }
                                if (s) {
                                    const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                                    l.push(t)
                                }
                            }
                            return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then((function(t) {
                                const n = t[0],
                                    o = t[1],
                                    a = t[2];
                                return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = o), s && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e
                            }))
                        }(e, t.targets, n) : e
                    }))
            }
            const J_ = new WeakMap;

            function Z_() {
                let e, t;

                function n(e, t, n, i, r, s) {
                    const o = s.num_components(),
                        a = n.num_points() * o,
                        l = a * r.BYTES_PER_ELEMENT,
                        c = function(e, t) {
                            switch (t) {
                                case Float32Array:
                                    return e.DT_FLOAT32;
                                case Int8Array:
                                    return e.DT_INT8;
                                case Int16Array:
                                    return e.DT_INT16;
                                case Int32Array:
                                    return e.DT_INT32;
                                case Uint8Array:
                                    return e.DT_UINT8;
                                case Uint16Array:
                                    return e.DT_UINT16;
                                case Uint32Array:
                                    return e.DT_UINT32
                            }
                        }(e, r),
                        u = e._malloc(l);
                    t.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
                    const h = new r(e.HEAPF32.buffer, u, a).slice();
                    return e._free(u), {
                        name: i,
                        array: h,
                        itemSize: o
                    }
                }
                onmessage = function(i) {
                    const r = i.data;
                    switch (r.type) {
                        case "init":
                            e = r.decoderConfig, t = new Promise((function(t) {
                                e.onModuleLoaded = function(e) {
                                    t({
                                        draco: e
                                    })
                                }, DracoDecoderModule(e)
                            }));
                            break;
                        case "decode":
                            const i = r.buffer,
                                s = r.taskConfig;
                            t.then((e => {
                                const t = e.draco,
                                    o = new t.Decoder;
                                try {
                                    const e = function(e, t, i, r) {
                                            const s = r.attributeIDs,
                                                o = r.attributeTypes;
                                            let a, l;
                                            const c = t.GetEncodedGeometryType(i);
                                            if (c === e.TRIANGULAR_MESH) a = new e.Mesh, l = t.DecodeArrayToMesh(i, i.byteLength, a);
                                            else {
                                                if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                a = new e.PointCloud, l = t.DecodeArrayToPointCloud(i, i.byteLength, a)
                                            }
                                            if (!l.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                            const u = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (const i in s) {
                                                const l = self[o[i]];
                                                let c, h;
                                                if (r.useUniqueIDs) h = s[i], c = t.GetAttributeByUniqueId(a, h);
                                                else {
                                                    if (h = t.GetAttributeId(a, e[s[i]]), -1 === h) continue;
                                                    c = t.GetAttribute(a, h)
                                                }
                                                const d = n(e, t, a, i, l, c);
                                                "color" === i && (d.vertexColorSpace = r.vertexColorSpace), u.attributes.push(d)
                                            }
                                            return c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                                const i = 3 * n.num_faces(),
                                                    r = 4 * i,
                                                    s = e._malloc(r);
                                                t.GetTrianglesUInt32Array(n, r, s);
                                                const o = new Uint32Array(e.HEAPF32.buffer, s, i).slice();
                                                return e._free(s), {
                                                    array: o,
                                                    itemSize: 1
                                                }
                                            }(e, t, a)), e.destroy(a), u
                                        }(t, o, new Int8Array(i), s),
                                        a = e.attributes.map((e => e.array.buffer));
                                    e.index && a.push(e.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: r.id,
                                        geometry: e
                                    }, a)
                                } catch (e) {
                                    self.postMessage({
                                        type: "error",
                                        id: r.id,
                                        error: e.message
                                    })
                                } finally {
                                    t.destroy(o)
                                }
                            }))
                    }
                }
            }
            var $_ = new class extends tl {
                    constructor(e) {
                        super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                            return new h_(e)
                        })), this.register((function(e) {
                            return new d_(e)
                        })), this.register((function(e) {
                            return new x_(e)
                        })), this.register((function(e) {
                            return new E_(e)
                        })), this.register((function(e) {
                            return new b_(e)
                        })), this.register((function(e) {
                            return new p_(e)
                        })), this.register((function(e) {
                            return new m_(e)
                        })), this.register((function(e) {
                            return new g_(e)
                        })), this.register((function(e) {
                            return new A_(e)
                        })), this.register((function(e) {
                            return new u_(e)
                        })), this.register((function(e) {
                            return new v_(e)
                        })), this.register((function(e) {
                            return new f_(e)
                        })), this.register((function(e) {
                            return new __(e)
                        })), this.register((function(e) {
                            return new y_(e)
                        })), this.register((function(e) {
                            return new l_(e)
                        })), this.register((function(e) {
                            return new w_(e)
                        })), this.register((function(e) {
                            return new C_(e)
                        }))
                    }
                    load(e, t, n, i) {
                        const r = this;
                        let s;
                        if ("" !== this.resourcePath) s = this.resourcePath;
                        else if ("" !== this.path) {
                            const t = bl.extractUrlBase(e);
                            s = bl.resolveURL(t, this.path)
                        } else s = bl.extractUrlBase(e);
                        this.manager.itemStart(e);
                        const o = function(t) {
                                i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                            },
                            a = new rl(this.manager);
                        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function(n) {
                            try {
                                r.parse(n, s, (function(n) {
                                    t(n), r.manager.itemEnd(e)
                                }), o)
                            } catch (e) {
                                o(e)
                            }
                        }), n, o)
                    }
                    setDRACOLoader(e) {
                        return this.dracoLoader = e, this
                    }
                    setKTX2Loader(e) {
                        return this.ktx2Loader = e, this
                    }
                    setMeshoptDecoder(e) {
                        return this.meshoptDecoder = e, this
                    }
                    register(e) {
                        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
                    }
                    unregister(e) {
                        return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
                    }
                    parse(e, t, n, i) {
                        let r;
                        const s = {},
                            o = {},
                            a = new TextDecoder;
                        if ("string" == typeof e) r = JSON.parse(e);
                        else if (e instanceof ArrayBuffer)
                            if (a.decode(new Uint8Array(e, 0, 4)) === S_) {
                                try {
                                    s[Qy] = new T_(e)
                                } catch (e) {
                                    return void(i && i(e))
                                }
                                r = JSON.parse(s[Qy].content)
                            } else r = JSON.parse(a.decode(e));
                        else r = e;
                        if (void 0 === r.asset || r.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                        const l = new q_(r, {
                            path: t || this.resourcePath || "",
                            crossOrigin: this.crossOrigin,
                            requestHeader: this.requestHeader,
                            manager: this.manager,
                            ktx2Loader: this.ktx2Loader,
                            meshoptDecoder: this.meshoptDecoder
                        });
                        l.fileLoader.setRequestHeader(this.requestHeader);
                        for (let e = 0; e < this.pluginCallbacks.length; e++) {
                            const t = this.pluginCallbacks[e](l);
                            t.name, o[t.name] = t, s[t.name] = !0
                        }
                        if (r.extensionsUsed)
                            for (let e = 0; e < r.extensionsUsed.length; ++e) {
                                const t = r.extensionsUsed[e],
                                    n = r.extensionsRequired || [];
                                switch (t) {
                                    case Jy:
                                        s[t] = new c_;
                                        break;
                                    case zy:
                                        s[t] = new M_(r, this.dracoLoader);
                                        break;
                                    case e_:
                                        s[t] = new I_;
                                        break;
                                    case t_:
                                        s[t] = new B_;
                                        break;
                                    default:
                                        n.indexOf(t) >= 0 && o[t]
                                }
                            }
                        l.setExtensions(s), l.setPlugins(o), l.parse(n, i)
                    }
                    parseAsync(e, t) {
                        const n = this;
                        return new Promise((function(i, r) {
                            n.parse(e, t, i, r)
                        }))
                    }
                }(Xd),
                ex = new class extends tl {
                    constructor(e) {
                        super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                            position: "POSITION",
                            normal: "NORMAL",
                            color: "COLOR",
                            uv: "TEX_COORD"
                        }, this.defaultAttributeTypes = {
                            position: "Float32Array",
                            normal: "Float32Array",
                            color: "Float32Array",
                            uv: "Float32Array"
                        }
                    }
                    setDecoderPath(e) {
                        return this.decoderPath = e, this
                    }
                    setDecoderConfig(e) {
                        return this.decoderConfig = e, this
                    }
                    setWorkerLimit(e) {
                        return this.workerLimit = e, this
                    }
                    load(e, t, n, i) {
                        const r = new rl(this.manager);
                        r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (e => {
                            this.parse(e, t, i)
                        }), n, i)
                    }
                    parse(e, t, n = (() => {})) {
                        this.decodeDracoFile(e, t, null, null, _e, n).catch(n)
                    }
                    decodeDracoFile(e, t, n, i, r = xe, s = (() => {})) {
                        const o = {
                            attributeIDs: n || this.defaultAttributeIDs,
                            attributeTypes: i || this.defaultAttributeTypes,
                            useUniqueIDs: !!n,
                            vertexColorSpace: r
                        };
                        return this.decodeGeometry(e, o).then(t).catch(s)
                    }
                    decodeGeometry(e, t) {
                        const n = JSON.stringify(t);
                        if (J_.has(e)) {
                            const t = J_.get(e);
                            if (t.key === n) return t.promise;
                            if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                        }
                        let i;
                        const r = this.workerNextTaskID++,
                            s = e.byteLength,
                            o = this._getWorker(r, s).then((n => (i = n, new Promise(((n, s) => {
                                i._callbacks[r] = {
                                    resolve: n,
                                    reject: s
                                }, i.postMessage({
                                    type: "decode",
                                    id: r,
                                    taskConfig: t,
                                    buffer: e
                                }, [e])
                            }))))).then((e => this._createGeometry(e.geometry)));
                        return o.catch((() => !0)).then((() => {
                            i && r && this._releaseTask(i, r)
                        })), J_.set(e, {
                            key: n,
                            promise: o
                        }), o
                    }
                    _createGeometry(e) {
                        const t = new si;
                        e.index && t.setIndex(new Yn(e.index.array, 1));
                        for (let n = 0; n < e.attributes.length; n++) {
                            const i = e.attributes[n],
                                r = i.name,
                                s = i.array,
                                o = i.itemSize,
                                a = new Yn(s, o);
                            "color" === r && (this._assignVertexColorSpace(a, i.vertexColorSpace), a.normalized = s instanceof Float32Array == 0), t.setAttribute(r, a)
                        }
                        return t
                    }
                    _assignVertexColorSpace(e, t) {
                        if (t !== _e) return;
                        const n = new kn;
                        for (let t = 0, i = e.count; t < i; t++) n.fromBufferAttribute(e, t), qe.toWorkingColorSpace(n, _e), e.setXYZ(t, n.r, n.g, n.b)
                    }
                    _loadLibrary(e, t) {
                        const n = new rl(this.manager);
                        return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, i) => {
                            n.load(e, t, void 0, i)
                        }))
                    }
                    preload() {
                        return this._initDecoder(), this
                    }
                    _initDecoder() {
                        if (this.decoderPending) return this.decoderPending;
                        const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                            t = [];
                        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                            const n = t[0];
                            e || (this.decoderConfig.wasmBinary = t[1]);
                            const i = Z_.toString(),
                                r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                            this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                        })), this.decoderPending
                    }
                    _getWorker(e, t) {
                        return this._initDecoder().then((() => {
                            if (this.workerPool.length < this.workerLimit) {
                                const e = new Worker(this.workerSourceURL);
                                e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                                    type: "init",
                                    decoderConfig: this.decoderConfig
                                }), e.onmessage = function(t) {
                                    const n = t.data;
                                    switch (n.type) {
                                        case "decode":
                                            e._callbacks[n.id].resolve(n);
                                            break;
                                        case "error":
                                            e._callbacks[n.id].reject(n)
                                    }
                                }, this.workerPool.push(e)
                            } else this.workerPool.sort((function(e, t) {
                                return e._taskLoad > t._taskLoad ? -1 : 1
                            }));
                            const n = this.workerPool[this.workerPool.length - 1];
                            return n._taskCosts[e] = t, n._taskLoad += t, n
                        }))
                    }
                    _releaseTask(e, t) {
                        e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
                    }
                    debug() {}
                    dispose() {
                        for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                        return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
                    }
                };

            function tx(e, t) {
                return ex.setDecoderPath("".concat(t, "draco/")), new Promise((function(t, n) {
                    $_.load(e, (function(e) {
                        t(e)
                    }))
                }))
            }
            $_.setDRACOLoader(ex);
            const nx = JSON.parse('{"textures":[{"textureMap":"Hotspot.png"},{"textureMap":"Cursor.png"}],"controls":{"firstPerson":{"minZoom":0.5,"maxZoom":1.5,"defaultZoom":1,"polarRotateSpeed":-0.3,"azimuthRotateSpeed":-0.3,"smoothTime":0.07,"draggingSmoothTime":0.07}},"hotspot":{"hoverOpacity":0.8,"opacity":0.6,"hoverTransitionTime":1,"size":0.4},"cursor":{"color":"FFFFEE","lerpFactor":0.1,"size":0.4}}'),
                ix = JSON.parse('{"1B":{"model":"1B_roomtour_grounded.glb","floorPlanImage":"onebed-floorplan-horizontal-2000.webp","startPoint":"360_Entry_01","infospots":[],"hotspots":[{"name":"360_Living_01","floorPlanPoint":{"cx":856.6,"cy":901.6},"textureMap":"2506/241220_Backyard_Tour_1B_Living_01.jpg","depthMap":"living01-depth.webp","position":{"x":-3.054314136505127,"y":1.5779738426208496,"z":0.8374505043029782},"target":{"x":-3.0543141348285077,"y":1.5779738426208607,"z":0.8374505041912036},"0-position":{"x":3.054314136505127,"y":1.5779738426208496,"z":-0.8374505043029785},"visibleHotspots":["360_Living_01","360_Living_03","360_Living_02","360_Entry_01"]},{"name":"360_Living_02","floorPlanPoint":{"cx":985.3,"cy":606.5},"textureMap":"2506/241220_Backyard_Tour_1B_Living_02.jpg","position":{"x":-2.133600708465888,"y":1.57797384264873,"z":-0.538161754738891},"target":{"x":2.1336007118225098,"y":1.577973842620861,"z":0.5381617546081543},"0-position":{"x":4.510206699371338,"y":1.5779738426208496,"z":0.5381617546081543},"visibleHotspots":["360_Living_02","360_Living_03","360_Living_01","360_Entry_01"],"visibleInfospots":["Empty_oven"]},{"name":"360_Living_03","floorPlanPoint":{"cx":614.5,"cy":606.5},"textureMap":"2506/241220_Backyard_Tour_1B_Living_03.jpg","position":{"x":-4.510206699371338,"y":1.5779738426208496,"z":-0.5381617546081549},"0-position":{"x":4.510206699371338,"y":1.5779738426208496,"z":0.5381617546081543},"target":{"x":-4.510206697694719,"y":1.5779738426208607,"z":-0.5381617547199294},"visibleHotspots":["360_Living_03","360_Living_02","360_Living_01","360_Entry_01"],"visibleInfospots":[]},{"name":"360_Entry_01","floorPlanPoint":{"cx":1494.4,"cy":861.3},"textureMap":"2506/241220_Backyard_Tour_1B_Entry_01.jpg","depthMap":"entry-depth.webp","position":{"x":0.914399746436702,"y":1.57797384264873,"z":0.837450504167595},"0-position":{"x":-0.9143997430801392,"y":1.57797384264873,"z":-0.8374505043029785},"target":{"x":0.914399744756758,"y":1.577973842620861,"z":0.837450504191204},"visibleHotspots":["360_Entry_01","360_Bathroom_01","360_Bedroom_01","360_Living_01"]},{"name":"360_Bedroom_01","floorPlanPoint":{"cx":1987.7,"cy":861.3},"textureMap":"2506/241220_Backyard_Tour_1B_Bedroom_01.jpg","depthMap":"bedroom-depth.webp","position":{"x":3.985815001678511,"y":1.577974000055737,"z":0.838200000055135},"0-position":{"x":-3.9858148097991943,"y":1.5779738426208496,"z":-0.8382000923156738},"target":{"x":3.985815,"y":1.577974,"z":0.8382},"visibleHotspots":["360_Entry_01","360_Bedroom_01"]},{"name":"360_Bathroom_01","floorPlanPoint":{"cx":1484.4,"cy":646.8},"textureMap":"2506/241220_Backyard_Tour_1B_Bathroom_01.jpg","depthMap":"bath-depth.webp","position":{"x":0.914399744784993,"y":1.577973842616203,"z":-0.479424951892371},"0-position":{"x":-0.9143997430801392,"y":1.5779738426208496,"z":0.47942495346069336},"target":{"x":0.914399744756759,"y":1.577973842620861,"z":-0.479424953572468},"visibleHotspots":["360_Bathroom_01","360_Entry_01"]}],"groundLevel":0.05},"2B":{"model":"2b_interior_optimized_NoXform_cor.glb","floorPlanImage":"2b-floorplan.webp","startPoint":"360_Entry_01","infospots":[],"hotspots":[{"name":"360_Bathroom_01","floorPlanPoint":{"cx":1660,"cy":650},"rotationDeg":-90,"textureMap":"2506/250110_Backyard_Tour_2B_Bathroom_01.jpg","position":{"x":2.4342520236968994,"y":1.5620250701904297,"z":-0.48093950748443604},"0-position":{"x":-2.4342520236968994,"y":1.5620250701904297,"z":0.48093950748443604},"target":{"x":2.4342,"y":1.562,"z":-0.4809},"visibleHotspots":["360_Bathroom_01","360_Entry_01"],"visibleInfospots":[]},{"name":"360_Bedroom_01","floorPlanPoint":{"cx":1987.7,"cy":861.3},"textureMap":"2506/250110_Backyard_Tour_2B_BedroomPrimary_01.jpg","position":{"x":5.505666255950928,"y":1.562054991722107,"z":0.5318851470947266},"0-position":{"x":-5.505666255950928,"y":1.562054991722107,"z":-0.5318851470947266},"target":{"x":5.5056,"y":1.562,"z":0.5318},"visibleHotspots":["360_Entry_01","360_Bedroom_01"],"visibleInfospots":[]},{"name":"360_Entry_01","floorPlanPoint":{"cx":1680,"cy":861.3},"rotationDeg":-90,"textureMap":"2506/250110_Backyard_Tour_2B_Entry_01.jpg","position":{"x":2.4342520236968994,"y":1.562054991722107,"z":0.8359329700469971},"0-position":{"x":-2.4342520236968994,"y":1.562054991722107,"z":-0.8359329700469971},"target":{"x":2.4342,"y":1.562,"z":0.8359},"visibleHotspots":["360_Entry_01","360_Bathroom_01","360_Bedroom_01","360_Living_01"],"visibleInfospots":[]},{"name":"360_Living_01","textureMap":"2506/250110_Backyard_Tour_2B_Living_01.jpg","rotationDeg":90,"floorPlanPoint":{"cx":1300,"cy":861.3},"position":{"x":-0.23700782656669617,"y":1.562054991722107,"z":0.8359329700469971},"0-position":{"x":0.23700782656669617,"y":1.562054991722107,"z":-0.8359329700469971},"target":{"x":-0.237,"y":1.56205,"z":0.8359},"visibleHotspots":["360_Living_01","360_Living_03","360_Living_02","360_Entry_01"],"visibleInfospots":[]},{"name":"360_Living_02","textureMap":"2506/250110_Backyard_Tour_2B_Living_02.jpg","rotationDeg":90,"floorPlanPoint":{"cx":1300,"cy":650},"position":{"x":-0.6137485504150391,"y":1.562054991722107,"z":-0.5396773219108582},"0-position":{"x":0.6137485504150391,"y":1.562054991722107,"z":0.5396773219108582},"target":{"x":-0.6137,"y":1.562054991722107,"z":-0.5396},"visibleHotspots":["360_Living_02","360_Living_03","360_Living_01"],"visibleInfospots":[]},{"name":"360_Living_03","floorPlanPoint":{"cx":1050,"cy":600},"textureMap":"2506/250110_Backyard_Tour_2B_Living_03.jpg","position":{"x":-2.99035382270813,"y":1.562054991722107,"z":-0.5396773219108582},"0-position":{"x":2.990353584289551,"y":1.562054991722107,"z":0.5396773219108582},"target":{"x":-2.9903,"y":1.562,"z":-0.5396},"visibleHotspots":["360_Living_01","360_Living_02","360_Living_03","360_Media_Room_01"],"visibleInfospots":[]},{"name":"360_Media_Room_01","floorPlanPoint":{"cx":620,"cy":620},"textureMap":"2506/250110_Backyard_Tour_2B_BedroomSecondary_01.jpg","position":{"x":-5.442133903503418,"y":1.562054991722107,"z":-0.5396773219108582},"0-position":{"x":5.442133903503418,"y":1.562054991722107,"z":0.5396773219108582},"target":{"x":-5.4421,"y":1.56205,"z":-0.53967},"visibleHotspots":["360_Living_03","360_Media_Room_01"],"visibleInfospots":[]}],"groundLevel":0.05},"studio":{"model":"studio.glb","floorPlanImage":"studio-floorplan.webp","startPoint":"360_Entry_01","infospots":[],"groundLevel":0.05,"hotspots":[{"name":"360_Bathroom_01","floorPlanPoint":{"cx":1800,"cy":600},"rotationDeg":-90,"textureMap":"2506/241230_Backyard_Tour_Studio_Bathroom_01.jpg","position":{"x":2.7434611320495605,"y":1.4929843809127807,"z":-0.48069462180137634},"0-position":{"x":-2.7434611320495605,"y":1.4929843809127807,"z":0.48069462180137634},"target":{"x":2.7434,"y":1.4929,"z":-0.4806},"visibleHotspots":["360_Entry_01"]},{"name":"360_Entry_01","floorPlanPoint":{"cx":1850,"cy":870},"rotationDeg":-90,"textureMap":"2506/241230_Backyard_Tour_Studio_Entry_01.jpg","position":{"x":2.7434611320495605,"y":1.492914302444458,"z":0.8361778855323792},"0-position":{"x":-2.7434611320495605,"y":1.492914302444458,"z":-0.8361778855323792},"target":{"x":2.7434,"y":1.4929,"z":0.8361},"visibleHotspots":["360_Living_01","360_Bathroom_01"]},{"name":"360_Living_01","floorPlanPoint":{"cx":1370,"cy":850},"rotationDeg":90,"textureMap":"2506/241231_Backyard_Tour_Studio_Living_01.jpg","position":{"x":-0.30454280972480774,"y":1.492914302444458,"z":0.8361778855323792},"0-position":{"x":0.30454280972480774,"y":1.492914302444458,"z":-0.8361778855323792},"target":{"x":-0.3045,"y":1.4929,"z":0.8361},"visibleHotspots":["360_Living_02","360_Entry_01","360_Living_03"]},{"name":"360_Living_02","floorPlanPoint":{"cx":1370,"cy":600},"rotationDeg":90,"textureMap":"2506/241231_Backyard_Tour_Studio_Living_02.jpg","position":{"x":-0.30454158782958984,"y":1.492914302444458,"z":-0.5394324064254761},"0-position":{"x":0.30454158782958984,"y":1.492914302444458,"z":0.5394324064254761},"target":{"x":-0.3045,"y":1.4929,"z":-0.5394},"visibleHotspots":["360_Living_03","360_Living_01"]},{"name":"360_Living_03","floorPlanPoint":{"cx":850,"cy":600},"rotationDeg":0,"textureMap":"2506/241231_Backyard_Tour_Studio_Living_03.jpg","position":{"x":-3.2907354831695557,"y":1.492914302444458,"z":-0.5394324064254761},"0-position":{"x":3.2907354831695557,"y":1.492914302444458,"z":0.5394324064254761},"target":{"x":-3.2907,"y":1.4929,"z":-0.5394},"visibleHotspots":["360_Living_02"]}]},"xl8":{"model":"xl8.glb","floorPlanImage":"xl8-floorplan.webp","startPoint":"360_Entry_01","infospots":[],"groundLevel":0.05,"hotspots":[{"name":"360_Bathroom_Primary_01","floorPlanPoint":{"cx":1300,"cy":950},"rotationDeg":90,"textureMap":"2506/250117_Backyard_Tour_XL8_BathroomPrimary_01.jpg","position":{"x":-0.4924807548522949,"y":1.5929194688796997,"z":2.156805992126465},"0-position":{"x":0.4924807548522949,"y":1.5929194688796997,"z":-2.156805992126465},"target":{"x":-0.4924,"y":1.5929,"z":2.1568},"visibleHotspots":["360_Bedroom_Primary_01"]},{"name":"360_Bathroom_Secondary_01","floorPlanPoint":{"cx":1300,"cy":500},"rotationDeg":0,"textureMap":"2506/250117_Backyard_Tour_XL8_BathroomSecondary_01.jpg","position":{"x":-0.26410186290740967,"y":1.5929194688796997,"z":-2.4247310161590576},"target":{"x":-0.2641,"y":1.5929,"z":-2.4247},"visibleHotspots":["360_Hallway_01"]},{"name":"360_Bedroom_Primary_01","floorPlanPoint":{"cx":1150,"cy":950},"rotationDeg":-90,"textureMap":"2506/250117_Backyard_Tour_XL8_BedroomPrimary_01.jpg","position":{"x":-2.0388917922973633,"y":1.5929194688796997,"z":2.156805992126465},"target":{"x":-2.0388,"y":1.5929,"z":2.1568},"visibleHotspots":["360_Hallway_02","360_Bathroom_Primary_01"]},{"name":"360_Bedroom_Secondary_01","floorPlanPoint":{"cx":1050,"cy":550},"textureMap":"2506/250117_Backyard_Tour_XL8_BedroomSecondary_01.jpg","position":{"x":-3.032285451889038,"y":1.5929194688796997,"z":-1.9960932731628418},"target":{"x":-3.0322,"y":1.5929,"z":-1.996},"visibleHotspots":["360_Hallway_02"]},{"name":"360_Entry_01","floorPlanPoint":{"cx":1600,"cy":730},"textureMap":"2506/250117_Backyard_Tour_XL8_Entry_01.jpg","position":{"x":2.9621384143829346,"y":1.5929194688796997,"z":-0.00219555851072073},"target":{"x":2.9621,"y":1.5929,"z":-0.0021},"visibleHotspots":["360_Hallway_01","360_Hallway_02","360_Kitchen_01","360_Living_Room_01"]},{"name":"360_Hallway_01","floorPlanPoint":{"cx":1300,"cy":730},"textureMap":"2506/250117_Backyard_Tour_XL8_Hallway_01.jpg","position":{"x":-0.26410186290740967,"y":1.5929194688796997,"z":-0.00219555851072073},"target":{"x":-0.2641,"y":1.5929,"z":-0.0021},"visibleHotspots":["360_Bathroom_Secondary_01","360_Hallway_02","360_Entry_01"]},{"name":"360_Hallway_02","floorPlanPoint":{"cx":1150,"cy":730},"textureMap":"2506/250117_Backyard_Tour_XL8_Hallway_02.jpg","position":{"x":-1.4320803880691528,"y":1.5929194688796997,"z":-0.00219555851072073},"target":{"x":-1.432,"y":1.5929,"z":-0.0021},"visibleHotspots":["360_Hallway_01","360_Bedroom_Secondary_01","360_Bedroom_Primary_01","360_Entry_01"]},{"name":"360_Kitchen_01","floorPlanPoint":{"cx":1550,"cy":950},"rotationDeg":-90,"textureMap":"2506/250117_Backyard_Tour_XL8_Kitchen_01.jpg","position":{"x":2.5049116611480713,"y":1.5929194688796997,"z":2.069261312484741},"target":{"x":2.5049,"y":1.5929,"z":2.0692},"visibleHotspots":["360_Entry_01","360_Living_Room_01"]},{"name":"360_Living_Room_01","floorPlanPoint":{"cx":1600,"cy":500},"rotationDeg":90,"textureMap":"2506/250117_Backyard_Tour_XL8_Living_01.jpg","position":{"x":2.9621384143829346,"y":1.5929194688796997,"z":-1.9960944652557373},"target":{"x":2.9621,"y":1.5929,"z":-1.996},"visibleHotspots":["360_Entry_01","360_Kitchen_01"]}]},"xl10":{"model":"xl10.glb","floorPlanImage":"xl10-floorplan.webp","startPoint":"360_Entry_01","groundLevel":0.05,"infospots":[],"hotspots":[{"name":"360_Entry_01","floorPlanPoint":{"cx":1730,"cy":735},"textureMap":"2506/250121_Backyard_Tour_XL10_Entry_01.jpg","position":{"x":3.9147000312805176,"y":1.571860432624817,"z":-0.005245895124971867},"target":{"x":3.9147,"y":1.5718,"z":-0.0051},"visibleHotspots":["360_Hallway_01","360_Hallway_02","360_Kitchen_01","360_Living_Room_01"]},{"name":"360_Kitchen_01","floorPlanPoint":{"cx":1600,"cy":950},"rotationDeg":90,"textureMap":"2506/250121_Backyard_Tour_XL10_Kitchen_01.jpg","position":{"x":2.9993433952331543,"y":1.571860432624817,"z":2.1082701683044434},"target":{"x":2.9993,"y":1.5718,"z":2.1082},"visibleHotspots":["360_Entry_01","360_Living_Room_01"]},{"name":"360_Living_Room_01","floorPlanPoint":{"cx":1730,"cy":520},"rotationDeg":-90,"textureMap":"2506/250121_Backyard_Tour_XL10_Living_Room_01.jpg","position":{"x":3.9147000312805176,"y":1.571860432624817,"z":-2.3183538913726807},"target":{"x":3.9147,"y":1.5718,"z":-2.3182},"visibleHotspots":["360_Entry_01","360_Kitchen_01"]},{"name":"360_Bathroom_Secondary_01","floorPlanPoint":{"cx":1300,"cy":520},"rotationDeg":90,"textureMap":"2506/250122_Backyard_Tour_XL10_BathroomSecondary_01.jpg","position":{"x":-0.2267991602420807,"y":1.571860432624817,"z":-2.4232990741729736},"target":{"x":-0.2268,"y":1.5718,"z":-2.4232},"visibleHotspots":["360_Hallway_01"]},{"name":"360_Bedroom_Primary_01","floorPlanPoint":{"cx":1100,"cy":950},"rotationDeg":0,"textureMap":"2506/250123_Backyard_Tour_XL10_BedroomPrimary_01.jpg","position":{"x":-2.3896262645721436,"y":1.571860432624817,"z":2.159015417098999},"target":{"x":-2.3896,"y":1.5718,"z":2.1589},"visibleHotspots":["360_Hallway_02","360_Bathroom_Primary_01"]},{"name":"360_Bedroom_Secondary","floorPlanPoint":{"cx":1050,"cy":520},"rotationDeg":-90,"textureMap":"2506/250123_Backyard_Tour_XL10_BedroomSecondary_01.jpg","position":{"x":-2.7672579288482666,"y":1.571860432624817,"z":-2.4232990741729736},"target":{"x":-2.7672,"y":1.5718,"z":-2.4232},"visibleHotspots":["360_Hallway_02"]},{"name":"360_Bathroom_Primary_01","floorPlanPoint":{"cx":1250,"cy":950},"rotationDeg":90,"textureMap":"2506/250123_Backyard_Tour_XL10_BathroomPrimary_01.jpg","position":{"x":-0.8080784678459167,"y":1.571860432624817,"z":2.159015417098999},"target":{"x":-0.808,"y":1.5718,"z":2.159},"visibleHotspots":["360_Bedroom_Primary_01"]},{"name":"360_Hallway_01","floorPlanPoint":{"cx":1300,"cy":735},"textureMap":"2506/250126_Backyard_Tour_XL10_Hallway_01.jpg","position":{"x":-0.2267991602420807,"y":1.571860432624817,"z":-0.005245895124971867},"target":{"x":-0.2267,"y":1.5718,"z":-0.0052},"visibleHotspots":["360_Entry_01","360_Bathroom_Secondary_01","360_Hallway_02"]},{"name":"360_Hallway_02","floorPlanPoint":{"cx":1150,"cy":735},"textureMap":"2506/250126_Backyard_Tour_XL10_Hallway_02.jpg","position":{"x":-1.2677903175354004,"y":1.571860432624817,"z":-0.005245895124971867},"target":{"x":-1.2677,"y":1.5718,"z":-0.0052},"visibleHotspots":["360_Bedroom_Primary_01","360_Bedroom_Secondary","360_Hallway_01","360_Entry_01"]}]},"xl10-4k":{"model":"xl10-4k.glb","floorPlanImage":"xl10-floorplan.webp","startPoint":"360_Entry_01","groundLevel":0.05,"infospots":[],"hotspots":[{"name":"360_Entry_01","floorPlanPoint":{"cx":1730,"cy":735},"textureMap":"2506/250121_Backyard_Tour_XL10_Entry_01.jpg","position":{"x":3.9147000312805176,"y":1.571860432624817,"z":-0.005245895124971867},"target":{"x":3.9147,"y":1.5718,"z":-0.0051},"visibleHotspots":["360_Hallway_01","360_Hallway_02","360_Kitchen_01","360_Living_Room_01"]},{"name":"360_Kitchen_01","floorPlanPoint":{"cx":1600,"cy":950},"rotationDeg":90,"textureMap":"2506/250121_Backyard_Tour_XL10_Kitchen_01.jpg","position":{"x":2.9993433952331543,"y":1.571860432624817,"z":2.1082701683044434},"target":{"x":2.9993,"y":1.5718,"z":2.1082},"visibleHotspots":["360_Entry_01","360_Living_Room_01"]},{"name":"360_Living_Room_01","floorPlanPoint":{"cx":1730,"cy":520},"rotationDeg":-90,"textureMap":"2506/250121_Backyard_Tour_XL10_Living_Room_01.jpg","position":{"x":3.9147000312805176,"y":1.571860432624817,"z":-2.3183538913726807},"target":{"x":3.9147,"y":1.5718,"z":-2.3182},"visibleHotspots":["360_Entry_01","360_Kitchen_01"]},{"name":"360_Bathroom_Secondary_01","floorPlanPoint":{"cx":1300,"cy":520},"rotationDeg":90,"textureMap":"2506/250122_Backyard_Tour_XL10_BathroomSecondary_01.jpg","position":{"x":-0.2267991602420807,"y":1.571860432624817,"z":-2.4232990741729736},"target":{"x":-0.2268,"y":1.5718,"z":-2.4232},"visibleHotspots":["360_Hallway_01"]},{"name":"360_Bedroom_Primary_01","floorPlanPoint":{"cx":1100,"cy":950},"rotationDeg":0,"textureMap":"2506/250123_Backyard_Tour_XL10_BedroomPrimary_01.jpg","position":{"x":-2.3896262645721436,"y":1.571860432624817,"z":2.159015417098999},"target":{"x":-2.3896,"y":1.5718,"z":2.1589},"visibleHotspots":["360_Hallway_02","360_Bathroom_Primary_01"]},{"name":"360_Bedroom_Secondary","floorPlanPoint":{"cx":1050,"cy":520},"rotationDeg":-90,"textureMap":"2506/250123_Backyard_Tour_XL10_BedroomSecondary_01.jpg","position":{"x":-2.7672579288482666,"y":1.571860432624817,"z":-2.4232990741729736},"target":{"x":-2.7672,"y":1.5718,"z":-2.4232},"visibleHotspots":["360_Hallway_02"]},{"name":"360_Bathroom_Primary_01","floorPlanPoint":{"cx":1250,"cy":950},"rotationDeg":90,"textureMap":"2506/250123_Backyard_Tour_XL10_BathroomPrimary_01.jpg","position":{"x":-0.8080784678459167,"y":1.571860432624817,"z":2.159015417098999},"target":{"x":-0.808,"y":1.5718,"z":2.159},"visibleHotspots":["360_Bedroom_Primary_01"]},{"name":"360_Hallway_01","floorPlanPoint":{"cx":1300,"cy":735},"textureMap":"2506/250126_Backyard_Tour_XL10_Hallway_01.jpg","position":{"x":-0.2267991602420807,"y":1.571860432624817,"z":-0.005245895124971867},"target":{"x":-0.2267,"y":1.5718,"z":-0.0052},"visibleHotspots":["360_Entry_01","360_Bathroom_Secondary_01","360_Hallway_02"]},{"name":"360_Hallway_02","floorPlanPoint":{"cx":1150,"cy":735},"textureMap":"2506/250126_Backyard_Tour_XL10_Hallway_02.jpg","position":{"x":-1.2677903175354004,"y":1.571860432624817,"z":-0.005245895124971867},"target":{"x":-1.2677,"y":1.5718,"z":-0.0052},"visibleHotspots":["360_Bedroom_Primary_01","360_Bedroom_Secondary","360_Hallway_01"]}]}}');

            function rx(e) {
                return rx = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, rx(e)
            }

            function sx() {
                sx = function() {
                    return t
                };
                var e, t = {},
                    n = Object.prototype,
                    i = n.hasOwnProperty,
                    r = Object.defineProperty || function(e, t, n) {
                        e[t] = n.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    o = s.iterator || "@@iterator",
                    a = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, n) {
                    return Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, n) {
                        return e[t] = n
                    }
                }

                function u(e, t, n, i) {
                    var s = t && t.prototype instanceof A ? t : A,
                        o = Object.create(s.prototype),
                        a = new B(i || []);
                    return r(o, "_invoke", {
                        value: S(e, n, a)
                    }), o
                }

                function h(e, t, n) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, n)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart",
                    f = "suspendedYield",
                    p = "executing",
                    m = "completed",
                    g = {};

                function A() {}

                function v() {}

                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }));
                var x = Object.getPrototypeOf,
                    E = x && x(x(R([])));
                E && E !== n && i.call(E, o) && (_ = E);
                var b = y.prototype = A.prototype = Object.create(_);

                function w(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function C(e, t) {
                    function n(r, s, o, a) {
                        var l = h(e[r], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                u = c.value;
                            return u && "object" == rx(u) && i.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                n("next", e, o, a)
                            }), (function(e) {
                                n("throw", e, o, a)
                            })) : t.resolve(u).then((function(e) {
                                c.value = e, o(c)
                            }), (function(e) {
                                return n("throw", e, o, a)
                            }))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(e, i) {
                            function r() {
                                return new t((function(t, r) {
                                    n(e, i, t, r)
                                }))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }

                function S(t, n, i) {
                    var r = d;
                    return function(s, o) {
                        if (r === p) throw Error("Generator is already running");
                        if (r === m) {
                            if ("throw" === s) throw o;
                            return {
                                value: e,
                                done: !0
                            }
                        }
                        for (i.method = s, i.arg = o;;) {
                            var a = i.delegate;
                            if (a) {
                                var l = T(a, i);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === i.method) i.sent = i._sent = i.arg;
                            else if ("throw" === i.method) {
                                if (r === d) throw r = m, i.arg;
                                i.dispatchException(i.arg)
                            } else "return" === i.method && i.abrupt("return", i.arg);
                            r = p;
                            var c = h(t, n, i);
                            if ("normal" === c.type) {
                                if (r = i.done ? m : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: i.done
                                }
                            }
                            "throw" === c.type && (r = m, i.method = "throw", i.arg = c.arg)
                        }
                    }
                }

                function T(t, n) {
                    var i = n.method,
                        r = t.iterator[i];
                    if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
                }

                function M(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function I(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function B(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(M, this), this.reset(!0)
                }

                function R(t) {
                    if (t || "" === t) {
                        var n = t[o];
                        if (n) return n.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var r = -1,
                                s = function n() {
                                    for (; ++r < t.length;)
                                        if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = e, n.done = !0, n
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(rx(t) + " is not iterable")
                }
                return v.prototype = y, r(b, "constructor", {
                    value: y,
                    configurable: !0
                }), r(y, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(b), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, w(C.prototype), c(C.prototype, a, (function() {
                    return this
                })), t.AsyncIterator = C, t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new C(u(e, n, i, r), s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                        return e.done ? e.value : o.next()
                    }))
                }, w(b), c(b, l, "Generator"), c(b, o, (function() {
                    return this
                })), c(b, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = Object(e),
                        n = [];
                    for (var i in t) n.push(i);
                    return n.reverse(),
                        function e() {
                            for (; n.length;) {
                                var i = n.pop();
                                if (i in t) return e.value = i, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, t.values = R, B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !t)
                            for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done) throw t;
                        var n = this;

                        function r(i, r) {
                            return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s],
                                a = o.completion;
                            if ("root" === o.tryLoc) return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc"),
                                    c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                } else {
                                    if (!c) throw Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(o)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.tryLoc === e) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    I(n)
                                }
                                return r
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = e), g
                    }
                }, t
            }

            function ox(e) {
                return function(e) {
                    if (Array.isArray(e)) return ax(e)
                }(e) || function(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                }(e) || function(e, t) {
                    if (e) {
                        if ("string" == typeof e) return ax(e, t);
                        var n = {}.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ax(e, t) : void 0
                    }
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function ax(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function lx(e, t, n, i, r, s, o) {
                try {
                    var a = e[s](o),
                        l = a.value
                } catch (e) {
                    return void n(e)
                }
                a.done ? t(l) : Promise.resolve(l).then(i, r)
            }

            function cx(e) {
                return function() {
                    var t = this,
                        n = arguments;
                    return new Promise((function(i, r) {
                        var s = e.apply(t, n);

                        function o(e) {
                            lx(s, i, r, o, a, "next", e)
                        }

                        function a(e) {
                            lx(s, i, r, o, a, "throw", e)
                        }
                        o(void 0)
                    }))
                }
            }

            function ux(e) {
                var t = function(e, t) {
                    if ("object" != rx(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != rx(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == rx(t) ? t : t + ""
            }
            var hx = function() {
                return function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, ux(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e(t) {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.engine = t, this.moveGsap = $m.timeline(), this.mouseDownPosition = null, this.mouseMoveThreshold = 5, this.currentModelInfo = ix[t.state.model.value]
                }), [{
                    key: "listeners",
                    get: function() {
                        var e = this;
                        return [{
                            eventTarget: this.engine.container,
                            eventName: "mousemove",
                            eventFunction: function(t) {
                                if (e.cursor && e.cursor.onMove(t), e.mouseDownPosition) {
                                    var n = t.clientX - e.mouseDownPosition.x,
                                        i = t.clientY - e.mouseDownPosition.y;
                                    Math.sqrt(n * n + i * i) > e.mouseMoveThreshold && (e.mouseDownPosition = null)
                                }
                            }
                        }, {
                            eventTarget: this.engine.container,
                            eventName: "mousedown",
                            eventFunction: function(t) {
                                e.engine.container.classList.add("cursor-dragging"), e.mouseDownPosition = {
                                    x: t.clientX,
                                    y: t.clientY
                                }
                            }
                        }, {
                            eventTarget: this.engine.container,
                            eventName: "mouseup",
                            eventFunction: function(t) {
                                e.engine.container.classList.remove("cursor-dragging"), e.engine.container.classList.add("cursor-grab"), e.mouseDownPosition && e.cursor && e.cursor.onClick(t), e.mouseDownPosition = null
                            }
                        }]
                    }
                }, {
                    key: "setup",
                    value: (t = cx(sx().mark((function e(t) {
                        var n, i, r, s, o, a, l, c = this;
                        return sx().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return e.prev = 0, i = ix, this.applyConfig(nx), this.panoItems = i[t].hotspots.map((function(e) {
                                        var t = e.name,
                                            n = e.textureMap,
                                            i = e.depthMap,
                                            r = e.visibleHotspots,
                                            s = e.visibleInfospots,
                                            o = e.position,
                                            a = e.target,
                                            l = e.rotationDeg;
                                        return c.createPanoItem(t, n, i, r, s, o, a, l)
                                    })), this.infospots = i[t].infospots, this.groundLevel = i[t].groundLevel, r = [].concat(ox(this.panoItems.flatMap((function(e) {
                                        var t = e.textureMap,
                                            n = e.depthMap;
                                        return [c.createTextureObject(t), n ? c.createTextureObject(n) : null]
                                    }))), ox((nx.textures || []).map((function(e) {
                                        var t = e.textureMap;
                                        return c.createTextureObject(t)
                                    })))).filter(Boolean), e.next = 9, Promise.all(r.map(function() {
                                        var e = cx(sx().mark((function e(t) {
                                            return sx().wrap((function(e) {
                                                for (;;) switch (e.prev = e.next) {
                                                    case 0:
                                                        return e.next = 2, c.engine.textures.loadTexture(t, "map");
                                                    case 2:
                                                    case "end":
                                                        return e.stop()
                                                }
                                            }), e)
                                        })));
                                        return function(t) {
                                            return e.apply(this, arguments)
                                        }
                                    }()));
                                case 9:
                                    return (n = Wd.textures).push.apply(n, ox(r)), this.engine.meshes = [], e.next = 13, tx("".concat(Wd.paths.assets_path + i[t].model), Wd.paths.decoders_path);
                                case 13:
                                    e.sent.scene.children.forEach((function(e) {
                                        e.children.forEach((function(e) {
                                            e.material && ("Tables" === e.material.name || "Tables" === e.name || "Interior" === e.material.name || "Interior" === e.name ? (e.material.colorWrite = !1, e.renderOrder = 1e3) : (e.visible = !1, e.renderOrder = 10)), c.engine.models.group.add(e.clone())
                                        }))
                                    })), this.engine.models.group.box = this.engine.models.computeBoundingBox(this.engine.models.group), this.engine.scene.traverse((function(e) {
                                        e instanceof Ai && e.material && c.engine.meshes.push(e)
                                    })), Wd.pano.geometry.useAdaptiveGeometry ? s = new Iy({
                                        radius: 30,
                                        projection: Wd.pano.geometry.projection,
                                        baseTessellation: Wd.pano.geometry.baseTessellation,
                                        maxTessellation: Wd.pano.geometry.maxTessellation,
                                        adaptiveLOD: Wd.pano.geometry.adaptiveLOD
                                    }) : (s = new Ba(30, 768, 768)).scale(-1, 1, 1), o = Wd.pano.geometry.useAdaptiveGeometry, a = new wi({
                                        uniforms: {
                                            texture1: {
                                                value: null
                                            },
                                            texture2: {
                                                value: null
                                            },
                                            cubeTexture1: {
                                                value: null
                                            },
                                            cubeTexture2: {
                                                value: null
                                            },
                                            mixRatio: {
                                                value: 0
                                            },
                                            ambientLightColor: {
                                                value: new kn(16777215)
                                            },
                                            ambientLightIntensity: {
                                                value: 1
                                            },
                                            displacementMap: {
                                                value: null
                                            },
                                            displacementScale: {
                                                value: 1
                                            },
                                            textureSize: {
                                                value: new ze(4096, 2048)
                                            },
                                            sharpness: {
                                                value: 0
                                            },
                                            lodBias: {
                                                value: 0
                                            },
                                            useBicubic: {
                                                value: !1
                                            },
                                            useCubemap: {
                                                value: "cubemap" === Wd.pano.geometry.projection
                                            },
                                            projectionType: {
                                                value: "cubemap" === Wd.pano.geometry.projection ? 1 : 0
                                            }
                                        },
                                        vertexShader: o ? "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewDirection;\n\nvoid main() {\n\tvUv = uv;\n\t\n\t// Calculate world position from local position\n\tvec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\tvWorldPosition = position.xyz; // Use local position for cubemap direction\n\t\n\tvec4 mvPosition = viewMatrix * worldPosition;\n\tvViewDirection = normalize(-mvPosition.xyz);\n\t\n\tgl_Position = projectionMatrix * mvPosition;\n}" : "#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
                                        fragmentShader: o ? "#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n#define GLSLIFY 1\n#endif\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform samplerCube cubeTexture1;\nuniform samplerCube cubeTexture2;\nuniform float mixRatio;\nuniform vec3 ambientLightColor;\nuniform float ambientLightIntensity;\nuniform vec2 textureSize;\nuniform float sharpness;\nuniform float lodBias;\nuniform bool useBicubic;\nuniform bool useCubemap;\nuniform int projectionType; // 0: equirectangular, 1: cubemap\n\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewDirection;\n\n#define PI 3.14159265359\n\nvec4 cubic(float v) {\n\tvec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n\tvec4 s = n * n * n;\n\tfloat x = s.x;\n\tfloat y = s.y - 4.0 * s.x;\n\tfloat z = s.z - 4.0 * s.y + 6.0 * s.x;\n\tfloat w = 6.0 - x - y - z;\n\treturn vec4(x, y, z, w) * (1.0/6.0);\n}\n\nvec4 textureBicubic(sampler2D sampler, vec2 texCoords, vec2 texSize) {\n\tvec2 invTexSize = 1.0 / texSize;\n\t\n\ttexCoords = texCoords * texSize - 0.5;\n\t\n\tvec2 fxy = fract(texCoords);\n\ttexCoords -= fxy;\n\t\n\tvec4 xcubic = cubic(fxy.x);\n\tvec4 ycubic = cubic(fxy.y);\n\t\n\tvec4 c = texCoords.xxyy + vec2(-0.5, +1.5).xyxy;\n\t\n\tvec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n\tvec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;\n\t\n\toffset *= invTexSize.xxyy;\n\t\n\tvec4 sample0 = texture2D(sampler, offset.xz);\n\tvec4 sample1 = texture2D(sampler, offset.yz);\n\tvec4 sample2 = texture2D(sampler, offset.xw);\n\tvec4 sample3 = texture2D(sampler, offset.yw);\n\t\n\tfloat sx = s.x / (s.x + s.y);\n\tfloat sy = s.z / (s.z + s.w);\n\t\n\treturn mix(\n\t\tmix(sample3, sample2, sx),\n\t\tmix(sample1, sample0, sx),\n\t\tsy\n\t);\n}\n\nvec4 sampleTexture(sampler2D tex, vec2 uv) {\n\tif (useBicubic) {\n\t\treturn textureBicubic(tex, uv, textureSize);\n\t} else {\n\t\t#ifdef GL_EXT_shader_texture_lod\n\t\t\treturn texture2DLodEXT(tex, uv, lodBias);\n\t\t#else\n\t\t\treturn texture2D(tex, uv);\n\t\t#endif\n\t}\n}\n\nvec3 sharpenFilter(vec3 color, sampler2D tex, vec2 uv, float strength) {\n\tvec2 step = 1.0 / textureSize;\n\t\n\tvec3 texA = sampleTexture(tex, uv + vec2(-step.x, -step.y)).rgb;\n\tvec3 texB = sampleTexture(tex, uv + vec2(0.0, -step.y)).rgb;\n\tvec3 texC = sampleTexture(tex, uv + vec2(step.x, -step.y)).rgb;\n\tvec3 texD = sampleTexture(tex, uv + vec2(-step.x, 0.0)).rgb;\n\tvec3 texE = color;\n\tvec3 texF = sampleTexture(tex, uv + vec2(step.x, 0.0)).rgb;\n\tvec3 texG = sampleTexture(tex, uv + vec2(-step.x, step.y)).rgb;\n\tvec3 texH = sampleTexture(tex, uv + vec2(0.0, step.y)).rgb;\n\tvec3 texI = sampleTexture(tex, uv + vec2(step.x, step.y)).rgb;\n\t\n\tvec3 sharpen = texE * 9.0 - (texA + texB + texC + texD + texF + texG + texH + texI);\n\t\n\treturn mix(color, sharpen, strength);\n}\n\n// Convert a direction vector to equirectangular UV coordinates\nvec2 directionToEquirectangularUV(vec3 direction) {\n\tvec3 normalizedDir = normalize(direction);\n\t\n\t// Calculate spherical coordinates\n\t// For interior cubemap, we need to adjust the coordinates\n\tfloat phi = acos(-normalizedDir.y); // Flip Y for correct orientation\n\tfloat theta = atan(normalizedDir.z, normalizedDir.x) + PI;\n\t\n\t// Convert to UV coordinates\n\tvec2 uv;\n\tuv.x = theta / (2.0 * PI);\n\tuv.y = phi / PI;\n\t\n\treturn uv;\n}\n\nvoid main() {\n\tvec4 tex1, tex2;\n\t\n\tif (projectionType == 1) {\n\t\t// Cubemap projection mode - sample equirectangular texture using direction\n\t\tvec3 direction = normalize(vWorldPosition);\n\t\tvec2 equirectUV = directionToEquirectangularUV(direction);\n\t\t\n\t\ttex1 = sampleTexture(texture1, equirectUV);\n\t\ttex2 = sampleTexture(texture2, equirectUV);\n\t\t\n\t\t// Apply sharpening if enabled\n\t\tif (sharpness > 0.0) {\n\t\t\tif (mixRatio < 0.5) {\n\t\t\t\ttex1.rgb = sharpenFilter(tex1.rgb, texture1, equirectUV, sharpness);\n\t\t\t} else {\n\t\t\t\ttex2.rgb = sharpenFilter(tex2.rgb, texture2, equirectUV, sharpness);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Standard equirectangular sampling\n\t\ttex1 = sampleTexture(texture1, vUv);\n\t\ttex2 = sampleTexture(texture2, vUv);\n\t\t\n\t\t// Apply sharpening if enabled\n\t\tif (sharpness > 0.0) {\n\t\t\tif (mixRatio < 0.5) {\n\t\t\t\ttex1.rgb = sharpenFilter(tex1.rgb, texture1, vUv, sharpness);\n\t\t\t} else {\n\t\t\t\ttex2.rgb = sharpenFilter(tex2.rgb, texture2, vUv, sharpness);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec4 mixedColor = mix(tex1, tex2, mixRatio);\n\t\n\t// Apply ambient light\n\tvec3 ambient = ambientLightColor * ambientLightIntensity;\n\tvec3 finalColor = mixedColor.rgb * ambient;\n\t\n\tgl_FragColor = vec4(finalColor, mixedColor.a);\n}" : "#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n#define GLSLIFY 1\n#endif\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform float mixRatio;\nuniform vec3 ambientLightColor;\nuniform float ambientLightIntensity;\nuniform vec2 textureSize;\nuniform float sharpness;\nuniform float lodBias;\nuniform bool useBicubic;\n\nvarying vec2 vUv;\n\nvec4 cubic(float v) {\n\tvec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n\tvec4 s = n * n * n;\n\tfloat x = s.x;\n\tfloat y = s.y - 4.0 * s.x;\n\tfloat z = s.z - 4.0 * s.y + 6.0 * s.x;\n\tfloat w = 6.0 - x - y - z;\n\treturn vec4(x, y, z, w) * (1.0/6.0);\n}\n\nvec4 textureBicubic(sampler2D sampler, vec2 texCoords, vec2 texSize) {\n\tvec2 invTexSize = 1.0 / texSize;\n\n\ttexCoords = texCoords * texSize - 0.5;\n\n\tvec2 fxy = fract(texCoords);\n\ttexCoords -= fxy;\n\n\tvec4 xcubic = cubic(fxy.x);\n\tvec4 ycubic = cubic(fxy.y);\n\n\tvec4 c = texCoords.xxyy + vec2(-0.5, +1.5).xyxy;\n\n\tvec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n\tvec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;\n\n\toffset *= invTexSize.xxyy;\n\n\tvec4 sample0 = texture2D(sampler, offset.xz);\n\tvec4 sample1 = texture2D(sampler, offset.yz);\n\tvec4 sample2 = texture2D(sampler, offset.xw);\n\tvec4 sample3 = texture2D(sampler, offset.yw);\n\n\tfloat sx = s.x / (s.x + s.y);\n\tfloat sy = s.z / (s.z + s.w);\n\n\treturn mix(\n\t\tmix(sample3, sample2, sx),\n\t\tmix(sample1, sample0, sx),\n\t\tsy\n\t);\n}\n\nvec4 sampleTexture(sampler2D tex, vec2 uv) {\n\tif (useBicubic) {\n\t\treturn textureBicubic(tex, uv, textureSize);\n\t} else {\n\t\t#ifdef GL_EXT_shader_texture_lod\n\t\t\treturn texture2DLodEXT(tex, uv, lodBias);\n\t\t#else\n\t\t\treturn texture2D(tex, uv);\n\t\t#endif\n\t}\n}\n\nvec3 sharpenFilter(vec3 color, sampler2D tex, vec2 uv, float strength) {\n\tvec2 step = 1.0 / textureSize;\n\n\tvec3 texA = sampleTexture(tex, uv + vec2(-step.x, -step.y)).rgb;\n\tvec3 texB = sampleTexture(tex, uv + vec2(0.0, -step.y)).rgb;\n\tvec3 texC = sampleTexture(tex, uv + vec2(step.x, -step.y)).rgb;\n\tvec3 texD = sampleTexture(tex, uv + vec2(-step.x, 0.0)).rgb;\n\tvec3 texE = color;\n\tvec3 texF = sampleTexture(tex, uv + vec2(step.x, 0.0)).rgb;\n\tvec3 texG = sampleTexture(tex, uv + vec2(-step.x, step.y)).rgb;\n\tvec3 texH = sampleTexture(tex, uv + vec2(0.0, step.y)).rgb;\n\tvec3 texI = sampleTexture(tex, uv + vec2(step.x, step.y)).rgb;\n\n\tvec3 sharpen = texE * 9.0 - (texA + texB + texC + texD + texF + texG + texH + texI);\n\n\treturn mix(color, sharpen, strength);\n}\n\nvoid main() {\n\tvec4 tex1 = sampleTexture(texture1, vUv);\n\tvec4 tex2 = sampleTexture(texture2, vUv);\n\tvec4 mixedColor = mix(tex1, tex2, mixRatio);\n\n\t// Apply sharpening if enabled\n\tif (sharpness > 0.0) {\n\t\tif (mixRatio < 0.5) {\n\t\t\tmixedColor.rgb = sharpenFilter(mixedColor.rgb, texture1, vUv, sharpness);\n\t\t} else {\n\t\t\tmixedColor.rgb = sharpenFilter(mixedColor.rgb, texture2, vUv, sharpness);\n\t\t}\n\t}\n\n\t// Apply ambient light\n\tvec3 ambient = ambientLightColor * ambientLightIntensity;\n\tvec3 finalColor = mixedColor.rgb * ambient;\n\n\t// Apply gamma correction for better color accuracy\n\t// finalColor = pow(finalColor, vec3(1.0 / 2.2));\n\n\tgl_FragColor = vec4(finalColor, mixedColor.a);\n}\n"
                                    }), (l = new Ai(s, a)).scale.setScalar(1), l.rotation.y = Math.PI, l.name = "pano", l.renderOrder = 10, this.mesh = l, this.engine.panoMesh = l, this.engine.scene.add(l), this.hotspots = new Oy(this.engine), this.cursor = new Dy(this.engine), this.setQuality(Wd.pano.quality), this.startPoint = i[t].startPoint, this.engine && (this.engine.testPanoProjection = function() {
                                        var e = "equirectangular" === c.getProjection() ? "cubemap" : "equirectangular";
                                        c.setProjection(e)
                                    }, this.engine.cleanupMemory = function() {
                                        c.cleanupUnusedTextures(), c.engine.logMemoryUsage && c.engine.logMemoryUsage()
                                    }), e.next = 37;
                                    break;
                                case 35:
                                    e.prev = 35, e.t0 = e.catch(0);
                                case 37:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this, [
                            [0, 35]
                        ])
                    }))), function(e) {
                        return t.apply(this, arguments)
                    })
                }, {
                    key: "handleHotspotsVisibility",
                    value: function(e) {
                        var t = this;
                        this.engine.scene.traverse((function(e) {
                            e.name.includes("Hotspot") && (e.visible = !1), e.name.includes("Infospot") && (e.visible = !1)
                        })), this.panoItems.forEach((function(n) {
                            var i, r;
                            n.name === e && (null === (i = n.visibleHotspots) || void 0 === i || i.forEach((function(n) {
                                if (n !== e) {
                                    var i = t.engine.scene.getObjectByName("Hotspot_".concat(n));
                                    i.visible = !0, $m.fromTo(i.material, {
                                        opacity: 0
                                    }, {
                                        opacity: .5,
                                        duration: 1,
                                        delay: .3
                                    })
                                }
                            })), null === (r = n.visibleInfospots) || void 0 === r || r.forEach((function(e) {
                                t.engine.scene.getObjectByName("Infospot_".concat(e)).visible = !0
                            })))
                        }))
                    }
                }, {
                    key: "applyConfig",
                    value: function(e) {
                        var t = e.controls,
                            n = e.hotspot,
                            i = e.cursor,
                            r = e.infospot;
                        null != t && t.firstPerson && (Object.assign(Wd.controls.firstPerson, t.firstPerson), this.engine.cameraControls.setFirstPersonParams()), n && Object.assign(Wd.hotspot, n), i && Object.assign(Wd.cursor, i), r && Object.assign(Wd.infospot, r)
                    }
                }, {
                    key: "change",
                    value: (e = cx(sx().mark((function e(t, n) {
                        var i, r, s, o, a, l, c, u, h, d, f, p = this;
                        return sx().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (!this.moveGsap.isActive()) {
                                        e.next = 3;
                                        break
                                    }
                                    return e.next = 3, this.moveGsap;
                                case 3:
                                    if (i = this.currentPano, this.currentPano = t, this.engine.container && i !== t && (r = this.engine.container.closest("samara-room-tour")) && r.dispatchEvent(new CustomEvent("samara-room-change", {
                                            detail: {
                                                previousRoom: i,
                                                currentRoom: t
                                            },
                                            bubbles: !0,
                                            composed: !0
                                        })), this.cursor && this.cursor.pin && (this.cursor.pin.visible = !1), this.engine.scene.traverse((function(e) {
                                            (e.name.includes("Hotspot") || e.name.includes("Infospot")) && (e.visible = !1, e.material && ($m.killTweensOf(e.material), e.material.opacity = 0))
                                        })), this.cameraPositions || (this.cameraPositions = {}, this.panoItems.forEach((function(e) {
                                            try {
                                                var t = e.position,
                                                    n = e.target;
                                                if (!t || !n) return;
                                                p.cameraPositions[e.name] = {
                                                    position: (new gt).copy(t),
                                                    target: new gt(n.x, n.y, n.z),
                                                    rotationDeg: e.rotationDeg
                                                }
                                            } catch (e) {}
                                        }))), this.engine.panoMesh) {
                                        e.next = 11;
                                        break
                                    }
                                    return e.abrupt("return");
                                case 11:
                                    if (s = this.engine.panoMesh.material, o = this.cameraPositions[t], a = o.position, l = o.target, c = o.rotationDeg, u = void 0 === c ? 180 : c, h = this.engine.controls.getPosition(), this.currentRoom = t, !n) {
                                        e.next = 27;
                                        break
                                    }
                                    return this.engine.panoMesh.rotation.y = Qe.degToRad(u), d = this.engine.textures.getTexture(this.panoItems.find((function(e) {
                                        return e.name === t
                                    })).textureMap), s.uniforms.texture2.value = d, d && d.image && s.uniforms.textureSize.value.set(d.image.width, d.image.height), this.engine.panoMesh.position.copy(a), this.engine.panoMesh.rotation, this.handleHotspotsVisibility(t), this.engine.controls.setLookAt(a.x, a.y, a.z, l.x, l.y, l.z), s.uniforms.texture1.value = s.uniforms.texture2.value, s.uniforms.mixRatio.value = 0, e.abrupt("return");
                                case 27:
                                    return f = {
                                        x: h.x,
                                        y: h.y,
                                        z: h.z,
                                        blend: 0
                                    }, this.engine.cursor && this.engine.cursor.pin && (this.engine.cursor.pin.visible = !1, Wd.container.style.cursor = "none"), this.moveGsap.to(f, {
                                        duration: n ? 0 : Wd.animation.move.duration,
                                        ease: Wd.animation.move.ease,
                                        blend: 1,
                                        x: a.x,
                                        y: a.y,
                                        z: a.z,
                                        rotationDeg: a.rotationDeg,
                                        onStart: function() {
                                            s.uniforms.texture1.value;
                                            var e = p.engine.textures.getTexture(p.panoItems.find((function(e) {
                                                return e.name === t
                                            })).textureMap);
                                            s.uniforms.texture2.value = e, e && e.image && s.uniforms.textureSize.value.set(e.image.width, e.image.height), p.engine.panoMesh.position.copy(a)
                                        },
                                        onComplete: function() {
                                            Ec.renderingStatus.next(!1), s.uniforms.texture1.value = s.uniforms.texture2.value, s.uniforms.mixRatio.value = 0, p.engine.cursor && p.engine.cursor.pin && (p.engine.cursor.pin.visible = !0, Wd.container.style.cursor = "auto"), setTimeout((function() {
                                                p.engine.scene.traverse((function(e) {
                                                    if (e.name.includes("Hotspot") || e.name.includes("Infospot")) {
                                                        var n = p.panoItems.find((function(e) {
                                                            return e.name === t
                                                        }));
                                                        if (n) {
                                                            var i, r, s = e.name.replace("Hotspot_", "");
                                                            (e.name.includes("Hotspot") && (null === (i = n.visibleHotspots) || void 0 === i ? void 0 : i.includes(s)) && s !== t || e.name.includes("Infospot") && (null === (r = n.visibleInfospots) || void 0 === r ? void 0 : r.includes(e.name.replace("Infospot_", "")))) && (e.visible = !0, $m.fromTo(e.material, {
                                                                opacity: 0
                                                            }, {
                                                                opacity: .5,
                                                                duration: .5,
                                                                ease: Vd.easeIn
                                                            }))
                                                        }
                                                    }
                                                })), p.changeCount || (p.changeCount = 0), p.changeCount++, p.changeCount % 20 == 0 && setTimeout((function() {
                                                    p.cleanupUnusedTextures()
                                                }), 2e3)
                                            }), 300)
                                        },
                                        onUpdate: function() {
                                            p.engine.controls.moveTo(f.x, f.y, f.z, !0);
                                            var e = p.moveGsap.progress();
                                            s.uniforms.mixRatio.value = e, p.engine.panoMesh.rotation.y = Qe.degToRad(u)
                                        }
                                    }), e.abrupt("return", this.moveGsap);
                                case 31:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function(t, n) {
                        return e.apply(this, arguments)
                    })
                }, {
                    key: "update",
                    value: function() {
                        if (this.cursor && this.cursor.update) try {
                            this.cursor.update()
                        } catch (e) {}
                        this.hotspots && this.hotspots.update(), this.mesh && this.mesh.geometry instanceof Iy && Wd.pano.geometry.adaptiveLOD && !this.engine.isAnimatingCamera && this.mesh.geometry.updateLOD(this.engine.camera, this.mesh.position)
                    }
                }, {
                    key: "createPanoItem",
                    value: function(e, t, n, i, r, s, o, a) {
                        var l = this.engine;
                        return {
                            name: e,
                            textureMap: t,
                            depthMap: n,
                            rotationDeg: a,
                            get position() {
                                if (s) return new gt(s.x, s.y, s.z);
                                if (l && l.scene) {
                                    var t = l.scene.getObjectByName(e);
                                    if (t) return t.getWorldPosition(new gt)
                                }
                                return new gt(0, 0, 0)
                            },
                            get target() {
                                var e = this.position,
                                    t = e.x,
                                    n = e.y,
                                    i = e.z,
                                    r = new gt(t + 1.6766192568e-9, n + 11177461712000001e-30, i - 1.1177461712e-10);
                                return o ? new gt(o.x, o.y, o.z) : r
                            },
                            visibleHotspots: i,
                            visibleInfospots: r
                        }
                    }
                }, {
                    key: "createTextureObject",
                    value: function(e) {
                        return window.innerWidth <= 768 && e && e.includes("2506/"), {
                            path: e,
                            name: e,
                            anisotropy: !0,
                            nonSrgb: !0,
                            filter: !0,
                            flip: !0,
                            generateMipmaps: !0,
                            minFilter: "LinearMipMapLinearFilter",
                            magFilter: "LinearFilter"
                        }
                    }
                }, {
                    key: "setQuality",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        if (this.mesh && this.mesh.material) {
                            var t = this.mesh.material;
                            void 0 !== e.useBicubic && (t.uniforms.useBicubic.value = e.useBicubic), void 0 !== e.sharpness && (t.uniforms.sharpness.value = Math.max(0, Math.min(1, e.sharpness))), void 0 !== e.lodBias && (t.uniforms.lodBias.value = e.lodBias), this.engine.update()
                        }
                    }
                }, {
                    key: "getQuality",
                    value: function() {
                        if (!this.mesh || !this.mesh.material) return null;
                        var e = this.mesh.material;
                        return {
                            useBicubic: e.uniforms.useBicubic.value,
                            sharpness: e.uniforms.sharpness.value,
                            lodBias: e.uniforms.lodBias.value,
                            textureSize: {
                                width: e.uniforms.textureSize.value.x,
                                height: e.uniforms.textureSize.value.y
                            }
                        }
                    }
                }, {
                    key: "setProjection",
                    value: function(e) {
                        this.mesh && this.mesh.geometry && ("equirectangular" !== e && "cubemap" !== e || (this.mesh.geometry instanceof Iy && this.mesh.geometry.setProjection(e), this.mesh.material.uniforms.projectionType && (this.mesh.material.uniforms.projectionType.value = "cubemap" === e ? 1 : 0, this.mesh.material.uniforms.useCubemap.value = "cubemap" === e), Wd.pano.geometry.projection = e, this.engine.update()))
                    }
                }, {
                    key: "getProjection",
                    value: function() {
                        return Wd.pano.geometry.projection
                    }
                }, {
                    key: "setLODLevels",
                    value: function(e) {
                        this.mesh && this.mesh.geometry instanceof Iy && this.mesh.geometry.setLODLevels(e)
                    }
                }, {
                    key: "autoConfigureQuality",
                    value: function() {
                        var e = this.engine.renderer.getContext(),
                            t = e.getExtension("WEBGL_debug_renderer_info"),
                            n = t ? e.getParameter(t.UNMASKED_RENDERER_WEBGL) : "unknown",
                            i = window.devicePixelRatio || 1,
                            r = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                            s = /nvidia|radeon|geforce rtx|rx 6/i.test(n.toLowerCase()),
                            o = {
                                useBicubic: !1,
                                sharpness: 0,
                                lodBias: 0
                            };
                        return r ? (o = {
                            useBicubic: !1,
                            sharpness: .1,
                            lodBias: .5
                        }, this.mesh && this.mesh.geometry instanceof Iy && (this.mesh.geometry.baseTessellation = 64, this.mesh.geometry.maxTessellation = 256)) : o = s && i >= 2 ? {
                            useBicubic: !0,
                            sharpness: .2,
                            lodBias: -.5
                        } : {
                            useBicubic: !1,
                            sharpness: .15,
                            lodBias: 0
                        }, this.setQuality(o), o
                    }
                }, {
                    key: "cleanupUnusedTextures",
                    value: function() {
                        var e, t = this;
                        if (this.engine && this.engine.textures && Wd.textures) {
                            var n = new Set;
                            if (this.mesh && this.mesh.material && this.mesh.material.uniforms) {
                                var i = this.mesh.material.uniforms;
                                i.texture1.value && n.add(i.texture1.value), i.texture2.value && n.add(i.texture2.value)
                            }
                            null === (e = this.panoItems) || void 0 === e || e.forEach((function(e) {
                                var i = t.engine.textures.getTexture(e.textureMap);
                                i && n.add(i)
                            })), Wd.textures.length, Wd.textures = Wd.textures.filter((function(e) {
                                return !(e.loadedTexture && !n.has(e.loadedTexture) && e.loadedTexture.dispose && (e.loadedTexture.dispose(), e.loadedTexture = null, 1))
                            })), Wd.textures.length
                        }
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.moveGsap && (this.moveGsap.kill(), this.moveGsap = null), this.cursor && (this.cursor.destroy(), this.cursor = null), this.hotspots && (this.hotspots.destroy(), this.hotspots = null), this.mesh && this.engine.scene && (this.engine.scene.remove(this.mesh), this.mesh.geometry && this.mesh.geometry.dispose(), this.mesh.material && (this.mesh.material.uniforms && Object.values(this.mesh.material.uniforms).forEach((function(e) {
                            e.value && e.value.dispose && e.value.dispose()
                        })), this.mesh.material.dispose()), this.mesh = null), this.engine.models && this.engine.models.group && this.engine.scene && (this.engine.models.group.traverse((function(e) {
                            e.geometry && e.geometry.dispose(), e.material && (Array.isArray(e.material) ? e.material.forEach((function(e) {
                                e.dispose && e.dispose()
                            })) : e.material.dispose && e.material.dispose())
                        })), this.engine.scene.remove(this.engine.models.group))
                    }
                }]);
                var e, t
            }();

            function dx(e) {
                return dx = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, dx(e)
            }

            function fx(e) {
                return function(e) {
                    if (Array.isArray(e)) return mx(e)
                }(e) || function(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                }(e) || px(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function px(e, t) {
                if (e) {
                    if ("string" == typeof e) return mx(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? mx(e, t) : void 0
                }
            }

            function mx(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function gx() {
                gx = function() {
                    return t
                };
                var e, t = {},
                    n = Object.prototype,
                    i = n.hasOwnProperty,
                    r = Object.defineProperty || function(e, t, n) {
                        e[t] = n.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    o = s.iterator || "@@iterator",
                    a = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, n) {
                    return Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, n) {
                        return e[t] = n
                    }
                }

                function u(e, t, n, i) {
                    var s = t && t.prototype instanceof A ? t : A,
                        o = Object.create(s.prototype),
                        a = new B(i || []);
                    return r(o, "_invoke", {
                        value: S(e, n, a)
                    }), o
                }

                function h(e, t, n) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, n)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart",
                    f = "suspendedYield",
                    p = "executing",
                    m = "completed",
                    g = {};

                function A() {}

                function v() {}

                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }));
                var x = Object.getPrototypeOf,
                    E = x && x(x(R([])));
                E && E !== n && i.call(E, o) && (_ = E);
                var b = y.prototype = A.prototype = Object.create(_);

                function w(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function C(e, t) {
                    function n(r, s, o, a) {
                        var l = h(e[r], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                u = c.value;
                            return u && "object" == dx(u) && i.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                n("next", e, o, a)
                            }), (function(e) {
                                n("throw", e, o, a)
                            })) : t.resolve(u).then((function(e) {
                                c.value = e, o(c)
                            }), (function(e) {
                                return n("throw", e, o, a)
                            }))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(e, i) {
                            function r() {
                                return new t((function(t, r) {
                                    n(e, i, t, r)
                                }))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }

                function S(t, n, i) {
                    var r = d;
                    return function(s, o) {
                        if (r === p) throw Error("Generator is already running");
                        if (r === m) {
                            if ("throw" === s) throw o;
                            return {
                                value: e,
                                done: !0
                            }
                        }
                        for (i.method = s, i.arg = o;;) {
                            var a = i.delegate;
                            if (a) {
                                var l = T(a, i);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === i.method) i.sent = i._sent = i.arg;
                            else if ("throw" === i.method) {
                                if (r === d) throw r = m, i.arg;
                                i.dispatchException(i.arg)
                            } else "return" === i.method && i.abrupt("return", i.arg);
                            r = p;
                            var c = h(t, n, i);
                            if ("normal" === c.type) {
                                if (r = i.done ? m : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: i.done
                                }
                            }
                            "throw" === c.type && (r = m, i.method = "throw", i.arg = c.arg)
                        }
                    }
                }

                function T(t, n) {
                    var i = n.method,
                        r = t.iterator[i];
                    if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
                }

                function M(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function I(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function B(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(M, this), this.reset(!0)
                }

                function R(t) {
                    if (t || "" === t) {
                        var n = t[o];
                        if (n) return n.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var r = -1,
                                s = function n() {
                                    for (; ++r < t.length;)
                                        if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = e, n.done = !0, n
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(dx(t) + " is not iterable")
                }
                return v.prototype = y, r(b, "constructor", {
                    value: y,
                    configurable: !0
                }), r(y, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(b), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, w(C.prototype), c(C.prototype, a, (function() {
                    return this
                })), t.AsyncIterator = C, t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new C(u(e, n, i, r), s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                        return e.done ? e.value : o.next()
                    }))
                }, w(b), c(b, l, "Generator"), c(b, o, (function() {
                    return this
                })), c(b, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = Object(e),
                        n = [];
                    for (var i in t) n.push(i);
                    return n.reverse(),
                        function e() {
                            for (; n.length;) {
                                var i = n.pop();
                                if (i in t) return e.value = i, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, t.values = R, B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !t)
                            for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done) throw t;
                        var n = this;

                        function r(i, r) {
                            return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s],
                                a = o.completion;
                            if ("root" === o.tryLoc) return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc"),
                                    c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                } else {
                                    if (!c) throw Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(o)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var n = this.tryEntries[t];
                            if (n.tryLoc === e) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    I(n)
                                }
                                return r
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = e), g
                    }
                }, t
            }

            function Ax(e, t, n, i, r, s, o) {
                try {
                    var a = e[s](o),
                        l = a.value
                } catch (e) {
                    return void n(e)
                }
                a.done ? t(l) : Promise.resolve(l).then(i, r)
            }

            function vx(e) {
                return function() {
                    var t = this,
                        n = arguments;
                    return new Promise((function(i, r) {
                        var s = e.apply(t, n);

                        function o(e) {
                            Ax(s, i, r, o, a, "next", e)
                        }

                        function a(e) {
                            Ax(s, i, r, o, a, "throw", e)
                        }
                        o(void 0)
                    }))
                }
            }

            function yx(e) {
                var t = function(e, t) {
                    if ("object" != dx(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != dx(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == dx(t) ? t : t + ""
            }
            var _x = function() {
                return function(e, t, n) {
                    return t && function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, yx(i.key), i)
                        }
                    }(e.prototype, t), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }((function e(t) {
                    var n, i;
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.state = {
                        model: new _c(t.activeModel || "1B")
                    }, this.container = (null == t ? void 0 : t.container) || null, this.listeners = [], this.isDestroyed = !1, t && (n = Wd, i = t, cg().merge(n, i)), Ec.complectation.next({
                        layout: t.activeModel || "1B"
                    }), this.pano = new hx(this)
                }), [{
                    key: "init",
                    value: (i = vx(gx().mark((function e(t, n, i, r) {
                        var s, o, a, l, c = this;
                        return gx().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (r && (this.container = r), !t && !this.renderer) {
                                        e.next = 12;
                                        break
                                    }
                                    return e.next = 4, this.initPromise;
                                case 4:
                                    this.cameraControls.initControls(!0), this.onResize(), t || this.initListeners(), this.addSubs(), this.startRendering(), setTimeout((function() {
                                        c.container && c.container.appendChild(c.renderer.domElement)
                                    }), 1), e.next = 57;
                                    break;
                                case 12:
                                    return this.initPromise = new Promise((function(e) {
                                        a = e
                                    })), this.textures = new Of, this.options = new EA, this.render = function(e, t, n) {
                                        return c.animate(e, t, n)
                                    }, this.isAnimatingCamera = !1, this.renderer = new Bo({
                                        antialias: Wd.renderer.defaultRenderer.antialias,
                                        alpha: Wd.renderer.defaultRenderer.alpha,
                                        premultipliedAlpha: !0
                                    }), this.renderer.setClearColor(0, 0), this.renderer.setPixelRatio(Wd.renderer.pixelRatio), this.renderer.physicallyCorrectLights = !0, this.renderer.outputColorSpace = Wd.renderer.outputEncoding, this.renderer.toneMappingExposure = Wd.renderer.exposure, this.renderer.toneMapping = Wd.renderer.toneMapping, this.scene = new Ro, this.camera = new Ii(Wd.camera.fov, (null === (s = this.container) || void 0 === s ? void 0 : s.clientWidth) || 1 / (null === (o = this.container) || void 0 === o ? void 0 : o.clientHeight) || 1, Wd.camera.near, Wd.camera.far), this.camera.position.set(Wd.camera.initPos.x, Wd.camera.initPos.y, Wd.camera.initPos.z), this.camera.zoom = Wd.controls.firstPerson.defaultZoom, this.camera.updateProjectionMatrix(), this.cameraControls = new rg(this), !n && this.container && this.container.appendChild(this.renderer.domElement), this.cameraControls.initControls(), this.ambientLight = new El(16777215, Wd.light.intensity), this.scene.add(this.ambientLight), this.models = new xg(this), this.textures.init(this), this.assets = new AA(this), this.postprocessing = new xy(this), this.postprocessing.init(), e.next = 41, this.assets.loadAndSetup();
                                case 41:
                                    if (!this.isDestroyed && this.pano) {
                                        e.next = 43;
                                        break
                                    }
                                    return e.abrupt("return");
                                case 43:
                                    return e.next = 45, this.pano.setup(this.state.model.value);
                                case 45:
                                    if (Wd.loadOnDemand.loadingManager.enabled = !1, (l = i || this.pano.startPoint || this.pano.currentModelInfo.startPoint) && !this.isDestroyed && this.pano && this.pano.change(l, !0), !this.isDestroyed) {
                                        e.next = 50;
                                        break
                                    }
                                    return e.abrupt("return");
                                case 50:
                                    return this.renderer && this.scene && this.camera && this.renderer.compile(this.scene, this.camera), this.CameraGsap = new ag, n || (this.initListeners(), this.onResize(), this.addSubs(), this.startRendering()), e.next = 55, new Promise((function(e) {
                                        return setTimeout(e, 1)
                                    }));
                                case 55:
                                    Ec.loading.next({
                                        isLoading: !1
                                    }), a();
                                case 57:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function(e, t, n, r) {
                        return i.apply(this, arguments)
                    })
                }, {
                    key: "pauseRendering",
                    value: function() {
                        $m.ticker.remove(this.render)
                    }
                }, {
                    key: "startRendering",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                            t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        $m.ticker.add(this.render, e, t)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        var e, t = this;
                        if (this.isDestroyed = !0, this.controls && (this.lastCamCoords = {
                                position: this.controls.getPosition(),
                                target: this.controls.getTarget()
                            }), this.pauseRendering(), Wd.textures && Wd.textures.length > 0 && (Wd.textures.forEach((function(e) {
                                e.loadedTexture && (e.loadedTexture.dispose && e.loadedTexture.dispose(), e.loadedTexture = null)
                            })), Wd.textures.length = 0), Wd.models && Wd.models.samara && Wd.models.samara.assetsArray && Wd.models.samara.assetsArray.forEach((function(e) {
                                e.textures && e.textures.length > 0 && (e.textures.forEach((function(e) {
                                    e.loadedTexture && (e.loadedTexture.dispose && e.loadedTexture.dispose(), e.loadedTexture = null)
                                })), e.textures.length = 0)
                            })), null === (e = this.sub) || void 0 === e || e.unsubscribe(), this.removeListeners(), this.pano && (this.pano.destroy(), this.pano = null), this.postprocessing && (this.postprocessing.destroy(), this.postprocessing = null), this.controls && (this.controls.dispose(), this.controls = null), this.cameraControls && (this.cameraControls.removeListeners(), this.cameraControls = null), this.scene) {
                            for (this.scene.traverse((function(e) {
                                    e.geometry && e.geometry.dispose(), e.material && (Array.isArray(e.material) ? e.material.forEach((function(e) {
                                        return t.disposeMaterial(e)
                                    })) : t.disposeMaterial(e.material))
                                })); this.scene.children.length > 0;) this.scene.remove(this.scene.children[0]);
                            this.scene = null
                        }
                        this.textures && (this.textures.destroy(), this.textures = null), Wd.environment && Wd.environment.assetsArray && Wd.environment.assetsArray.forEach((function(e) {
                            e.loadedHDRTexture && (e.loadedHDRTexture.dispose && e.loadedHDRTexture.dispose(), e.loadedHDRTexture = null)
                        })), this.renderer && (this.renderer.domElement && this.renderer.domElement.parentNode && this.renderer.domElement.parentNode.removeChild(this.renderer.domElement), this.renderer.dispose(), this.renderer.forceContextLoss(), this.renderer.domElement = null, this.renderer = null), this.models && (this.models = null), this.assets && (this.assets.destroy(), this.assets = null), this.CameraGsap && (this.CameraGsap = null), window.engine === this && (window.engine = null), this._prevCameraPosition = null, this._prevAzimuthAngle = null, this._prevPolarAngle = null, this._prevCameraZoom = null, this._prevCameraFov = null
                    }
                }, {
                    key: "disposeMaterial",
                    value: function(e) {
                        e && (["map", "lightMap", "bumpMap", "normalMap", "specularMap", "envMap", "alphaMap", "aoMap", "emissiveMap", "metalnessMap", "roughnessMap", "displacementMap", "clearcoatMap", "clearcoatNormalMap", "clearcoatRoughnessMap"].forEach((function(t) {
                            e[t] && e[t].dispose()
                        })), e.dispose())
                    }
                }, {
                    key: "addSubs",
                    value: function() {
                        var e = this;
                        this.sub = Ec.complectation.subscribe((function(t) {
                            e.onComplectationChange()
                        }));
                        var t, n = Gg(this.container, "mousemove"),
                            i = Gg(this.container, "keyup"),
                            r = Gg(this.container, "touchstart"),
                            s = Zg(3e3),
                            o = Zg(5e3);
                        this.sub.add(aA(i, n, r, Ec.renderingStatus).subscribe((function() {
                            e.renderingActive || (e.startRendering(), e.renderingActive = !0)
                        }))), this.sub.add(aA(i, n, r, Ec.renderingStatus).pipe(function() {
                            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                            var n = nA(e);
                            return Pg((function(t, i) {
                                (n ? lA(e, t, n) : lA(e, t)).subscribe(i)
                            }))
                        }("initial"), (t = function() {
                            return aA(s.pipe(cA(0)), o.pipe(cA(1)))
                        }, Pg((function(e, n) {
                            var i = null,
                                r = !1,
                                s = function() {
                                    return r && !i && n.complete()
                                };
                            e.subscribe(Lg(n, (function(e) {
                                null == i || i.unsubscribe();
                                0;
                                Rg(t()).subscribe(i = Lg(n, (function(e) {
                                    return n.next(e)
                                }), (function() {
                                    i = null, s()
                                })))
                            }), (function() {
                                r = !0, s()
                            })))
                        })))).subscribe((function(t) {
                            0 === t && e.renderingActive && (e.pauseRendering(), e.renderingActive = !1)
                        })))
                    }
                }, {
                    key: "initListeners",
                    value: function() {
                        var e = this;
                        this.listeners = [{
                            eventTarget: document,
                            eventName: "visibilitychange",
                            eventFunction: function() {
                                return e.onVisibilityChange()
                            }
                        }, {
                            eventTarget: this.renderer.domElement,
                            eventName: "webglcontextlost",
                            eventFunction: function() {
                                return e.onContextLoss()
                            }
                        }, {
                            eventTarget: this.renderer.domElement,
                            eventName: "webglcontextrestored",
                            eventFunction: function() {
                                return e.onContextRestored()
                            }
                        }, {
                            eventTarget: window,
                            eventName: "resize",
                            eventFunction: function() {
                                return e.onResize()
                            }
                        }, {
                            eventTarget: this.controls,
                            eventName: "sleep",
                            eventFunction: function() {
                                return e.onControlsEnd()
                            }
                        }, {
                            eventTarget: this.controls,
                            eventName: "change",
                            eventFunction: function() {
                                return e.onControlsUpdate()
                            }
                        }, {
                            eventTarget: this.controls,
                            eventName: "update",
                            eventFunction: function() {
                                return e.onControlsUpdate()
                            }
                        }, {
                            eventTarget: this.controls,
                            eventName: "end",
                            eventFunction: function() {
                                return e.onControlsEnd()
                            }
                        }], this.pano && (this.listeners = [].concat(fx(this.listeners), fx(this.pano.listeners))), this.listeners.forEach((function(e) {
                            e.eventTarget.addEventListener(e.eventName, e.eventFunction)
                        }))
                    }
                }, {
                    key: "onControlsUpdate",
                    value: function() {
                        Ec.renderingStatus.next(!0)
                    }
                }, {
                    key: "onControlsEnd",
                    value: function() {
                        Ec.renderingStatus.next(!1)
                    }
                }, {
                    key: "removeListeners",
                    value: function() {
                        this.listeners && Array.isArray(this.listeners) && this.listeners.forEach((function(e) {
                            e.eventTarget.removeEventListener(e.eventName, e.eventFunction)
                        }))
                    }
                }, {
                    key: "onVisibilityChange",
                    value: function() {
                        "visible" === document.visibilityState ? this.startRendering() : this.pauseRendering()
                    }
                }, {
                    key: "materialGsap",
                    value: function(e, t, n) {
                        var i = {
                            duration: .01,
                            onUpdate: function() {
                                return Ec.renderingStatus.next(!0)
                            },
                            onComplete: function() {
                                return Ec.renderingStatus.next(!1)
                            }
                        };
                        if ("color" === e.name) {
                            var r = new kn(e.value);
                            i.r = r.r, i.g = r.g, i.b = r.b
                        } else i[e.name] = e.value;
                        var s = [];
                        t && t.length > 0 && t.filter((function(e) {
                            return void 0 !== e
                        })).forEach((function(t) {
                            s.push("color" === e.name ? t.color : t)
                        })), Array.isArray(n) && this.scene.traverse((function(t) {
                            t instanceof Ai && t.material && n.includes(t.material.name) && s.push("color" === e.name ? t.material.color : t.material)
                        })), s.length > 0 && $m.timeline().to(s, i)
                    }
                }, {
                    key: "onResize",
                    value: function() {
                        if (this.container) {
                            var e = this.container.clientWidth,
                                t = this.container.clientHeight;
                            this.renderer.setSize(e, t), this.postprocessing.composer.setSize(e, t), this.camera.aspect = e / t, this.camera.updateProjectionMatrix(), this.update()
                        }
                    }
                }, {
                    key: "renderOnce",
                    value: function() {
                        this.renderer.render(this.scene, this.camera)
                    }
                }, {
                    key: "onContextLoss",
                    value: (n = vx(gx().mark((function e() {
                        return gx().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return Ec.errors.next({
                                        isError: !0,
                                        message: "Restoring context, please wait."
                                    }), e.next = 3, new Promise((function(e) {
                                        return setTimeout(e, 1)
                                    }));
                                case 3:
                                    this.renderer.forceContextRestore();
                                case 4:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return n.apply(this, arguments)
                    })
                }, {
                    key: "onContextRestored",
                    value: (t = vx(gx().mark((function e() {
                        var t, n, i = this;
                        return gx().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (this.renderer && this.textures) {
                                        e.next = 3;
                                        break
                                    }
                                    return e.abrupt("return");
                                case 3:
                                    return Wd.environment.assetsArray.forEach((function(e) {
                                        e.loadedHDRTexture = null
                                    })), t = Wd.environment.assetsArray.find((function(e) {
                                        return e.isDefault
                                    })), e.next = 7, this.textures.loadTexture(t, "pmrem");
                                case 7:
                                    this.scene.traverse((function(e) {
                                        e.material && e.material.envMap && (e.material.envMap = i.textures.getHdrTexture(t.name), e.material.envMapIntensity = t.defaultHdrIntensity)
                                    })), n = function(e) {
                                        for (var t in e.needsUpdate = !0, e) e[t] && e[t].isTexture && "envMap" !== t && (e[t].needsUpdate = !0)
                                    }, this.scene.traverse((function(e) {
                                        if (e.geometry) {
                                            for (var t in e.geometry.attributes) e.geometry.attributes[t].needsUpdate = !0;
                                            e.geometry.index && (e.geometry.index.needsUpdate = !0)
                                        }
                                        e.material && (e.material.length ? e.material.forEach(n) : n(e.material))
                                    })), this.update(), Ec.errors.next({
                                        isError: !1
                                    });
                                case 12:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return t.apply(this, arguments)
                    })
                }, {
                    key: "getParams",
                    value: function() {
                        return Wd
                    }
                }, {
                    key: "getState",
                    value: function() {
                        return Ec
                    }
                }, {
                    key: "status",
                    value: function() {
                        return Ec.loading
                    }
                }, {
                    key: "update",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .1;
                        $m.timeline().to({
                            val: 0
                        }, {
                            val: 1,
                            duration: e,
                            onStart: function() {
                                return Ec.renderingStatus.next(!0)
                            },
                            onUpdate: function() {
                                return Ec.renderingStatus.next(!0)
                            },
                            onComplete: function() {
                                return Ec.renderingStatus.next(!1)
                            }
                        })
                    }
                }, {
                    key: "animate",
                    value: function(e, t, n) {
                        var i, r, s = this,
                            o = t / 1e3,
                            a = this._prevCameraPosition || this.camera.position.clone(),
                            l = null !== (i = this._prevAzimuthAngle) && void 0 !== i ? i : this.controls ? this.controls.azimuthAngle : 0,
                            c = null !== (r = this._prevPolarAngle) && void 0 !== r ? r : this.controls ? this.controls.polarAngle : Math.PI / 2,
                            u = this._prevCameraZoom || this.camera.zoom,
                            h = this._prevCameraFov || this.camera.fov;
                        if (this.controls && this.controls.update(o), this.camera && this.controls) {
                            var d = !a.equals(this.camera.position),
                                f = Math.abs(l - this.controls.azimuthAngle) > 1e-4,
                                p = Math.abs(c - this.controls.polarAngle) > 1e-4,
                                m = u !== this.camera.zoom,
                                g = h !== this.camera.fov;
                            if (d || f || p || m || g) {
                                var A, v, y, _ = this.pano && this.pano.currentPano ? this.pano.panoItems.findIndex((function(e) {
                                        return e.name === s.pano.currentPano
                                    })) : -1,
                                    x = (null === (A = this.controls) || void 0 === A || null === (v = A.getTarget) || void 0 === v ? void 0 : v.call(A, new gt)) || new gt;
                                window.dispatchEvent(new CustomEvent("samara-camera-change", {
                                    detail: {
                                        position: {
                                            x: this.camera.position.x,
                                            y: this.camera.position.y,
                                            z: this.camera.position.z
                                        },
                                        rotation: {
                                            x: Sc.radToDeg(this.camera.rotation.x),
                                            y: Sc.radToDeg(this.camera.rotation.y),
                                            z: Sc.radToDeg(this.camera.rotation.z)
                                        },
                                        azimuthAngle: this.controls ? Sc.radToDeg(this.controls.azimuthAngle) : null,
                                        polarAngle: this.controls ? Sc.radToDeg(this.controls.polarAngle) : null,
                                        target: {
                                            x: x.x,
                                            y: x.y,
                                            z: x.z
                                        },
                                        zoom: this.camera.zoom,
                                        fov: this.camera.fov,
                                        sphereIndex: _,
                                        sphereName: (null === (y = this.pano) || void 0 === y ? void 0 : y.currentPano) || null
                                    },
                                    bubbles: !0
                                })), this._prevCameraPosition = this.camera.position.clone(), this._prevAzimuthAngle = this.controls.azimuthAngle, this._prevPolarAngle = this.controls.polarAngle, this._prevCameraZoom = this.camera.zoom, this._prevCameraFov = this.camera.fov
                            }
                        }
                        Wd.postProcessing.enabled ? this.postprocessing.render() : this.renderer.render(this.scene, this.camera), this.pano && this.pano.update(), this.models.materials.transmissiveMaterials.forEach((function(e) {
                            e.time += o
                        }))
                    }
                }, {
                    key: "setOption",
                    value: function(e) {
                        this.options.setOption(e)
                    }
                }, {
                    key: "onComplectationChange",
                    value: (e = vx(gx().mark((function e() {
                        return gx().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                case "end":
                                    return e.stop()
                            }
                        }), e)
                    }))), function() {
                        return e.apply(this, arguments)
                    })
                }]);
                var e, t, n, i
            }();

            function xx(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : window.engine;
                if (t && e) {
                    var n = e.split(", "),
                        i = {};
                    if (n.forEach((function(e) {
                            var t = function(e, t) {
                                    return function(e) {
                                        if (Array.isArray(e)) return e
                                    }(e) || function(e, t) {
                                        var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                        if (null != n) {
                                            var i, r, s, o, a = [],
                                                l = !0,
                                                c = !1;
                                            try {
                                                if (s = (n = n.call(e)).next, 0 === t);
                                                else
                                                    for (; !(l = (i = s.call(n)).done) && (a.push(i.value), a.length !== t); l = !0);
                                            } catch (e) {
                                                c = !0, r = e
                                            } finally {
                                                try {
                                                    if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                                } finally {
                                                    if (c) throw r
                                                }
                                            }
                                            return a
                                        }
                                    }(e, t) || px(e, t) || function() {
                                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }()
                                }(e.split(": "), 2),
                                n = t[0],
                                r = t[1];
                            i[n] = r
                        })), i.z && (t.camera.zoom = parseFloat(i.z)), i.fov && (t.camera.fov = parseFloat(i.fov)), i.theta && i.phi) {
                        var r = Sc.degToRad(parseFloat(i.theta.replace("°", ""))),
                            s = Sc.degToRad(parseFloat(i.phi.replace("°", "")));
                        if (t.controls && t.controls.setFromSpherical) {
                            var o = t.controls.getDistance ? t.controls.getDistance() : 1,
                                a = new kl(o, s, r);
                            t.controls.setFromSpherical(a)
                        } else {
                            var l = Math.sin(s) * Math.sin(r),
                                c = Math.cos(s),
                                u = Math.sin(s) * Math.cos(r),
                                h = new gt(t.camera.position.x + l, t.camera.position.y + c, t.camera.position.z + u);
                            t.camera.lookAt(h)
                        }
                    } else i.rotY && i.rotX && (t.camera.rotation.x = Sc.degToRad(parseFloat(i.rotX.replace("°", ""))), t.camera.rotation.y = Sc.degToRad(parseFloat(i.rotY.replace("°", ""))));
                    t.camera.updateProjectionMatrix(), t.camera.updateMatrixWorld(), t.controls && t.controls.update()
                }
            }
            window.applyCameraFromInfo = xx, window.exported = {
                CreateScene: _x,
                CameraGsap: ag,
                applyCameraFromInfo: xx
            };
            const Ex = globalThis,
                bx = Ex.ShadowRoot && (void 0 === Ex.ShadyCSS || Ex.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
                wx = Symbol(),
                Cx = new WeakMap;
            class Sx {
                constructor(e, t, n) {
                    if (this._$cssResult$ = !0, n !== wx) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
                    this.cssText = e, this.t = t
                }
                get styleSheet() {
                    let e = this.o;
                    const t = this.t;
                    if (bx && void 0 === e) {
                        const n = void 0 !== t && 1 === t.length;
                        n && (e = Cx.get(t)), void 0 === e && ((this.o = e = new CSSStyleSheet).replaceSync(this.cssText), n && Cx.set(t, e))
                    }
                    return e
                }
                toString() {
                    return this.cssText
                }
            }
            const Tx = (e, ...t) => {
                    const n = 1 === e.length ? e[0] : t.reduce(((t, n, i) => t + (e => {
                        if (!0 === e._$cssResult$) return e.cssText;
                        if ("number" == typeof e) return e;
                        throw Error("Value passed to 'css' function must be a 'css' function result: " + e + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
                    })(n) + e[i + 1]), e[0]);
                    return new Sx(n, e, wx)
                },
                Mx = bx ? e => e : e => e instanceof CSSStyleSheet ? (e => {
                    let t = "";
                    for (const n of e.cssRules) t += n.cssText;
                    return (e => new Sx("string" == typeof e ? e : e + "", void 0, wx))(t)
                })(e) : e,
                {
                    is: Ix,
                    defineProperty: Bx,
                    getOwnPropertyDescriptor: Rx,
                    getOwnPropertyNames: Dx,
                    getOwnPropertySymbols: Px,
                    getPrototypeOf: Lx
                } = Object,
                Ux = globalThis,
                Nx = Ux.trustedTypes,
                Ox = Nx ? Nx.emptyScript : "",
                Fx = Ux.reactiveElementPolyfillSupport,
                kx = (e, t) => e,
                Qx = {
                    toAttribute(e, t) {
                        switch (t) {
                            case Boolean:
                                e = e ? Ox : null;
                                break;
                            case Object:
                            case Array:
                                e = null == e ? e : JSON.stringify(e)
                        }
                        return e
                    },
                    fromAttribute(e, t) {
                        let n = e;
                        switch (t) {
                            case Boolean:
                                n = null !== e;
                                break;
                            case Number:
                                n = null === e ? null : Number(e);
                                break;
                            case Object:
                            case Array:
                                try {
                                    n = JSON.parse(e)
                                } catch (e) {
                                    n = null
                                }
                        }
                        return n
                    }
                },
                zx = (e, t) => !Ix(e, t),
                Hx = {
                    attribute: !0,
                    type: String,
                    converter: Qx,
                    reflect: !1,
                    hasChanged: zx
                };
            Symbol.metadata ??= Symbol("metadata"), Ux.litPropertyMetadata ??= new WeakMap;
            class Gx extends HTMLElement {
                static addInitializer(e) {
                    this._$Ei(), (this.l ??= []).push(e)
                }
                static get observedAttributes() {
                    return this.finalize(), this._$Eh && [...this._$Eh.keys()]
                }
                static createProperty(e, t = Hx) {
                    if (t.state && (t.attribute = !1), this._$Ei(), this.elementProperties.set(e, t), !t.noAccessor) {
                        const n = Symbol(),
                            i = this.getPropertyDescriptor(e, n, t);
                        void 0 !== i && Bx(this.prototype, e, i)
                    }
                }
                static getPropertyDescriptor(e, t, n) {
                    const {
                        get: i,
                        set: r
                    } = Rx(this.prototype, e) ?? {
                        get() {
                            return this[t]
                        },
                        set(e) {
                            this[t] = e
                        }
                    };
                    return {
                        get() {
                            return i?.call(this)
                        },
                        set(t) {
                            const s = i?.call(this);
                            r.call(this, t), this.requestUpdate(e, s, n)
                        },
                        configurable: !0,
                        enumerable: !0
                    }
                }
                static getPropertyOptions(e) {
                    return this.elementProperties.get(e) ?? Hx
                }
                static _$Ei() {
                    if (this.hasOwnProperty(kx("elementProperties"))) return;
                    const e = Lx(this);
                    e.finalize(), void 0 !== e.l && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties)
                }
                static finalize() {
                    if (this.hasOwnProperty(kx("finalized"))) return;
                    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(kx("properties"))) {
                        const e = this.properties,
                            t = [...Dx(e), ...Px(e)];
                        for (const n of t) this.createProperty(n, e[n])
                    }
                    const e = this[Symbol.metadata];
                    if (null !== e) {
                        const t = litPropertyMetadata.get(e);
                        if (void 0 !== t)
                            for (const [e, n] of t) this.elementProperties.set(e, n)
                    }
                    this._$Eh = new Map;
                    for (const [e, t] of this.elementProperties) {
                        const n = this._$Eu(e, t);
                        void 0 !== n && this._$Eh.set(n, e)
                    }
                    this.elementStyles = this.finalizeStyles(this.styles)
                }
                static finalizeStyles(e) {
                    const t = [];
                    if (Array.isArray(e)) {
                        const n = new Set(e.flat(1 / 0).reverse());
                        for (const e of n) t.unshift(Mx(e))
                    } else void 0 !== e && t.push(Mx(e));
                    return t
                }
                static _$Eu(e, t) {
                    const n = t.attribute;
                    return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof e ? e.toLowerCase() : void 0
                }
                constructor() {
                    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev()
                }
                _$Ev() {
                    this._$ES = new Promise((e => this.enableUpdating = e)), this._$AL = new Map, this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((e => e(this)))
                }
                addController(e) {
                    (this._$EO ??= new Set).add(e), void 0 !== this.renderRoot && this.isConnected && e.hostConnected?.()
                }
                removeController(e) {
                    this._$EO?.delete(e)
                }
                _$E_() {
                    const e = new Map,
                        t = this.constructor.elementProperties;
                    for (const n of t.keys()) this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
                    e.size > 0 && (this._$Ep = e)
                }
                createRenderRoot() {
                    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
                    return ((e, t) => {
                        if (bx) e.adoptedStyleSheets = t.map((e => e instanceof CSSStyleSheet ? e : e.styleSheet));
                        else
                            for (const n of t) {
                                const t = document.createElement("style"),
                                    i = Ex.litNonce;
                                void 0 !== i && t.setAttribute("nonce", i), t.textContent = n.cssText, e.appendChild(t)
                            }
                    })(e, this.constructor.elementStyles), e
                }
                connectedCallback() {
                    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach((e => e.hostConnected?.()))
                }
                enableUpdating(e) {}
                disconnectedCallback() {
                    this._$EO?.forEach((e => e.hostDisconnected?.()))
                }
                attributeChangedCallback(e, t, n) {
                    this._$AK(e, n)
                }
                _$EC(e, t) {
                    const n = this.constructor.elementProperties.get(e),
                        i = this.constructor._$Eu(e, n);
                    if (void 0 !== i && !0 === n.reflect) {
                        const r = (void 0 !== n.converter?.toAttribute ? n.converter : Qx).toAttribute(t, n.type);
                        this._$Em = e, null == r ? this.removeAttribute(i) : this.setAttribute(i, r), this._$Em = null
                    }
                }
                _$AK(e, t) {
                    const n = this.constructor,
                        i = n._$Eh.get(e);
                    if (void 0 !== i && this._$Em !== i) {
                        const e = n.getPropertyOptions(i),
                            r = "function" == typeof e.converter ? {
                                fromAttribute: e.converter
                            } : void 0 !== e.converter?.fromAttribute ? e.converter : Qx;
                        this._$Em = i, this[i] = r.fromAttribute(t, e.type), this._$Em = null
                    }
                }
                requestUpdate(e, t, n) {
                    if (void 0 !== e) {
                        if (n ??= this.constructor.getPropertyOptions(e), !(n.hasChanged ?? zx)(this[e], t)) return;
                        this.P(e, t, n)
                    }!1 === this.isUpdatePending && (this._$ES = this._$ET())
                }
                P(e, t, n) {
                    this._$AL.has(e) || this._$AL.set(e, t), !0 === n.reflect && this._$Em !== e && (this._$Ej ??= new Set).add(e)
                }
                async _$ET() {
                    this.isUpdatePending = !0;
                    try {
                        await this._$ES
                    } catch (e) {
                        Promise.reject(e)
                    }
                    const e = this.scheduleUpdate();
                    return null != e && await e, !this.isUpdatePending
                }
                scheduleUpdate() {
                    return this.performUpdate()
                }
                performUpdate() {
                    if (!this.isUpdatePending) return;
                    if (!this.hasUpdated) {
                        if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
                            for (const [e, t] of this._$Ep) this[e] = t;
                            this._$Ep = void 0
                        }
                        const e = this.constructor.elementProperties;
                        if (e.size > 0)
                            for (const [t, n] of e) !0 !== n.wrapped || this._$AL.has(t) || void 0 === this[t] || this.P(t, this[t], n)
                    }
                    let e = !1;
                    const t = this._$AL;
                    try {
                        e = this.shouldUpdate(t), e ? (this.willUpdate(t), this._$EO?.forEach((e => e.hostUpdate?.())), this.update(t)) : this._$EU()
                    } catch (t) {
                        throw e = !1, this._$EU(), t
                    }
                    e && this._$AE(t)
                }
                willUpdate(e) {}
                _$AE(e) {
                    this._$EO?.forEach((e => e.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e)
                }
                _$EU() {
                    this._$AL = new Map, this.isUpdatePending = !1
                }
                get updateComplete() {
                    return this.getUpdateComplete()
                }
                getUpdateComplete() {
                    return this._$ES
                }
                shouldUpdate(e) {
                    return !0
                }
                update(e) {
                    this._$Ej &&= this._$Ej.forEach((e => this._$EC(e, this[e]))), this._$EU()
                }
                updated(e) {}
                firstUpdated(e) {}
            }
            Gx.elementStyles = [], Gx.shadowRootOptions = {
                mode: "open"
            }, Gx[kx("elementProperties")] = new Map, Gx[kx("finalized")] = new Map, Fx?.({
                ReactiveElement: Gx
            }), (Ux.reactiveElementVersions ??= []).push("2.0.4");
            const Vx = globalThis,
                jx = Vx.trustedTypes,
                Wx = jx ? jx.createPolicy("lit-html", {
                    createHTML: e => e
                }) : void 0,
                Xx = "$lit$",
                Yx = `lit$${Math.random().toFixed(9).slice(2)}$`,
                qx = "?" + Yx,
                Kx = `<${qx}>`,
                Jx = document,
                Zx = () => Jx.createComment(""),
                $x = e => null === e || "object" != typeof e && "function" != typeof e,
                eE = Array.isArray,
                tE = "[ \t\n\f\r]",
                nE = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
                iE = /-->/g,
                rE = />/g,
                sE = RegExp(`>|${tE}(?:([^\\s"'>=/]+)(${tE}*=${tE}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`, "g"),
                oE = /'/g,
                aE = /"/g,
                lE = /^(?:script|style|textarea|title)$/i,
                cE = (e => (t, ...n) => ({
                    _$litType$: e,
                    strings: t,
                    values: n
                }))(1),
                uE = Symbol.for("lit-noChange"),
                hE = Symbol.for("lit-nothing"),
                dE = new WeakMap,
                fE = Jx.createTreeWalker(Jx, 129);

            function pE(e, t) {
                if (!eE(e) || !e.hasOwnProperty("raw")) throw Error("invalid template strings array");
                return void 0 !== Wx ? Wx.createHTML(t) : t
            }
            class mE {
                constructor({
                    strings: e,
                    _$litType$: t
                }, n) {
                    let i;
                    this.parts = [];
                    let r = 0,
                        s = 0;
                    const o = e.length - 1,
                        a = this.parts,
                        [l, c] = ((e, t) => {
                            const n = e.length - 1,
                                i = [];
                            let r, s = 2 === t ? "<svg>" : 3 === t ? "<math>" : "",
                                o = nE;
                            for (let t = 0; t < n; t++) {
                                const n = e[t];
                                let a, l, c = -1,
                                    u = 0;
                                for (; u < n.length && (o.lastIndex = u, l = o.exec(n), null !== l);) u = o.lastIndex, o === nE ? "!--" === l[1] ? o = iE : void 0 !== l[1] ? o = rE : void 0 !== l[2] ? (lE.test(l[2]) && (r = RegExp("</" + l[2], "g")), o = sE) : void 0 !== l[3] && (o = sE) : o === sE ? ">" === l[0] ? (o = r ?? nE, c = -1) : void 0 === l[1] ? c = -2 : (c = o.lastIndex - l[2].length, a = l[1], o = void 0 === l[3] ? sE : '"' === l[3] ? aE : oE) : o === aE || o === oE ? o = sE : o === iE || o === rE ? o = nE : (o = sE, r = void 0);
                                const h = o === sE && e[t + 1].startsWith("/>") ? " " : "";
                                s += o === nE ? n + Kx : c >= 0 ? (i.push(a), n.slice(0, c) + Xx + n.slice(c) + Yx + h) : n + Yx + (-2 === c ? t : h)
                            }
                            return [pE(e, s + (e[n] || "<?>") + (2 === t ? "</svg>" : 3 === t ? "</math>" : "")), i]
                        })(e, t);
                    if (this.el = mE.createElement(l, n), fE.currentNode = this.el.content, 2 === t || 3 === t) {
                        const e = this.el.content.firstChild;
                        e.replaceWith(...e.childNodes)
                    }
                    for (; null !== (i = fE.nextNode()) && a.length < o;) {
                        if (1 === i.nodeType) {
                            if (i.hasAttributes())
                                for (const e of i.getAttributeNames())
                                    if (e.endsWith(Xx)) {
                                        const t = c[s++],
                                            n = i.getAttribute(e).split(Yx),
                                            o = /([.?@])?(.*)/.exec(t);
                                        a.push({
                                            type: 1,
                                            index: r,
                                            name: o[2],
                                            strings: n,
                                            ctor: "." === o[1] ? _E : "?" === o[1] ? xE : "@" === o[1] ? EE : yE
                                        }), i.removeAttribute(e)
                                    } else e.startsWith(Yx) && (a.push({
                                        type: 6,
                                        index: r
                                    }), i.removeAttribute(e));
                            if (lE.test(i.tagName)) {
                                const e = i.textContent.split(Yx),
                                    t = e.length - 1;
                                if (t > 0) {
                                    i.textContent = jx ? jx.emptyScript : "";
                                    for (let n = 0; n < t; n++) i.append(e[n], Zx()), fE.nextNode(), a.push({
                                        type: 2,
                                        index: ++r
                                    });
                                    i.append(e[t], Zx())
                                }
                            }
                        } else if (8 === i.nodeType)
                            if (i.data === qx) a.push({
                                type: 2,
                                index: r
                            });
                            else {
                                let e = -1;
                                for (; - 1 !== (e = i.data.indexOf(Yx, e + 1));) a.push({
                                    type: 7,
                                    index: r
                                }), e += Yx.length - 1
                            } r++
                    }
                }
                static createElement(e, t) {
                    const n = Jx.createElement("template");
                    return n.innerHTML = e, n
                }
            }

            function gE(e, t, n = e, i) {
                if (t === uE) return t;
                let r = void 0 !== i ? n._$Co?.[i] : n._$Cl;
                const s = $x(t) ? void 0 : t._$litDirective$;
                return r?.constructor !== s && (r?._$AO?.(!1), void 0 === s ? r = void 0 : (r = new s(e), r._$AT(e, n, i)), void 0 !== i ? (n._$Co ??= [])[i] = r : n._$Cl = r), void 0 !== r && (t = gE(e, r._$AS(e, t.values), r, i)), t
            }
            class AE {
                constructor(e, t) {
                    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t
                }
                get parentNode() {
                    return this._$AM.parentNode
                }
                get _$AU() {
                    return this._$AM._$AU
                }
                u(e) {
                    const {
                        el: {
                            content: t
                        },
                        parts: n
                    } = this._$AD, i = (e?.creationScope ?? Jx).importNode(t, !0);
                    fE.currentNode = i;
                    let r = fE.nextNode(),
                        s = 0,
                        o = 0,
                        a = n[0];
                    for (; void 0 !== a;) {
                        if (s === a.index) {
                            let t;
                            2 === a.type ? t = new vE(r, r.nextSibling, this, e) : 1 === a.type ? t = new a.ctor(r, a.name, a.strings, this, e) : 6 === a.type && (t = new bE(r, this, e)), this._$AV.push(t), a = n[++o]
                        }
                        s !== a?.index && (r = fE.nextNode(), s++)
                    }
                    return fE.currentNode = Jx, i
                }
                p(e) {
                    let t = 0;
                    for (const n of this._$AV) void 0 !== n && (void 0 !== n.strings ? (n._$AI(e, n, t), t += n.strings.length - 2) : n._$AI(e[t])), t++
                }
            }
            class vE {
                get _$AU() {
                    return this._$AM?._$AU ?? this._$Cv
                }
                constructor(e, t, n, i) {
                    this.type = 2, this._$AH = hE, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = n, this.options = i, this._$Cv = i?.isConnected ?? !0
                }
                get parentNode() {
                    let e = this._$AA.parentNode;
                    const t = this._$AM;
                    return void 0 !== t && 11 === e?.nodeType && (e = t.parentNode), e
                }
                get startNode() {
                    return this._$AA
                }
                get endNode() {
                    return this._$AB
                }
                _$AI(e, t = this) {
                    e = gE(this, e, t), $x(e) ? e === hE || null == e || "" === e ? (this._$AH !== hE && this._$AR(), this._$AH = hE) : e !== this._$AH && e !== uE && this._(e) : void 0 !== e._$litType$ ? this.$(e) : void 0 !== e.nodeType ? this.T(e) : (e => eE(e) || "function" == typeof e?.[Symbol.iterator])(e) ? this.k(e) : this._(e)
                }
                O(e) {
                    return this._$AA.parentNode.insertBefore(e, this._$AB)
                }
                T(e) {
                    this._$AH !== e && (this._$AR(), this._$AH = this.O(e))
                }
                _(e) {
                    this._$AH !== hE && $x(this._$AH) ? this._$AA.nextSibling.data = e : this.T(Jx.createTextNode(e)), this._$AH = e
                }
                $(e) {
                    const {
                        values: t,
                        _$litType$: n
                    } = e, i = "number" == typeof n ? this._$AC(e) : (void 0 === n.el && (n.el = mE.createElement(pE(n.h, n.h[0]), this.options)), n);
                    if (this._$AH?._$AD === i) this._$AH.p(t);
                    else {
                        const e = new AE(i, this),
                            n = e.u(this.options);
                        e.p(t), this.T(n), this._$AH = e
                    }
                }
                _$AC(e) {
                    let t = dE.get(e.strings);
                    return void 0 === t && dE.set(e.strings, t = new mE(e)), t
                }
                k(e) {
                    eE(this._$AH) || (this._$AH = [], this._$AR());
                    const t = this._$AH;
                    let n, i = 0;
                    for (const r of e) i === t.length ? t.push(n = new vE(this.O(Zx()), this.O(Zx()), this, this.options)) : n = t[i], n._$AI(r), i++;
                    i < t.length && (this._$AR(n && n._$AB.nextSibling, i), t.length = i)
                }
                _$AR(e = this._$AA.nextSibling, t) {
                    for (this._$AP?.(!1, !0, t); e && e !== this._$AB;) {
                        const t = e.nextSibling;
                        e.remove(), e = t
                    }
                }
                setConnected(e) {
                    void 0 === this._$AM && (this._$Cv = e, this._$AP?.(e))
                }
            }
            class yE {
                get tagName() {
                    return this.element.tagName
                }
                get _$AU() {
                    return this._$AM._$AU
                }
                constructor(e, t, n, i, r) {
                    this.type = 1, this._$AH = hE, this._$AN = void 0, this.element = e, this.name = t, this._$AM = i, this.options = r, n.length > 2 || "" !== n[0] || "" !== n[1] ? (this._$AH = Array(n.length - 1).fill(new String), this.strings = n) : this._$AH = hE
                }
                _$AI(e, t = this, n, i) {
                    const r = this.strings;
                    let s = !1;
                    if (void 0 === r) e = gE(this, e, t, 0), s = !$x(e) || e !== this._$AH && e !== uE, s && (this._$AH = e);
                    else {
                        const i = e;
                        let o, a;
                        for (e = r[0], o = 0; o < r.length - 1; o++) a = gE(this, i[n + o], t, o), a === uE && (a = this._$AH[o]), s ||= !$x(a) || a !== this._$AH[o], a === hE ? e = hE : e !== hE && (e += (a ?? "") + r[o + 1]), this._$AH[o] = a
                    }
                    s && !i && this.j(e)
                }
                j(e) {
                    e === hE ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "")
                }
            }
            class _E extends yE {
                constructor() {
                    super(...arguments), this.type = 3
                }
                j(e) {
                    this.element[this.name] = e === hE ? void 0 : e
                }
            }
            class xE extends yE {
                constructor() {
                    super(...arguments), this.type = 4
                }
                j(e) {
                    this.element.toggleAttribute(this.name, !!e && e !== hE)
                }
            }
            class EE extends yE {
                constructor(e, t, n, i, r) {
                    super(e, t, n, i, r), this.type = 5
                }
                _$AI(e, t = this) {
                    if ((e = gE(this, e, t, 0) ?? hE) === uE) return;
                    const n = this._$AH,
                        i = e === hE && n !== hE || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive,
                        r = e !== hE && (n === hE || i);
                    i && this.element.removeEventListener(this.name, this, n), r && this.element.addEventListener(this.name, this, e), this._$AH = e
                }
                handleEvent(e) {
                    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, e) : this._$AH.handleEvent(e)
                }
            }
            class bE {
                constructor(e, t, n) {
                    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = n
                }
                get _$AU() {
                    return this._$AM._$AU
                }
                _$AI(e) {
                    gE(this, e)
                }
            }
            const wE = Vx.litHtmlPolyfillSupport;
            wE?.(mE, vE), (Vx.litHtmlVersions ??= []).push("3.2.1");
            class CE extends Gx {
                constructor() {
                    super(...arguments), this.renderOptions = {
                        host: this
                    }, this._$Do = void 0
                }
                createRenderRoot() {
                    const e = super.createRenderRoot();
                    return this.renderOptions.renderBefore ??= e.firstChild, e
                }
                update(e) {
                    const t = this.render();
                    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = ((e, t, n) => {
                        const i = n?.renderBefore ?? t;
                        let r = i._$litPart$;
                        if (void 0 === r) {
                            const e = n?.renderBefore ?? null;
                            i._$litPart$ = r = new vE(t.insertBefore(Zx(), e), e, void 0, n ?? {})
                        }
                        return r._$AI(e), r
                    })(t, this.renderRoot, this.renderOptions)
                }
                connectedCallback() {
                    super.connectedCallback(), this._$Do?.setConnected(!0)
                }
                disconnectedCallback() {
                    super.disconnectedCallback(), this._$Do?.setConnected(!1)
                }
                render() {
                    return uE
                }
            }
            CE._$litElement$ = !0, CE.finalized = !0, globalThis.litElementHydrateSupport?.({
                LitElement: CE
            });
            const SE = globalThis.litElementPolyfillSupport;
            SE?.({
                LitElement: CE
            }), (globalThis.litElementVersions ??= []).push("4.1.1");
            class TE {
                constructor(e) {}
                get _$AU() {
                    return this._$AM._$AU
                }
                _$AT(e, t, n) {
                    this._$Ct = e, this._$AM = t, this._$Ci = n
                }
                _$AS(e, t) {
                    return this.update(e, t)
                }
                update(e, t) {
                    return this.render(...t)
                }
            }
            const ME = (e, t) => {
                    const n = e._$AN;
                    if (void 0 === n) return !1;
                    for (const e of n) e._$AO?.(t, !1), ME(e, t);
                    return !0
                },
                IE = e => {
                    let t, n;
                    do {
                        if (void 0 === (t = e._$AM)) break;
                        n = t._$AN, n.delete(e), e = t
                    } while (0 === n?.size)
                },
                BE = e => {
                    for (let t; t = e._$AM; e = t) {
                        let n = t._$AN;
                        if (void 0 === n) t._$AN = n = new Set;
                        else if (n.has(e)) break;
                        n.add(e), PE(t)
                    }
                };

            function RE(e) {
                void 0 !== this._$AN ? (IE(this), this._$AM = e, BE(this)) : this._$AM = e
            }

            function DE(e, t = !1, n = 0) {
                const i = this._$AH,
                    r = this._$AN;
                if (void 0 !== r && 0 !== r.size)
                    if (t)
                        if (Array.isArray(i))
                            for (let e = n; e < i.length; e++) ME(i[e], !1), IE(i[e]);
                        else null != i && (ME(i, !1), IE(i));
                else ME(this, e)
            }
            const PE = e => {
                2 == e.type && (e._$AP ??= DE, e._$AQ ??= RE)
            };
            class LE extends TE {
                constructor() {
                    super(...arguments), this._$AN = void 0
                }
                _$AT(e, t, n) {
                    super._$AT(e, t, n), BE(this), this.isConnected = e._$AU
                }
                _$AO(e, t = !0) {
                    e !== this.isConnected && (this.isConnected = e, e ? this.reconnected?.() : this.disconnected?.()), t && (ME(this, e), IE(this))
                }
                setValue(e) {
                    if ((e => void 0 === this._$Ct.strings)()) this._$Ct._$AI(e, this);
                    else {
                        const t = [...this._$Ct._$AH];
                        t[this._$Ci] = e, this._$Ct._$AI(t, this, 0)
                    }
                }
                disconnected() {}
                reconnected() {}
            }
            const UE = new WeakMap,
                NE = (e => (...t) => ({
                    _$litDirective$: e,
                    values: t
                }))(class extends LE {
                    render(e) {
                        return hE
                    }
                    update(e, [t]) {
                        const n = t !== this.Y;
                        return n && void 0 !== this.Y && this.rt(void 0), (n || this.lt !== this.ct) && (this.Y = t, this.ht = e.options?.host, this.rt(this.ct = e.element)), hE
                    }
                    rt(e) {
                        if (this.isConnected || (e = void 0), "function" == typeof this.Y) {
                            const t = this.ht ?? globalThis;
                            let n = UE.get(t);
                            void 0 === n && (n = new WeakMap, UE.set(t, n)), void 0 !== n.get(this.Y) && this.Y.call(this.ht, void 0), n.set(this.Y, e), void 0 !== e && this.Y.call(this.ht, e)
                        } else this.Y.value = e
                    }
                    get lt() {
                        return "function" == typeof this.Y ? UE.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value
                    }
                    disconnected() {
                        this.lt === this.ct && this.rt(void 0)
                    }
                    reconnected() {
                        this.rt(this.ct)
                    }
                });

            function OE(e) {
                return OE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, OE(e)
            }
            var FE, kE, QE, zE;

            function HE(e, t) {
                return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
                    raw: {
                        value: Object.freeze(t)
                    }
                }))
            }

            function GE(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, VE(i.key), i)
                }
            }

            function VE(e) {
                var t = function(e, t) {
                    if ("object" != OE(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, "string");
                        if ("object" != OE(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == OE(t) ? t : t + ""
            }

            function jE(e, t, n) {
                return t = qE(t),
                    function(e, t) {
                        if (t && ("object" == OE(t) || "function" == typeof t)) return t;
                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                        return function(e) {
                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return e
                        }(e)
                    }(e, WE() ? Reflect.construct(t, [], qE(e).constructor) : t.apply(e, n))
            }

            function WE() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (e) {}
                return (WE = function() {
                    return !!e
                })()
            }

            function XE(e, t, n, i) {
                var r = YE(qE(e.prototype), t, n);
                return "function" == typeof r ? function(e) {
                    return r.apply(n, e)
                } : r
            }

            function YE() {
                return YE = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, n) {
                    var i = function(e, t) {
                        for (; !{}.hasOwnProperty.call(e, t) && null !== (e = qE(e)););
                        return e
                    }(e, t);
                    if (i) {
                        var r = Object.getOwnPropertyDescriptor(i, t);
                        return r.get ? r.get.call(arguments.length < 3 ? e : n) : r.value
                    }
                }, YE.apply(null, arguments)
            }

            function qE(e) {
                return qE = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }, qE(e)
            }

            function KE(e, t) {
                return KE = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                }, KE(e, t)
            }
            var JE, ZE, $E, eb = function(e) {
                function t() {
                    var e;
                    return function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), (e = jE(this, t)).loading = {
                        isLoading: !0,
                        percent: null
                    }, e.errors = {
                        isError: !1,
                        message: null
                    }, e
                }
                return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), t && KE(e, t)
                    }(t, e),
                    function(e, t, n) {
                        return t && GE(e.prototype, t), n && GE(e, n), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), e
                    }(t, [{
                        key: "onRef",
                        value: function(e) {
                            this.container = e
                        }
                    }, {
                        key: "_handleZoomEvent",
                        value: function(e) {
                            if (this.scene && this.scene.controls && this.scene.camera) {
                                var t = e.detail || {},
                                    n = t.action,
                                    i = t.value;
                                switch (n) {
                                    case "in":
                                        var r = this.scene.camera.zoom,
                                            s = Math.min(r * (i || 1.2), this.scene.controls.maxZoom);
                                        this.scene.controls.zoomTo(s, !0);
                                        break;
                                    case "out":
                                        var o = this.scene.camera.zoom,
                                            a = Math.max(o / (i || 1.2), this.scene.controls.minZoom);
                                        this.scene.controls.zoomTo(a, !0);
                                        break;
                                    case "set":
                                        if (void 0 !== i) {
                                            var l = Math.max(this.scene.controls.minZoom, Math.min(i, this.scene.controls.maxZoom));
                                            this.scene.controls.zoomTo(l, !1), setTimeout((function() {}), 300)
                                        }
                                        break;
                                    case "reset":
                                        var c = 0 === this.scene.controls.distance ? 1.5 : 2;
                                        this.scene.controls.zoomTo(c, !0);
                                        break;
                                    case "get":
                                        this.dispatchEvent(new CustomEvent("samara-zoom-info", {
                                            detail: {
                                                currentZoom: this.scene.camera.zoom,
                                                minZoom: this.scene.controls.minZoom,
                                                maxZoom: this.scene.controls.maxZoom,
                                                isFirstPerson: 0 === this.scene.controls.distance
                                            },
                                            bubbles: !0,
                                            composed: !0
                                        }));
                                        break;
                                    case "setLimits":
                                        void 0 !== e.detail.min && (this.scene.controls.minZoom = e.detail.min), void 0 !== e.detail.max && (this.scene.controls.maxZoom = e.detail.max);
                                        var u = this.scene.camera.zoom,
                                            h = Math.max(this.scene.controls.minZoom, Math.min(u, this.scene.controls.maxZoom));
                                        h !== u && this.scene.controls.zoomTo(h, !0)
                                }
                            }
                        }
                    }, {
                        key: "connectedCallback",
                        value: function() {
                            var e = this;
                            XE(t, "connectedCallback", this)([]), this.url && (Wd.paths = {
                                models_path: this.url + "models/",
                                textures_path: this.url + "textures/",
                                decoders_path: this.url + "decoders/",
                                assets_path: this.url + "assets/"
                            }), this._handleZoomEvent = this._handleZoomEvent.bind(this), window.addEventListener("samara-zoom", this._handleZoomEvent), this.sub = Ec.loading.subscribe((function(t) {
                                e.loading = t, e.dispatchEvent(new CustomEvent("samara-loading-progress", {
                                    detail: {
                                        isLoading: t.isLoading,
                                        percent: t.percent
                                    },
                                    bubbles: !0,
                                    composed: !0
                                })), t.isLoading || e.dispatchEvent(new CustomEvent("samara-loading-complete", {
                                    detail: {
                                        activeModel: e.activeModel
                                    },
                                    bubbles: !0,
                                    composed: !0
                                }))
                            })), this.sub.add(Ec.errors.subscribe((function(t) {
                                e.errors = t, t.isError && e.dispatchEvent(new CustomEvent("samara-error", {
                                    detail: {
                                        message: t.message
                                    },
                                    bubbles: !0,
                                    composed: !0
                                }))
                            })))
                        }
                    }, {
                        key: "firstUpdated",
                        value: function() {
                            this.scene || this._initializeScene()
                        }
                    }, {
                        key: "updated",
                        value: function(e) {
                            e.has("activeModel") && this.scene && this._recreateScene()
                        }
                    }, {
                        key: "_initializeScene",
                        value: function() {
                            var e, t = {
                                activeModel: this.activeModel,
                                debug: "true" === new URLSearchParams(window.location.search).get("debug"),
                                container: this.container
                            };
                            this.scene = new _x(t);
                            var n = (null === (e = this.scene.pano.currentModelInfo.hotspots) || void 0 === e || null === (e = e[0]) || void 0 === e ? void 0 : e.name) || "Living 01";
                            this.scene.init(!1, !1, n, this.container), window.engine = this.scene, this.dispatchEvent(new CustomEvent("samara-initialized", {
                                detail: {
                                    activeModel: this.activeModel,
                                    initialRoom: n
                                },
                                bubbles: !0,
                                composed: !0
                            }))
                        }
                    }, {
                        key: "_recreateScene",
                        value: function() {
                            var e, t = this;
                            if (this.dispatchEvent(new CustomEvent("samara-model-change-start", {
                                    detail: {
                                        previousModel: null === (e = this.scene) || void 0 === e || null === (e = e.state) || void 0 === e || null === (e = e.model) || void 0 === e ? void 0 : e.value,
                                        newModel: this.activeModel
                                    },
                                    bubbles: !0,
                                    composed: !0
                                })), Ec.loading.next({
                                    isLoading: !0,
                                    percent: 0
                                }), this.scene && (window.engine === this.scene && (window.engine = null), this.scene.destroy(), this.scene = null), this.container) {
                                var n = this.container.querySelector("canvas");
                                n && n.remove()
                            }
                            window.gc && window.gc(), setTimeout((function() {
                                t._initializeScene(), t.dispatchEvent(new CustomEvent("samara-model-change-complete", {
                                    detail: {
                                        activeModel: t.activeModel
                                    },
                                    bubbles: !0,
                                    composed: !0
                                }))
                            }), 100)
                        }
                    }, {
                        key: "disconnectedCallback",
                        value: function() {
                            XE(t, "disconnectedCallback", this)([]), window.removeEventListener("samara-zoom", this._handleZoomEvent), this.sub && (this.sub.unsubscribe(), this.sub = null), window.engine === this.scene ? (window.engine.destroy(), window.engine = null) : this.scene && this.scene.destroy(), this.scene = null
                        }
                    }, {
                        key: "render",
                        value: function() {
                            return cE(FE || (FE = HE(['\n\t\t\t<div class="scene-wrapper">\n\t\t\t\t<div class="scene" ', ">\n\t\t\t\t\t", "\n\t\t\t\t</div>\n\n\t\t\t\t", "\n\t\t\t</div>\n\t\t"])), NE(this.onRef), this.loading.isLoading ? hE : cE(kE || (kE = HE(["<infospot-component></infospot-component>"]))), this.errors.isError ? cE(QE || (QE = HE(['<div class="errors-overlay">\n\t\t\t\t\t\t\t', '\n\t\t\t\t\t\t\t<div class="icon">\n\t\t\t\t\t\t\t\t<svg\n\t\t\t\t\t\t\t\t\tviewBox="0 0 50 50"\n\t\t\t\t\t\t\t\t\txmlns="http://www.w3.org/2000/svg"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\tfill="black"\n\t\t\t\t\t\t\t\t\t\td="M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<animateTransform\n\t\t\t\t\t\t\t\t\t\t\tattributeType="xml"\n\t\t\t\t\t\t\t\t\t\t\tattributeName="transform"\n\t\t\t\t\t\t\t\t\t\t\ttype="rotate"\n\t\t\t\t\t\t\t\t\t\t\tfrom="0 25 25"\n\t\t\t\t\t\t\t\t\t\t\tto="360 25 25"\n\t\t\t\t\t\t\t\t\t\t\tdur="1s"\n\t\t\t\t\t\t\t\t\t\t\trepeatCount="indefinite"\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</path>\n\t\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>'])), this.errors.message) : hE)
                        }
                    }], [{
                        key: "styles",
                        get: function() {
                            return Tx(zE || (zE = HE(["\n\t\t\t:host {\n\t\t\t\t-webkit-tap-highlight-color: rgba(255, 255, 255, 0) !important;\n\t\t\t\t-webkit-focus-ring-color: rgba(255, 255, 255, 0) !important;\n\t\t\t\toutline: none !important;\n\t\t\t\tbox-sizing: border-box;\n\t\t\t\t--white: rgb(255, 255, 255);\n\t\t\t\t--black: rgb(0, 0, 0);\n\t\t\t\t--transparent: rgba(0, 0, 0, 0);\n\t\t\t\t--samara-primary: #000000;\n\t\t\t\t--samara-secondary: #e0ded4;\n\t\t\t\t--grey5: rgba(169, 169, 169, 0.5);\n\t\t\t\tdisplay: block;\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tbackground-color: transparent;\n\t\t\t}\n\n\t\t\t.loading-overlay,\n\t\t\t.errors-overlay {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tz-index: 2;\n\t\t\t\tbackground-color: transparent;\n\t\t\t\tjustify-content: center;\n\t\t\t\talign-items: center;\n\t\t\t\tdisplay: flex;\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t}\n\n\t\t\t.loading-overlay {\n\t\t\t\tflex-direction: column;\n\t\t\t}\n\n\t\t\t.errors-overlay {\n\t\t\t\tz-index: 3;\n\t\t\t}\n\n\t\t\t.scene {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tbackground-color: transparent;\n\t\t\t\tdisplay: flex;\n\t\t\t\tposition: relative;\n\t\t\t\tcursor: grab !important;\n\t\t\t}\n\n\t\t\t.scene-wrapper {\n\t\t\t\theight: 100%;\n\t\t\t\twidth: 100%;\n\t\t\t\toutline: none;\n\t\t\t\tflex-direction: row;\n\t\t\t\tjustify-content: space-between;\n\t\t\t\tdisplay: flex;\n\t\t\t\tposition: relative;\n\t\t\t\toverflow: hidden;\n\t\t\t\tfont-family: sans-serif;\n\t\t\t\tbackground-color: transparent;\n\t\t\t}\n\n\t\t\t.scene canvas {\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t}\n\n\t\t\t.cursor-pointer {\n\t\t\t\tcursor: pointer !important;\n\t\t\t}\n\n\t\t\t.cursor-dragging {\n\t\t\t\tcursor: grabbing !important;\n\t\t\t}\n\n\t\t\t.icon {\n\t\t\t\toverflow: hidden;\n\t\t\t\tmax-width: 1em;\n\t\t\t\twidth: 1em;\n\t\t\t\tmin-width: 1em;\n\t\t\t\theight: 1em;\n\t\t\t\tmax-height: 1em;\n\t\t\t\tcursor: pointer;\n\t\t\t\tpadding: 0.5em;\n\t\t\t\tposition: relative;\n\t\t\t\tborder-radius: 50%;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tjustify-content: center;\n\t\t\t}\n\n\t\t\t.icon svg {\n\t\t\t\tvertical-align: middle;\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t"])))
                        }
                    }, {
                        key: "properties",
                        get: function() {
                            return {
                                loading: {
                                    state: !0
                                },
                                errors: {
                                    state: !0
                                },
                                url: {},
                                activeModel: {
                                    type: String,
                                    attribute: !0
                                }
                            }
                        }
                    }])
            }(CE);

            function tb(e) {
                return tb = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, tb(e)
            }

            function nb(e, t) {
                return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
                    raw: {
                        value: Object.freeze(t)
                    }
                }))
            }

            function ib(e, t, n) {
                return t = ab(t),
                    function(e, t) {
                        if (t && ("object" == tb(t) || "function" == typeof t)) return t;
                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                        return function(e) {
                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return e
                        }(e)
                    }(e, rb() ? Reflect.construct(t, [], ab(e).constructor) : t.apply(e, n))
            }

            function rb() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (e) {}
                return (rb = function() {
                    return !!e
                })()
            }

            function sb(e, t, n, i) {
                var r = ob(ab(e.prototype), t, n);
                return "function" == typeof r ? function(e) {
                    return r.apply(n, e)
                } : r
            }

            function ob() {
                return ob = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, n) {
                    var i = function(e, t) {
                        for (; !{}.hasOwnProperty.call(e, t) && null !== (e = ab(e)););
                        return e
                    }(e, t);
                    if (i) {
                        var r = Object.getOwnPropertyDescriptor(i, t);
                        return r.get ? r.get.call(arguments.length < 3 ? e : n) : r.value
                    }
                }, ob.apply(null, arguments)
            }

            function ab(e) {
                return ab = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }, ab(e)
            }

            function lb(e, t) {
                return lb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                }, lb(e, t)
            }

            function cb(e) {
                var t = function(e, t) {
                    if ("object" != tb(e) || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var i = n.call(e, t);
                        if ("object" != tb(i)) return i;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e, "string");
                return "symbol" == tb(t) ? t : t + ""
            }
            customElements.define("samara-room-tour", eb);
            var ub = function(e) {
                function t() {
                    var e;
                    return function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), (e = ib(this, t)).engine = window.engine, e.vector = new gt, e
                }
                return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), t && lb(e, t)
                    }(t, e),
                    function(e, t, n) {
                        return t && function(e, t) {
                            for (var n = 0; n < t.length; n++) {
                                var i = t[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, cb(i.key), i)
                            }
                        }(e.prototype, t), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), e
                    }(t, [{
                        key: "connectedCallback",
                        value: function() {
                            sb(t, "connectedCallback", this)([])
                        }
                    }, {
                        key: "disconnectedCallback",
                        value: function() {
                            sb(t, "disconnectedCallback", this)([])
                        }
                    }, {
                        key: "onRef",
                        value: function(e, t) {
                            var n;
                            e && null !== (n = this.engine) && void 0 !== n && null !== (n = n.pano) && void 0 !== n && null !== (n = n.hotspots) && void 0 !== n && null !== (n = n.infospots) && void 0 !== n && n[t] && (this.engine.pano.hotspots.infospots[t].htmlEl = e)
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var e, t = this,
                                n = (null === (e = this.engine) || void 0 === e || null === (e = e.pano) || void 0 === e || null === (e = e.hotspots) || void 0 === e ? void 0 : e.infospots) || [];
                            return cE(JE || (JE = nb(["\n      ", "\n    "])), n.map((function(e, n) {
                                return cE(ZE || (ZE = nb(['\n          <div class="info" ', '>\n            <img src="', 'Infospot.png" />\n            <div class="popup">', "</div>\n          </div>\n        "])), NE((function(e) {
                                    return t.onRef(e, n)
                                })), Wd.paths.assets_path, e._bubbleText)
                            })))
                        }
                    }])
            }(CE);
            ! function(e, t, n) {
                (t = cb(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n
            }(ub, "styles", Tx($E || ($E = nb(["\n    .popup {\n      display: block;\n      opacity: 0;\n      position: absolute;\n      background: rgba(255, 255, 255, 0.6);\n      color: black;\n      border-radius: 8px;\n      padding: 10px;\n      backdrop-filter: blur(1em);\n      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n      pointer-events: none;\n      z-index: 999;\n      font-weight: 600;\n      bottom: calc(100% - 25px);\n      left: 50%;\n      transform: translateX(-50%);\n      white-space: nowrap;\n      transition: opacity 0.2s ease-in-out;\n    }\n\n    .info:hover .popup {\n      opacity: 1;\n    }\n\n    .info {\n      width: 5em;\n      height: 5em;\n      position: absolute;\n      z-index: 999;\n      top: 0;\n      left: 0;\n      cursor: pointer;\n      display: none;\n\n      img {\n        width: 100%;\n        height: auto;\n        pointer-events: none; /* Add this line to prevent dragging of the image */\n      }\n    }\n  "])))), customElements.define("infospot-component", ub)
        })()
    })();

    function Oe(e) {
        function t() {
            window.removeEventListener("samara-initialized", t);
            const n = () => {
                const t = window.engine?.getState();
                window.engine?.pano?.panoItems && t && !t.loading.value.isLoading ? e() : requestAnimationFrame(n)
            };
            n()
        }
        return window.addEventListener("samara-initialized", t), () => {
            window.removeEventListener("samara-initialized", t)
        }
    }

    function Fe(e, t, n) {
        let i, r, s;
        o(e, xe, (e => n(1, s = e)));
        const a = [65, 80],
            l = {
                useBicubic: !0,
                sharpness: .2,
                lodBias: -.5
            },
            c = {
                useBicubic: !0,
                sharpness: .25,
                lodBias: -.75
            },
            u = [{
                model: "studio",
                azimuthAngle: -105,
                polarAngle: 80.37,
                sphereIndex: 4
            }, {
                model: "onebed",
                azimuthAngle: -102.03,
                polarAngle: 84.66,
                sphereIndex: 2
            }, {
                model: "twobed",
                azimuthAngle: -658.34,
                polarAngle: 75.88,
                sphereIndex: 3
            }, {
                model: "xl8",
                azimuthAngle: -191.88,
                polarAngle: 77.92,
                sphereIndex: 8
            }, {
                model: "xl10",
                azimuthAngle: 178.23,
                polarAngle: 76.63,
                sphereIndex: 2
            }],
            h = {
                studio: "studio",
                onebed: "one-bedroom",
                twobed: "two-bedroom",
                xl8: "xl-8",
                xl10: "xl-10"
            },
            d = {
                studio: "studio",
                onebed: "1B",
                twobed: "2B",
                xl8: "xl8",
                xl10: "xl10"
            };
        let p, m, g = 0,
            A = !1,
            v = !1,
            y = null,
            _ = null;

        function x(e) {
            n(2, g = !0 === e.detail.isLoading ? e.detail.percent / 100 : 1)
        }

        function E(e) {
            !0 !== v && (void 0 !== m && clearTimeout(m), m = setTimeout((() => {
                const {
                    azimuthAngle: t,
                    polarAngle: n,
                    sphereIndex: i
                } = e.detail, r = btoa("z" + (!0 === s.isZoomed ? 1 : 0) + `c${t.toFixed(2)},${n.toFixed(2)}` + `s${i}`).replaceAll("=", "");
                history.replaceState(null, "", `/backyard/${h[s.model]}/#${r}`)
            }), 300))
        }

        function b(e) {
            if (!0 === v) return;
            const {
                previousRoom: t,
                currentRoom: n
            } = e.detail;
            gtag("event", "tour_room_navigated", {
                model: s.model,
                source: s.source,
                previous_room: t,
                current_room: n
            })
        }

        function w(e) {
            void 0 !== window.engine && (window.engine.cameraControls.setCamera(1, !0 === s.isZoomed ? a[0] : a[1], !0 === e ? .4 : 0), window.engine.pano.setQuality(!0 === s.isZoomed ? c : l))
        }
        return B((() => {
            if (_ = s.model, "full-screen" === s.variant) {
                const e = document.getElementById("floor-plan");
                if (null !== e) {
                    const t = e.offsetTop - 180;
                    setTimeout((() => {
                        window.scrollTo({
                            top: t
                        })
                    }), 600)
                }
            }
            return Oe((() => {
                w(!1)
            }))
        })), R((() => {
            void 0 !== m && clearTimeout(m), history.replaceState(null, "", "home" === s.source ? "/" : document.location.pathname), window.removeEventListener("samara-camera-change", E), window.removeEventListener("samara-room-change", b), delete window.engine
        })), e.$$.update = () => {
            if (2 & e.$$.dirty && n(4, i = () => {
                    f(xe, s.isZoomed = !s.isZoomed, s), w(!0), gtag("event", "tour_zoom_toggled", {
                        model: s.model,
                        zoom_state: !0 === s.isZoomed ? "zoomed_in" : "zoomed_out",
                        source: s.source
                    })
                }), 131 & e.$$.dirty && (() => {
                    if (!0 === A) return;
                    if (void 0 === p) return;
                    p.addEventListener("samara-loading-progress", x), window.addEventListener("samara-camera-change", E), window.addEventListener("samara-room-change", b);
                    let e = null;
                    if (window.location.hash.length > 1) {
                        const t = window.location.hash.substring(1);
                        e = function(e) {
                            try {
                                const t = atob(e),
                                    n = t.match(/z([01])/),
                                    i = t.match(/c([-\d.]+),([-\d.]+)/),
                                    r = t.match(/s(\d+)/);
                                return null === n || null === i || null === r ? null : {
                                    isZoomed: "1" === n[1],
                                    azimuthAngle: parseFloat(i[1]),
                                    polarAngle: parseFloat(i[2]),
                                    sphereIndex: parseInt(r[1], 10)
                                }
                            } catch (e) {
                                return null
                            }
                        }(t)
                    }
                    if (null === e) {
                        const i = u.find((e => e.model === s.model));
                        void 0 !== i && (e = {
                            isZoomed: window.innerWidth <= 768,
                            azimuthAngle: i.azimuthAngle,
                            polarAngle: i.polarAngle,
                            sphereIndex: i.sphereIndex
                        })
                    }
                    if (null !== e) {
                        function r() {
                            window.engine.cameraControls.applyCameraStateFromAngles({
                                fov: !0 === e.isZoomed ? a[0] : a[1],
                                azimuthAngle: e.azimuthAngle,
                                polarAngle: e.polarAngle,
                                sphereIndex: e.sphereIndex
                            }), window.engine.pano.setQuality(!0 === e.isZoomed ? c : l), setTimeout((() => {
                                v = !1
                            }), 500)
                        }
                        f(xe, s.isZoomed = e.isZoomed, s), v = !0, void 0 !== window.engine && void 0 !== window.engine.cameraControls ? r() : Oe(r)
                    }
                    n(7, A = !0), n(8, y = s.model)
                })(), 2 & e.$$.dirty && n(3, r = d[s.model]), 386 & e.$$.dirty && !0 === A && s.model && null !== y && y !== s.model) {
                n(8, y = s.model), history.replaceState(null, "", document.location.pathname);
                Oe((() => {
                    const e = u.find((e => e.model === s.model));
                    void 0 !== e && void 0 !== window.engine && void 0 !== window.engine.cameraControls && (v = !0, setTimeout((() => {
                        window.engine.cameraControls.applyCameraStateFromAngles({
                            fov: !0 === s.isZoomed ? a[0] : a[1],
                            azimuthAngle: e.azimuthAngle,
                            polarAngle: e.polarAngle,
                            sphereIndex: e.sphereIndex
                        }), setTimeout((() => {
                            v = !1
                        }), 500)
                    }), 100))
                }))
            }
        }, [p, s, g, r, i, function() {
            gtag("event", "tour_closed", {
                model: s.model,
                source: s.source
            }), window.Tour.hide()
        }, function() {
            gtag("event", "tour_specs_pricing_clicked", {
                model: s.model,
                source: s.source,
                action: s.model !== _ ? "navigate_to_model" : "scroll_to_specs"
            }), s.model !== _ ? window.openRoute(`/backyard/${h[s.model]}`) : (window.Tour.hide(), setTimeout((() => {
                const e = document.getElementById("tech-specs");
                if (null !== e) {
                    const t = e.offsetTop - 180;
                    window.scrollTo({
                        top: t,
                        behavior: "smooth"
                    })
                }
            }), 400))
        }, A, y, function(e) {
            L[e ? "unshift" : "push"]((() => {
                p = e, n(0, p)
            }))
        }]
    }
    class ke extends $ {
        constructor(e) {
            super(), Z(this, e, Fe, Ne, s, {})
        }
    }
    let Qe;
    if (window.Tour = {
            show(e, t, n) {
                if ("undefined" != typeof Tooltip && Tooltip.hide(), void 0 === t) {
                    const e = document.location.pathname.match(/\/backyard\/([^\/]+)\/?$/);
                    if (t = null, null !== e) {
                        const n = e[1],
                            i = {
                                studio: "studio",
                                "one-bedroom": "onebed",
                                "two-bedroom": "twobed",
                                "xl-8": "xl8",
                                "xl-10": "xl10"
                            };
                        void 0 !== i[n] && (t = i[n])
                    }
                }
                xe.update((i => ({
                    ...i,
                    variant: e,
                    source: n,
                    model: t,
                    nextModel: t,
                    isModelSelectorVisible: "home" === n || "nav" === n
                }))), Qe = function() {
                    const e = document.getElementById("tour");
                    if (null === e) return;
                    const t = new ke({
                        target: e
                    });
                    return function() {
                        e.classList.add("dismiss"), t.$destroy(), e.classList.remove("dismiss")
                    }
                }(), gtag("event", "tour_opened", {
                    model: t,
                    source: n
                })
            },
            hide() {
                void 0 !== Qe && (Qe(), Qe = void 0)
            }
        }, "" !== document.location.hash) {
        const e = document.location.pathname.match(/\/backyard\/([^\/]+)\/?$/);
        let t = "onebed";
        if (null !== e) {
            const n = e[1],
                i = {
                    studio: "studio",
                    "one-bedroom": "onebed",
                    "two-bedroom": "twobed",
                    "xl-8": "xl8",
                    "xl-10": "xl10"
                };
            void 0 !== i[n] && (t = i[n])
        }
        window.Tour.show("full-screen", t, "restore")
    }
}();
//# sourceMappingURL=bundle.js.map