async function createApplication(e, t = {}, n) {
    const i = n || `/assets/javascripts/${e}/bundle.js`;
    let r = null,
        a = null;
    try {
        [a, r] = await Promise.all([loadStyles(`/assets/stylesheets/${e}/bundle.css`), async function(n, i = 2) {
            for (let r = 0; r <= i; r++) try {
                const i = await import(n);
                if (void 0 === i.default) throw new Error(`Module ${e} does not have a default export`);
                return i.default(t)
            } catch (t) {
                if (r === i) throw t;
                console.warn(`Failed to load ${e} module (attempt ${r+1}/${i+1}):`, t), await new Promise((e => setTimeout(e, 1e3 * Math.pow(2, r))))
            }
        }(i)])
    } catch (t) {
        throw console.error(`failed to create application — ${e} — ${t}`), null !== a && a(), t
    }
    return function() {
        null !== r && r(), null !== a && a()
    }
}

function createDestroy(e, t, n = "router:will-change-url") {
    let i;
    async function r() {
        try {
            i = await t()
        } catch (e) {
            console.error("Failed to create handler:", e), void 0 !== window.Sentry && window.Sentry.captureException(e)
        }
    }

    function a(t) {
        const n = t?.detail?.url || location.pathname;
        e.test(n) && setTimeout(r, 0)
    }
    document.addEventListener("DOMContentLoaded", a), window.addEventListener("router:did-update-content", a), window.addEventListener(n, (function() {
        i && (i(), i = void 0)
    }))
}

function loadStyles(e) {
    function t() {}
    return new Promise((n => {
        if (document.querySelector(`link[href="${e}"]`)) return void n(t);
        const i = document.createElement("link");
        i.onload = function() {
            n(t)
        }, i.rel = "stylesheet", i.href = e, document.querySelector("head").appendChild(i)
    }))
}

function createPressHighlights(e) {
    if (null == e) return function() {};
    e.dataset.init = "true";
    const t = e.querySelector(".press-highlights-items");
    if (null == t) return function() {};
    const n = e.querySelectorAll(".press-highlights-scroll-button");
    if (n.length < 2) return function() {};
    const [i, r] = n, a = e.querySelector(".press-highlights-scroll-spacer");
    if (null == a) return function() {};

    function s() {
        const e = Array.from(t.querySelectorAll(".press-highlights-scroll-item") || []);
        if (0 === e.length) return;
        const n = e.findLast((e => e.getBoundingClientRect().left < 0));
        if (void 0 === n) return;
        const i = n.nextElementSibling;
        if (null == i) return;
        let r = 0;
        const a = n.getBoundingClientRect(),
            s = i.getBoundingClientRect();
        void 0 !== a && void 0 !== s && (r = s.left - a.right);
        const o = e[0] === n || e[1] === n ? 0 : t.scrollLeft - n.clientWidth - r;
        t.scrollTo({
            left: o,
            behavior: "smooth"
        })
    }

    function o() {
        const e = Array.from(t.querySelectorAll(".press-highlights-scroll-item") || []);
        if (0 === e.length) return;
        const n = window.innerWidth,
            i = e.find((e => e.getBoundingClientRect().right > n));
        if (void 0 === i) return;
        const r = i.previousElementSibling;
        if (null == r) return;
        let a = 0;
        const s = i.getBoundingClientRect(),
            o = r.getBoundingClientRect();
        void 0 !== s && void 0 !== o && (a = s.left - o.right);
        const l = e[e.length - 1],
            c = e[e.length - 2],
            h = l !== i && c !== i || void 0 === l ? t.scrollLeft + i.clientWidth + a : t.scrollWidth - t.clientWidth;
        t.scrollTo({
            left: h,
            behavior: "smooth"
        })
    }

    function l() {
        if (void 0 === i || void 0 === r || void 0 === a) return;
        i.classList.toggle("press-highlights-scroll-button-visible", t.scrollLeft > .2 * window.innerWidth);
        let e = 0;
        const n = a.getBoundingClientRect();
        void 0 !== n && (e = n.left), r.classList.toggle("press-highlights-scroll-button-visible", e > 1.1 * window.innerWidth)
    }
    return null != t && t.addEventListener("scroll", l), null != i && i.addEventListener("click", s), null != r && r.addEventListener("click", o), window.addEventListener("resize", l), l(),
        function() {
            null != t && t.removeEventListener("scroll", l), null != i && i.removeEventListener("click", s), null != r && r.removeEventListener("click", o), window.removeEventListener("resize", l), null != e && delete e.dataset.init
        }
}

function createInfiniteSlideshow(e) {
    e.dataset.init = !0;
    let t, n, i = e.querySelector(".infinite-slideshow-spacer"),
        r = Array.from(i.children),
        a = !1,
        s = r[0].clientWidth,
        o = r[0].clientHeight,
        l = 0,
        c = [],
        h = -1;

    function u(t) {
        l = t;
        let n = l % r.length;
        r.forEach(((e, t) => {
            e.classList.toggle("current", t === n)
        })), h !== n && e.dispatchEvent(new CustomEvent("change", {
            detail: {
                index: n
            }
        })), h = n
    }

    function d() {
        c.forEach((e => {
            e.parentElement && e.parentElement.removeChild(e)
        }));
        const e = Math.floor(i.clientWidth / s);
        !0 === Number.isFinite(e) && (c = Array(e).fill(void 0).map(((e, t) => {
            const n = document.createElement("div");
            return n.className = "infinite-slideshow-snapper", n.style.left = t * s + "px", i.appendChild(n), n
        })))
    }

    function p(t) {
        e.style.scrollSnapType = t ? null : "none"
    }

    function m() {
        f();
        u(Math.floor(i.clientWidth / s / 2 / r.length) * r.length + l % r.length), e.removeEventListener("scroll", g), p(!1);
        const t = .5 * (e.clientWidth - s);
        e.scrollLeft = l * s - (e.clientWidth - s) + t, f(), p(!0), e.addEventListener("scroll", g)
    }

    function f() {
        const t = Math.floor(e.scrollLeft / s),
            n = t + Math.ceil(e.clientWidth / s),
            i = e.getBoundingClientRect(),
            a = Math.round(.5 * (i.height - o));
        for (let e = t; e <= n; e++) {
            const t = r[e % r.length];
            if (void 0 === t) continue;
            const n = e * s;
            t.style.transform = `translate3d(${n}px, ${a}px, 0)`;
            const o = t.getBoundingClientRect(),
                l = o.x - i.x + .5 * o.width;
            Math.abs(.5 * i.width - l) < .5 * s && u(e)
        }
    }

    function g() {
        a || (clearTimeout(t), t = setTimeout(m, 300), f())
    }
    d(), m(), e.addEventListener("jump", (function(n) {
        e.scrollTo({
            left: (l + n.detail.direction) * s - .5 * (e.clientWidth - s),
            behavior: "smooth"
        }), clearTimeout(t), t = setTimeout(m, 600)
    })), window.addEventListener("resize", (function() {
        p(!1), clearTimeout(t), clearTimeout(n), n = setTimeout((() => {
            a = !1, p(!0)
        }), 100), a = !0, s = r[0].clientWidth, o = r[0].clientHeight, e.scrollLeft = l * s - .5 * (e.clientWidth - s), f(), d(), u(l)
    })), void 0 !== e.dataset.initialPageIndex && (l = e.dataset.initialPageIndex, e.scrollLeft = l * s - .5 * (e.clientWidth - s), m())
}
/*! For license information please see simple.js.LICENSE.txt */
var SimplePanorama;
(async () => {
    window.experimentValueFor = function(e, t, n) {
        return void 0 === window.statsig ? n : window.statsig.getExperiment(e).get(t, n)
    }, void 0 !== window.statsig && window.statsig.initializeAsync().then((function() {
        document.querySelectorAll("*[data-experiment-name]").forEach((e => {
            const t = experimentValueFor(e.dataset.experimentName, e.dataset.experimentDataValue);
            t && (e.innerText = t)
        }))
    }))
})(), window.API = {
    BASE_URL: "https://mailer.samara.com/api",
    fetch: (e, t = {}) => window.API.shouldFailNext ? (window.API.shouldFailNext = !1, new Promise(((e, t) => {
        setTimeout(t, 1e3, new Error("forced rejection"))
    }))) : fetch(window.API.BASE_URL + e, {
        headers: {
            "Content-Type": "application/json"
        },
        ...t
    }),
    completeAddress(e, t, n, i) {
        let r = `/address?query=${e}`;
        return t && (r += `&session=${t}`), n && (r += `&bias=${n}`), window.API.fetch(r, {
            signal: i
        })
    },
    subscribe: (e, t) => window.API.fetch("/subscribe", {
        method: "POST",
        body: JSON.stringify({
            email: e,
            tags: t
        })
    }),
    contact: e => window.API.fetch("/contact", {
        method: "POST",
        body: e
    }),
    requestShowroomTour: e => window.API.fetch("/contact/showroom", {
        method: "POST",
        body: e
    }),
    requestEstimate: e => window.API.fetch("/contact/estimate", {
        method: "POST",
        body: e
    }),
    orderBegin: () => window.API.fetch("/order/create"),
    orderFetchBySessionId: e => window.API.fetch(`/order/${e}`),
    orderUpdate: (e, t) => window.API.fetch(`/order/${e}`, {
        method: "PUT",
        body: t
    }),
    orderUpdateUsage: (e, t) => window.API.fetch(`/order/${e}/usage`, {
        method: "PUT",
        body: JSON.stringify(t)
    }),
    orderComplete: (e, t) => window.API.fetch(`/order/${e}`, {
        method: "POST",
        body: t
    }),
    expand: (e, t, n, i, r) => window.API.fetch("/expand", {
        method: "POST",
        body: JSON.stringify({
            zip: e,
            email: t,
            origin: n,
            sessionId: i,
            address: r
        })
    }),
    appointmentSlots(e, t, n, i) {
        let r = `/appointment/${e}?date=${t.toISOString()}`;
        return n && (r += `&zip=${n}`), i && (r += `&slug=${i}`), window.API.fetch(r)
    },
    bookAppointment: (e, t, n) => window.API.fetch(`/appointment/${e}`, {
        method: "POST",
        body: JSON.stringify({
            ...n,
            date: t
        })
    }),
    bookHelloCall: (e, t) => window.API.fetch("/appointment/discovery", {
        method: "POST",
        body: JSON.stringify({
            date: e,
            slug: t
        })
    }),
    bookEvent: e => window.API.fetch("/appointment/event", {
        method: "POST",
        body: JSON.stringify(e)
    }),
    multiUnitGetInTouch: e => window.API.fetch("/contact/multiunit", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(e)
    }),
    estimationRequestFetchBySlug: e => window.API.fetch(`/hello/${e}`, {
        headers: {
            "Content-Type": "application/json"
        }
    }),
    createFinancingRecord: e => window.API.fetch("/financing", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(e)
    }),
    updateFinancingRecord: (e, t) => window.API.fetch(`/financing/${e}`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(t)
    }),
    updateHelloQuestionnaire: (e, t) => window.API.fetch(`/hello/${e}`, {
        method: "PUT",
        body: JSON.stringify(t)
    })
}, window.addEventListener("mousedown", (e => {
    e.altKey && (window.API.shouldFailNext = !0)
})), window.process = {
    ...window.process
}, window.process.env = {
    ...window.process.env,
    NODE_ENV: "production"
}, window.fetchWithRetry = async function(e, t = {}, n = {}) {
    const {
        maxRetries: i = 2,
        retryDelay: r = 1e3,
        timeout: a = 3e4,
        onRetry: s = null
    } = n, o = new AbortController, l = setTimeout((() => o.abort()), a), c = {
        ...t,
        signal: o.signal
    };
    return async function t(n) {
        try {
            const t = await fetch(e, c);
            if (clearTimeout(l), !t.ok && n < i && (t.status >= 500 || 408 === t.status || 429 === t.status)) throw new Error(`HTTP ${t.status}: ${t.statusText}`);
            return t
        } catch (e) {
            if (clearTimeout(l), "AbortError" === e.name) throw new Error("Request timeout");
            if (n < i) {
                s && s(n + 1, e);
                const i = r * Math.pow(2, n);
                return await new Promise((e => setTimeout(e, i))), t(n + 1)
            }
            throw e
        }
    }(0)
}, window.logFetchError = function(e, t) {
    const n = {
        url: e,
        error: t.message,
        timestamp: (new Date).toISOString(),
        userAgent: navigator.userAgent
    };
    return console.error("Fetch failed:", n), void 0 !== window.Sentry && window.Sentry.captureException(t, {
        extra: n,
        tags: {
            component: "fetch"
        }
    }), n
}, window.loadImageWithFallback = function(e, t) {
    const n = e.src;
    e.onerror = function() {
        e.src !== t && (console.warn(`Failed to load image: ${n}, using fallback`), e.src = t)
    }, e.onload = function() {
        e.src === t && setTimeout((() => {
            const t = new Image;
            t.onload = () => {
                e.src = n
            }, t.src = n
        }), 3e4)
    }
}, (() => {
    const e = 768;
    let t, n = window.innerWidth;

    function i() {
        document.querySelectorAll("img[srcset]").forEach((e => {
            const t = e.srcset;
            e.removeAttribute("srcset"), setTimeout((() => {
                e.setAttribute("srcset", t)
            }), 0)
        }))
    }
    window.addEventListener("resize", (function() {
        const r = window.innerWidth;
        n < e && r < e || n > e && r > e ? n = r : (n = r, clearTimeout(t), t = setTimeout(i, 40))
    }))
})(), (() => {
    const e = new Set,
        t = document.getElementById("sentry-script");

    function n(e, t) {
        const n = `${e.message||""} ${t||""}`;
        return [/Script error/i, /ResizeObserver loop limit exceeded/i, /Non-Error promise rejection captured/i, /NetworkError.*Load failed/i, /Failed to fetch dynamically imported module/i, /Load failed/i, /NetworkError/i, /Failed to fetch/i, /Importing a module script failed/i].some((e => e.test(n)))
    }

    function i(e, t, n, i) {
        const r = {
            message: e.message || "Unknown error",
            source: t || "Unknown source",
            lineno: n || 0,
            colno: i || 0,
            stack: e.stack,
            userAgent: navigator.userAgent,
            timestamp: (new Date).toISOString(),
            url: window.location.href,
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };
        return window.isWebGLSupported && (r.webGL = window.isWebGLSupported()), r
    }

    function r(t, n = {}) {
        if (void 0 === window.Sentry) return;
        const i = function(e, t) {
            const n = e.message || "Unknown error",
                i = e.stack || "";
            return `${n}-${t}-${e.lineno||0}-${e.colno||0}-${i.substring(0,100)}`
        }(t, n.source || "Unknown");
        e.has(i) || (e.add(i), setTimeout((() => e.delete(i)), 3e5), window.Sentry.captureException(t, {
            extra: n,
            fingerprint: [i]
        }))
    }
    t && (t.onload = function() {
        const e = {
            dsn: "https://6239eb46ed1b0d72b5c7186827b1f830@o1233526.ingest.sentry.io/4505953549287424"
        };
        Sentry.init(e)
    });
    const a = window.console.error;
    window.console.error = function() {
        if (a.apply(console, arguments), 0 === arguments.length) return;
        const e = arguments[0];
        let t, i = {};
        if (e instanceof Error) t = e, arguments.length > 1 && (i.additionalArgs = Array.from(arguments).slice(1));
        else if ("string" == typeof e)
            if (e.includes("Unhandled promise rejection")) {
                if (arguments.length > 1 && void 0 !== arguments[1]) {
                    const e = arguments[1];
                    e instanceof Error ? t = e : (t = new Error(`Promise rejection: ${String(e)}`), i.rejectionValue = e)
                } else t = new Error("Unhandled promise rejection (no details)");
                i.type = "promise_rejection"
            } else t = new Error(Array.from(arguments).join(" — "));
        else t = new Error(`Console error: ${JSON.stringify(e)}`), i.originalValue = e, arguments.length > 1 && (i.additionalArgs = Array.from(arguments).slice(1));
        n(t, "console") || (i.source = "console.error", r(t, i))
    }, window.addEventListener("error", (function(e) {
        const {
            error: t,
            message: a,
            source: s,
            lineno: o,
            colno: l
        } = e, c = t || new Error(a);
        if (n(c, s)) return;
        const h = i(c, s, o, l);
        console.error("Global error caught:", h), r(c, h), "localhost" !== window.location.hostname && e.preventDefault()
    })), window.addEventListener("unhandledrejection", (function(e) {
        const t = e.reason;
        if (t && n(t, "Promise")) return;
        const i = t instanceof Error ? t : new Error(String(t)),
            a = {
                type: "unhandledRejection",
                reason: t,
                promise: e.promise,
                timestamp: (new Date).toISOString(),
                url: window.location.href,
                source: "Promise"
            };
        console.error("Unhandled promise rejection:", a), r(i, a), "localhost" !== window.location.hostname && e.preventDefault()
    })), window.reportError = function(e, t = {}) {
        const n = e instanceof Error ? e : new Error(String(e)),
            a = i(n, t.source || "Manual");
        console.error("Manually reported error:", a), r(n, Object.assign({}, a, t))
    }
})(), createDestroy(/.*/, (function() {
    const e = document.querySelector(".footer-nav");
    if (!e || e.dataset.enabled) return function() {};
    e.dataset.enabled = !0;
    const t = document.querySelector(".footer-contact-subscription");
    return t.querySelector("input[type=email]").addEventListener("focus", (function() {
            t.classList.remove("footer-contact-subscription-failure", "footer-contact-subscription-success", "footer-contact-subscription-loading")
        })), t.querySelector("form").addEventListener("submit", (async function(n) {
            n.preventDefault();
            const i = t.querySelector("input[type=email]");
            i.blur(), await async function(e) {
                t.classList.add("footer-contact-subscription-loading"), gtag("event", "footer_subscribe");
                try {
                    await API.subscribe(e, ["footer"]), t.classList.add("footer-contact-subscription-success")
                } catch (e) {
                    t.classList.add("footer-contact-subscription-failure"), "undefined" != typeof Sentry && Sentry.captureException(e)
                }
                t.classList.remove("footer-contact-subscription-loading")
            }(i.value), t.querySelector("input[type=email]").value = "", e.querySelector("form").reset()
        })),
        function() {}
})), createDestroy(/.*/, (function() {
    const e = document.body.querySelectorAll(".press-highlights") || [],
        t = [];
    return e.forEach((e => {
            if (null != e && void 0 === e.dataset.init) {
                const n = createPressHighlights(e);
                void 0 !== n && "function" == typeof n && t.push(n)
            }
        })),
        function() {
            t.forEach((e => {
                "function" == typeof e && e()
            }))
        }
})), createDestroy(/.*/, (function() {
    return document.body.querySelectorAll(".infinite-slideshow").forEach((e => {
            void 0 === e.dataset.init && createInfiniteSlideshow(e)
        })),
        function() {}
})), createDestroy(/.*/, (function() {
    return document.body.querySelectorAll(".modern-slideshow").forEach((e => {
            void 0 === e.dataset.init && function(e) {
                function t(t) {
                    const n = e.getBoundingClientRect(),
                        i = n.left + .5 * n.width,
                        r = Array.from(e.children),
                        a = r.findIndex((e => {
                            const t = e.getBoundingClientRect(),
                                n = t.left + .5 * t.width;
                            return Math.abs(i - n) < .5 * t.width
                        })),
                        s = r[Math.min(Math.max(a + t, 0), r.length - 1)].getBoundingClientRect(),
                        o = s.left + .5 * s.width;
                    e.scrollTo({
                        top: 0,
                        left: e.scrollLeft + (o - i),
                        behavior: "smooth"
                    })
                }
                e.dataset.init = !0, setTimeout((() => {
                    e.scrollTo(0, 0)
                }), 40), e.addEventListener("click", (function(n) {
                    window.innerWidth < 768 || t(n.clientX / e.clientWidth < .5 ? -1 : 1)
                }))
            }(e)
        })),
        function() {}
})), document.addEventListener("DOMContentLoaded", (function() {
    const e = document.querySelector(".mobile-navigation");
    if (null === e) return;
    if (e.classList.contains("mobile-navigation-active")) return;
    let t = 0,
        n = null;

    function i(t) {
        const n = "/" === t ? "/backyard" : t;
        e.querySelectorAll("a").forEach((e => {
            const t = e.getAttribute("href");
            if (null == t) return;
            const i = t.split("/").length > 2,
                r = t === n || !0 === i && !0 === n.startsWith(t);
            e.classList.toggle("current", !0 === r);
            const a = e.closest("li");
            null != a && a.classList.toggle("current", !0 === r)
        }));
        const i = e.querySelector(".mobile-navigation-item-models");
        if (null != i) {
            const t = e.querySelector(".mobile-navigation-models");
            let r = !1;
            null != t && (r = t.querySelectorAll("a.current, li.current").length > 0);
            const a = "/backyard/models" === n || !0 === n.startsWith("/backyard/models/") || !0 === r;
            i.classList.toggle("current", !0 === a)
        }
    }

    function r() {
        if (null === e) return;
        const i = e.children[t].getBoundingClientRect();
        e.dataset.index = t, e.style.width = `${i.width}px`, e.style.height = `${i.height}px`, null !== n && (n.style.display = 0 !== t ? "block" : "none")
    }
    e.querySelector(".mobile-navigation-hamburger").addEventListener("click", (function(e) {
        e.stopPropagation(), t = 1, r()
    })), e.querySelector(".mobile-navigation-close").addEventListener("click", (function() {
        t = 0, r()
    })), e.querySelector(".mobile-navigation-item-models").addEventListener("click", (function() {
        t = 2, r()
    })), e.querySelector(".mobile-navigation-item-back").addEventListener("click", (function() {
        t = 1, r()
    })), e.querySelector(".mobile-navigation-item-contact").addEventListener("click", (function() {
        t = 0, r()
    })), window.addEventListener("scroll", (function() {
        0 !== t && (t = 0, r())
    })), window.addEventListener("router:did-update-content", (function(e) {
        t = 0, r(), i(e.detail.url)
    })), n = document.createElement("div"), n.className = "mobile-navigation-overlay", n.style.cssText = "position: fixed; inset: 0; z-index: 998; display: none;", document.body.appendChild(n), n.addEventListener("click", (function(e) {
        e.preventDefault(), e.stopPropagation(), t = 0, r()
    })), n.addEventListener("touchstart", (function(e) {
        e.preventDefault(), e.stopPropagation(), t = 0, r()
    }), {
        passive: !1
    }), r(), i(location.pathname), e.classList.add("mobile-navigation-active")
})), (() => {
    const e = {
        CLASSES: {
            MAIN_NAV: "nav.main-navigation",
            CURRENT: "current",
            TRANSITION_CONFIG: "transition-configurator",
            HOVER_MODELS: "main-navigation-hover-models",
            HOVER_HAMBURGER: "main-navigation-hamburger-hover",
            HIDDEN_WILDFIRES: "hidden-due-to-wildfires",
            BACKYARD: "backyard",
            MODELS_ITEM: "backyard-menu-item-models",
            HAMBURGER: "main-navigation-hamburger",
            HAMBURGER_DROPDOWN: ".main-navigation-hamburger-dropdown",
            CONFIGURE_BUTTON: ".backyard-configure"
        },
        EVENTS: {
            NAV_HOVER: "navigation:hover",
            NAV_UNHOVER: "navigation:unhover",
            ROUTER_CHANGE: "router:will-change-url",
            ROUTER_SCROLL: "router:scroll-top",
            GTAG_CONFIG_CLICK: "configurator_button_clicked"
        },
        DELAYS: {
            COLLAPSE: 400,
            DROPDOWN_HIDE: 400,
            MOUSE_MOVE_DEBOUNCE: 16
        },
        THRESHOLDS: {
            SCROLL_HIDE: 10,
            DESKTOP_WIDTH: 768,
            DROPDOWN_GAP: 20
        },
        PADDING: {
            DROPDOWN_CHECK: 10,
            HAMBURGER_BUFFER: 20,
            CORRIDOR_HORIZONTAL: 30,
            CORRIDOR_VERTICAL: 20
        },
        MODEL_SLUGS: {
            studio: "studio",
            "one-bedroom": "onebed",
            "two-bedroom": "twobed",
            "xl-8": "xl-8",
            "xl-10": "xl-10"
        }
    };
    document.addEventListener("DOMContentLoaded", (function() {
        const t = {
            element: null,
            items: null,
            configureButton: null,
            isMonitoringMouseMove: !1,
            mouseMoveTimeout: null
        };

        function n() {
            return !0 === window.matchMedia("(pointer: coarse)").matches
        }

        function i(e, t, n = 0) {
            return e.clientX >= t.left && e.clientX <= t.right && e.clientY >= t.top - n && e.clientY <= t.bottom + n
        }

        function r() {
            return t.element.querySelector(e.CLASSES.HAMBURGER_DROPDOWN)
        }

        function a() {
            t.element.classList.remove(e.CLASSES.HOVER_HAMBURGER), y()
        }

        function s() {
            t.element.classList.add(e.CLASSES.HOVER_HAMBURGER), !1 === t.isMonitoringMouseMove && (t.isMonitoringMouseMove = !0, window.addEventListener("mousemove", v))
        }

        function o(n) {
            const i = "/" === n.detail.url ? "/backyard" : n.detail.url;
            ! function(n) {
                t.items.forEach((t => {
                    const i = t.getAttribute("href");
                    if (null == i) return;
                    const r = i.split("/").length > 2,
                        a = i === n || !0 === r && !0 === n.startsWith(i);
                    t.classList.toggle(e.CLASSES.CURRENT, !0 === a)
                }));
                const i = r();
                null != i && i.querySelectorAll("a").forEach((t => {
                    const i = t.getAttribute("href");
                    if (null !== i && "#" !== i && "/" !== i) {
                        const r = i.split("/").length > 2,
                            a = i === n || !0 === r && !0 === n.startsWith(i);
                        t.classList.toggle(e.CLASSES.CURRENT, !0 === a)
                    }
                }))
            }(i),
            function(n) {
                t.element.classList.toggle(e.CLASSES.TRANSITION_CONFIG, !0 === n.startsWith("/backyard/configure"))
            }(i),
            function(n) {
                const i = n.match(/([^\/]+)\/?$/),
                    r = null !== i ? i[i.length - 1] : void 0,
                    a = e.MODEL_SLUGS[r];
                t.configureButton.href = void 0 !== a ? `/backyard/configure#bonewhite+${a}` : "/backyard/configure"
            }(i)
        }

        function l() {}

        function c() {
            window.dispatchEvent(new Event(e.EVENTS.NAV_HOVER))
        }

        function h() {
            window.dispatchEvent(new Event(e.EVENTS.NAV_UNHOVER))
        }

        function u(e) {
            e.preventDefault()
        }

        function d() {
            "undefined" != typeof gtag && gtag("event", e.EVENTS.GTAG_CONFIG_CLICK)
        }

        function p() {
            const t = window.scrollY < e.THRESHOLDS.SCROLL_HIDE || !1 === document.body.classList.contains(e.CLASSES.BACKYARD),
                n = document.querySelector("nav .backyard-configure");
            null != n && n.classList.toggle(e.CLASSES.HIDDEN_WILDFIRES, !0 === t)
        }

        function m(n) {
            const i = n.target.parentElement,
                r = !0 === i.classList.contains(e.CLASSES.MODELS_ITEM),
                a = !0 === i.classList.contains(e.CLASSES.HAMBURGER);
            t.element.classList.toggle(e.CLASSES.HOVER_MODELS, r), !0 === a ? s() : (t.element.classList.remove(e.CLASSES.HOVER_HAMBURGER), y())
        }

        function f(n) {
            !1 === t.element.classList.contains(e.CLASSES.HOVER_HAMBURGER) && s()
        }

        function g(i) {
            !0 !== n() && window.innerWidth > e.THRESHOLDS.DESKTOP_WIDTH == !0 && (t.element.classList.add(e.CLASSES.HOVER_MODELS), a())
        }

        function _(s) {
            if (!0 !== n() && (t.element.classList.remove(e.CLASSES.HOVER_MODELS), !0 === t.element.classList.contains(e.CLASSES.HOVER_HAMBURGER))) {
                const n = r();
                if (null != n && null !== s.relatedTarget && !0 === n.contains(s.relatedTarget)) return;
                if (!0 === t.isMonitoringMouseMove) return;
                !0 === !i(s, n.getBoundingClientRect(), e.PADDING.DROPDOWN_CHECK) && a()
            }
        }

        function v(n) {
            const s = n.clientX,
                o = n.clientY;
            null !== t.mouseMoveTimeout && clearTimeout(t.mouseMoveTimeout), t.mouseMoveTimeout = setTimeout((function() {
                ! function(n, s) {
                    const o = r();
                    if (null == o) return;
                    const l = o.getBoundingClientRect(),
                        c = t.element.querySelector(".main-navigation-list-container"),
                        h = c ? c.getBoundingClientRect() : t.element.getBoundingClientRect(),
                        u = t.element.querySelector(`.${e.CLASSES.HAMBURGER}`),
                        d = n < l.left,
                        p = s >= l.top && s <= l.bottom;
                    if (!0 === d && !0 === p) return void a();
                    const m = {
                            clientX: n,
                            clientY: s
                        },
                        f = i(m, l, e.THRESHOLDS.DROPDOWN_GAP),
                        g = i(m, h, 0);
                    if (!1 === f && !1 === g) a();
                    else if (!1 === f && !0 === g && null != u) {
                        const t = u.getBoundingClientRect(),
                            r = i(m, t, e.PADDING.HAMBURGER_BUFFER),
                            o = s >= t.bottom && s <= l.top,
                            c = Math.min(t.left, l.left) - 20,
                            h = Math.max(t.right, l.right) + 20,
                            d = !0 === o && n >= c && n <= h,
                            p = i(m, l, e.THRESHOLDS.DROPDOWN_GAP);
                        !1 === r && !1 === d && !1 === p && a()
                    }
                }(s, o)
            }), e.DELAYS.MOUSE_MOVE_DEBOUNCE)
        }

        function y() {
            !0 === t.isMonitoringMouseMove && (t.isMonitoringMouseMove = !1, null !== t.mouseMoveTimeout && (clearTimeout(t.mouseMoveTimeout), t.mouseMoveTimeout = null), window.removeEventListener("mousemove", v))
        }

        function x() {}

        function b(t) {
            let n = t.target,
                i = !1;
            for (; null !== n && "A" !== n.tagName;) {
                if (!0 === n.hasAttribute("onclick")) {
                    i = !0;
                    break
                }
                n = n.parentElement
            }!1 === i && null !== n && "A" === n.tagName && (i = n.hasAttribute("onclick")), !0 === i ? a() : setTimeout((function() {
                a()
            }), e.DELAYS.DROPDOWN_HIDE)
        }!1 != (t.element = document.querySelector(e.CLASSES.MAIN_NAV), null !== t.element && void 0 !== t.element && (t.items = t.element.querySelectorAll("a"), t.configureButton = t.element.querySelector(e.CLASSES.CONFIGURE_BUTTON), null !== t.configureButton && void 0 !== t.configureButton && (t.configureButton.hidden = !1, !0))) && (window.addEventListener(e.EVENTS.ROUTER_CHANGE, o), window.addEventListener(e.EVENTS.ROUTER_SCROLL, l), window.addEventListener("scroll", p), Array.from(t.element.children).forEach((e => {
            e.addEventListener("mouseenter", c), e.addEventListener("mouseleave", h)
        })), t.element.addEventListener("touchmove", u), t.element.addEventListener("mouseleave", _), function() {
            t.element.querySelectorAll("ul > li > a, ul > li > svg").forEach((e => {
                e.addEventListener("mouseenter", m)
            }));
            const n = t.element.querySelector(`.${e.CLASSES.MODELS_ITEM}`);
            null != n && n.addEventListener("mouseenter", g);
            const i = t.element.querySelector(`.${e.CLASSES.HAMBURGER}`);
            if (null != i) {
                const n = i.querySelector("a, svg");
                null != n && (n.addEventListener("mouseenter", (function(n) {
                    !1 === t.element.classList.contains(e.CLASSES.HOVER_HAMBURGER) && s(), n.stopPropagation()
                })), n.addEventListener("mousemove", f))
            }
        }(), function() {
            const e = r();
            null != e && (e.addEventListener("mouseenter", x), e.querySelectorAll("a").forEach((e => {
                e.addEventListener("click", b)
            })))
        }(), null !== t.configureButton && void 0 !== t.configureButton && t.configureButton.addEventListener("click", d), o({
            detail: {
                url: location.pathname
            }
        }))
    }))
})(), createDestroy(/.*/, (function() {
    return document.body.querySelectorAll(".paging-indicator").forEach((e => {
            void 0 === e.dataset.init && function(e) {
                e.dataset.init = !0;
                const t = e.querySelectorAll("li");
                if (e.dataset.changeEmmiterSelector && document.querySelector(e.dataset.changeEmmiterSelector).addEventListener("change", (function(e) {
                        t.forEach(((t, n) => {
                            t.classList.toggle("paging-indicator-current", n === e.detail.index)
                        }))
                    })), e.dataset.scrollElementSelector) {
                    let n;
                    document.querySelector(e.dataset.scrollElementSelector).addEventListener("scroll", (function(e) {
                        const i = Math.round(e.target.scrollLeft / e.target.scrollWidth * t.length);
                        n !== i && (n = i, t.forEach(((e, t) => {
                            e.classList.toggle("paging-indicator-current", t === i)
                        })))
                    }))
                }
            }(e)
        })),
        function() {}
})), "undefined" != typeof Element && (Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function(e) {
    var t = this;
    do {
        if (t.matches(e)) return t;
        t = t.parentElement || t.parentNode
    } while (null !== t && 1 === t.nodeType);
    return null
})), document.addEventListener("DOMContentLoaded", (function() {
    const e = {
            "/news/time-names-backyard-a-best-invention-of-2024": {
                title: "TIME names Samara’s Backyard a Best Invention of 2024 — News — Samara",
                description: "Each year, TIME honors genius ideas and products that are changing how we live, work, play, and think about what’s possible. We’re proud to announce that this year, Backyard has been recognized as one of TIME’s Best Inventions of 2024.",
                class_names: "newsroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/newsroom/internal",
                position: 14,
                share_sheet_image_id: "7e59efa2-59ea-4288-8dea-05bb7cdfb800",
                og_image: "https://www.samara.com/assets/remote/7e59efa2-59ea-4288-8dea-05bb7cdfb800/w=1200"
            },
            "/news/there-s-more-to-love-with-backyard-xl-10": {
                title: "There’s more to love with Backyard XL 10 — News — Samara",
                description: "Backyard just got bigger. We’re excited to unveil Backyard XL 10, the latest and largest addition to Samara’s ADU lineup.",
                class_names: "newsroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/newsroom/internal",
                position: 13,
                share_sheet_image_id: "b1ae142b-b246-4501-20f1-f1350a84c300",
                og_image: "https://www.samara.com/assets/remote/b1ae142b-b246-4501-20f1-f1350a84c300/w=1200"
            },
            "/news/samara-launches-proprietary-financing-product-to-bring-more-space-to-millions-of-homeowners": {
                title: "Samara Launches Proprietary Financing Product to  Bring More Space to Millions of Homeowners — News — Samara",
                description: "REDWOOD CITY, CALIFORNIA  — Today, Samara Finance, LLC, a wholly-owned subsidiary of Samara, announced it launched a first-of-its-kind financing product, making it easier for homeowners to finance Backyard, its accessory dwelling unit (ADU). Now, Samara uniquely manages the ADU process from conception to completion, handling everything from product design and prefab manufacturing, to permitting, delivery and installation, to financing. The new financing option makes it possible for homeowners to add flexible space to their homes with competitive rates. This enables the company to accelerate expansion and deliver more units in 2024 and beyond.",
                class_names: "newsroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/newsroom/internal",
                position: 12,
                share_sheet_image_id: "c5700752-823e-4522-f805-a3a788b63400",
                og_image: "https://www.samara.com/assets/remote/c5700752-823e-4522-f805-a3a788b63400/w=1200"
            },
            "/news/introducing-backyard-xl": {
                title: "Introducing Backyard XL 8 — News — Samara",
                description: "We’re proud to unveil Backyard XL 8, our latest ADU model that makes it easy for homeowners to add more flexible living space to their existing properties. With two bedrooms and two bathrooms, the luxe 800-square-foot home provides ample space with larger appliances, and premium amenities.",
                class_names: "newsroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/newsroom/internal",
                position: 11,
                share_sheet_image_id: "4f02d289-169f-4ab4-50e7-edb29cfa4300",
                og_image: "https://www.samara.com/assets/remote/4f02d289-169f-4ab4-50e7-edb29cfa4300/w=1200"
            },
            "/news/samara-acquires-factory-to-scale-manufacturing-of-backyard": {
                title: "Samara Acquires Factory to Scale Manufacturing of Backyard  as Demand for ADUs Soars in California — News — Samara",
                description: "REDWOOD CITY, CALIFORNIA — Today, Samara announced it has acquired a factory that brings the manufacturing of its high-quality accessory dwelling unit (ADU), Backyard, completely in house. Located in Mexicali, Mexico, the factory gives Samara more control over the quality standard of Backyard, shortens delivery timelines, accelerates product development and enables the company to meet rising customer demand in California and beyond.",
                class_names: "newsroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/newsroom/internal",
                position: 10,
                share_sheet_image_id: "dd6932ff-e29e-410b-b2e6-4f23130e1e00",
                og_image: "https://www.samara.com/assets/remote/dd6932ff-e29e-410b-b2e6-4f23130e1e00/w=1200"
            },
            "/news/samara-raises-41-million-to-bring-high-quality-adus-to-every-backyard-in-california-and-beyond": {
                title: "Samara raises $41 million to bring high quality ADUs to every backyard in California and beyond — News — Samara",
                description: "We’re excited to announce our $41M Series A round, led by Thrive Capital with participation from leading VC firms and angel investors. This latest funding will allow us to scale our brand, product offerings, team, and much needed manufacturing capacity to unlock growth and bring high quality accessory dwelling units (ADUs) to every backyard in California and beyond.",
                class_names: "newsroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/newsroom/internal",
                position: 9,
                share_sheet_image_id: "59ee21f7-d5a4-4592-e873-b16c86b7ea00",
                og_image: "https://www.samara.com/assets/remote/59ee21f7-d5a4-4592-e873-b16c86b7ea00/w=1200"
            },
            "/insights/how-we-built-a-fire-resistant-ADU": {
                title: "How We Built a Fire-Resistant ADU — Samara",
                description: "California shapes how we think about building. To create high-performing homes built for today and tomorrow, we've carefully selected materials and made practical design decisions for longevity—choices that naturally create inherent fire resistance.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 14,
                share_sheet_image_id: "93578295-abea-42a3-500e-969069e49200",
                og_image: "https://www.samara.com/assets/remote/93578295-abea-42a3-500e-969069e49200/w=1200"
            },
            "/insights/can-hoas-block-adu-construction-in-california": {
                title: "Can HOAs Block ADU Construction in California? Understanding Your Rights — Samara",
                description: "If you’re considering building an ADU and belong to an HOA, you might wonder about potential restrictions or requirements. Here’s what you need to know about your rights and the limits of HOA authority over ADU construction.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 13,
                share_sheet_image_id: "2b76073a-ab8d-4488-6ebc-af6a19c92700",
                og_image: "https://www.samara.com/assets/remote/2b76073a-ab8d-4488-6ebc-af6a19c92700/w=1200"
            },
            "/insights/how-to-finance-an-adu": {
                title: "How to Finance an ADU — Samara",
                description: "Homeowners can tap into a variety of funding resources to build an ADU. Use this guide to explore how to finance an ADU to add value to your property. ",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 12,
                share_sheet_image_id: "7b4af13f-4e79-4bc5-81c9-8e245b224e00",
                og_image: "https://www.samara.com/assets/remote/7b4af13f-4e79-4bc5-81c9-8e245b224e00/w=1200"
            },
            "/insights/how-big-can-an-adu-be-in-california": {
                title: "How Many Bedrooms Can an ADU in California Have? — Samara",
                description: "The number of bedrooms in your new ADU will influence the final design. Learn how many bedrooms your ADU should have to maximize your experience.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 11,
                share_sheet_image_id: "8a85faee-0714-4c7c-eb3c-712f65391800",
                og_image: "https://www.samara.com/assets/remote/8a85faee-0714-4c7c-eb3c-712f65391800/w=1200"
            },
            "/insights/2025-accessory-dwelling-unit-handbook": {
                title: "California’s New ADU Handbook: What’s Changed for 2025 — Samara",
                description: "",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 10,
                share_sheet_image_id: "7fd63db2-b177-45ea-299d-1dd0804d2d00",
                og_image: "https://www.samara.com/assets/remote/7fd63db2-b177-45ea-299d-1dd0804d2d00/w=1200"
            },
            "/insights/report-adus-win-over-california-homeowners": {
                title: "Report: ADUs Win Over California Homeowners — Samara",
                description: "We recently surveyed California homeowners on how they felt about ADUs. While regulatory complexities remain the top concern, an overwhelming 87% of homeowners welcome or accept ADUs in their neighborhoods.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 9,
                share_sheet_image_id: "6b07990f-4555-423d-b568-2b6f43dbcd00",
                og_image: "https://www.samara.com/assets/remote/6b07990f-4555-423d-b568-2b6f43dbcd00/w=1200"
            },
            "/insights/how-to-get-an-adu-permit": {
                title: "How to Get an ADU Permit in California — Samara",
                description: "Simplify the ADU permit process in California with this easy guide. Learn about zoning, building permits, and more to get your ADU project started.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 8,
                share_sheet_image_id: "e96ecaec-e24a-42e1-5f4f-f02dc7047100",
                og_image: "https://www.samara.com/assets/remote/e96ecaec-e24a-42e1-5f4f-f02dc7047100/w=1200"
            },
            "/insights/adu-cost-california": {
                title: "How Much Does It Cost To Build an ADU in California? — Samara",
                description: "Before you design and build an ADU, consider the costs and benefits. Tally up how much an ADU costs in California and if it fits your budget.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 7,
                share_sheet_image_id: "0cbd6443-3673-4085-e6b4-44e240261e00",
                og_image: "https://www.samara.com/assets/remote/0cbd6443-3673-4085-e6b4-44e240261e00/w=1200"
            },
            "/insights/adu-california": {
                title: "What Is Considered an ADU in California? — Samara",
                description: "Building an ADU can offer homeowners many benefits despite the initial investment. Find out what's considered an ADU in the state of California. ",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 6,
                share_sheet_image_id: "e0a07661-bd4d-4453-36fa-d68eabbf0300",
                og_image: "https://www.samara.com/assets/remote/e0a07661-bd4d-4453-36fa-d68eabbf0300/w=1200"
            },
            "/insights/adu-california-grant": {
                title: "How To Get an ADU Grant in California — Samara",
                description: "An ADU California grant can help you build your accessory dwelling unit. Learn how to get an ADU grant in California to offset the associated costs.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 5,
                share_sheet_image_id: "4e095cd5-6432-4dd8-42de-02f965b60400",
                og_image: "https://www.samara.com/assets/remote/4e095cd5-6432-4dd8-42de-02f965b60400/w=1200"
            },
            "/backyard/guides/bay-area-adu": {
                title: "The Complete Bay Area ADU Requirements Guide — Samara",
                description: "Learn the rules and regulations for building an ADU in the Bay Area so your journey from proposal to permit goes as smoothly as possible.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 16,
                share_sheet_image_id: "b5179a48-48f8-4a17-81eb-8a5da9b19900",
                og_image: "https://www.samara.com/assets/remote/b5179a48-48f8-4a17-81eb-8a5da9b19900/w=1200"
            },
            "/backyard/guides/burlingame-adu": {
                title: "The Complete Burlingame ADU Requirements Guide — Samara",
                description: "A clear guide to Burlingame’s ADU rules, including size, height, setbacks, zoning, parking, and how many units you can build.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 15,
                share_sheet_image_id: "08a44d59-17fb-41ca-f1b5-15eae2eb5c00",
                og_image: "https://www.samara.com/assets/remote/08a44d59-17fb-41ca-f1b5-15eae2eb5c00/w=1200"
            },
            "/backyard/guides/saratoga-adu": {
                title: "The Complete Saratoga ADU Requirements Guide — Samara",
                description: "Find out what’s allowed when building an ADU in Saratoga, including size, setbacks, parking, and zoning rules, plus how Samara can help you through the process.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 14,
                share_sheet_image_id: "5aa3b561-1b8d-4156-ff2b-eb030aed1700",
                og_image: "https://www.samara.com/assets/remote/5aa3b561-1b8d-4156-ff2b-eb030aed1700/w=1200"
            },
            "/backyard/guides/adu-calabasas": {
                title: "The Complete Calabasas ADU Requirements Guide — Samara",
                description: "A clear guide to Calabasas ADU rules, covering size, height, setbacks, zoning, parking, and how many units are allowed per property.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 13,
                share_sheet_image_id: "43b07275-c075-45da-b298-934b72bc7600",
                og_image: "https://www.samara.com/assets/remote/43b07275-c075-45da-b298-934b72bc7600/w=1200"
            },
            "/backyard/guides/thousand-oaks-adu": {
                title: "The Complete Thousand Oaks ADU Requirements Guide — Samara",
                description: "Learn the key ADU regulations in Thousand Oaks, including size, zoning, and parking requirements—plus how Samara can help you navigate the process.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 12,
                share_sheet_image_id: "8d84cf08-0d95-4a91-6bae-4f9d09343300",
                og_image: "https://www.samara.com/assets/remote/8d84cf08-0d95-4a91-6bae-4f9d09343300/w=1200"
            },
            "/backyard/guides/adu-in-los-gatos": {
                title: "The Complete Los Gatos ADU Requirements Guide — Samara",
                description: "A complete and current guide to ADU rules in Los Gatos, including size, height, setbacks, parking, design, and how many units you can build.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 11,
                share_sheet_image_id: "bb576003-2447-4d91-5083-33e0005e6200",
                og_image: "https://www.samara.com/assets/remote/bb576003-2447-4d91-5083-33e0005e6200/w=1200"
            },
            "/backyard/guides/ventura-county-adu": {
                title: "The Complete Ventura County ADU Requirements Guide — Samara",
                description: "Learn the key ADU regulations in Ventura County, including size, zoning, and permitting requirements—plus how Samara can help you navigate the process.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 10,
                share_sheet_image_id: "f6c5177d-90d6-4926-3942-7b0d63e67d00",
                og_image: "https://www.samara.com/assets/remote/f6c5177d-90d6-4926-3942-7b0d63e67d00/w=1200"
            },
            "/backyard/guides/orange-county-adu": {
                title: "The Complete Orange County ADU Requirements Guide — Samara",
                description: "A practical guide to ADU requirements in Orange County, including size limits, zoning rules, and how to navigate the permitting process with Samara.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 9,
                share_sheet_image_id: "ce2295aa-0c92-4ad2-d202-a7a422d77a00",
                og_image: "https://www.samara.com/assets/remote/ce2295aa-0c92-4ad2-d202-a7a422d77a00/w=1200"
            },
            "/backyard/guides/palo-alto-adu": {
                title: "The Complete Palo Alto ADU Requirements Guide — Samara",
                description: "A clear overview of Palo Alto ADU rules, from zoning and size limits to design and parking requirements, plus how to get started with Samara.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 8,
                share_sheet_image_id: "76faf420-49ce-4e54-247c-bd89dea3b400",
                og_image: "https://www.samara.com/assets/remote/76faf420-49ce-4e54-247c-bd89dea3b400/w=1200"
            },
            "/backyard/guides/marin-county-adu": {
                title: "The Complete Marin County ADU Requirements Guide — Samara",
                description: "Learn about Marin County ADU regulations so that your journey from proposal to permit is as smooth and efficient as possible.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 7,
                share_sheet_image_id: "0c59cc9e-11d0-4b8f-39d8-5f6192a73100",
                og_image: "https://www.samara.com/assets/remote/0c59cc9e-11d0-4b8f-39d8-5f6192a73100/w=1200"
            },
            "/backyard/guides/cupertino-adu": {
                title: "The Complete Cupertino ADU Requirements Guide — Samara",
                description: "Learn Cupertino’s ADU regulations and permitting process, including size limits and zoning rules, in our streamlined requirements guide.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 6,
                share_sheet_image_id: "cb164fb1-4e71-4396-95f8-2c7154f06600",
                og_image: "https://www.samara.com/assets/remote/cb164fb1-4e71-4396-95f8-2c7154f06600/w=1200"
            },
            "/backyard/guides/santa-rosa-adu": {
                title: "The Complete Santa Rosa ADU Requirements Guide — Samara",
                description: "Learn all about Santa Rosa ADU rules and regulations so you can make your journey from proposal to permit as smooth as possible. ",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 5,
                share_sheet_image_id: "92a57b28-5ad7-43f9-d3e9-e0da4556e800",
                og_image: "https://www.samara.com/assets/remote/92a57b28-5ad7-43f9-d3e9-e0da4556e800/w=1200"
            },
            "/backyard/guides/san-mateo-adu": {
                title: "The Complete San Mateo ADU Requirements Guide — Samara",
                description: "Learn about San Mateo’s ADU standards so your ADU building process is as simple and straightforward as possible. ",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 4,
                share_sheet_image_id: "ddbedbdf-2363-49a4-d87f-a7a74b34a600",
                og_image: "https://www.samara.com/assets/remote/ddbedbdf-2363-49a4-d87f-a7a74b34a600/w=1200"
            },
            "/backyard/guides/santa-barbara-adu": {
                title: "The Complete Santa Barbara ADU Requirements Guide — Samara",
                description: "Learn all about Santa Barbara ADU regulations so you can make your journey from proposal to permit as smooth as possible. ",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 3,
                share_sheet_image_id: "a91f5a15-11dc-4fca-54d1-b267f20ca900",
                og_image: "https://www.samara.com/assets/remote/a91f5a15-11dc-4fca-54d1-b267f20ca900/w=1200"
            },
            "/backyard/guides/santa-clara-adu": {
                title: "The Complete Santa Clara ADU Requirements Guide — Samara",
                description: "Learn the regulations and requirements for building an ADU in Santa Clara, California, and how to get started with Samara. ",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 2,
                share_sheet_image_id: "d8684a7b-a3a3-4420-87de-28a30b633100",
                og_image: "https://www.samara.com/assets/remote/d8684a7b-a3a3-4420-87de-28a30b633100/w=1200"
            },
            "/backyard/guides/santa-cruz-adu": {
                title: "The Complete Santa Cruz ADU Requirements Guide — Samara",
                description: "Learn the basic regulations and requirements for building an ADU in the city of Santa Cruz and how to get started with Samara.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 1,
                share_sheet_image_id: "a0bb7522-be2c-4a34-a03a-224b8502ba00",
                og_image: "https://www.samara.com/assets/remote/a0bb7522-be2c-4a34-a03a-224b8502ba00/w=1200"
            },
            "/backyard/guides/carlsbad-adu": {
                title: "The Complete Carlsbad ADU Requirements Guide — Samara",
                description: "Discover everything you need to know about Carlsbad ADU regulations and how to make the process smooth and straightforward with Samara. ",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: 0,
                share_sheet_image_id: "60821965-4392-499c-182a-d171f978f300",
                og_image: "https://www.samara.com/assets/remote/60821965-4392-499c-182a-d171f978f300/w=1200"
            },
            "/backyard/guides/walnut-creek-adu": {
                title: "The Complete Walnut Creek ADU Requirements Guide — Samara",
                description: "Learn the ins and outs of Walnut Creek’s ADU regulations so your building process is as smooth and streamlined as possible.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: -1,
                share_sheet_image_id: "3b6dd46e-e4d9-422e-86d0-cc282266cc00",
                og_image: "https://www.samara.com/assets/remote/3b6dd46e-e4d9-422e-86d0-cc282266cc00/w=1200"
            },
            "/backyard/guides/alameda-adu": {
                title: "The Complete Alameda ADU Requirements Guide — Samara",
                description: "An up-to-date overview of Alameda’s ADU rules, including limits on size, height, setbacks, zoning, parking, and how many units are allowed.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: -2,
                share_sheet_image_id: "e2ac5ebf-540a-4827-274c-cfe85a0f6f00",
                og_image: "https://www.samara.com/assets/remote/e2ac5ebf-540a-4827-274c-cfe85a0f6f00/w=1200"
            },
            "/backyard/guides/adu-builder-fremont": {
                title: "The Complete Fremont ADU Requirements Guide — Samara",
                description: "Detailed ADU guidelines for Fremont homeowners, including what’s allowed by state law, how local permitting works, and how many units you can build per lot.",
                class_names: "backyard insights insights-post",
                theme_color: "#000000",
                navigation_inverted: !1,
                partial_name: "partials/pages/insights/post",
                position: -3,
                share_sheet_image_id: "079a0bdd-8cb2-4661-ea82-21be8825d900",
                og_image: "https://www.samara.com/assets/remote/079a0bdd-8cb2-4661-ea82-21be8825d900/w=1200"
            },
            "/": {
                title: "Samara - Backyard Homes and ADUs",
                description: "Discover Samara's Backyard homes and ADUs. Elevated design, expertly crafted. Fast and easy installation. Solar-powered and future-ready.",
                class_names: "backyard",
                theme_color: "#000000",
                navigation_inverted: !0,
                position: 28,
                partial_name: "partials/pages/backyard/backyard",
                share_sheet_image_id: "4422b17d-6e18-4bbb-6e87-102fb9821c00",
                og_image: "https://www.samara.com/assets/remote/4422b17d-6e18-4bbb-6e87-102fb9821c00/w=1200"
            },
            "/backyard": {
                title: "Samara - Backyard Homes and ADUs",
                description: "Discover Samara's Backyard homes and ADUs. Elevated design, expertly crafted. Fast and easy installation. Solar-powered and future-ready.",
                class_names: "backyard",
                theme_color: "#000000",
                navigation_inverted: !0,
                position: 27,
                partial_name: "partials/pages/backyard/backyard",
                share_sheet_image_id: "dee522f0-e339-4516-1e61-0cb9fb83b300",
                og_image: "https://www.samara.com/assets/remote/dee522f0-e339-4516-1e61-0cb9fb83b300/w=1200"
            },
            "/backyard/models": {
                title: "Backyard - ADU Models - Samara",
                description: "Explore the full lineup of Samara's Backyard ADU models, including studio, one bedroom, and two bedroom layouts ranging from 420 to 950 square feet.",
                class_names: "backyard backyard-models backyard-models-index",
                theme_color: "#000000",
                navigation_inverted: !0,
                position: 26,
                partial_name: "partials/pages/backyard/models",
                share_sheet_image_id: "28663ada-d1e4-451f-90af-131a0b1e1700",
                og_image: "https://www.samara.com/assets/remote/28663ada-d1e4-451f-90af-131a0b1e1700/w=1200"
            },
            "/backyard/how-it-works": {
                title: "Backyard – How It Works – Samara",
                description: "Learn how easy it is to install an accessory dwelling unit from Samara. From configuration to completion in as few as seven months.",
                class_names: "backyard how-it-works",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 25,
                partial_name: "partials/pages/backyard/how-it-works",
                share_sheet_image_id: "26440ce7-ba39-472d-0fec-c1d99823a500",
                og_image: "https://www.samara.com/assets/remote/26440ce7-ba39-472d-0fec-c1d99823a500/w=1200"
            },
            "/backyard/financing": {
                title: "ADU Financing in California - Samara",
                description: "Explore tailored ADU financing options in California with Samara, offering affordable, efficient solutions to help you finance your backyard home.",
                class_names: "backyard financing",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 24,
                partial_name: "partials/pages/financing",
                share_sheet_image_id: null,
                og_image: "https://www.samara.com/assets/images/banner.png"
            },
            "/backyard/faq": {
                title: "Backyard – Frequently Asked Questions – Samara",
                description: "Find answers to the most asked questions about Backyard: building regulations, financial planning, construction, and more.",
                class_names: "backyard faq",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 23,
                partial_name: "partials/pages/backyard/faq",
                share_sheet_image_id: "525b3d2c-6270-4ef5-d824-ecd2f4edd000",
                og_image: "https://www.samara.com/assets/remote/525b3d2c-6270-4ef5-d824-ecd2f4edd000/w=1200"
            },
            "/backyard/studio": {
                title: "Backyard Studio - Prefab Studio ADU - Samara",
                description: "Samara's prefab studio ADU is a small but mighty 420 sq. ft., featuring high cathedral ceilings, clever storage, and a fully-equipped kitchen designed for comfort and style. ",
                class_names: "backyard backyard-models backyard-models-studio",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 22,
                partial_name: "partials/pages/backyard/models/studio",
                share_sheet_image_id: "b60fe753-3258-4d18-aebf-200d8305f300",
                og_image: "https://www.samara.com/assets/remote/b60fe753-3258-4d18-aebf-200d8305f300/w=1200"
            },
            "/backyard/one-bedroom": {
                title: "Backyard One Bedroom - 1 Bedroom ADU - Samara",
                description: "Samara’s 1 bedroom ADU features a spacious bathroom, ample storage, and a next-gen electric kitchen. It's the perfect blend of style and functionality in 540 square feet.",
                class_names: "backyard backyard-models backyard-models-onebed",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 21,
                partial_name: "partials/pages/backyard/models/onebed",
                share_sheet_image_id: "f30ce6f7-e670-4bf3-82cc-d33910a66a00",
                og_image: "https://www.samara.com/assets/remote/f30ce6f7-e670-4bf3-82cc-d33910a66a00/w=1200"
            },
            "/backyard/two-bedroom": {
                title: "Backyard Two Bedroom - 2 Bedroom ADU - Samara",
                description: "Samara's 2 bedroom ADU offers 690 sq. ft. of flexible living space perfect for hosting guests, working from home, or generating rental income. Call it the ultimate flex.",
                class_names: "backyard backyard-models backyard-models-twobed",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 20,
                partial_name: "partials/pages/backyard/models/twobed",
                share_sheet_image_id: "13bf7b1a-901d-432f-bc02-e9978ee59500",
                og_image: "https://www.samara.com/assets/remote/13bf7b1a-901d-432f-bc02-e9978ee59500/w=1200"
            },
            "/backyard/xl-8": {
                title: "Backyard XL 8 - 800 sq. ft. ADU - Samara",
                description: "Learn more about Backyard XL 8, Samara’s 800 sq. ft. ADU featuring two bedrooms and two baths, larger appliances, and plenty of storage. Perfect for whatever use you can dream up.",
                class_names: "backyard backyard-models backyard-models-xl",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 19,
                partial_name: "partials/pages/backyard/models/xl-8",
                share_sheet_image_id: "b9f187b1-bc1b-42f7-9973-e781d980ac00",
                og_image: "https://www.samara.com/assets/remote/b9f187b1-bc1b-42f7-9973-e781d980ac00/w=1200"
            },
            "/backyard/xl-10": {
                title: "Backyard XL 10 - 2 Bedroom, 2 Bath ADU - Samara",
                description: "Backyard XL 10 is Samara’s spacious 2 bedroom, 2 bath ADU with an upsized kitchen and living room and 950 sq. ft. of flexible space.",
                class_names: "backyard backyard-models backyard-models-xl-10",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 18,
                partial_name: "partials/pages/backyard/models/xl-10",
                share_sheet_image_id: "b851ca06-c7b5-4c2a-e2da-68d097780f00",
                og_image: "https://www.samara.com/assets/remote/b851ca06-c7b5-4c2a-e2da-68d097780f00/w=1200"
            },
            "/backyard/compare": {
                title: "Compare Backyard Models – Samara",
                description: "Compare the full lineup of Samara's Backyard ADU models, including studio, one bedroom, and two bedroom layouts ranging from 420 to 950 square feet.",
                class_names: "backyard backyard-compare",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 17,
                partial_name: "partials/pages/backyard/compare",
                share_sheet_image_id: null,
                og_image: "https://www.samara.com/assets/images/banner.png"
            },
            "/backyard/configure": {
                title: "Customize Backyard – Samara",
                description: "Customize and get a quote for Samara's Backyard ADU. Elevated design, expertly crafted. Fast and easy installation. Solar-powered and future-ready.",
                class_names: "backyard configurator",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 16,
                partial_name: "partials/pages/backyard/configure",
                share_sheet_image_id: "a02d2050-630d-403d-d386-ccb3506c2300",
                og_image: "https://www.samara.com/assets/remote/a02d2050-630d-403d-d386-ccb3506c2300/w=1200"
            },
            "/backyard/guides": {
                title: "California ADU Requirement Guides – Samara",
                description: "You’ll need a permit from your local planning department to build an ADU. Learn about the rules and regulations governing ADU construction across California and see what's required in your area.",
                class_names: "",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 15,
                partial_name: "partials/pages/insights/guides",
                share_sheet_image_id: null,
                og_image: "https://www.samara.com/assets/images/banner.png"
            },
            "/news": {
                title: "News – Samara",
                description: "Read the latest news about Samara.",
                class_names: "newsroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 14,
                partial_name: "partials/pages/newsroom/newsroom",
                share_sheet_image_id: "7fd49401-f728-4c12-0229-3fe7abf62900",
                og_image: "https://www.samara.com/assets/remote/7fd49401-f728-4c12-0229-3fe7abf62900/w=1200"
            },
            "/insights": {
                title: "Insights — Samara",
                description: "",
                class_names: "backyard insights insights-index",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 13,
                partial_name: "partials/pages/insights/index",
                share_sheet_image_id: null,
                og_image: "https://www.samara.com/assets/images/banner.png"
            },
            "/insights/life-with-backyard-meet-the-kurodas": {
                title: "Life with Backyard: Meet the Kurodas - Samara",
                description: "The Kurodas give us a tour of their cozy Backyard, built to help them stay close to family.",
                class_names: "backyard insights insights-story",
                theme_color: "#000000",
                navigation_inverted: !0,
                position: 12,
                partial_name: "partials/pages/insights",
                share_sheet_image_id: "4fc66bdc-2449-4d2d-d7f5-1dc35f7fd400",
                og_image: "https://www.samara.com/assets/remote/4fc66bdc-2449-4d2d-d7f5-1dc35f7fd400/w=1200"
            },
            "/jobs": {
                title: "Jobs – Samara",
                description: "Join Samara to help create new ways of living that help people dream bigger.",
                class_names: "jobs",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 11,
                partial_name: "partials/pages/jobs/jobs",
                share_sheet_image_id: "69bca2cb-e628-48ad-c8fc-ebd743b2c700",
                og_image: "https://www.samara.com/assets/images/jobs/jobs.png"
            },
            "/showrooms": {
                title: "Showrooms – Samara",
                description: "Tour Backyard in person at an our San Francisco Bay Area and Los Angeles showrooms. Learn more about our locations and book a private tour.",
                class_names: "backyard showroom",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 10,
                partial_name: "partials/pages/showroom/showroom",
                share_sheet_image_id: "7f28da8b-6ec2-423a-f3a8-8a5e7ffa4500",
                og_image: "https://www.samara.com/assets/remote/7f28da8b-6ec2-423a-f3a8-8a5e7ffa4500/w=1200"
            },
            "/showrooms/redwood-city": {
                title: "Redwood City Showroom – Samara",
                description: "Tour Backyard in person at Samara Redwood City. Find our hours and learn how to book a private tour.",
                class_names: "backyard showroom tour",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 9,
                partial_name: "partials/pages/showroom/redwood-city",
                share_sheet_image_id: "8e379157-712c-4bea-a50a-38c36767db00",
                og_image: "https://www.samara.com/assets/remote/8e379157-712c-4bea-a50a-38c36767db00/w=1200"
            },
            "/showrooms/redwood-city/visit": {
                title: "Schedule Your Showroom Visit – Samara",
                description: "Tour Backyard in person at Samara Redwood City. Find our hours and learn how to book a private tour.",
                class_names: "backyard showroom tour",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 8,
                partial_name: "partials/pages/showroom/visit",
                share_sheet_image_id: "6b07701e-267e-4d6f-b0ea-a32fd8c27a00",
                og_image: "https://www.samara.com/assets/remote/6b07701e-267e-4d6f-b0ea-a32fd8c27a00/w=1200"
            },
            "/showrooms/thousand-oaks": {
                title: "Thousand Oaks Pop-up Showroom – Samara",
                description: "Tour Backyard in person at Samara Thousand Oaks. Find our hours and learn how to book a private tour.",
                class_names: "backyard showroom tour",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 7,
                partial_name: "partials/pages/showroom/thousand-oaks",
                share_sheet_image_id: "00cc326f-f637-4227-f98d-dff49167c900",
                og_image: "https://www.samara.com/assets/remote/00cc326f-f637-4227-f98d-dff49167c900/w=1200"
            },
            "/showrooms/thousand-oaks/visit": {
                title: "Schedule Your Showroom Visit – Samara",
                description: "",
                class_names: "",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 6,
                partial_name: "partials/pages/showroom/visit",
                share_sheet_image_id: null,
                og_image: "https://www.samara.com/assets/images/banner.png"
            },
            "/developers": {
                title: "Samara for Developers",
                description: "Unlock the potential of your parcel with Backyard Multiunit.",
                class_names: "multiunit backyard",
                theme_color: "#000000",
                navigation_inverted: !0,
                position: 5,
                partial_name: "partials/pages/multiunit",
                share_sheet_image_id: "a6119568-ae31-44e7-e7a6-ad201ad8a500",
                og_image: "https://www.samara.com/assets/remote/a6119568-ae31-44e7-e7a6-ad201ad8a500/w=1200"
            },
            "/yoshino": {
                title: "Yoshino – Samara",
                description: "",
                class_names: "yoshino",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 4,
                partial_name: "partials/pages/yoshino",
                share_sheet_image_id: "c0af00a8-c2aa-41a5-8568-e8167fc15800",
                og_image: "https://www.samara.com/assets/remote/c0af00a8-c2aa-41a5-8568-e8167fc15800/w=1200"
            },
            "/terms-of-service": {
                title: "Terms of Service – Samara",
                description: "",
                class_names: "legal",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 3,
                partial_name: "partials/pages/terms-of-service",
                share_sheet_image_id: "834edb4b-cd31-423c-4ed3-1accf2066200",
                og_image: "https://www.samara.com/assets/remote/834edb4b-cd31-423c-4ed3-1accf2066200/w=1200"
            },
            "/privacy-policy": {
                title: "Privacy Policy – Samara",
                description: null,
                class_names: "legal",
                theme_color: "#000000",
                navigation_inverted: !1,
                position: 2,
                partial_name: "partials/pages/privacy-policy",
                share_sheet_image_id: "94f4f098-aa84-4d11-1b87-65836380a800",
                og_image: "https://www.samara.com/assets/remote/94f4f098-aa84-4d11-1b87-65836380a800/w=1200"
            },
            "/la-fires": {
                title: "Support for Homeowners in Fire-Affected Southern California Communities – Samara",
                description: "Following the devastating fires across Los Angeles and Ventura counties, we're making our ADUs more accessible to homeowners in Los Angeles, Ventura, San Bernardino, Orange, Riverside, and San Diego counties through community recovery pricing. Learn about support options and timing.",
                class_names: "socal-wildfires",
                theme_color: "#000000",
                navigation_inverted: !0,
                position: 1,
                partial_name: "partials/pages/socal-wildfires",
                share_sheet_image_id: null,
                og_image: "https://www.samara.com/assets/images/banner.png"
            }
        },
        t = {},
        n = document.querySelector("main .page"),
        i = document.querySelector("meta[name=theme-color]"),
        r = document.querySelector("nav"),
        a = document.querySelector("main");
    let s, o, l = [],
        c = !1;

    function h(e, t) {
        window.dispatchEvent(new CustomEvent(e, {
            detail: t
        }))
    }

    function u(e = null) {
        let t = e || location.pathname;
        return t = t.split("#")[0], t.length > 1 && t.endsWith("/") && (t = t.slice(0, t.length - 1)), "/" === t ? "/backyard" : t.startsWith("/backyard/configure") ? "/backyard/configure" : t
    }

    function d() {
        let t = e[u()];
        if (void 0 !== t) {
            null !== i && i.setAttribute("content", t.theme_color);
            const e = t.class_names.split(" ").filter((e => e.length > 0));
            e.length > 0 && document.body.classList.add(...e), null !== r && r.classList.toggle("inverted", t.navigation_inverted);
            const n = document.querySelector("meta[property='og:title']"),
                a = document.querySelector("meta[property='og:description']"),
                s = document.querySelector("meta[property='og:image']"),
                o = document.querySelector("meta[property='og:url']"),
                l = document.querySelector("meta[name='twitter:title']"),
                c = document.querySelector("meta[name='twitter:description']"),
                h = document.querySelector("meta[name='twitter:image']"),
                d = document.querySelector("meta[name='description']");
            void 0 !== t.title && (document.title = t.title, null !== n && n.setAttribute("content", t.title), null !== l && l.setAttribute("content", t.title)), void 0 !== t.description && (null !== d && d.setAttribute("content", t.description), null !== a && a.setAttribute("content", t.description), null !== c && c.setAttribute("content", t.description)), void 0 !== t.og_image && (null !== s && s.setAttribute("content", t.og_image), null !== h && h.setAttribute("content", t.og_image)), null !== o && o.setAttribute("content", "https://www.samara.com" + u())
        }
        s = u()
    }
    async function p(i, m = !0, f = !0) {
        const g = e[u(i)];
        if (c) return void(l = [i, m]);
        if (m && (i === location.pathname || "/" === i && "/backyard" === location.pathname || "/backyard" === i && "/" === location.pathname)) return h("router:scroll-top", {
            url: i
        }), void window.scrollTo({
            top: 0,
            behavior: "smooth"
        });
        clearTimeout(o), c = !0, a.classList.add("segue");
        const _ = function(t) {
            return (e[u(location.pathname)]?.position || 0) < (e[u(t)]?.position || 0) ? -1 : 1
        }(i);
        h("router:will-change-url", {
            url: i
        }), "/backyard/models" === location.pathname && setTimeout((() => {
            r.classList.toggle("inverted", g.navigation_inverted)
        }), 200), f && await

        function(e) {
            return new Promise((t => {
                a.addEventListener("animationend", t, {
                    once: !0
                }), a.classList.add(e < 0 ? "out-pop" : "out")
            }))
        }(_);
        let v = "";
        const y = u(i),
            x = t[y];
        if (x && "pending" !== x) v = x;
        else try {
            const e = await fetch(`${u(i)}.data`);
            v = await e.text(), t[y] = v
        } catch (e) {
            console.error("failed to load page", i)
        }! function() {
            const t = e[s || u()];
            if (void 0 !== t && null !== r) {
                const e = t.class_names.split(" ").filter((e => e.length > 0));
                e.length > 0 && document.body.classList.remove(...e)
            }
        }(), window.scrollTo({
            top: 0
        }), n.innerHTML = v, document.body.dataset.slug = u(i), m && window.history.pushState(null, g, i), d(), h("router:did-update-content", {
            url: i
        }), f && await

        function(e) {
            return new Promise((t => {
                a.classList.remove(e < 0 ? "out-pop" : "out"), a.addEventListener("animationend", (() => {
                    a.classList.remove(e < 0 ? "in-pop" : "in"), t()
                }), {
                    once: !0
                }), a.classList.add(e < 0 ? "in-pop" : "in")
            }))
        }(_), h("router:did-change-url", {
            url: i
        }), c = !1, o = setTimeout((() => {
            a.classList.remove("segue"), document.body.style.backgroundColor = null
        }), 10), l.length > 0 && (setTimeout(p, 0, ...l), l = [])
    }

    function m(e) {
        if (!e) return null;
        let t;
        if ("A" === e.nodeName && (t = e), e.parentElement && ("A" === e.parentElement.nodeName && (t = e.parentElement), "function" == typeof e.closest && (t = e.closest("a"))), null == t) return null;
        const n = t.getAttribute("href");
        return n && n.startsWith("/") && !t.getAttribute("download") && "_blank" !== t.getAttribute("target") ? t : null
    }
    window.openRoute = p, window.addEventListener("click", (function(e) {
        if (e.metaKey) return;
        const t = m(e.target);
        t && (e.preventDefault(), p(t.getAttribute("href")))
    })), window.addEventListener("popstate", (function() {
        p(location.pathname, !1, !1)
    })), window.addEventListener("mousemove", (function(e) {
        const n = m(e.target);
        n && async function(e) {
            const n = u(e);
            if (!t[n]) {
                t[n] = "pending";
                try {
                    const i = await fetch(`${u(e)}.data`);
                    t[n] = await i.text()
                } catch (t) {
                    console.warn("failed to preload page", e)
                }
            }
        }(n.getAttribute("href"))
    })), window.addEventListener("router:will-change-url", (function() {
        document.body.classList.add("segue")
    })), window.addEventListener("router:did-change-url", (function() {
        document.body.classList.remove("segue")
    })), d()
})), document.addEventListener("DOMContentLoaded", (function() {
    window.Tooltip = function() {
        const e = 1,
            t = 2e3,
            n = document.getElementById("tooltip"),
            i = n.querySelector("span");
        let r, a = !1,
            s = !1,
            o = {
                x: 0,
                y: 0
            },
            l = {
                x: 0,
                y: 0
            },
            c = !1;

        function h() {
            n.classList.add("dismissed")
        }

        function u() {
            document.querySelectorAll("*[data-tooltip]").forEach((e => {
                e.removeAttribute("data-tooltip"), e.addEventListener("mousemove", (function(t) {
                    const n = t.clientX < .5 * window.innerWidth;
                    return n && 0 === e.scrollLeft ? (e.style.cursor = null, void f()) : n || e.scrollLeft !== e.scrollWidth - e.clientWidth ? (p(n ? "arrow-left" : "arrow-right", "", l.x, l.y), void(e.style.cursor = "pointer")) : (e.style.cursor = null, void f())
                })), e.addEventListener("mouseleave", (function() {
                    e.style.cursor = null, f()
                }))
            }))
        }

        function d() {
            document.querySelectorAll("*[data-tooltip-disabled]").forEach((e => {
                e.removeAttribute("data-tooltip-disabled"), e.addEventListener("mouseenter", (function() {
                    s = !0, f()
                })), e.addEventListener("mouseleave", (function() {
                    s = !1
                }))
            }))
        }

        function p(e, c, u, d) {
            window.innerWidth < 768 || !1 !== document.hasFocus() && (s || (clearTimeout(r), r = setTimeout(h, t), n.classList.remove("dismissed"), void 0 !== u && void 0 !== d && (o = {
                x: u,
                y: d
            }, l = {
                x: u,
                y: d
            }, g()), a = !0, n.className = "visible", n.classList.add(e), n.classList.toggle("tooltip-no-text", 0 === c.length), i.innerHTML = c))
        }

        function m(e, i) {
            clearTimeout(r), r = setTimeout(h, t), n.classList.remove("dismissed"), l = {
                x: e,
                y: i
            }, c || requestAnimationFrame(g)
        }

        function f() {
            a && (n.classList.remove("visible"), a = !1)
        }

        function g() {
            0 === o.x && (o = l), o.x = o.x + (l.x - o.x) * e, o.y = o.y + (l.y - o.y) * e, n.style.transform = `translate3d(${o.x.toFixed(2)}px,${o.y.toFixed(2)}px,0.0)`, c = Math.abs(o.x - l.x) > .1 || Math.abs(o.y - l.y) > .1, c && requestAnimationFrame(g)
        }
        return document.documentElement.addEventListener("mouseleave", (function() {
            f()
        })), window.addEventListener("mousemove", (function(e) {
            m(e.clientX, e.clientY)
        })), window.addEventListener("router:did-update-content", d), window.addEventListener("router:did-update-content", u), window.addEventListener("scroll", (function() {
            f()
        })), d(), u(), {
            show: p,
            move: m,
            hide: f
        }
    }()
})), (() => {
    const e = 2e3;

    function t(t, n, i) {
        const r = document.createElement("div");
        r.className = "video-modal-controls";
        const a = document.createElement("button");
        a.className = "video-modal-controls-close", a.innerHTML = "<img src='/assets/images/backyard/xmark-white.svg' width='24' height='24' />";
        const s = document.createElement("input");
        let o;
        s.className = "video-modal-controls-scrubber", s.type = "range", s.min = "0.0", s.max = "1.0", s.step = "0.001";
        let l = !1,
            c = !1,
            h = null;

        function u() {
            if (t.readyState >= t.HAVE_METADATA) {
                const e = t.duration;
                e > 0 && isFinite(e) ? s.value = (t.currentTime / e).toString() : s.value = "0"
            } else s.value = "0"
        }

        function d() {
            r.classList.add("video-modal-controls-visible"), h && clearTimeout(h), h = setTimeout((() => {
                !0 !== l && !0 !== t.paused && r.classList.remove("video-modal-controls-visible")
            }), e)
        }

        function p() {
            return !0 === t.paused ? {
                text: "Play",
                icon: "play"
            } : {
                text: "Pause",
                icon: "pause"
            }
        }

        function m(e) {
            if (e.touches && e.touches.length > 0) {
                return e.touches[0].clientX - e.target.getBoundingClientRect().left
            }
            return e.offsetX
        }

        function f(e) {
            return Math.min(Math.max((n = e, i = 7.5, r = s.clientWidth - 7.5, (a = 0) + (n - i) / (r - i) * (.999 - a)), 0), .999) * t.duration;
            var n, i, r, a
        }

        function g(e) {
            e.target === r && (!0 === t.paused ? t.play() : t.pause(), d())
        }

        function _() {
            l = !0, c = !1 === t.paused, t.pause(), d()
        }

        function v(e) {
            const n = f(m(e));
            if (!1 === isNaN(n) && (t.currentTime = n), l = !1, !0 === c) {
                function i() {
                    t.play()
                }!0 === t.seeking ? t.addEventListener("seeked", i, {
                    once: !0
                }) : i()
            }
            d()
        }

        function y(e) {
            e.stopPropagation();
            const n = f(m(e));
            Tooltip.show("mono-nums", function(e) {
                const t = Math.floor(e / 60),
                    n = Math.floor(e % 60);
                return `${t}:${n<10?"0"+n:n}`
            }(n), e.clientX, e.clientY), !0 === l && (t.currentTime = n), d()
        }

        function x(e) {
            const {
                icon: t,
                text: n
            } = p();
            Tooltip.show(t, n, e.clientX, e.clientY), d()
        }

        function b(e) {
            !0 !== l && !0 !== t.paused && (r.classList.remove("video-modal-controls-visible"), null !== h && (clearTimeout(h), h = null))
        }

        function w(e) {
            if (!0 === l) return;
            const {
                icon: t,
                text: n
            } = p();
            Tooltip.show(t, n)
        }

        function S(e) {
            !1 !== r.classList.contains("video-modal-controls-visible") && (e.stopPropagation(), Tooltip.show("xmark", "Close", e.clientX, e.clientY))
        }

        function M(e) {
            e.stopPropagation(), i()
        }
        return r.addEventListener("mousemove", x), r.addEventListener("mouseleave", b), r.addEventListener("click", g), a.addEventListener("mousemove", S), a.addEventListener("click", M), s.addEventListener("mousedown", _), s.addEventListener("touchstart", _), s.addEventListener("mouseup", v), s.addEventListener("touchend", v), s.addEventListener("mousemove", y), s.addEventListener("touchmove", y), t.addEventListener("pause", w), t.addEventListener("play", w), t.addEventListener("loadedmetadata", u), r.appendChild(a), r.appendChild(s), n.appendChild(r), u(),
            function e() {
                const n = t.duration;
                n > 0 && isFinite(n) && (s.value = (t.currentTime / n).toString()), o = requestAnimationFrame(e)
            }(),
            function() {
                r.removeEventListener("mousemove", x), r.removeEventListener("mouseleave", b), r.removeEventListener("click", g), a.removeEventListener("mousemove", S), a.removeEventListener("click", M), s.removeEventListener("mousedown", _), s.removeEventListener("touchstart", _), s.removeEventListener("mouseup", v), s.removeEventListener("touchend", v), s.removeEventListener("mousemove", y), s.removeEventListener("touchmove", y), t.removeEventListener("pause", w), t.removeEventListener("play", w), t.removeEventListener("loadedmetadata", u), Tooltip.hide(), cancelAnimationFrame(o), null !== h && (clearTimeout(h), h = null)
            }
    }
    window.Video = {
        present(e) {
            Tooltip.hide(),
                function(e) {
                    if (console.assert("VIDEO" === e.nodeName, "sourceElement has to be video element"), void 0 !== e.dataset.isPresented) return;
                    e.dataset.isPresented = !0;
                    const n = e.parentElement,
                        i = e.getBoundingClientRect(),
                        r = document.createElement("div");
                    r.className = "video-modal";
                    const a = document.createElement("div");
                    a.className = "video-modal-container";
                    const s = t(e, a, c);
                    a.appendChild(e), r.appendChild(a), document.body.appendChild(r);
                    const o = l(i, a);

                    function l(e, t) {
                        const n = e.width / t.clientWidth;
                        return `translate3d(${e.left+.5*e.width-.5*window.innerWidth}px, ${e.top+.5*e.height-.5*window.innerHeight}px, 0) scale(${n})`
                    }

                    function c() {
                        e.pause(), Tooltip.hide(), s(), r.classList.add("video-modal-dismissing");
                        const t = l(n.getBoundingClientRect(), a);
                        a.style.transform = t, window.removeEventListener("keydown", h), r.removeEventListener("click", u), r.removeEventListener("mousemove", d);
                        const i = 1e3 * parseFloat(getComputedStyle(a).transitionDuration);
                        setTimeout((() => {
                            delete e.dataset.isPresented, e.play(), n.appendChild(e), setTimeout((() => {
                                document.body.removeChild(r)
                            }), 0)
                        }), 1.1 * i)
                    }

                    function h(t) {
                        switch (t.key) {
                            case "Escape":
                                c();
                                break;
                            case " ":
                                !0 === e.paused ? e.play() : e.pause()
                        }
                    }

                    function u(e) {
                        e.stopPropagation(), e.target === r && c()
                    }

                    function d(e) {
                        e.target === r && Tooltip.show("xmark", "Close", e.clientX, e.clientY)
                    }
                    a.style.transition = "none", a.style.transform = o, setTimeout((() => {
                        a.style.transition = null, a.style.transform = null
                    }), 0), window.addEventListener("keydown", h), r.addEventListener("click", u), r.addEventListener("mousemove", d), r.addEventListener("touchend", u), r.addEventListener("touchmove", d)
                }(e.target)
        }
    }
})(), window.Backyard = window.Backyard || {}, Backyard.createALotCanHappenCards = function() {
    const e = document.querySelector(".a-lot-can-happen-cards .infinite-slideshow");
    if (null === e) return () => {};
    const t = document.querySelector(".a-lot-can-happen-cards-label");
    let n, i;

    function r() {
        const n = e.querySelector(".current img");
        n && (t.classList.add("change"), setTimeout((() => {
            t.innerText = n.getAttribute("alt"), t.classList.remove("change")
        }), 200))
    }

    function a() {
        e.dispatchEvent(new CustomEvent("jump", {
            detail: {
                direction: 1
            }
        }))
    }

    function s() {
        clearTimeout(i), i = setTimeout(a, 4e3)
    }

    function o() {
        s()
    }
    return s(), e.addEventListener("change", (function() {
            t.classList.add("change"), clearTimeout(n), n = setTimeout(r, 200)
        })), e.addEventListener("scroll", (function() {
            s()
        })), e.addEventListener("click", (function(t) {
            const n = e.getBoundingClientRect(),
                i = t.clientX < n.x + .5 * n.width;
            e.dispatchEvent(new CustomEvent("jump", {
                detail: {
                    direction: i ? -1 : 1
                }
            }))
        })), document.addEventListener("visibilitychange", o),
        function() {
            clearTimeout(i), document.removeEventListener("visibilitychange", o)
        }
}, window.Backyard = window.Backyard || {}, Backyard.createBentoCardDetails = function() {
    return document.querySelectorAll(".bento-details-card").forEach((function(e) {
            const t = e.querySelector("input");
            null !== e && null !== t && (e.addEventListener("click", (function(e) {
                "INPUT" !== e.target.nodeName && (e.stopPropagation(), e.preventDefault(), t.click())
            })), t.addEventListener("change", (function(t) {
                const n = t.target.checked,
                    i = e.querySelector("ul");
                if (null !== i)
                    if (n) {
                        i.style.transition = "none", i.style.maxHeight = "unset", i.style.opacity = 0;
                        const e = i.clientHeight;
                        i.style.transition = null, i.style.maxHeight = null, setTimeout((() => {
                            i.style.maxHeight = e + "px", i.style.opacity = 1
                        }), 0)
                    } else i.style.maxHeight = null, i.style.opacity = null
            })))
        })),
        function() {}
}, window.Backyard = window.Backyard || {}, Backyard.createBirds = function() {
    const e = document.querySelector(".xl-10-birds");
    let t, n, i, r, a, s = !1,
        o = !0,
        l = [],
        c = [];

    function h() {
        s = !0, a = void 0, r = void 0, n = void 0, cancelAnimationFrame(t), window.removeEventListener("resize", f), window.removeEventListener("scroll", m)
    }
    if (null === e) return h;

    function u() {
        function e() {
            const e = this;

            function t(t, i, r) {
                e.vertices.push(new n.Vector3(t, i, r))
            }

            function i(t, i, r) {
                e.faces.push(new n.Face3(t, i, r))
            }
            n.Geometry.call(this), t(5, 0, 0), t(-5, -2, 1), t(-5, 0, 0), t(-5, -2, -1), t(0, 2, -6), t(0, 2, 6), t(2, 0, 0), t(-3, 0, 0), i(0, 2, 1), i(4, 7, 6), i(5, 6, 7), this.computeCentroids(), this.computeFaceNormals()
        }
        return e.prototype = Object.create(n.Geometry.prototype), new e
    }

    function d() {
        !1 !== o && (t = requestAnimationFrame(d), function() {
            if (!1 === o) return;
            let e = 0;
            for (let t = 0, n = l.length; t < n; t++) {
                const n = c[t];
                n.run(c), n.needsReset && (e += 1);
                const i = l[t];
                i.material.opacity = n.fadeFactor, i.rotation.y = Math.atan2(-n.velocity.z, n.velocity.x), i.rotation.z = Math.asin(n.velocity.y / n.velocity.length()), i.phase = (i.phase + (Math.max(0, i.rotation.z) + .1)) % 62.83, i.geometry.vertices[5].y = i.geometry.vertices[4].y = 5 * Math.sin(i.phase)
            }
            e === c.length && c.forEach((e => {
                e.reset()
            })), a.render(r, i)
        }())
    }
    async function p() {
        try {
            const e = await import("/assets/javascripts/vendor/three.js");
            n = e.default
        } catch (e) {
            return void console.error("failed to release birds", e)
        }
        if (!0 !== s && void 0 !== n) {
            r = new n.Scene;
            for (let t = 0; t < 10; t += 1) {
                const t = new function() {
                    let t, i, r = new n.Vector3,
                        a = 500,
                        s = 500,
                        o = 200,
                        l = .1,
                        c = !1;
                    this.fadeFactor = 0, this.needsReset = !1, this.position = new n.Vector3, this.velocity = new n.Vector3, t = new n.Vector3, this.setGoal = function(e) {
                        i = e
                    }, this.setAvoidWalls = function(e) {
                        c = e
                    }, this.setWorldSize = function(e, t, n) {
                        a = e, s = t, o = n
                    }, this.run = async function(e) {
                        !1 === this.needsReset && (this.needsReset = Math.abs(this.position.y - i.y) < 50), this.fadeFactor < 1 && (this.fadeFactor += .01), c && (r.set(-a, this.position.y, this.position.z), r = this.avoid(r), r.multiplyScalar(5), t.addSelf(r), r.set(a, this.position.y, this.position.z), r = this.avoid(r), r.multiplyScalar(5), t.addSelf(r), r.set(this.position.x, -s, this.position.z), r = this.avoid(r), r.multiplyScalar(5), t.addSelf(r), r.set(this.position.x, s, this.position.z), r = this.avoid(r), r.multiplyScalar(5), t.addSelf(r), r.set(this.position.x, this.position.y, -o), r = this.avoid(r), r.multiplyScalar(5), t.addSelf(r), r.set(this.position.x, this.position.y, o), r = this.avoid(r), r.multiplyScalar(5), t.addSelf(r)), Math.random() > .5 && this.flock(e), this.move()
                    }, this.flock = function(e) {
                        i && t.addSelf(this.reach(i, .005)), t.addSelf(this.alignment(e)), t.addSelf(this.cohesion(e)), t.addSelf(this.separation(e))
                    }, this.move = function() {
                        this.velocity.addSelf(t);
                        let e = this.velocity.length();
                        e > 1 && this.velocity.divideScalar(e / 1), this.position.addSelf(this.velocity), t.set(0, 0, 0)
                    }, this.checkBounds = function() {
                        this.position.x > a && (this.position.x = -a), this.position.x < -a && (this.position.x = a), this.position.y > s && (this.position.y = -s), this.position.y < -s && (this.position.y = s), this.position.z > o && (this.position.z = -o), this.position.z < -o && (this.position.z = o)
                    }, this.avoid = function(e) {
                        let t = new n.Vector3;
                        return t.copy(this.position), t.subSelf(e), t.multiplyScalar(1 / this.position.distanceToSquared(e)), t
                    }, this.repulse = function(e) {
                        let i = this.position.distanceTo(e);
                        if (i < 150) {
                            let r = new n.Vector3;
                            r.sub(this.position, e), r.multiplyScalar(.1 / i), t.addSelf(r)
                        }
                    }, this.reach = function(e, t) {
                        let i = new n.Vector3;
                        return i.sub(e, this.position), i.multiplyScalar(t), i
                    }, this.alignment = function(e) {
                        let t, i = new n.Vector3,
                            r = 0;
                        for (let n = 0, a = e.length; n < a; n++) Math.random() > .3 || (t = e[n], distance = t.position.distanceTo(this.position), distance > 0 && distance <= 50 && (i.addSelf(t.velocity), r++));
                        if (r > 0) {
                            i.divideScalar(r);
                            let e = i.length();
                            e > l && i.divideScalar(e / l)
                        }
                        return i
                    }, this.cohesion = function(e) {
                        let t, i, r = new n.Vector3,
                            a = new n.Vector3,
                            s = 0;
                        for (let n = 0, a = e.length; n < a; n++) Math.random() > .6 || (t = e[n], i = t.position.distanceTo(this.position), i > 0 && i <= 50 && (r.addSelf(t.position), s++));
                        s > 0 && r.divideScalar(s), a.sub(r, this.position);
                        let o = a.length();
                        return o > l && a.divideScalar(o / l), a
                    }, this.separation = function(e) {
                        let t, i, r = new n.Vector3,
                            a = new n.Vector3;
                        for (let n = 0, s = e.length; n < s; n++) Math.random() > .6 || (t = e[n], i = t.position.distanceTo(this.position), i > 0 && i <= 50 && (a.sub(this.position, t.position), a.normalize(), a.divideScalar(i), r.addSelf(a)));
                        return r
                    }, this.reset = function(t) {
                        this.needsReset = !1, this.fadeFactor = 0, this.position.x = (t ? -400 : -e.clientWidth) + -200 * Math.random(), this.position.y = (t ? -150 : -300) + 100 * Math.random(), this.position.z = 200 * Math.random() - 100, this.velocity.x = 2 * Math.random() - 1, this.velocity.y = 2 * Math.random() - 1, this.velocity.z = 2 * Math.random() - 1, this.setWorldSize(e.clientWidth, e.clientHeight, 1e3), this.setGoal(new n.Vector3(2.25 * e.clientHeight, .25 * e.clientWidth + Math.random() * e.clientHeight * .5, -200 * Math.random()))
                    }
                };
                t.reset(!0);
                const i = new n.Mesh(u(), new n.MeshBasicMaterial({
                        color: 0,
                        side: n.DoubleSide
                    })),
                    a = .5 + .05 * Math.random();
                i.scale = new n.Vector3(a, a, a), i.color = (500 - i.position.z) / 1e3, i.phase = Math.floor(62.83 * Math.random()), i.position = t.position, c.push(t), l.push(i), r.add(i)
            }
            i = new n.PerspectiveCamera(75, e.clientWidth / e.clientHeight, 1, 1e4), i.position.z = 450, a = new n.CanvasRenderer, a.setSize(e.clientWidth, e.clientHeight), e.appendChild(a.domElement), window.addEventListener("resize", f), window.addEventListener("scroll", m), f(), m(), d()
        }
    }

    function m() {
        const n = e.getBoundingClientRect(),
            i = n.top >= 0 && n.top <= e.clientHeight || n.bottom >= 0 && n.bottom <= e.clientHeight;
        o !== i && (o = i, o ? d() : cancelAnimationFrame(t))
    }

    function f() {
        i.aspect = e.clientWidth / (.5 * e.clientHeight), i.updateProjectionMatrix(), a.setSize(e.clientWidth, .5 * e.clientHeight)
    }
    return "complete" === document.readyState ? p() : document.addEventListener("readystatechange", (function() {
        "complete" === document.readyState && p()
    })), h
}, createDestroy(/^\/backyard\/compare.*/, (function() {
    const e = "compare:v3",
        t = document.querySelector(".backyard-compare-header"),
        n = Array.from(document.querySelectorAll(".backyard-compare-header select")),
        i = document.querySelectorAll(".backyard-compare-row"),
        r = document.querySelectorAll(".backyard-compare-row tr");
    let a, s;

    function o() {
        return n.slice(0, window.innerWidth < 1024 ? 2 : 3)
    }
    let l = window.innerWidth;

    function c() {
        if (l < 1024 && window.innerWidth >= 1024) {
            const e = o().map((e => e.value));
            e[0] !== e[2] && e[1] !== e[2] || (n[2].value = ["onebed", "twobed", "xl-8", "studio", "xl-10"].find((t => !0 !== e.includes(t)))), h()
        }
        l = window.innerWidth;
        let e = Number.MAX_SAFE_INTEGER;
        a = void 0, i.forEach(((t, n) => {
            if (void 0 !== t.dataset.mayHide) return;
            if (0 === t.clientHeight) return;
            const i = t.getBoundingClientRect().top,
                r = Math.abs(i - .5 * window.innerHeight);
            r < e && (e = r, a = n, s = i)
        })), t.classList.toggle("backyard-compare-header-sticky", 1.5 * t.getBoundingClientRect().height < window.scrollY)
    }

    function h(t) {
        t && t.target && t.target.blur();
        const n = o().map((e => e.value));
        localStorage.setItem(e, JSON.stringify(n)), r.forEach((e => {
                let t = 0;
                e.querySelectorAll("td").forEach((e => {
                    const i = !1 === n.includes(e.dataset.layout);
                    e.hidden = i, !1 === i && e.querySelector(".backyard-compare-text-empty") && (t += 1)
                }));
                const i = t === n.length;
                e.closest("table").classList.toggle("backyard-compare-row-hidden", i);
                const r = e.closest(".backyard-compare-row"),
                    a = r.querySelectorAll("table").length === r.querySelectorAll(".backyard-compare-row-hidden").length;
                r.classList.toggle("backyard-compare-row-hidden", a), n.slice().reverse().forEach((t => {
                    e.insertBefore(e.querySelector(`td[data-layout=${t}]`), e.firstChild)
                }))
            })), document.querySelectorAll(".backyard-compare-header option").forEach((e => {
                e.disabled = e.parentElement.value !== e.value && n.includes(e.value)
            })), o().forEach((e => {
                const t = e.value.replace("bed", "-bedroom");
                e.previousElementSibling.href = `/backyard/${t}`, e.previousElementSibling.querySelector("img").src = `/assets/images/backyard/models/models-index-${e.value}/models-index-${e.value}-1000.webp`
            })),
            function() {
                if (void 0 === a || a < 1) return;
                const e = i[a].getBoundingClientRect().top - s;
                window.scrollBy(0, e)
            }()
    }
    return n.forEach((e => {
            e.addEventListener("change", h)
        })), window.addEventListener("scroll", c), window.addEventListener("resize", c),
        function() {
            if (null === localStorage.getItem(e)) return;
            JSON.parse(localStorage.getItem(e)).forEach(((e, t) => {
                n[t].value = e
            }))
        }(), h(), c(),
        function() {
            window.addEventListener("scroll", c), window.addEventListener("resize", c)
        }
})), window.Backyard = window.Backyard || {}, Backyard.createFaqMenu = function() {
    const e = document.querySelector(".backyard-faq .sidebar"),
        t = Array.from(e.querySelectorAll(".menu li")),
        n = Array.from(document.querySelectorAll(".backyard-faq .faq-group")),
        i = e.querySelector("h1");
    let r, a = !1,
        s = !1,
        o = window.scrollY;

    function l(e, t, n, i, r) {
        return i + (e - t) / (n - t) * (r - i)
    }

    function c() {
        if (s = !!a && o !== window.scrollY, s || (a = !1, function() {
                if (void 0 === n.findLastIndex) return;
                const e = Math.max(n.findLastIndex((e => e.getBoundingClientRect().top < .5 * window.innerHeight)), 0);
                t.forEach(((t, n) => {
                    t.classList.toggle("active", n === e)
                }))
            }()), o = window.scrollY, s && (clearTimeout(r), r = setTimeout(c, 100)), window.innerWidth >= 768) {
            const e = Math.min(Math.max(l(window.scrollY, 0, 132, 0, 1), 0), 1),
                t = l(e, 0, 1, 0, 50),
                n = l(e, 0, 1, 1, .66);
            i.style.transform = `translateY(${t}px) scale(${n})`
        } else i.style.transform = null
    }
    return window.addEventListener("scroll", c, {
            passive: !0
        }), window.addEventListener("resize", c, {
            passive: !0
        }), c(), t.slice(0, -1).forEach(((e, i) => {
            e.addEventListener("click", (function() {
                const e = window.scrollY + n[i].getBoundingClientRect().top - 150;
                t.forEach(((e, t) => {
                    e.classList.toggle("active", i === t)
                })), a = !0, window.scrollTo({
                    top: e,
                    behavior: "smooth"
                })
            }))
        })),
        function() {
            window.removeEventListener("scroll", c), window.removeEventListener("resize", c)
        }
}, window.Backyard = window.Backyard || {}, Backyard.createInteriorPhotoCards = function() {
    return document.querySelectorAll(".interior-carousel-cards-card").forEach(((e, t, n) => {
            e.addEventListener("click", (function(t) {
                const i = window.innerWidth < 768,
                    {
                        left: r,
                        width: a
                    } = e.getBoundingClientRect(),
                    s = Math.round(r + .5 * a),
                    o = .5 * window.innerWidth - s;
                if (!i && o > 0 && Math.abs(o) > .5 * a) t.stopPropagation(), e.parentElement.classList.add("scrolling"), e.parentElement.scrollTo({
                    left: e.parentElement.scrollLeft - e.clientWidth,
                    behavior: "smooth"
                });
                else if (!i && o < 0 && Math.abs(o) > .5 * a) t.stopPropagation(), e.parentElement.classList.add("scrolling"), e.parentElement.scrollTo({
                    left: e.parentElement.scrollLeft + e.clientWidth,
                    behavior: "smooth"
                });
                else if (t.target.classList.contains("interior-carousel-cards-card-images")) {
                    t.preventDefault(), t.stopPropagation();
                    const n = e.querySelectorAll("input"),
                        i = Array.from(n).findIndex((e => e.checked)),
                        r = i + 1 > n.length - 1 ? 0 : i + 1;
                    n.forEach(((e, t) => {
                        e.checked = t === r
                    }))
                }
                setTimeout((function() {
                    n.forEach((e => {
                        const {
                            left: t,
                            width: n
                        } = e.getBoundingClientRect(), i = Math.round(t + .5 * n), r = .5 * window.innerWidth - i;
                        e.parentElement.classList.remove("scrolling"), e.classList.toggle("current", Math.abs(r) < .5 * n)
                    }))
                }), 600)
            }))
        })),
        function() {}
}, window.Backyard = window.Backyard || {}, Backyard.introCarousel = function() {
    const e = ["Studio", "One bedroom", "Two bedroom", '<span class="alt">Backyard</span> XL 8', '<span class="alt">Backyard</span> XL 10'],
        t = ["/backyard/studio", "/backyard/one-bedroom", "/backyard/two-bedroom", "/backyard/xl-8", "/backyard/xl-10"],
        n = ["420 sq. ft.", "540 sq. ft.", "690 sq. ft.", "800 sq. ft.", "950 sq. ft."],
        i = [!1, !1, !1, !1, !0],
        r = document.querySelector(".intro-carousel-new .infinite-slideshow");
    if (!r) return () => {};
    const a = r.querySelectorAll("img");
    let s = 1;

    function o(r) {
        if (r === s) return;
        s = r;
        const o = document.getElementById("intro-carousel-layout-new");
        o && (o.hidden = !i[s]);
        const l = document.getElementById("intro-carousel-layout-name");
        l && (l.innerHTML = e[s], l.href = t[s]);
        const c = document.getElementById("intro-carousel-layout-area");
        c && (c.innerText = n[s]), a.forEach(((e, t) => {
            e.classList.toggle("current", t === s)
        }))
    }
    let l = !1;
    return r.addEventListener("change", (function(e) {
            o(e.detail.index)
        })), r.addEventListener("click", (function(e) {
            l || window.innerWidth < 768 || (l = !0, setTimeout((() => {
                l = !1
            }), 400), r.dispatchEvent(new CustomEvent("jump", {
                detail: {
                    direction: e.clientX < .5 * window.innerWidth ? -1 : 1
                }
            })))
        })), r.addEventListener("offset", (function(e) {
            var t;
            o((t = e.detail.targetIndex, Math.trunc(t - Math.floor(t / a.length) * a.length)))
        })),
        function() {}
}, window.Backyard = window.Backyard || {}, Backyard.intro = function() {
    const e = document.querySelector(".backyard .intro");
    if (null === e) return function() {};
    const t = e.querySelectorAll(".part");

    function n() {
        window.innerWidth;
        const e = (n = window.scrollY, i = 0, r = .25 * window.innerHeight, (a = 0) + (n - i) / (r - i) * (1 - a));
        var n, i, r, a;
        const s = Math.min(Math.max(Math.round(e * t.length), 0), t.length - 1);
        t.forEach(((e, t) => {
            e.classList.toggle("active", t <= s)
        }))
    }
    if ("undefined" != typeof experimentValueFor) {
        const t = e.querySelector("#cta-experiment");
        t && (t.innerText = experimentValueFor("cta", "text"))
    }
    return window.addEventListener("scroll", n, {
            passive: !0
        }), window.addEventListener("resize", n), n(), setTimeout((async function() {
            if (!1 === window.innerWidth < 768) return;

            function t(e) {
                return new Promise((t => {
                    setTimeout(t, e)
                }))
            }
            const n = Array.from(e.querySelectorAll("span[data-sentence]")).reduce(((e, t) => {
                const n = parseInt(t.dataset.sentence) - 1;
                return e[n] ? e[n].push(t) : e[n] = [t], e
            }), []);
            for (let e = 0; e < n.length; e++) n[e].forEach((e => {
                e.classList.add("active")
            })), await t(0 === e ? 1250 : 1e3)
        }), 200), e.querySelectorAll("h2 img").forEach((e => {
            e.complete ? e.classList.add("loaded") : e.addEventListener("load", (() => e.classList.add("loaded")), {
                once: !0
            })
        })),
        function() {
            window.removeEventListener("scroll", n), window.removeEventListener("resize", n)
        }
}, window.addEventListener("DOMContentLoaded", (() => {
    setTimeout((() => {
        document.body.classList.add("intro-complete")
    }), 2e3)
})), window.Backyard = window.Backyard || {}, Backyard.invertNavigation = function() {
    const e = document.getElementsByTagName("nav")[0],
        t = Array.from(document.querySelectorAll(".slides > *, article > *, .page-section"));

    function n() {
        const n = window.innerWidth < 768,
            i = t.find((e => {
                const t = n ? 45 : 65,
                    {
                        top: i,
                        bottom: r
                    } = e.getBoundingClientRect();
                return i < t && r > t
            }));
        if (i && e)
            if (n && i.dataset.invertMobile) {
                const t = "true" === i.dataset.invertMobile;
                e.classList.toggle("inverted", t)
            } else e.classList.toggle("inverted", void 0 !== i.dataset.invert)
    }
    return window.addEventListener("scroll", n, {
            passive: !0
        }), n(),
        function() {
            window.removeEventListener("scroll", n)
        }
}, window.Backyard = window.Backyard || {}, Backyard.createJealousy = function() {
    const e = document.querySelector(".jealousy");
    if (null === e) return () => {};
    const t = Array.from(document.querySelectorAll(".jealousy input"));
    let n;

    function i() {
        e.classList.remove("active"), t.forEach(((e, t) => e.checked = 1 === t))
    }

    function r(r) {
        if (clearTimeout(n), n = setTimeout(i, 1e4), e.classList.add("active"), "INPUT" === r.target.nodeName || "UL" === r.target.nodeName) return;
        let a = t.findIndex((e => !0 === e.checked));
        a < t.length - 1 ? a += 1 : a = 0, t.forEach(((e, t) => e.checked = t === a))
    }
    return e.addEventListener("click", r),
        function() {
            e.removeEventListener("click", r)
        }
}, window.Backyard = window.Backyard || {}, Backyard.loadImagesLazily = function() {
    const e = new IntersectionObserver((t => {
        t.forEach((({
            isIntersecting: t,
            target: n
        }) => {
            if (t) {
                if (n.setAttribute("loading", "eager"), "VIDEO" === n.nodeName && n.clientWidth > 0) {
                    const e = n;
                    e.load(), e.addEventListener("canplay", (() => {
                        e.play().catch((() => {}))
                    }), {
                        once: !0
                    })
                }
                e.unobserve(n)
            }
        }))
    }), {
        rootMargin: "100%"
    });
    return document.querySelectorAll("*[loading=lazy]").forEach((t => {
            e.observe(t)
        })),
        function() {
            e.disconnect()
        }
}, createDestroy(/^\/backyard\/.+/, (function() {
    const e = document.querySelectorAll(".backyard-models-navigation a");

    function t(e) {
        e.preventDefault();
        const t = e.target.closest("a");
        if (null === t) return;
        const n = t.getAttribute("href");
        if (null === n || "string" != typeof n || 0 === n.length) return;
        ! function(e) {
            const t = document.getElementById(e);
            if (null === t) return;
            const n = t.getBoundingClientRect().top - (window.innerWidth < 768 ? 68 : 180);
            window.scrollTo({
                top: n,
                behavior: "smooth"
            })
        }(n.substring(1))
    }
    return e.forEach((e => {
            e.addEventListener("click", t)
        })),
        function() {
            e.forEach((e => {
                e.removeEventListener("click", t)
            }))
        }
})), createDestroy(/^\/backyard\/.+/, (function() {
    const e = document.querySelectorAll("*[data-models-parallax]");

    function t(e, t, n, i, r) {
        return i + (e - t) / (n - t) * (r - i)
    }

    function n() {
        e.forEach((e => {
            const n = e.parentElement.getBoundingClientRect(),
                i = t(n.top, window.innerHeight, -n.height, 0, 1);
            if (i < 0 || i > 1) return;
            const r = (window.innerWidth > 768 ? e.dataset.modelsParallax : e.dataset.modelsParallaxMobile || e.dataset.modelsParallax).split(",").map(parseFloat),
                a = window.innerWidth < 768 ? 1 : .5,
                s = t(i, 0, 1, r[0] * n.height * a, r[1] * n.height * a);
            e.style.transform = `translate3d(0, ${s}px, 0)`
        }))
    }
    return window.addEventListener("scroll", n), window.addEventListener("resize", n), n(),
        function() {
            window.removeEventListener("scroll", n), window.removeEventListener("resize", n)
        }
})), window.Backyard = window.Backyard || {}, Backyard.threeSizes = function() {
    const e = [
            [152e3, 1697],
            [17e4, 1898],
            [19e4, 2121],
            [249e3, 2778],
            [277e3, 3092]
        ],
        t = {
            desktop: [
                [0, .2, -2.5, 15.75, 31],
                [0, .4, -30, -1, 27.5],
                [.2, .6, -25, 1.25, 22.5],
                [.4, .8, -27.75, .875, 29.5],
                [.6, 1, -25.75, 2.125, 30]
            ],
            mobile: [
                [0, .2, -3, 11, 24],
                [0, .4, -24.5, -3, 19],
                [.2, .6, -18.5, -3, 13],
                [.4, .8, -20, 0, 21],
                [.6, 1, -18, 0, 20]
            ]
        },
        n = document.querySelector(".three-sizes-layouts-pages-container");
    if (null === n) return console.warn("three-sizes container not found"),
        function() {};
    const i = Array.from(document.querySelectorAll(".three-sizes-layouts-selector button")),
        r = Array.from(document.querySelectorAll(".three-sizes-layouts-pages-page")),
        a = Array.from(document.querySelectorAll(".three-sizes-colors > div")),
        s = Array.from(document.querySelectorAll(".three-sizes-layouts-pages-controls button"));
    let o, l, c = 0,
        h = 1,
        u = Array(r.length).fill(0);

    function d(e, t, n, i, r) {
        return i + (e - t) / (n - t) * (r - i)
    }

    function p(e, t) {
        h = Math.max(Math.min(e, r.length - 1), 0), n.scrollTo({
            left: e * n.clientWidth,
            behavior: t ? "instant" : "smooth"
        }), n.dispatchEvent(new CustomEvent("change", {
            detail: {
                index: e
            }
        })), f(t)
    }

    function m(e) {
        let t = e;
        !1 === Number.isFinite(t) && (t = 0);
        return new Intl.NumberFormat("en-US", {
            style: "currency",
            currency: "USD",
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
        }).format(t)
    }

    function f(l) {
        l ? (clearTimeout(o), n.classList.add("without-animation"), o = setTimeout((() => {
            n.classList.remove("without-animation")
        }), 100)) : n.classList.remove("without-animation");
        const p = Math.max(Math.min(Math.round(n.scrollLeft / n.scrollWidth * r.length), r.length - 1), 0);
        Number.isFinite(p) && (h = p, n.dispatchEvent(new CustomEvent("change", {
            detail: {
                index: h
            }
        }))), 0 === c && (c = n.scrollWidth);
        const f = n.scrollLeft / c,
            g = window.innerWidth < 768 ? "mobile" : "desktop";
        r.forEach(((e, n) => {
            e.classList.toggle("selected", n === h), e.querySelectorAll("img").forEach(((e, t) => {
                e.classList.toggle("current", t === u[n])
            }));
            const [i, r, a, s, o] = t[g][n], l = i + .5 * (r - i), c = f < l ? d(f, i, l, a, s) : d(f, l, r, s, o);
            e.querySelector(".three-sizes-layouts-pages-image").style.transform = `translate3d(${c}vw, 0, 0)`
        })), i.forEach(((e, t) => {
            e.classList.toggle("selected", t === h)
        })), a.forEach(((e, t) => {
            e.classList.toggle("selected", t === u[h])
        })), s.forEach(((e, t) => {
            0 === t && 0 === h || 1 === t && h === r.length - 1 ? e.disabled = !0 : e.disabled = !1
        }));
        const _ = document.getElementById("three-sizes-footer-cost-total");
        _ && (_.innerText = m(e[h][0]));
        const v = document.getElementById("three-sizes-footer-cost-monthly");
        v && (v.innerText = `${m(e[h][1])}/mo`);
        const y = document.getElementById("three-sizes-footer-configure-link");
        y && (y.href = `/backyard/configure#${["bonewhite","driftwood","parchment","evergreen","dark-bronze"][u[h]]}+${["studio","onebed","twobed","xl-8","xl-10"][h]}`);
        const x = document.getElementById("three-sizes-footer-explore-link");
        x && (x.href = `/backyard/${["studio","one-bedroom","two-bedroom","xl-8","xl-10"][h]}`, x.querySelector(".three-sizes-footer-explore-link-model").innerHTML = ["the studio", "the one bedroom", "the two bedroom", "<span class='alt'>Backyard</span> XL 8", "<span class='alt'>Backyard</span> XL 10"][h]);
        const b = document.getElementById("three-sizes-footer-summary");
        b && (b.innerHTML = ["420 sq. ft. <span></span> 1 bath", "540 sq. ft. <span></span> 1 bedroom <span></span> 1 bath", "690 sq. ft. <span></span> 2 bedrooms <span></span> 1 bath", "800 sq. ft. <span></span> 2 bedrooms <span></span> 2 baths", "950 sq. ft. <span></span> 2 bedrooms <span></span> 2 baths"][h])
    }

    function g(e) {
        "resize" === e.type && (c = n.scrollWidth), cancelAnimationFrame(l), l = requestAnimationFrame((() => {
            f(e && "resize" === e.type)
        }))
    }
    return i.forEach(((e, t) => {
            e.addEventListener("click", (function() {
                p(t)
            }))
        })), a.forEach(((e, t) => {
            e.addEventListener("click", (function() {
                u[h] = t, f()
            }))
        })), s.forEach(((e, t) => {
            e.addEventListener("click", (function() {
                switch (t) {
                    case 0:
                        p(h - 1);
                        break;
                    case 1:
                        p(h + 1);
                        break;
                    default:
                        return
                }
                f()
            }))
        })), null !== n && (n.addEventListener("scroll", g), n.addEventListener("click", (function(e) {
            window.innerWidth < 768 || (e.clientX < .5 * n.clientWidth ? h > 0 && p(h - 1) : e.clientX > .5 * n.clientWidth && h < r.length - 1 && p(h + 1))
        })), n.addEventListener("mousemove", (function(e) {
            s[0].classList.toggle("highlight", e.clientX < .5 * n.clientWidth), s[1].classList.toggle("highlight", e.clientX > .5 * n.clientWidth), e.clientX < .5 * n.clientWidth ? n.style.cursor = 0 === h ? null : "pointer" : e.clientX > .5 * n.clientWidth && (n.style.cursor = h === r.length - 1 ? null : "pointer")
        })), n.addEventListener("mouseleave", (function() {
            s.forEach((e => {
                e.classList.remove("highlight")
            }))
        }))), window.addEventListener("resize", g, {
            passive: !0
        }), document.addEventListener("scroll", g, {
            passive: !0
        }), p(1, !0),
        function() {
            window.removeEventListener("scroll", g), window.removeEventListener("resize", g)
        }
}, window.Backyard = window.Backyard || {}, Backyard.createTourBanner = function() {
    const e = {
            mobileBreakpoint: 768,
            minPolarAngleMobile: 35,
            maxPolarAngleMobile: 60,
            minPolarAngleDesktop: 45,
            maxPolarAngleDesktop: 90,
            azimuthAngleMobile: 135,
            azimuthAngleDesktop: 120,
            fovMobile: 90,
            fovDesktop: 65,
            visibilityBuffer: 200,
            polarAngleSmoothing: .2,
            scrollThrottle: 16,
            texturePath: "/assets/tour/textures/2506/250117_Backyard_Tour_XL8_BedroomPrimary_01.jpg",
            modelPath: "/assets/tour/assets/xl8.glb",
            decoderPath: "/assets/tour/decoders/draco/"
        },
        t = document.querySelector(".ddd-tour-banner-container");
    let n, i, r, a, s = !1,
        o = null,
        l = null,
        c = !1,
        h = !1,
        u = 0,
        d = null,
        p = !1,
        m = 118;
    if (null === t) return () => {};
    const f = window.innerWidth <= e.mobileBreakpoint,
        g = !0 === f ? e.fovMobile : e.fovDesktop,
        _ = !0 === f ? e.azimuthAngleMobile : e.azimuthAngleDesktop;

    function v() {
        if (!0 === s) return;
        if (!1 === c && !0 === function() {
                const e = t.getBoundingClientRect(),
                    n = window.innerHeight,
                    i = e.top;
                return e.bottom > -n && i < 2 * n
            }() && !0 !== c && !0 !== h && !0 !== s && (h = !0, l = new SimplePanorama(t, {
                texturePath: e.texturePath,
                modelPath: e.modelPath,
                decoderPath: e.decoderPath,
                azimuthAngle: _,
                polarAngle: i,
                fov: g
            }), l.init().then((() => {
                !0 !== s ? (c = !0, h = !1) : b()
            }))), !1 === c) return void(o = requestAnimationFrame(v));
        if (r = function() {
                const e = t.getBoundingClientRect(),
                    r = -e.height,
                    a = window.innerHeight,
                    s = e.top,
                    o = Math.max(0, Math.min(1, (s - r) / (a - r)));
                return i - (i - n) * o
            }(), !1 === function() {
                const n = t.getBoundingClientRect(),
                    i = n.bottom,
                    r = n.top,
                    a = window.innerHeight;
                return i > -e.visibilityBuffer && r < a + e.visibilityBuffer
            }()) return a = r, null !== l && void 0 !== l.setCameraAngleDegrees && l.setCameraAngleDegrees(a, m), void(o = requestAnimationFrame(v));
        const u = r - a,
            d = !0 === p ? 0.3 : e.polarAngleSmoothing;
        a += u * d, Math.abs(u) > .01 && null !== l && void 0 !== l.setCameraAngleDegrees && l.setCameraAngleDegrees(a, m), o = requestAnimationFrame(v)
    }

    function y() {
        const t = performance.now();
        t - u < e.scrollThrottle || (u = t, p = !0, null !== d && clearTimeout(d), d = setTimeout((() => {
            p = !1
        }), 150), null === o && !1 === s && (o = requestAnimationFrame(v)))
    }

    function x() {
        if (!0 === s || !1 === c || null === l) return;
        const t = window.innerWidth <= e.mobileBreakpoint,
            r = !0 === t ? e.fovMobile : e.fovDesktop,
            o = !0 === t ? e.azimuthAngleMobile : e.azimuthAngleDesktop;
        n = !0 === t ? e.minPolarAngleMobile : e.minPolarAngleDesktop, i = !0 === t ? e.maxPolarAngleMobile : e.maxPolarAngleDesktop, m = o, void 0 !== l.setFOV && l.setFOV(r, !1, 0), void 0 !== l.setCameraAngleDegrees && l.setCameraAngleDegrees(a, m)
    }

    function b() {
        null !== l && (l.destroy(), l = null)
    }
    return n = !0 === f ? e.minPolarAngleMobile : e.minPolarAngleDesktop, i = !0 === f ? e.maxPolarAngleMobile : e.maxPolarAngleDesktop, m = _, r = i, a = i, window.addEventListener("scroll", y, {
            passive: !0
        }), window.addEventListener("resize", x, {
            passive: !0
        }), o = requestAnimationFrame(v),
        function() {
            s = !0, null !== o && (cancelAnimationFrame(o), o = null), null !== d && (clearTimeout(d), d = null), window.removeEventListener("scroll", y), window.removeEventListener("resize", x), b()
        }
}, window.Backyard = window.Backyard || {}, Backyard.xl10 = function() {
    const e = document.querySelector(".xl-11");
    if (null === e) return () => {};
    const t = e.querySelectorAll(".xl-11-parallax");
    let n = 0;

    function i() {
        if (window.scrollY > e.clientHeight) return;
        const n = window.innerWidth > 768 ? [-.25, -.32] : [0, -.12],
            i = Math.min((r = Math.min(Math.max(window.scrollY, 0), e.clientHeight), a = 0, s = e.clientHeight, ((o = n[0]) + (r - a) / (s - a) * (n[1] - o)) * e.clientWidth), 0);
        var r, a, s, o;
        t.forEach((e => {
            e.style.transform = `translate3d(0, ${i}px, 0)`
        }))
    }

    function r() {
        n += 1, n === e.querySelectorAll("img").length && e.classList.add("xl-10-loaded")
    }
    return e.querySelectorAll("img").forEach((e => {
            e.complete ? r() : e.addEventListener("load", r, {
                once: !0
            })
        })), window.addEventListener("scroll", i), window.addEventListener("resize", i), i(),
        function() {
            window.removeEventListener("scroll", i), window.removeEventListener("resize", i)
        }
}, (() => {
    "use strict";
    var e = {
            d: (t, n) => {
                for (var i in n) e.o(n, i) && !e.o(t, i) && Object.defineProperty(t, i, {
                    enumerable: !0,
                    get: n[i]
                })
            },
            o: (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        },
        t = {};
    e.d(t, {
        SimplePanoramaScene: () => pm
    });
    const n = "170",
        i = 100,
        r = "attached",
        a = 301,
        s = 302,
        o = 306,
        l = 1e3,
        c = 1001,
        h = 1002,
        u = 1003,
        d = 1005,
        p = 1006,
        m = 1007,
        f = 1008,
        g = 1009,
        _ = 1010,
        v = 1011,
        y = 1012,
        x = 1013,
        b = 1014,
        w = 1015,
        S = 1016,
        M = 1017,
        T = 1018,
        E = 1020,
        A = 35902,
        R = 1023,
        C = 1026,
        L = 1027,
        P = 1028,
        D = 1029,
        U = 1031,
        I = 1033,
        N = 33776,
        O = 33777,
        k = 33778,
        F = 33779,
        B = 35840,
        z = 35841,
        H = 35842,
        V = 35843,
        G = 36196,
        W = 37492,
        q = 37496,
        X = 37808,
        j = 37809,
        Y = 37810,
        K = 37811,
        Z = 37812,
        $ = 37813,
        J = 37814,
        Q = 37815,
        ee = 37816,
        te = 37817,
        ne = 37818,
        ie = 37819,
        re = 37820,
        ae = 37821,
        se = 36492,
        oe = 36494,
        le = 36495,
        ce = 36284,
        he = 36285,
        ue = 36286,
        de = 2300,
        pe = 2301,
        me = 2302,
        fe = "",
        ge = "srgb",
        _e = "srgb-linear",
        ve = "linear",
        ye = "srgb",
        xe = 7680,
        be = 35044,
        we = "300 es",
        Se = 2e3,
        Me = 2001;
    class Te {
        addEventListener(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        }
        hasEventListener(e, t) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        }
        removeEventListener(e, t) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[e];
            if (void 0 !== n) {
                const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
            }
        }
        dispatchEvent(e) {
            if (void 0 === this._listeners) return;
            const t = this._listeners[e.type];
            if (void 0 !== t) {
                e.target = this;
                const n = t.slice(0);
                for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
                e.target = null
            }
        }
    }
    const Ee = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    let Ae = 1234567;
    const Re = Math.PI / 180,
        Ce = 180 / Math.PI;

    function Le() {
        const e = 4294967295 * Math.random() | 0,
            t = 4294967295 * Math.random() | 0,
            n = 4294967295 * Math.random() | 0,
            i = 4294967295 * Math.random() | 0;
        return (Ee[255 & e] + Ee[e >> 8 & 255] + Ee[e >> 16 & 255] + Ee[e >> 24 & 255] + "-" + Ee[255 & t] + Ee[t >> 8 & 255] + "-" + Ee[t >> 16 & 15 | 64] + Ee[t >> 24 & 255] + "-" + Ee[63 & n | 128] + Ee[n >> 8 & 255] + "-" + Ee[n >> 16 & 255] + Ee[n >> 24 & 255] + Ee[255 & i] + Ee[i >> 8 & 255] + Ee[i >> 16 & 255] + Ee[i >> 24 & 255]).toLowerCase()
    }

    function Pe(e, t, n) {
        return Math.max(t, Math.min(n, e))
    }

    function De(e, t) {
        return (e % t + t) % t
    }

    function Ue(e, t, n) {
        return (1 - n) * e + n * t
    }

    function Ie(e, t) {
        switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return e / 4294967295;
            case Uint16Array:
                return e / 65535;
            case Uint8Array:
                return e / 255;
            case Int32Array:
                return Math.max(e / 2147483647, -1);
            case Int16Array:
                return Math.max(e / 32767, -1);
            case Int8Array:
                return Math.max(e / 127, -1);
            default:
                throw new Error("Invalid component type.")
        }
    }

    function Ne(e, t) {
        switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return Math.round(4294967295 * e);
            case Uint16Array:
                return Math.round(65535 * e);
            case Uint8Array:
                return Math.round(255 * e);
            case Int32Array:
                return Math.round(2147483647 * e);
            case Int16Array:
                return Math.round(32767 * e);
            case Int8Array:
                return Math.round(127 * e);
            default:
                throw new Error("Invalid component type.")
        }
    }
    const Oe = {
        DEG2RAD: Re,
        RAD2DEG: Ce,
        generateUUID: Le,
        clamp: Pe,
        euclideanModulo: De,
        mapLinear: function(e, t, n, i, r) {
            return i + (e - t) * (r - i) / (n - t)
        },
        inverseLerp: function(e, t, n) {
            return e !== t ? (n - e) / (t - e) : 0
        },
        lerp: Ue,
        damp: function(e, t, n, i) {
            return Ue(e, t, 1 - Math.exp(-n * i))
        },
        pingpong: function(e, t = 1) {
            return t - Math.abs(De(e, 2 * t) - t)
        },
        smoothstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        seededRandom: function(e) {
            void 0 !== e && (Ae = e);
            let t = Ae += 1831565813;
            return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296
        },
        degToRad: function(e) {
            return e * Re
        },
        radToDeg: function(e) {
            return e * Ce
        },
        isPowerOfTwo: function(e) {
            return !(e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        },
        setQuaternionFromProperEuler: function(e, t, n, i, r) {
            const a = Math.cos,
                s = Math.sin,
                o = a(n / 2),
                l = s(n / 2),
                c = a((t + i) / 2),
                h = s((t + i) / 2),
                u = a((t - i) / 2),
                d = s((t - i) / 2),
                p = a((i - t) / 2),
                m = s((i - t) / 2);
            switch (r) {
                case "XYX":
                    e.set(o * h, l * u, l * d, o * c);
                    break;
                case "YZY":
                    e.set(l * d, o * h, l * u, o * c);
                    break;
                case "ZXZ":
                    e.set(l * u, l * d, o * h, o * c);
                    break;
                case "XZX":
                    e.set(o * h, l * m, l * p, o * c);
                    break;
                case "YXY":
                    e.set(l * p, o * h, l * m, o * c);
                    break;
                case "ZYZ":
                    e.set(l * m, l * p, o * h, o * c)
            }
        },
        normalize: Ne,
        denormalize: Ie
    };
    class ke {
        constructor(e = 0, t = 0) {
            ke.prototype.isVector2 = !0, this.x = e, this.y = t
        }
        get width() {
            return this.x
        }
        set width(e) {
            this.x = e
        }
        get height() {
            return this.y
        }
        set height(e) {
            this.y = e
        }
        set(e, t) {
            return this.x = e, this.y = t, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y
        }
        cross(e) {
            return this.x * e.y - this.y * e.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Pe(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this
        }
        rotateAround(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                r = this.x - e.x,
                a = this.y - e.y;
            return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }
    class Fe {
        constructor(e, t, n, i, r, a, s, o, l) {
            Fe.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, a, s, o, l)
        }
        set(e, t, n, i, r, a, s, o, l) {
            const c = this.elements;
            return c[0] = e, c[1] = i, c[2] = s, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = a, c[8] = l, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                r = this.elements,
                a = n[0],
                s = n[3],
                o = n[6],
                l = n[1],
                c = n[4],
                h = n[7],
                u = n[2],
                d = n[5],
                p = n[8],
                m = i[0],
                f = i[3],
                g = i[6],
                _ = i[1],
                v = i[4],
                y = i[7],
                x = i[2],
                b = i[5],
                w = i[8];
            return r[0] = a * m + s * _ + o * x, r[3] = a * f + s * v + o * b, r[6] = a * g + s * y + o * w, r[1] = l * m + c * _ + h * x, r[4] = l * f + c * v + h * b, r[7] = l * g + c * y + h * w, r[2] = u * m + d * _ + p * x, r[5] = u * f + d * v + p * b, r[8] = u * g + d * y + p * w, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                r = e[3],
                a = e[4],
                s = e[5],
                o = e[6],
                l = e[7],
                c = e[8];
            return t * a * c - t * s * l - n * r * c + n * s * o + i * r * l - i * a * o
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                r = e[3],
                a = e[4],
                s = e[5],
                o = e[6],
                l = e[7],
                c = e[8],
                h = c * a - s * l,
                u = s * o - c * r,
                d = l * r - a * o,
                p = t * h + n * u + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const m = 1 / p;
            return e[0] = h * m, e[1] = (i * l - c * n) * m, e[2] = (s * n - i * a) * m, e[3] = u * m, e[4] = (c * t - i * o) * m, e[5] = (i * r - s * t) * m, e[6] = d * m, e[7] = (n * o - l * t) * m, e[8] = (a * t - n * r) * m, this
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        }
        setUvTransform(e, t, n, i, r, a, s) {
            const o = Math.cos(r),
                l = Math.sin(r);
            return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -i * l, i * o, -i * (-l * a + o * s) + s + t, 0, 0, 1), this
        }
        scale(e, t) {
            return this.premultiply(Be.makeScale(e, t)), this
        }
        rotate(e) {
            return this.premultiply(Be.makeRotation(-e)), this
        }
        translate(e, t) {
            return this.premultiply(Be.makeTranslation(e, t)), this
        }
        makeTranslation(e, t) {
            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
        }
        makeRotation(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
        }
        makeScale(e, t) {
            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let e = 0; e < 9; e++)
                if (t[e] !== n[e]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }
    const Be = new Fe;

    function ze(e) {
        for (let t = e.length - 1; t >= 0; --t)
            if (e[t] >= 65535) return !0;
        return !1
    }

    function He(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e)
    }

    function Ve() {
        const e = He("canvas");
        return e.style.display = "block", e
    }
    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
    const Ge = {};

    function We(e) {
        e in Ge || (Ge[e] = !0)
    }
    const qe = {
        enabled: !0,
        workingColorSpace: _e,
        spaces: {},
        convert: function(e, t, n) {
            return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === ye && (e.r = Xe(e.r), e.g = Xe(e.g), e.b = Xe(e.b)), this.spaces[t].primaries !== this.spaces[n].primaries && (e.applyMatrix3(this.spaces[t].toXYZ), e.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === ye && (e.r = je(e.r), e.g = je(e.g), e.b = je(e.b)), e) : e
        },
        fromWorkingColorSpace: function(e, t) {
            return this.convert(e, this.workingColorSpace, t)
        },
        toWorkingColorSpace: function(e, t) {
            return this.convert(e, t, this.workingColorSpace)
        },
        getPrimaries: function(e) {
            return this.spaces[e].primaries
        },
        getTransfer: function(e) {
            return e === fe ? ve : this.spaces[e].transfer
        },
        getLuminanceCoefficients: function(e, t = this.workingColorSpace) {
            return e.fromArray(this.spaces[t].luminanceCoefficients)
        },
        define: function(e) {
            Object.assign(this.spaces, e)
        },
        _getMatrix: function(e, t, n) {
            return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)
        },
        _getDrawingBufferColorSpace: function(e) {
            return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace
        },
        _getUnpackColorSpace: function(e = this.workingColorSpace) {
            return this.spaces[e].workingColorSpaceConfig.unpackColorSpace
        }
    };

    function Xe(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }

    function je(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }
    const Ye = [.64, .33, .3, .6, .15, .06],
        Ke = [.2126, .7152, .0722],
        Ze = [.3127, .329],
        $e = (new Fe).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
        Je = (new Fe).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
    let Qe;
    qe.define({
        [_e]: {
            primaries: Ye,
            whitePoint: Ze,
            transfer: ve,
            toXYZ: $e,
            fromXYZ: Je,
            luminanceCoefficients: Ke,
            workingColorSpaceConfig: {
                unpackColorSpace: ge
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: ge
            }
        },
        [ge]: {
            primaries: Ye,
            whitePoint: Ze,
            transfer: ye,
            toXYZ: $e,
            fromXYZ: Je,
            luminanceCoefficients: Ke,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: ge
            }
        }
    });
    class et {
        static getDataURL(e) {
            if (/^data:/i.test(e.src)) return e.src;
            if ("undefined" == typeof HTMLCanvasElement) return e.src;
            let t;
            if (e instanceof HTMLCanvasElement) t = e;
            else {
                void 0 === Qe && (Qe = He("canvas")), Qe.width = e.width, Qe.height = e.height;
                const n = Qe.getContext("2d");
                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Qe
            }
            return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
        static sRGBToLinear(e) {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                const t = He("canvas");
                t.width = e.width, t.height = e.height;
                const n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                const i = n.getImageData(0, 0, e.width, e.height),
                    r = i.data;
                for (let e = 0; e < r.length; e++) r[e] = 255 * Xe(r[e] / 255);
                return n.putImageData(i, 0, 0), t
            }
            if (e.data) {
                const t = e.data.slice(0);
                for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Xe(t[e] / 255)) : t[e] = Xe(t[e]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                }
            }
            return e
        }
    }
    let tt = 0;
    class nt {
        constructor(e = null) {
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: tt++
            }), this.uuid = Le(), this.data = e, this.dataReady = !0, this.version = 0
        }
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
            const n = {
                    uuid: this.uuid,
                    url: ""
                },
                i = this.data;
            if (null !== i) {
                let e;
                if (Array.isArray(i)) {
                    e = [];
                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(it(i[t].image)) : e.push(it(i[t]))
                } else e = it(i);
                n.url = e
            }
            return t || (e.images[this.uuid] = n), n
        }
    }

    function it(e) {
        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? et.getDataURL(e) : e.data ? {
            data: Array.from(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
        } : {}
    }
    let rt = 0;
    class at extends Te {
        constructor(e = at.DEFAULT_IMAGE, t = at.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, a = 1008, s = 1023, o = 1009, l = at.DEFAULT_ANISOTROPY, c = "") {
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: rt++
            }), this.uuid = Le(), this.name = "", this.source = new nt(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new ke(0, 0), this.repeat = new ke(1, 1), this.center = new ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Fe, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
        }
        get image() {
            return this.source.data
        }
        set image(e = null) {
            this.source.data = e
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                case l:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case c:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case h:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                case l:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case c:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case h:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
        set needsUpdate(e) {
            !0 === e && (this.version++, this.source.needsUpdate = !0)
        }
        set needsPMREMUpdate(e) {
            !0 === e && this.pmremVersion++
        }
    }
    at.DEFAULT_IMAGE = null, at.DEFAULT_MAPPING = 300, at.DEFAULT_ANISOTROPY = 1;
    class st {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            st.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
        }
        get width() {
            return this.z
        }
        set width(e) {
            this.z = e
        }
        get height() {
            return this.w
        }
        set height(e) {
            this.w = e
        }
        set(e, t, n, i) {
            return this.x = e, this.y = t, this.z = n, this.w = i, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setW(e) {
            return this.w = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = this.w,
                a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, i, r;
            const a = .01,
                s = .1,
                o = e.elements,
                l = o[0],
                c = o[4],
                h = o[8],
                u = o[1],
                d = o[5],
                p = o[9],
                m = o[2],
                f = o[6],
                g = o[10];
            if (Math.abs(c - u) < a && Math.abs(h - m) < a && Math.abs(p - f) < a) {
                if (Math.abs(c + u) < s && Math.abs(h + m) < s && Math.abs(p + f) < s && Math.abs(l + d + g - 3) < s) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const e = (l + 1) / 2,
                    o = (d + 1) / 2,
                    _ = (g + 1) / 2,
                    v = (c + u) / 4,
                    y = (h + m) / 4,
                    x = (p + f) / 4;
                return e > o && e > _ ? e < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = v / n, r = y / n) : o > _ ? o < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = v / i, r = x / i) : _ < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(_), n = y / r, i = x / r), this.set(n, i, r, t), this
            }
            let _ = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
            return Math.abs(_) < .001 && (_ = 1), this.x = (f - p) / _, this.y = (h - m) / _, this.z = (u - c) / _, this.w = Math.acos((l + d + g - 1) / 2), this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w
        }
    }
    class ot extends Te {
        constructor(e = 1, t = 1, n = {}) {
            super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new st(0, 0, e, t), this.scissorTest = !1, this.viewport = new st(0, 0, e, t);
            const i = {
                width: e,
                height: t,
                depth: 1
            };
            n = Object.assign({
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: p,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1
            }, n);
            const r = new at(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
            r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
            const a = n.count;
            for (let e = 0; e < a; e++) this.textures[e] = r.clone(), this.textures[e].isRenderTargetTexture = !0;
            this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
        }
        get texture() {
            return this.textures[0]
        }
        set texture(e) {
            this.textures[0] = e
        }
        setSize(e, t, n = 1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e, this.height = t, this.depth = n;
                for (let i = 0, r = this.textures.length; i < r; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
                this.dispose()
            }
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
            for (let t = 0, n = e.textures.length; t < n; t++) this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0;
            const t = Object.assign({}, e.texture.image);
            return this.texture.source = new nt(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    class lt extends ot {
        constructor(e = 1, t = 1, n = {}) {
            super(e, t, n), this.isWebGLRenderTarget = !0
        }
    }
    class ct extends at {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = u, this.minFilter = u, this.wrapR = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
        }
        addLayerUpdate(e) {
            this.layerUpdates.add(e)
        }
        clearLayerUpdates() {
            this.layerUpdates.clear()
        }
    }
    class ht {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
        }
        static slerpFlat(e, t, n, i, r, a, s) {
            let o = n[i + 0],
                l = n[i + 1],
                c = n[i + 2],
                h = n[i + 3];
            const u = r[a + 0],
                d = r[a + 1],
                p = r[a + 2],
                m = r[a + 3];
            if (0 === s) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = h);
            if (1 === s) return e[t + 0] = u, e[t + 1] = d, e[t + 2] = p, void(e[t + 3] = m);
            if (h !== m || o !== u || l !== d || c !== p) {
                let e = 1 - s;
                const t = o * u + l * d + c * p + h * m,
                    n = t >= 0 ? 1 : -1,
                    i = 1 - t * t;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i),
                        a = Math.atan2(r, t * n);
                    e = Math.sin(e * a) / r, s = Math.sin(s * a) / r
                }
                const r = s * n;
                if (o = o * e + u * r, l = l * e + d * r, c = c * e + p * r, h = h * e + m * r, e === 1 - s) {
                    const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                    o *= e, l *= e, c *= e, h *= e
                }
            }
            e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, a) {
            const s = n[i],
                o = n[i + 1],
                l = n[i + 2],
                c = n[i + 3],
                h = r[a],
                u = r[a + 1],
                d = r[a + 2],
                p = r[a + 3];
            return e[t] = s * p + c * h + o * d - l * u, e[t + 1] = o * p + c * u + l * h - s * d, e[t + 2] = l * p + c * d + s * u - o * h, e[t + 3] = c * p - s * h - o * u - l * d, e
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(e) {
            this._w = e, this._onChangeCallback()
        }
        set(e, t, n, i) {
            return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
        }
        setFromEuler(e, t = !0) {
            const n = e._x,
                i = e._y,
                r = e._z,
                a = e._order,
                s = Math.cos,
                o = Math.sin,
                l = s(n / 2),
                c = s(i / 2),
                h = s(r / 2),
                u = o(n / 2),
                d = o(i / 2),
                p = o(r / 2);
            switch (a) {
                case "XYZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "YXZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "ZXY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "ZYX":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "YZX":
                    this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "XZY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p
            }
            return !0 === t && this._onChangeCallback(), this
        }
        setFromAxisAngle(e, t) {
            const n = t / 2,
                i = Math.sin(n);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }
        setFromRotationMatrix(e) {
            const t = e.elements,
                n = t[0],
                i = t[4],
                r = t[8],
                a = t[1],
                s = t[5],
                o = t[9],
                l = t[2],
                c = t[6],
                h = t[10],
                u = n + s + h;
            if (u > 0) {
                const e = .5 / Math.sqrt(u + 1);
                this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (a - i) * e
            } else if (n > s && n > h) {
                const e = 2 * Math.sqrt(1 + n - s - h);
                this._w = (c - o) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (r + l) / e
            } else if (s > h) {
                const e = 2 * Math.sqrt(1 + s - n - h);
                this._w = (r - l) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (o + c) / e
            } else {
                const e = 2 * Math.sqrt(1 + h - n - s);
                this._w = (a - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(Pe(this.dot(e), -1, 1)))
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (0 === n) return this;
            const i = Math.min(1, t / n);
            return this.slerp(e, i), this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let e = this.length();
            return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
        }
        multiply(e) {
            return this.multiplyQuaternions(this, e)
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this)
        }
        multiplyQuaternions(e, t) {
            const n = e._x,
                i = e._y,
                r = e._z,
                a = e._w,
                s = t._x,
                o = t._y,
                l = t._z,
                c = t._w;
            return this._x = n * c + a * s + i * l - r * o, this._y = i * c + a * o + r * s - n * l, this._z = r * c + a * l + n * o - i * s, this._w = a * c - n * s - i * o - r * l, this._onChangeCallback(), this
        }
        slerp(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            const n = this._x,
                i = this._y,
                r = this._z,
                a = this._w;
            let s = a * e._w + n * e._x + i * e._y + r * e._z;
            if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
            const o = 1 - s * s;
            if (o <= Number.EPSILON) {
                const e = 1 - t;
                return this._w = e * a + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this
            }
            const l = Math.sqrt(o),
                c = Math.atan2(l, s),
                h = Math.sin((1 - t) * c) / l,
                u = Math.sin(t * c) / l;
            return this._w = a * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
        }
        slerpQuaternions(e, t, n) {
            return this.copy(e).slerp(t, n)
        }
        random() {
            const e = 2 * Math.PI * Math.random(),
                t = 2 * Math.PI * Math.random(),
                n = Math.random(),
                i = Math.sqrt(1 - n),
                r = Math.sqrt(n);
            return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }
        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
        }
        toJSON() {
            return this.toArray()
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}*[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w
        }
    }
    class ut {
        constructor(e = 0, t = 0, n = 0) {
            ut.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
        }
        set(e, t, n) {
            return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        }
        applyEuler(e) {
            return this.applyQuaternion(pt.setFromEuler(e))
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(pt.setFromAxisAngle(e, t))
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.elements,
                a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this
        }
        applyQuaternion(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.x,
                a = e.y,
                s = e.z,
                o = e.w,
                l = 2 * (a * i - s * n),
                c = 2 * (s * t - r * i),
                h = 2 * (r * n - a * t);
            return this.x = t + o * l + a * h - s * c, this.y = n + o * c + s * l - r * h, this.z = i + o * h + r * c - a * l, this
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }
        transformDirection(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.elements;
            return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
        }
        cross(e) {
            return this.crossVectors(this, e)
        }
        crossVectors(e, t) {
            const n = e.x,
                i = e.y,
                r = e.z,
                a = t.x,
                s = t.y,
                o = t.z;
            return this.x = i * o - r * s, this.y = r * a - n * o, this.z = n * s - i * a, this
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (0 === t) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        }
        projectOnPlane(e) {
            return dt.copy(this).projectOnVector(e), this.sub(dt)
        }
        reflect(e) {
            return this.sub(dt.copy(e).multiplyScalar(2 * this.dot(e)))
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Pe(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y,
                i = this.z - e.z;
            return t * t + n * n + i * i
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }
        setFromSphericalCoords(e, t, n) {
            const i = Math.sin(t) * e;
            return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(),
                n = this.setFromMatrixColumn(e, 1).length(),
                i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = i, this
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, 4 * t)
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, 3 * t)
        }
        setFromEuler(e) {
            return this.x = e._x, this.y = e._y, this.z = e._z, this
        }
        setFromColor(e) {
            return this.x = e.r, this.y = e.g, this.z = e.b, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection() {
            const e = Math.random() * Math.PI * 2,
                t = 2 * Math.random() - 1,
                n = Math.sqrt(1 - t * t);
            return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    }
    const dt = new ut,
        pt = new ht;
    class mt {
        constructor(e = new ut(1 / 0, 1 / 0, 1 / 0), t = new ut(-1 / 0, -1 / 0, -1 / 0)) {
            this.isBox3 = !0, this.min = e, this.max = t
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        }
        setFromArray(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(gt.fromArray(e, t));
            return this
        }
        setFromBufferAttribute(e) {
            this.makeEmpty();
            for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(gt.fromBufferAttribute(e, t));
            return this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            const n = gt.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        }
        setFromObject(e, t = !1) {
            return this.makeEmpty(), this.expandByObject(e, t)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        }
        expandByObject(e, t = !1) {
            e.updateWorldMatrix(!1, !1);
            const n = e.geometry;
            if (void 0 !== n) {
                const i = n.getAttribute("position");
                if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                    for (let t = 0, n = i.count; t < n; t++) !0 === e.isMesh ? e.getVertexPosition(t, gt) : gt.fromBufferAttribute(i, t), gt.applyMatrix4(e.matrixWorld), this.expandByPoint(gt);
                else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), _t.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), _t.copy(n.boundingBox)), _t.applyMatrix4(e.matrixWorld), this.union(_t)
            }
            const i = e.children;
            for (let e = 0, n = i.length; e < n; e++) this.expandByObject(i[e], t);
            return this
        }
        containsPoint(e) {
            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(e) {
            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, gt), gt.distanceToSquared(e.center) <= e.radius * e.radius
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(Mt), Tt.subVectors(this.max, Mt), vt.subVectors(e.a, Mt), yt.subVectors(e.b, Mt), xt.subVectors(e.c, Mt), bt.subVectors(yt, vt), wt.subVectors(xt, yt), St.subVectors(vt, xt);
            let t = [0, -bt.z, bt.y, 0, -wt.z, wt.y, 0, -St.z, St.y, bt.z, 0, -bt.x, wt.z, 0, -wt.x, St.z, 0, -St.x, -bt.y, bt.x, 0, -wt.y, wt.x, 0, -St.y, St.x, 0];
            return !!Rt(t, vt, yt, xt, Tt) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Rt(t, vt, yt, xt, Tt) && (Et.crossVectors(bt, wt), t = [Et.x, Et.y, Et.z], Rt(t, vt, yt, xt, Tt)))
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return this.clampPoint(e, gt).distanceTo(e)
        }
        getBoundingSphere(e) {
            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(gt).length()), e
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        }
        applyMatrix4(e) {
            return this.isEmpty() || (ft[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ft[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ft[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ft[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ft[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ft[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ft[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ft[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ft)), this
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }
    const ft = [new ut, new ut, new ut, new ut, new ut, new ut, new ut, new ut],
        gt = new ut,
        _t = new mt,
        vt = new ut,
        yt = new ut,
        xt = new ut,
        bt = new ut,
        wt = new ut,
        St = new ut,
        Mt = new ut,
        Tt = new ut,
        Et = new ut,
        At = new ut;

    function Rt(e, t, n, i, r) {
        for (let a = 0, s = e.length - 3; a <= s; a += 3) {
            At.fromArray(e, a);
            const s = r.x * Math.abs(At.x) + r.y * Math.abs(At.y) + r.z * Math.abs(At.z),
                o = t.dot(At),
                l = n.dot(At),
                c = i.dot(At);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s) return !1
        }
        return !0
    }
    const Ct = new mt,
        Lt = new ut,
        Pt = new ut;
    class Dt {
        constructor(e = new ut, t = -1) {
            this.isSphere = !0, this.center = e, this.radius = t
        }
        set(e, t) {
            return this.center.copy(e), this.radius = t, this
        }
        setFromPoints(e, t) {
            const n = this.center;
            void 0 !== t ? n.copy(t) : Ct.setFromPoints(e).getCenter(n);
            let i = 0;
            for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
            return this.radius = Math.sqrt(i), this
        }
        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }
        intersectsBox(e) {
            return e.intersectsSphere(this)
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        }
        translate(e) {
            return this.center.add(e), this
        }
        expandByPoint(e) {
            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
            Lt.subVectors(e, this.center);
            const t = Lt.lengthSq();
            if (t > this.radius * this.radius) {
                const e = Math.sqrt(t),
                    n = .5 * (e - this.radius);
                this.center.addScaledVector(Lt, n / e), this.radius += n
            }
            return this
        }
        union(e) {
            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Pt.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Lt.copy(e.center).add(Pt)), this.expandByPoint(Lt.copy(e.center).sub(Pt))), this)
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const Ut = new ut,
        It = new ut,
        Nt = new ut,
        Ot = new ut,
        kt = new ut,
        Ft = new ut,
        Bt = new ut;
    class zt {
        constructor(e = new ut, t = new ut(0, 0, -1)) {
            this.origin = e, this.direction = t
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        }
        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        }
        at(e, t) {
            return t.copy(this.origin).addScaledVector(this.direction, e)
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        }
        recast(e) {
            return this.origin.copy(this.at(e, Ut)), this
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }
        distanceSqToPoint(e) {
            const t = Ut.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (Ut.copy(this.origin).addScaledVector(this.direction, t), Ut.distanceToSquared(e))
        }
        distanceSqToSegment(e, t, n, i) {
            It.copy(e).add(t).multiplyScalar(.5), Nt.copy(t).sub(e).normalize(), Ot.copy(this.origin).sub(It);
            const r = .5 * e.distanceTo(t),
                a = -this.direction.dot(Nt),
                s = Ot.dot(this.direction),
                o = -Ot.dot(Nt),
                l = Ot.lengthSq(),
                c = Math.abs(1 - a * a);
            let h, u, d, p;
            if (c > 0)
                if (h = a * o - s, u = a * s - o, p = r * c, h >= 0)
                    if (u >= -p)
                        if (u <= p) {
                            const e = 1 / c;
                            h *= e, u *= e, d = h * (h + a * u + 2 * s) + u * (a * h + u + 2 * o) + l
                        } else u = r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
            else u = -r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
            else u <= -p ? (h = Math.max(0, -(-a * r + s)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(a * r + s)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
            else u = a > 0 ? -r : r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
            return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(It).addScaledVector(Nt, u), d
        }
        intersectSphere(e, t) {
            Ut.subVectors(e.center, this.origin);
            const n = Ut.dot(this.direction),
                i = Ut.dot(Ut) - n * n,
                r = e.radius * e.radius;
            if (i > r) return null;
            const a = Math.sqrt(r - i),
                s = n - a,
                o = n + a;
            return o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
        }
        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        }
        intersectBox(e, t) {
            let n, i, r, a, s, o;
            const l = 1 / this.direction.x,
                c = 1 / this.direction.y,
                h = 1 / this.direction.z,
                u = this.origin;
            return l >= 0 ? (n = (e.min.x - u.x) * l, i = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, i = (e.min.x - u.x) * l), c >= 0 ? (r = (e.min.y - u.y) * c, a = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, a = (e.min.y - u.y) * c), n > a || r > i ? null : ((r > n || isNaN(n)) && (n = r), (a < i || isNaN(i)) && (i = a), h >= 0 ? (s = (e.min.z - u.z) * h, o = (e.max.z - u.z) * h) : (s = (e.max.z - u.z) * h, o = (e.min.z - u.z) * h), n > o || s > i ? null : ((s > n || n != n) && (n = s), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
        }
        intersectsBox(e) {
            return null !== this.intersectBox(e, Ut)
        }
        intersectTriangle(e, t, n, i, r) {
            kt.subVectors(t, e), Ft.subVectors(n, e), Bt.crossVectors(kt, Ft);
            let a, s = this.direction.dot(Bt);
            if (s > 0) {
                if (i) return null;
                a = 1
            } else {
                if (!(s < 0)) return null;
                a = -1, s = -s
            }
            Ot.subVectors(this.origin, e);
            const o = a * this.direction.dot(Ft.crossVectors(Ot, Ft));
            if (o < 0) return null;
            const l = a * this.direction.dot(kt.cross(Ot));
            if (l < 0) return null;
            if (o + l > s) return null;
            const c = -a * Ot.dot(Bt);
            return c < 0 ? null : this.at(c / s, r)
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class Ht {
        constructor(e, t, n, i, r, a, s, o, l, c, h, u, d, p, m, f) {
            Ht.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, a, s, o, l, c, h, u, d, p, m, f)
        }
        set(e, t, n, i, r, a, s, o, l, c, h, u, d, p, m, f) {
            const g = this.elements;
            return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
            return (new Ht).fromArray(this.elements)
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        }
        copyPosition(e) {
            const t = this.elements,
                n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        }
        extractRotation(e) {
            const t = this.elements,
                n = e.elements,
                i = 1 / Vt.setFromMatrixColumn(e, 0).length(),
                r = 1 / Vt.setFromMatrixColumn(e, 1).length(),
                a = 1 / Vt.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromEuler(e) {
            const t = this.elements,
                n = e.x,
                i = e.y,
                r = e.z,
                a = Math.cos(n),
                s = Math.sin(n),
                o = Math.cos(i),
                l = Math.sin(i),
                c = Math.cos(r),
                h = Math.sin(r);
            if ("XYZ" === e.order) {
                const e = a * c,
                    n = a * h,
                    i = s * c,
                    r = s * h;
                t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -s * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = a * o
            } else if ("YXZ" === e.order) {
                const e = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                t[0] = e + r * s, t[4] = i * s - n, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -s, t[2] = n * s - i, t[6] = r + e * s, t[10] = a * o
            } else if ("ZXY" === e.order) {
                const e = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                t[0] = e - r * s, t[4] = -a * h, t[8] = i + n * s, t[1] = n + i * s, t[5] = a * c, t[9] = r - e * s, t[2] = -a * l, t[6] = s, t[10] = a * o
            } else if ("ZYX" === e.order) {
                const e = a * c,
                    n = a * h,
                    i = s * c,
                    r = s * h;
                t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * h, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = s * o, t[10] = a * o
            } else if ("YZX" === e.order) {
                const e = a * o,
                    n = a * l,
                    i = s * o,
                    r = s * l;
                t[0] = o * c, t[4] = r - e * h, t[8] = i * h + n, t[1] = h, t[5] = a * c, t[9] = -s * c, t[2] = -l * c, t[6] = n * h + i, t[10] = e - r * h
            } else if ("XZY" === e.order) {
                const e = a * o,
                    n = a * l,
                    i = s * o,
                    r = s * l;
                t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = e * h + r, t[5] = a * c, t[9] = n * h - i, t[2] = i * h - n, t[6] = s * c, t[10] = r * h + e
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromQuaternion(e) {
            return this.compose(Wt, e, qt)
        }
        lookAt(e, t, n) {
            const i = this.elements;
            return Yt.subVectors(e, t), 0 === Yt.lengthSq() && (Yt.z = 1), Yt.normalize(), Xt.crossVectors(n, Yt), 0 === Xt.lengthSq() && (1 === Math.abs(n.z) ? Yt.x += 1e-4 : Yt.z += 1e-4, Yt.normalize(), Xt.crossVectors(n, Yt)), Xt.normalize(), jt.crossVectors(Yt, Xt), i[0] = Xt.x, i[4] = jt.x, i[8] = Yt.x, i[1] = Xt.y, i[5] = jt.y, i[9] = Yt.y, i[2] = Xt.z, i[6] = jt.z, i[10] = Yt.z, this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                r = this.elements,
                a = n[0],
                s = n[4],
                o = n[8],
                l = n[12],
                c = n[1],
                h = n[5],
                u = n[9],
                d = n[13],
                p = n[2],
                m = n[6],
                f = n[10],
                g = n[14],
                _ = n[3],
                v = n[7],
                y = n[11],
                x = n[15],
                b = i[0],
                w = i[4],
                S = i[8],
                M = i[12],
                T = i[1],
                E = i[5],
                A = i[9],
                R = i[13],
                C = i[2],
                L = i[6],
                P = i[10],
                D = i[14],
                U = i[3],
                I = i[7],
                N = i[11],
                O = i[15];
            return r[0] = a * b + s * T + o * C + l * U, r[4] = a * w + s * E + o * L + l * I, r[8] = a * S + s * A + o * P + l * N, r[12] = a * M + s * R + o * D + l * O, r[1] = c * b + h * T + u * C + d * U, r[5] = c * w + h * E + u * L + d * I, r[9] = c * S + h * A + u * P + d * N, r[13] = c * M + h * R + u * D + d * O, r[2] = p * b + m * T + f * C + g * U, r[6] = p * w + m * E + f * L + g * I, r[10] = p * S + m * A + f * P + g * N, r[14] = p * M + m * R + f * D + g * O, r[3] = _ * b + v * T + y * C + x * U, r[7] = _ * w + v * E + y * L + x * I, r[11] = _ * S + v * A + y * P + x * N, r[15] = _ * M + v * R + y * D + x * O, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[4],
                i = e[8],
                r = e[12],
                a = e[1],
                s = e[5],
                o = e[9],
                l = e[13],
                c = e[2],
                h = e[6],
                u = e[10],
                d = e[14];
            return e[3] * (+r * o * h - i * l * h - r * s * u + n * l * u + i * s * d - n * o * d) + e[7] * (+t * o * d - t * l * u + r * a * u - i * a * d + i * l * c - r * o * c) + e[11] * (+t * l * h - t * s * d - r * a * h + n * a * d + r * s * c - n * l * c) + e[15] * (-i * s * c - t * o * h + t * s * u + i * a * h - n * a * u + n * o * c)
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        }
        setPosition(e, t, n) {
            const i = this.elements;
            return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                r = e[3],
                a = e[4],
                s = e[5],
                o = e[6],
                l = e[7],
                c = e[8],
                h = e[9],
                u = e[10],
                d = e[11],
                p = e[12],
                m = e[13],
                f = e[14],
                g = e[15],
                _ = h * f * l - m * u * l + m * o * d - s * f * d - h * o * g + s * u * g,
                v = p * u * l - c * f * l - p * o * d + a * f * d + c * o * g - a * u * g,
                y = c * m * l - p * h * l + p * s * d - a * m * d - c * s * g + a * h * g,
                x = p * h * o - c * m * o - p * s * u + a * m * u + c * s * f - a * h * f,
                b = t * _ + n * v + i * y + r * x;
            if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / b;
            return e[0] = _ * w, e[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * w, e[2] = (s * f * r - m * o * r + m * i * l - n * f * l - s * i * g + n * o * g) * w, e[3] = (h * o * r - s * u * r - h * i * l + n * u * l + s * i * d - n * o * d) * w, e[4] = v * w, e[5] = (c * f * r - p * u * r + p * i * d - t * f * d - c * i * g + t * u * g) * w, e[6] = (p * o * r - a * f * r - p * i * l + t * f * l + a * i * g - t * o * g) * w, e[7] = (a * u * r - c * o * r + c * i * l - t * u * l - a * i * d + t * o * d) * w, e[8] = y * w, e[9] = (p * h * r - c * m * r - p * n * d + t * m * d + c * n * g - t * h * g) * w, e[10] = (a * m * r - p * s * r + p * n * l - t * m * l - a * n * g + t * s * g) * w, e[11] = (c * s * r - a * h * r - c * n * l + t * h * l + a * n * d - t * s * d) * w, e[12] = x * w, e[13] = (c * m * i - p * h * i + p * n * u - t * m * u - c * n * f + t * h * f) * w, e[14] = (p * s * i - a * m * i - p * n * o + t * m * o + a * n * f - t * s * f) * w, e[15] = (a * h * i - c * s * i + c * n * o - t * h * o - a * n * u + t * s * u) * w, this
        }
        scale(e) {
            const t = this.elements,
                n = e.x,
                i = e.y,
                r = e.z;
            return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
        }
        getMaxScaleOnAxis() {
            const e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i))
        }
        makeTranslation(e, t, n) {
            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        }
        makeRotationX(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        }
        makeRotationY(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                r = 1 - n,
                a = e.x,
                s = e.y,
                o = e.z,
                l = r * a,
                c = r * s;
            return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1), this
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }
        makeShear(e, t, n, i, r, a) {
            return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this
        }
        compose(e, t, n) {
            const i = this.elements,
                r = t._x,
                a = t._y,
                s = t._z,
                o = t._w,
                l = r + r,
                c = a + a,
                h = s + s,
                u = r * l,
                d = r * c,
                p = r * h,
                m = a * c,
                f = a * h,
                g = s * h,
                _ = o * l,
                v = o * c,
                y = o * h,
                x = n.x,
                b = n.y,
                w = n.z;
            return i[0] = (1 - (m + g)) * x, i[1] = (d + y) * x, i[2] = (p - v) * x, i[3] = 0, i[4] = (d - y) * b, i[5] = (1 - (u + g)) * b, i[6] = (f + _) * b, i[7] = 0, i[8] = (p + v) * w, i[9] = (f - _) * w, i[10] = (1 - (u + m)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
        }
        decompose(e, t, n) {
            const i = this.elements;
            let r = Vt.set(i[0], i[1], i[2]).length();
            const a = Vt.set(i[4], i[5], i[6]).length(),
                s = Vt.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Gt.copy(this);
            const o = 1 / r,
                l = 1 / a,
                c = 1 / s;
            return Gt.elements[0] *= o, Gt.elements[1] *= o, Gt.elements[2] *= o, Gt.elements[4] *= l, Gt.elements[5] *= l, Gt.elements[6] *= l, Gt.elements[8] *= c, Gt.elements[9] *= c, Gt.elements[10] *= c, t.setFromRotationMatrix(Gt), n.x = r, n.y = a, n.z = s, this
        }
        makePerspective(e, t, n, i, r, a, s = 2e3) {
            const o = this.elements,
                l = 2 * r / (t - e),
                c = 2 * r / (n - i),
                h = (t + e) / (t - e),
                u = (n + i) / (n - i);
            let d, p;
            if (s === Se) d = -(a + r) / (a - r), p = -2 * a * r / (a - r);
            else {
                if (s !== Me) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                d = -a / (a - r), p = -a * r / (a - r)
            }
            return o[0] = l, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
        }
        makeOrthographic(e, t, n, i, r, a, s = 2e3) {
            const o = this.elements,
                l = 1 / (t - e),
                c = 1 / (n - i),
                h = 1 / (a - r),
                u = (t + e) * l,
                d = (n + i) * c;
            let p, m;
            if (s === Se) p = (a + r) * h, m = -2 * h;
            else {
                if (s !== Me) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                p = r * h, m = -1 * h
            }
            return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = m, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let e = 0; e < 16; e++)
                if (t[e] !== n[e]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    }
    const Vt = new ut,
        Gt = new Ht,
        Wt = new ut(0, 0, 0),
        qt = new ut(1, 1, 1),
        Xt = new ut,
        jt = new ut,
        Yt = new ut,
        Kt = new Ht,
        Zt = new ht;
    class $t {
        constructor(e = 0, t = 0, n = 0, i = $t.DEFAULT_ORDER) {
            this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e, this._onChangeCallback()
        }
        set(e, t, n, i = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }
        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            const i = e.elements,
                r = i[0],
                a = i[4],
                s = i[8],
                o = i[1],
                l = i[5],
                c = i[9],
                h = i[2],
                u = i[6],
                d = i[10];
            switch (t) {
                case "XYZ":
                    this._y = Math.asin(Pe(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Pe(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Pe(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Pe(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(Pe(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(s, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-Pe(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, d), this._y = 0)
            }
            return this._order = t, !0 === n && this._onChangeCallback(), this
        }
        setFromQuaternion(e, t, n) {
            return Kt.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Kt, t, n)
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t)
        }
        reorder(e) {
            return Zt.setFromEuler(this), this.setFromQuaternion(Zt, e)
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }
        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}*[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order
        }
    }
    $t.DEFAULT_ORDER = "XYZ";
    class Jt {
        constructor() {
            this.mask = 1
        }
        set(e) {
            this.mask = 1 << e >>> 0
        }
        enable(e) {
            this.mask |= 1 << e
        }
        enableAll() {
            this.mask = -1
        }
        toggle(e) {
            this.mask ^= 1 << e
        }
        disable(e) {
            this.mask &= ~(1 << e)
        }
        disableAll() {
            this.mask = 0
        }
        test(e) {
            return !!(this.mask & e.mask)
        }
        isEnabled(e) {
            return !!(this.mask & 1 << e)
        }
    }
    let Qt = 0;
    const en = new ut,
        tn = new ht,
        nn = new Ht,
        rn = new ut,
        an = new ut,
        sn = new ut,
        on = new ht,
        ln = new ut(1, 0, 0),
        cn = new ut(0, 1, 0),
        hn = new ut(0, 0, 1),
        un = {
            type: "added"
        },
        dn = {
            type: "removed"
        },
        pn = {
            type: "childadded",
            child: null
        },
        mn = {
            type: "childremoved",
            child: null
        };
    class fn extends Te {
        constructor() {
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: Qt++
            }), this.uuid = Le(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fn.DEFAULT_UP.clone();
            const e = new ut,
                t = new $t,
                n = new ht,
                i = new ut(1, 1, 1);
            t._onChange((function() {
                n.setFromEuler(t, !1)
            })), n._onChange((function() {
                t.setFromQuaternion(n, void 0, !1)
            })), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new Ht
                },
                normalMatrix: {
                    value: new Fe
                }
            }), this.matrix = new Ht, this.matrixWorld = new Ht, this.matrixAutoUpdate = fn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = fn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Jt, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0)
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e)
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e)
        }
        rotateOnAxis(e, t) {
            return tn.setFromAxisAngle(e, t), this.quaternion.multiply(tn), this
        }
        rotateOnWorldAxis(e, t) {
            return tn.setFromAxisAngle(e, t), this.quaternion.premultiply(tn), this
        }
        rotateX(e) {
            return this.rotateOnAxis(ln, e)
        }
        rotateY(e) {
            return this.rotateOnAxis(cn, e)
        }
        rotateZ(e) {
            return this.rotateOnAxis(hn, e)
        }
        translateOnAxis(e, t) {
            return en.copy(e).applyQuaternion(this.quaternion), this.position.add(en.multiplyScalar(t)), this
        }
        translateX(e) {
            return this.translateOnAxis(ln, e)
        }
        translateY(e) {
            return this.translateOnAxis(cn, e)
        }
        translateZ(e) {
            return this.translateOnAxis(hn, e)
        }
        localToWorld(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(nn.copy(this.matrixWorld).invert())
        }
        lookAt(e, t, n) {
            e.isVector3 ? rn.copy(e) : rn.set(e, t, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), an.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? nn.lookAt(an, rn, this.up) : nn.lookAt(rn, an, this.up), this.quaternion.setFromRotationMatrix(nn), i && (nn.extractRotation(i.matrixWorld), tn.setFromRotationMatrix(nn), this.quaternion.premultiply(tn.invert()))
        }
        add(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return e === this || e && e.isObject3D && (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(un), pn.child = e, this.dispatchEvent(pn), pn.child = null), this
        }
        remove(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            const t = this.children.indexOf(e);
            return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(dn), mn.child = e, this.dispatchEvent(mn), mn.child = null), this
        }
        removeFromParent() {
            const e = this.parent;
            return null !== e && e.remove(this), this
        }
        clear() {
            return this.remove(...this.children)
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1), nn.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), nn.multiply(e.parent.matrixWorld)), e.applyMatrix4(nn), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(un), pn.child = e, this.dispatchEvent(pn), pn.child = null, this
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e)
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e)
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== i) return i
            }
        }
        getObjectsByProperty(e, t, n = []) {
            this[e] === t && n.push(this);
            const i = this.children;
            for (let r = 0, a = i.length; r < a; r++) i[r].getObjectsByProperty(e, t, n);
            return n
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(an, e, sn), e
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(an, on, e), e
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
        raycast() {}
        traverse(e) {
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
        }
        traverseVisible(e) {
            if (!1 === this.visible) return;
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
        }
        traverseAncestors(e) {
            const t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
        }
        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) {
                const e = this.children;
                for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
            }
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e,
                n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};

            function r(t, n) {
                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
            }
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((e => ({
                    boxInitialized: e.boxInitialized,
                    boxMin: e.box.min.toArray(),
                    boxMax: e.box.max.toArray(),
                    sphereInitialized: e.sphereInitialized,
                    sphereRadius: e.sphere.radius,
                    sphereCenter: e.sphere.center.toArray()
                }))), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), null !== this._colorsTexture && (i.colorsTexture = this._colorsTexture.toJSON(e)), null !== this.boundingSphere && (i.boundingSphere = {
                    center: i.boundingSphere.center.toArray(),
                    radius: i.boundingSphere.radius
                }), null !== this.boundingBox && (i.boundingBox = {
                    min: i.boundingBox.min.toArray(),
                    max: i.boundingBox.max.toArray()
                })), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(e.geometries, this.geometry);
                const t = this.geometry.parameters;
                if (void 0 !== t && void 0 !== t.shapes) {
                    const n = t.shapes;
                    if (Array.isArray(n))
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            r(e.shapes, i)
                        } else r(e.shapes, n)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const t = [];
                    for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
                    i.material = t
                } else i.material = r(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let t = 0; t < this.animations.length; t++) {
                    const n = this.animations[t];
                    i.animations.push(r(e.animations, n))
                }
            }
            if (t) {
                const t = a(e.geometries),
                    i = a(e.materials),
                    r = a(e.textures),
                    s = a(e.images),
                    o = a(e.shapes),
                    l = a(e.skeletons),
                    c = a(e.animations),
                    h = a(e.nodes);
                t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), h.length > 0 && (n.nodes = h)
            }
            return n.object = i, n;

            function a(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    delete i.metadata, t.push(i)
                }
                return t
            }
        }
        clone(e) {
            return (new this.constructor).copy(this, e)
        }
        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (let t = 0; t < e.children.length; t++) {
                    const n = e.children[t];
                    this.add(n.clone())
                }
            return this
        }
    }
    fn.DEFAULT_UP = new ut(0, 1, 0), fn.DEFAULT_MATRIX_AUTO_UPDATE = !0, fn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const gn = new ut,
        _n = new ut,
        vn = new ut,
        yn = new ut,
        xn = new ut,
        bn = new ut,
        wn = new ut,
        Sn = new ut,
        Mn = new ut,
        Tn = new ut,
        En = new st,
        An = new st,
        Rn = new st;
    class Cn {
        constructor(e = new ut, t = new ut, n = new ut) {
            this.a = e, this.b = t, this.c = n
        }
        static getNormal(e, t, n, i) {
            i.subVectors(n, t), gn.subVectors(e, t), i.cross(gn);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        }
        static getBarycoord(e, t, n, i, r) {
            gn.subVectors(i, t), _n.subVectors(n, t), vn.subVectors(e, t);
            const a = gn.dot(gn),
                s = gn.dot(_n),
                o = gn.dot(vn),
                l = _n.dot(_n),
                c = _n.dot(vn),
                h = a * l - s * s;
            if (0 === h) return r.set(0, 0, 0), null;
            const u = 1 / h,
                d = (l * o - s * c) * u,
                p = (a * c - s * o) * u;
            return r.set(1 - d - p, p, d)
        }
        static containsPoint(e, t, n, i) {
            return null !== this.getBarycoord(e, t, n, i, yn) && yn.x >= 0 && yn.y >= 0 && yn.x + yn.y <= 1
        }
        static getInterpolation(e, t, n, i, r, a, s, o) {
            return null === this.getBarycoord(e, t, n, i, yn) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, yn.x), o.addScaledVector(a, yn.y), o.addScaledVector(s, yn.z), o)
        }
        static getInterpolatedAttribute(e, t, n, i, r, a) {
            return En.setScalar(0), An.setScalar(0), Rn.setScalar(0), En.fromBufferAttribute(e, t), An.fromBufferAttribute(e, n), Rn.fromBufferAttribute(e, i), a.setScalar(0), a.addScaledVector(En, r.x), a.addScaledVector(An, r.y), a.addScaledVector(Rn, r.z), a
        }
        static isFrontFacing(e, t, n, i) {
            return gn.subVectors(n, t), _n.subVectors(e, t), gn.cross(_n).dot(i) < 0
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        }
        setFromPointsAndIndices(e, t, n, i) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
        }
        setFromAttributeAndIndices(e, t, n, i) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        }
        getArea() {
            return gn.subVectors(this.c, this.b), _n.subVectors(this.a, this.b), .5 * gn.cross(_n).length()
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(e) {
            return Cn.getNormal(this.a, this.b, this.c, e)
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(e, t) {
            return Cn.getBarycoord(e, this.a, this.b, this.c, t)
        }
        getInterpolation(e, t, n, i, r) {
            return Cn.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
        }
        containsPoint(e) {
            return Cn.containsPoint(e, this.a, this.b, this.c)
        }
        isFrontFacing(e) {
            return Cn.isFrontFacing(this.a, this.b, this.c, e)
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this)
        }
        closestPointToPoint(e, t) {
            const n = this.a,
                i = this.b,
                r = this.c;
            let a, s;
            xn.subVectors(i, n), bn.subVectors(r, n), Sn.subVectors(e, n);
            const o = xn.dot(Sn),
                l = bn.dot(Sn);
            if (o <= 0 && l <= 0) return t.copy(n);
            Mn.subVectors(e, i);
            const c = xn.dot(Mn),
                h = bn.dot(Mn);
            if (c >= 0 && h <= c) return t.copy(i);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0) return a = o / (o - c), t.copy(n).addScaledVector(xn, a);
            Tn.subVectors(e, r);
            const d = xn.dot(Tn),
                p = bn.dot(Tn);
            if (p >= 0 && d <= p) return t.copy(r);
            const m = d * l - o * p;
            if (m <= 0 && l >= 0 && p <= 0) return s = l / (l - p), t.copy(n).addScaledVector(bn, s);
            const f = c * p - d * h;
            if (f <= 0 && h - c >= 0 && d - p >= 0) return wn.subVectors(r, i), s = (h - c) / (h - c + (d - p)), t.copy(i).addScaledVector(wn, s);
            const g = 1 / (f + m + u);
            return a = m * g, s = u * g, t.copy(n).addScaledVector(xn, a).addScaledVector(bn, s)
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }
    const Ln = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        Pn = {
            h: 0,
            s: 0,
            l: 0
        },
        Dn = {
            h: 0,
            s: 0,
            l: 0
        };

    function Un(e, t, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }
    class In {
        constructor(e, t, n) {
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
        }
        set(e, t, n) {
            if (void 0 === t && void 0 === n) {
                const t = e;
                t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
            } else this.setRGB(e, t, n);
            return this
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this
        }
        setHex(e, t = ge) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, qe.toWorkingColorSpace(this, t), this
        }
        setRGB(e, t, n, i = qe.workingColorSpace) {
            return this.r = e, this.g = t, this.b = n, qe.toWorkingColorSpace(this, i), this
        }
        setHSL(e, t, n, i = qe.workingColorSpace) {
            if (e = De(e, 1), t = Pe(t, 0, 1), n = Pe(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
            else {
                const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                    r = 2 * n - i;
                this.r = Un(r, i, e + 1 / 3), this.g = Un(r, i, e), this.b = Un(r, i, e - 1 / 3)
            }
            return qe.toWorkingColorSpace(this, i), this
        }
        setStyle(e, t = ge) {
            function n(e) {
                void 0 !== e && parseFloat(e)
            }
            let i;
            if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                let e;
                const r = i[1],
                    a = i[2];
                switch (r) {
                    case "rgb":
                    case "rgba":
                        if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(e[4]), this.setRGB(Math.min(255, parseInt(e[1], 10)) / 255, Math.min(255, parseInt(e[2], 10)) / 255, Math.min(255, parseInt(e[3], 10)) / 255, t);
                        if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(e[4]), this.setRGB(Math.min(100, parseInt(e[1], 10)) / 100, Math.min(100, parseInt(e[2], 10)) / 100, Math.min(100, parseInt(e[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(e[4]), this.setHSL(parseFloat(e[1]) / 360, parseFloat(e[2]) / 100, parseFloat(e[3]) / 100, t)
                }
            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const e = i[1],
                    n = e.length;
                if (3 === n) return this.setRGB(parseInt(e.charAt(0), 16) / 15, parseInt(e.charAt(1), 16) / 15, parseInt(e.charAt(2), 16) / 15, t);
                if (6 === n) return this.setHex(parseInt(e, 16), t)
            } else if (e && e.length > 0) return this.setColorName(e, t);
            return this
        }
        setColorName(e, t = ge) {
            const n = Ln[e.toLowerCase()];
            return void 0 !== n && this.setHex(n, t), this
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b)
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        }
        copySRGBToLinear(e) {
            return this.r = Xe(e.r), this.g = Xe(e.g), this.b = Xe(e.b), this
        }
        copyLinearToSRGB(e) {
            return this.r = je(e.r), this.g = je(e.g), this.b = je(e.b), this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
        }
        getHex(e = ge) {
            return qe.fromWorkingColorSpace(Nn.copy(this), e), 65536 * Math.round(Pe(255 * Nn.r, 0, 255)) + 256 * Math.round(Pe(255 * Nn.g, 0, 255)) + Math.round(Pe(255 * Nn.b, 0, 255))
        }
        getHexString(e = ge) {
            return ("000000" + this.getHex(e).toString(16)).slice(-6)
        }
        getHSL(e, t = qe.workingColorSpace) {
            qe.fromWorkingColorSpace(Nn.copy(this), t);
            const n = Nn.r,
                i = Nn.g,
                r = Nn.b,
                a = Math.max(n, i, r),
                s = Math.min(n, i, r);
            let o, l;
            const c = (s + a) / 2;
            if (s === a) o = 0, l = 0;
            else {
                const e = a - s;
                switch (l = c <= .5 ? e / (a + s) : e / (2 - a - s), a) {
                    case n:
                        o = (i - r) / e + (i < r ? 6 : 0);
                        break;
                    case i:
                        o = (r - n) / e + 2;
                        break;
                    case r:
                        o = (n - i) / e + 4
                }
                o /= 6
            }
            return e.h = o, e.s = l, e.l = c, e
        }
        getRGB(e, t = qe.workingColorSpace) {
            return qe.fromWorkingColorSpace(Nn.copy(this), t), e.r = Nn.r, e.g = Nn.g, e.b = Nn.b, e
        }
        getStyle(e = ge) {
            qe.fromWorkingColorSpace(Nn.copy(this), e);
            const t = Nn.r,
                n = Nn.g,
                i = Nn.b;
            return e !== ge ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255*t)},${Math.round(255*n)},${Math.round(255*i)})`
        }
        offsetHSL(e, t, n) {
            return this.getHSL(Pn), this.setHSL(Pn.h + e, Pn.s + t, Pn.l + n)
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
        }
        lerpHSL(e, t) {
            this.getHSL(Pn), e.getHSL(Dn);
            const n = Ue(Pn.h, Dn.h, t),
                i = Ue(Pn.s, Dn.s, t),
                r = Ue(Pn.l, Dn.l, t);
            return this.setHSL(n, i, r), this
        }
        setFromVector3(e) {
            return this.r = e.x, this.g = e.y, this.b = e.z, this
        }
        applyMatrix3(e) {
            const t = this.r,
                n = this.g,
                i = this.b,
                r = e.elements;
            return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
        }
        toJSON() {
            return this.getHex()
        }*[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b
        }
    }
    const Nn = new In;
    In.NAMES = Ln;
    let On = 0;
    class kn extends Te {
        static get type() {
            return "Material"
        }
        get type() {
            return this.constructor.type
        }
        set type(e) {}
        constructor() {
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: On++
            }), this.uuid = Le(), this.name = "", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = i, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new In(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = xe, this.stencilZFail = xe, this.stencilZPass = xe, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
        }
        get alphaTest() {
            return this._alphaTest
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }
        setValues(e) {
            if (void 0 !== e)
                for (const t in e) {
                    const n = e[t];
                    if (void 0 === n) continue;
                    const i = this[t];
                    void 0 !== i && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n)
                }
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function r(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    delete i.metadata, t.push(i)
                }
                return t
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (n.dispersion = this.dispersion), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), 204 !== this.blendSrc && (n.blendSrc = this.blendSrc), 205 !== this.blendDst && (n.blendDst = this.blendDst), this.blendEquation !== i && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== xe && (n.stencilFail = this.stencilFail), this.stencilZFail !== xe && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== xe && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
                const t = r(e.textures),
                    i = r(e.images);
                t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i)
            }
            return n
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (null !== t) {
                const e = t.length;
                n = new Array(e);
                for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        onBuild() {}
    }
    class Fn extends kn {
        static get type() {
            return "MeshBasicMaterial"
        }
        constructor(e) {
            super(), this.isMeshBasicMaterial = !0, this.color = new In(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $t, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
        }
    }
    const Bn = new ut,
        zn = new ke;
    class Hn {
        constructor(e, t, n = !1) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = be, this.updateRanges = [], this.gpuType = w, this.version = 0
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
        }
        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        copyArray(e) {
            return this.array.set(e), this
        }
        applyMatrix3(e) {
            if (2 === this.itemSize)
                for (let t = 0, n = this.count; t < n; t++) zn.fromBufferAttribute(this, t), zn.applyMatrix3(e), this.setXY(t, zn.x, zn.y);
            else if (3 === this.itemSize)
                for (let t = 0, n = this.count; t < n; t++) Bn.fromBufferAttribute(this, t), Bn.applyMatrix3(e), this.setXYZ(t, Bn.x, Bn.y, Bn.z);
            return this
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.count; t < n; t++) Bn.fromBufferAttribute(this, t), Bn.applyMatrix4(e), this.setXYZ(t, Bn.x, Bn.y, Bn.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Bn.fromBufferAttribute(this, t), Bn.applyNormalMatrix(e), this.setXYZ(t, Bn.x, Bn.y, Bn.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Bn.fromBufferAttribute(this, t), Bn.transformDirection(e), this.setXYZ(t, Bn.x, Bn.y, Bn.z);
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        getComponent(e, t) {
            let n = this.array[e * this.itemSize + t];
            return this.normalized && (n = Ie(n, this.array)), n
        }
        setComponent(e, t, n) {
            return this.normalized && (n = Ne(n, this.array)), this.array[e * this.itemSize + t] = n, this
        }
        getX(e) {
            let t = this.array[e * this.itemSize];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        setX(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.array[e * this.itemSize] = t, this
        }
        getY(e) {
            let t = this.array[e * this.itemSize + 1];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        setY(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.array[e * this.itemSize + 1] = t, this
        }
        getZ(e) {
            let t = this.array[e * this.itemSize + 2];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        setZ(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.array[e * this.itemSize + 2] = t, this
        }
        getW(e) {
            let t = this.array[e * this.itemSize + 3];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        setW(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.array[e * this.itemSize + 3] = t, this
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.normalized && (t = Ne(t, this.array), n = Ne(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e *= this.itemSize, this.normalized && (t = Ne(t, this.array), n = Ne(n, this.array), i = Ne(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, r) {
            return e *= this.itemSize, this.normalized && (t = Ne(t, this.array), n = Ne(n, this.array), i = Ne(i, this.array), r = Ne(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (e.name = this.name), this.usage !== be && (e.usage = this.usage), e
        }
    }
    class Vn extends Hn {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }
    class Gn extends Hn {
        constructor(e, t, n) {
            super(new Uint32Array(e), t, n)
        }
    }
    class Wn extends Hn {
        constructor(e, t, n) {
            super(new Float32Array(e), t, n)
        }
    }
    let qn = 0;
    const Xn = new Ht,
        jn = new fn,
        Yn = new ut,
        Kn = new mt,
        Zn = new mt,
        $n = new ut;
    class Jn extends Te {
        constructor() {
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: qn++
            }), this.uuid = Le(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new(ze(e) ? Gn : Vn)(e, 1) : this.index = e, this
        }
        setIndirect(e) {
            return this.indirect = e, this
        }
        getIndirect() {
            return this.indirect
        }
        getAttribute(e) {
            return this.attributes[e]
        }
        setAttribute(e, t) {
            return this.attributes[e] = t, this
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this
        }
        hasAttribute(e) {
            return void 0 !== this.attributes[e]
        }
        addGroup(e, t, n = 0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        }
        applyMatrix4(e) {
            const t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const t = (new Fe).getNormalMatrix(e);
                n.applyNormalMatrix(t), n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        }
        applyQuaternion(e) {
            return Xn.makeRotationFromQuaternion(e), this.applyMatrix4(Xn), this
        }
        rotateX(e) {
            return Xn.makeRotationX(e), this.applyMatrix4(Xn), this
        }
        rotateY(e) {
            return Xn.makeRotationY(e), this.applyMatrix4(Xn), this
        }
        rotateZ(e) {
            return Xn.makeRotationZ(e), this.applyMatrix4(Xn), this
        }
        translate(e, t, n) {
            return Xn.makeTranslation(e, t, n), this.applyMatrix4(Xn), this
        }
        scale(e, t, n) {
            return Xn.makeScale(e, t, n), this.applyMatrix4(Xn), this
        }
        lookAt(e) {
            return jn.lookAt(e), jn.updateMatrix(), this.applyMatrix4(jn.matrix), this
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Yn).negate(), this.translate(Yn.x, Yn.y, Yn.z), this
        }
        setFromPoints(e) {
            const t = this.getAttribute("position");
            if (void 0 === t) {
                const t = [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    t.push(i.x, i.y, i.z || 0)
                }
                this.setAttribute("position", new Wn(t, 3))
            } else {
                for (let n = 0, i = t.count; n < i; n++) {
                    const i = e[n];
                    t.setXYZ(n, i.x, i.y, i.z || 0)
                }
                e.length, t.count, t.needsUpdate = !0
            }
            return this
        }
        computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new mt);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) this.boundingBox.set(new ut(-1 / 0, -1 / 0, -1 / 0), new ut(1 / 0, 1 / 0, 1 / 0));
            else {
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            Kn.setFromBufferAttribute(n), this.morphTargetsRelative ? ($n.addVectors(this.boundingBox.min, Kn.min), this.boundingBox.expandByPoint($n), $n.addVectors(this.boundingBox.max, Kn.max), this.boundingBox.expandByPoint($n)) : (this.boundingBox.expandByPoint(Kn.min), this.boundingBox.expandByPoint(Kn.max))
                        }
                } else this.boundingBox.makeEmpty();
                isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
            }
        }
        computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new Dt);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) this.boundingSphere.set(new ut, 1 / 0);
            else if (e) {
                const n = this.boundingSphere.center;
                if (Kn.setFromBufferAttribute(e), t)
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        Zn.setFromBufferAttribute(n), this.morphTargetsRelative ? ($n.addVectors(Kn.min, Zn.min), Kn.expandByPoint($n), $n.addVectors(Kn.max, Zn.max), Kn.expandByPoint($n)) : (Kn.expandByPoint(Zn.min), Kn.expandByPoint(Zn.max))
                    }
                Kn.getCenter(n);
                let i = 0;
                for (let t = 0, r = e.count; t < r; t++) $n.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared($n));
                if (t)
                    for (let r = 0, a = t.length; r < a; r++) {
                        const a = t[r],
                            s = this.morphTargetsRelative;
                        for (let t = 0, r = a.count; t < r; t++) $n.fromBufferAttribute(a, t), s && (Yn.fromBufferAttribute(e, t), $n.add(Yn)), i = Math.max(i, n.distanceToSquared($n))
                    }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius)
            }
        }
        computeTangents() {
            const e = this.index,
                t = this.attributes;
            if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return;
            const n = t.position,
                i = t.normal,
                r = t.uv;
            !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Hn(new Float32Array(4 * n.count), 4));
            const a = this.getAttribute("tangent"),
                s = [],
                o = [];
            for (let e = 0; e < n.count; e++) s[e] = new ut, o[e] = new ut;
            const l = new ut,
                c = new ut,
                h = new ut,
                u = new ke,
                d = new ke,
                p = new ke,
                m = new ut,
                f = new ut;

            function g(e, t, i) {
                l.fromBufferAttribute(n, e), c.fromBufferAttribute(n, t), h.fromBufferAttribute(n, i), u.fromBufferAttribute(r, e), d.fromBufferAttribute(r, t), p.fromBufferAttribute(r, i), c.sub(l), h.sub(l), d.sub(u), p.sub(u);
                const a = 1 / (d.x * p.y - p.x * d.y);
                isFinite(a) && (m.copy(c).multiplyScalar(p.y).addScaledVector(h, -d.y).multiplyScalar(a), f.copy(h).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(a), s[e].add(m), s[t].add(m), s[i].add(m), o[e].add(f), o[t].add(f), o[i].add(f))
            }
            let _ = this.groups;
            0 === _.length && (_ = [{
                start: 0,
                count: e.count
            }]);
            for (let t = 0, n = _.length; t < n; ++t) {
                const n = _[t],
                    i = n.start;
                for (let t = i, r = i + n.count; t < r; t += 3) g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
            }
            const v = new ut,
                y = new ut,
                x = new ut,
                b = new ut;

            function w(e) {
                x.fromBufferAttribute(i, e), b.copy(x);
                const t = s[e];
                v.copy(t), v.sub(x.multiplyScalar(x.dot(t))).normalize(), y.crossVectors(b, t);
                const n = y.dot(o[e]) < 0 ? -1 : 1;
                a.setXYZW(e, v.x, v.y, v.z, n)
            }
            for (let t = 0, n = _.length; t < n; ++t) {
                const n = _[t],
                    i = n.start;
                for (let t = i, r = i + n.count; t < r; t += 3) w(e.getX(t + 0)), w(e.getX(t + 1)), w(e.getX(t + 2))
            }
        }
        computeVertexNormals() {
            const e = this.index,
                t = this.getAttribute("position");
            if (void 0 !== t) {
                let n = this.getAttribute("normal");
                if (void 0 === n) n = new Hn(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                else
                    for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                const i = new ut,
                    r = new ut,
                    a = new ut,
                    s = new ut,
                    o = new ut,
                    l = new ut,
                    c = new ut,
                    h = new ut;
                if (e)
                    for (let u = 0, d = e.count; u < d; u += 3) {
                        const d = e.getX(u + 0),
                            p = e.getX(u + 1),
                            m = e.getX(u + 2);
                        i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), a.fromBufferAttribute(t, m), c.subVectors(a, r), h.subVectors(i, r), c.cross(h), s.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), s.add(c), o.add(c), l.add(c), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z)
                    } else
                        for (let e = 0, s = t.count; e < s; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), a.fromBufferAttribute(t, e + 2), c.subVectors(a, r), h.subVectors(i, r), c.cross(h), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        }
        normalizeNormals() {
            const e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++) $n.fromBufferAttribute(e, t), $n.normalize(), e.setXYZ(t, $n.x, $n.y, $n.z)
        }
        toNonIndexed() {
            function e(e, t) {
                const n = e.array,
                    i = e.itemSize,
                    r = e.normalized,
                    a = new n.constructor(t.length * i);
                let s = 0,
                    o = 0;
                for (let r = 0, l = t.length; r < l; r++) {
                    s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                    for (let e = 0; e < i; e++) a[o++] = n[s++]
                }
                return new Hn(a, i, r)
            }
            if (null === this.index) return this;
            const t = new Jn,
                n = this.index.array,
                i = this.attributes;
            for (const r in i) {
                const a = e(i[r], n);
                t.setAttribute(r, a)
            }
            const r = this.morphAttributes;
            for (const i in r) {
                const a = [],
                    s = r[i];
                for (let t = 0, i = s.length; t < i; t++) {
                    const i = e(s[t], n);
                    a.push(i)
                }
                t.morphAttributes[i] = a
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for (let e = 0, n = a.length; e < n; e++) {
                const n = a[e];
                t.addGroup(n.start, n.count, n.materialIndex)
            }
            return t
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.6,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                const t = this.parameters;
                for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            null !== t && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for (const t in n) {
                const i = n[t];
                e.data.attributes[t] = i.toJSON(e.data)
            }
            const i = {};
            let r = !1;
            for (const t in this.morphAttributes) {
                const n = this.morphAttributes[t],
                    a = [];
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    a.push(i.toJSON(e.data))
                }
                a.length > 0 && (i[t] = a, r = !0)
            }
            r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const a = this.groups;
            a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
            const s = this.boundingSphere;
            return null !== s && (e.data.boundingSphere = {
                center: s.center.toArray(),
                radius: s.radius
            }), e
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            null !== n && this.setIndex(n.clone(t));
            const i = e.attributes;
            for (const e in i) {
                const n = i[e];
                this.setAttribute(e, n.clone(t))
            }
            const r = e.morphAttributes;
            for (const e in r) {
                const n = [],
                    i = r[e];
                for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                this.morphAttributes[e] = n
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const a = e.groups;
            for (let e = 0, t = a.length; e < t; e++) {
                const t = a[e];
                this.addGroup(t.start, t.count, t.materialIndex)
            }
            const s = e.boundingBox;
            null !== s && (this.boundingBox = s.clone());
            const o = e.boundingSphere;
            return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    const Qn = new Ht,
        ei = new zt,
        ti = new Dt,
        ni = new ut,
        ii = new ut,
        ri = new ut,
        ai = new ut,
        si = new ut,
        oi = new ut,
        li = new ut,
        ci = new ut;
    class hi extends fn {
        constructor(e = new Jn, t = new Fn) {
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        updateMorphTargets() {
            const e = this.geometry.morphAttributes,
                t = Object.keys(e);
            if (t.length > 0) {
                const n = e[t[0]];
                if (void 0 !== n) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let e = 0, t = n.length; e < t; e++) {
                        const t = n[e].name || String(e);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                    }
                }
            }
        }
        getVertexPosition(e, t) {
            const n = this.geometry,
                i = n.attributes.position,
                r = n.morphAttributes.position,
                a = n.morphTargetsRelative;
            t.fromBufferAttribute(i, e);
            const s = this.morphTargetInfluences;
            if (r && s) {
                oi.set(0, 0, 0);
                for (let n = 0, i = r.length; n < i; n++) {
                    const i = s[n],
                        o = r[n];
                    0 !== i && (si.fromBufferAttribute(o, e), a ? oi.addScaledVector(si, i) : oi.addScaledVector(si.sub(t), i))
                }
                t.add(oi)
            }
            return t
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.material,
                r = this.matrixWorld;
            if (void 0 !== i) {
                if (null === n.boundingSphere && n.computeBoundingSphere(), ti.copy(n.boundingSphere), ti.applyMatrix4(r), ei.copy(e.ray).recast(e.near), !1 === ti.containsPoint(ei.origin)) {
                    if (null === ei.intersectSphere(ti, ni)) return;
                    if (ei.origin.distanceToSquared(ni) > (e.far - e.near) ** 2) return
                }
                Qn.copy(r).invert(), ei.copy(e.ray).applyMatrix4(Qn), null !== n.boundingBox && !1 === ei.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, ei)
            }
        }
        _computeIntersections(e, t, n) {
            let i;
            const r = this.geometry,
                a = this.material,
                s = r.index,
                o = r.attributes.position,
                l = r.attributes.uv,
                c = r.attributes.uv1,
                h = r.attributes.normal,
                u = r.groups,
                d = r.drawRange;
            if (null !== s)
                if (Array.isArray(a))
                    for (let r = 0, o = u.length; r < o; r++) {
                        const o = u[r],
                            p = a[o.materialIndex];
                        for (let r = Math.max(o.start, d.start), a = Math.min(s.count, Math.min(o.start + o.count, d.start + d.count)); r < a; r += 3) i = ui(this, p, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = o.materialIndex, t.push(i))
                    } else
                        for (let r = Math.max(0, d.start), o = Math.min(s.count, d.start + d.count); r < o; r += 3) i = ui(this, a, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), t.push(i));
                else if (void 0 !== o)
                if (Array.isArray(a))
                    for (let r = 0, s = u.length; r < s; r++) {
                        const s = u[r],
                            p = a[s.materialIndex];
                        for (let r = Math.max(s.start, d.start), a = Math.min(o.count, Math.min(s.start + s.count, d.start + d.count)); r < a; r += 3) i = ui(this, p, e, n, l, c, h, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = s.materialIndex, t.push(i))
                    } else
                        for (let r = Math.max(0, d.start), s = Math.min(o.count, d.start + d.count); r < s; r += 3) i = ui(this, a, e, n, l, c, h, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), t.push(i))
        }
    }

    function ui(e, t, n, i, r, a, s, o, l, c) {
        e.getVertexPosition(o, ii), e.getVertexPosition(l, ri), e.getVertexPosition(c, ai);
        const h = function(e, t, n, i, r, a, s, o) {
            let l;
            if (l = 1 === t.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 0 === t.side, o), null === l) return null;
            ci.copy(o), ci.applyMatrix4(e.matrixWorld);
            const c = n.ray.origin.distanceTo(ci);
            return c < n.near || c > n.far ? null : {
                distance: c,
                point: ci.clone(),
                object: e
            }
        }(e, t, n, i, ii, ri, ai, li);
        if (h) {
            const e = new ut;
            Cn.getBarycoord(li, ii, ri, ai, e), r && (h.uv = Cn.getInterpolatedAttribute(r, o, l, c, e, new ke)), a && (h.uv1 = Cn.getInterpolatedAttribute(a, o, l, c, e, new ke)), s && (h.normal = Cn.getInterpolatedAttribute(s, o, l, c, e, new ut), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
            const t = {
                a: o,
                b: l,
                c: c,
                normal: new ut,
                materialIndex: 0
            };
            Cn.getNormal(ii, ri, ai, t.normal), h.face = t, h.barycoord = e
        }
        return h
    }
    class di extends Jn {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: a
            };
            const s = this;
            i = Math.floor(i), r = Math.floor(r), a = Math.floor(a);
            const o = [],
                l = [],
                c = [],
                h = [];
            let u = 0,
                d = 0;

            function p(e, t, n, i, r, a, p, m, f, g, _) {
                const v = a / f,
                    y = p / g,
                    x = a / 2,
                    b = p / 2,
                    w = m / 2,
                    S = f + 1,
                    M = g + 1;
                let T = 0,
                    E = 0;
                const A = new ut;
                for (let a = 0; a < M; a++) {
                    const s = a * y - b;
                    for (let o = 0; o < S; o++) {
                        const u = o * v - x;
                        A[e] = u * i, A[t] = s * r, A[n] = w, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / f), h.push(1 - a / g), T += 1
                    }
                }
                for (let e = 0; e < g; e++)
                    for (let t = 0; t < f; t++) {
                        const n = u + t + S * e,
                            i = u + t + S * (e + 1),
                            r = u + (t + 1) + S * (e + 1),
                            a = u + (t + 1) + S * e;
                        o.push(n, i, a), o.push(i, r, a), E += 6
                    }
                s.addGroup(d, E, _), d += E, u += T
            }
            p("z", "y", "x", -1, -1, n, t, e, a, r, 0), p("z", "y", "x", 1, -1, n, t, -e, a, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, a, 2), p("x", "z", "y", 1, -1, e, n, -t, i, a, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Wn(l, 3)), this.setAttribute("normal", new Wn(c, 3)), this.setAttribute("uv", new Wn(h, 2))
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
        }
        static fromJSON(e) {
            return new di(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
        }
    }

    function pi(e) {
        const t = {};
        for (const n in e) {
            t[n] = {};
            for (const i in e[n]) {
                const r = e[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? t[n][i] = null : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
            }
        }
        return t
    }

    function mi(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const i = pi(e[n]);
            for (const e in i) t[e] = i[e]
        }
        return t
    }

    function fi(e) {
        const t = e.getRenderTarget();
        return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : qe.workingColorSpace
    }
    const gi = {
        clone: pi,
        merge: mi
    };
    class _i extends kn {
        static get type() {
            return "ShaderMaterial"
        }
        constructor(e) {
            super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv1: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = pi(e.uniforms), this.uniformsGroups = function(e) {
                const t = [];
                for (let n = 0; n < e.length; n++) t.push(e[n].clone());
                return t
            }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for (const n in this.uniforms) {
                const i = this.uniforms[n].value;
                i && i.isTexture ? t.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(e).uuid
                } : i && i.isColor ? t.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? t.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? t.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? t.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? t.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? t.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : t.uniforms[n] = {
                    value: i
                }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
            const n = {};
            for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t
        }
    }
    class vi extends fn {
        constructor() {
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ht, this.projectionMatrix = new Ht, this.projectionMatrixInverse = new Ht, this.coordinateSystem = Se
        }
        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
        }
        getWorldDirection(e) {
            return super.getWorldDirection(e).negate()
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const yi = new ut,
        xi = new ke,
        bi = new ke;
    class wi extends vi {
        constructor(e = 50, t = 1, n = .1, i = 2e3) {
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        }
        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * Ce * Math.atan(t), this.updateProjectionMatrix()
        }
        getFocalLength() {
            const e = Math.tan(.5 * Re * this.fov);
            return .5 * this.getFilmHeight() / e
        }
        getEffectiveFOV() {
            return 2 * Ce * Math.atan(Math.tan(.5 * Re * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        getViewBounds(e, t, n) {
            yi.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(yi.x, yi.y).multiplyScalar(-e / yi.z), yi.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(yi.x, yi.y).multiplyScalar(-e / yi.z)
        }
        getViewSize(e, t) {
            return this.getViewBounds(e, xi, bi), t.subVectors(bi, xi)
        }
        setViewOffset(e, t, n, i, r, a) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(.5 * Re * this.fov) / this.zoom,
                n = 2 * t,
                i = this.aspect * n,
                r = -.5 * i;
            const a = this.view;
            if (null !== this.view && this.view.enabled) {
                const e = a.fullWidth,
                    s = a.fullHeight;
                r += a.offsetX * i / e, t -= a.offsetY * n / s, i *= a.width / e, n *= a.height / s
            }
            const s = this.filmOffset;
            0 !== s && (r += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }
    const Si = -90;
    class Mi extends fn {
        constructor(e, t, n) {
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
            const i = new wi(Si, 1, e, t);
            i.layers = this.layers, this.add(i);
            const r = new wi(Si, 1, e, t);
            r.layers = this.layers, this.add(r);
            const a = new wi(Si, 1, e, t);
            a.layers = this.layers, this.add(a);
            const s = new wi(Si, 1, e, t);
            s.layers = this.layers, this.add(s);
            const o = new wi(Si, 1, e, t);
            o.layers = this.layers, this.add(o);
            const l = new wi(Si, 1, e, t);
            l.layers = this.layers, this.add(l)
        }
        updateCoordinateSystem() {
            const e = this.coordinateSystem,
                t = this.children.concat(),
                [n, i, r, a, s, o] = t;
            for (const e of t) this.remove(e);
            if (e === Se) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);
            else {
                if (e !== Me) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), s.up.set(0, -1, 0), s.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1)
            }
            for (const e of t) this.add(e), e.updateMatrixWorld()
        }
        update(e, t) {
            null === this.parent && this.updateMatrixWorld();
            const {
                renderTarget: n,
                activeMipmapLevel: i
            } = this;
            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
            const [r, a, s, o, l, c] = this.children, h = e.getRenderTarget(), u = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), p = e.xr.enabled;
            e.xr.enabled = !1;
            const m = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, a), e.setRenderTarget(n, 2, i), e.render(t, s), e.setRenderTarget(n, 3, i), e.render(t, o), e.setRenderTarget(n, 4, i), e.render(t, l), n.texture.generateMipmaps = m, e.setRenderTarget(n, 5, i), e.render(t, c), e.setRenderTarget(h, u, d), e.xr.enabled = p, n.texture.needsPMREMUpdate = !0
        }
    }
    class Ti extends at {
        constructor(e, t, n, i, r, s, o, l, c, h) {
            super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : a, n, i, r, s, o, l, c, h), this.isCubeTexture = !0, this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(e) {
            this.image = e
        }
    }
    class Ei extends lt {
        constructor(e = 1, t = {}) {
            super(e, e, t), this.isWebGLCubeRenderTarget = !0;
            const n = {
                    width: e,
                    height: e,
                    depth: 1
                },
                i = [n, n, n, n, n, n];
            this.texture = new Ti(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : p
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                    tEquirect: {
                        value: null
                    }
                },
                i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                a = new di(5, 5, 5),
                s = new _i({
                    name: "CubemapFromEquirect",
                    uniforms: pi(n),
                    vertexShader: i,
                    fragmentShader: r,
                    side: 1,
                    blending: 0
                });
            s.uniforms.tEquirect.value = t;
            const o = new hi(a, s),
                l = t.minFilter;
            return t.minFilter === f && (t.minFilter = p), new Mi(1, 10, this).update(e, o), t.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
        }
        clear(e, t, n, i) {
            const r = e.getRenderTarget();
            for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
            e.setRenderTarget(r)
        }
    }
    const Ai = new ut,
        Ri = new ut,
        Ci = new Fe;
    class Li {
        constructor(e = new ut(1, 0, 0), t = 0) {
            this.isPlane = !0, this.normal = e, this.constant = t
        }
        set(e, t) {
            return this.normal.copy(e), this.constant = t, this
        }
        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n), this.constant = i, this
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        }
        setFromCoplanarPoints(e, t, n) {
            const i = Ai.subVectors(n, t).cross(Ri.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e), this
        }
        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
        }
        projectPoint(e, t) {
            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
        }
        intersectLine(e, t) {
            const n = e.delta(Ai),
                i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
            const r = -(e.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        }
        intersectsBox(e) {
            return e.intersectsPlane(this)
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this)
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(e, t) {
            const n = t || Ci.getNormalMatrix(e),
                i = this.coplanarPoint(Ai).applyMatrix4(e),
                r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r), this
        }
        translate(e) {
            return this.constant -= e.dot(this.normal), this
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const Pi = new Dt,
        Di = new ut;
    class Ui {
        constructor(e = new Li, t = new Li, n = new Li, i = new Li, r = new Li, a = new Li) {
            this.planes = [e, t, n, i, r, a]
        }
        set(e, t, n, i, r, a) {
            const s = this.planes;
            return s[0].copy(e), s[1].copy(t), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(a), this
        }
        copy(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        }
        setFromProjectionMatrix(e, t = 2e3) {
            const n = this.planes,
                i = e.elements,
                r = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = i[4],
                c = i[5],
                h = i[6],
                u = i[7],
                d = i[8],
                p = i[9],
                m = i[10],
                f = i[11],
                g = i[12],
                _ = i[13],
                v = i[14],
                y = i[15];
            if (n[0].setComponents(o - r, u - l, f - d, y - g).normalize(), n[1].setComponents(o + r, u + l, f + d, y + g).normalize(), n[2].setComponents(o + a, u + c, f + p, y + _).normalize(), n[3].setComponents(o - a, u - c, f - p, y - _).normalize(), n[4].setComponents(o - s, u - h, f - m, y - v).normalize(), t === Se) n[5].setComponents(o + s, u + h, f + m, y + v).normalize();
            else {
                if (t !== Me) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                n[5].setComponents(s, h, m, v).normalize()
            }
            return this
        }
        intersectsObject(e) {
            if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), Pi.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
            else {
                const t = e.geometry;
                null === t.boundingSphere && t.computeBoundingSphere(), Pi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
            }
            return this.intersectsSphere(Pi)
        }
        intersectsSprite(e) {
            return Pi.center.set(0, 0, 0), Pi.radius = .7071067811865476, Pi.applyMatrix4(e.matrixWorld), this.intersectsSphere(Pi)
        }
        intersectsSphere(e) {
            const t = this.planes,
                n = e.center,
                i = -e.radius;
            for (let e = 0; e < 6; e++)
                if (t[e].distanceToPoint(n) < i) return !1;
            return !0
        }
        intersectsBox(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = t[n];
                if (Di.x = i.normal.x > 0 ? e.max.x : e.min.x, Di.y = i.normal.y > 0 ? e.max.y : e.min.y, Di.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Di) < 0) return !1
            }
            return !0
        }
        containsPoint(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }

    function Ii() {
        let e = null,
            t = !1,
            n = null,
            i = null;

        function r(t, a) {
            n(t, a), i = e.requestAnimationFrame(r)
        }
        return {
            start: function() {
                !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0)
            },
            stop: function() {
                e.cancelAnimationFrame(i), t = !1
            },
            setAnimationLoop: function(e) {
                n = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }

    function Ni(e) {
        const t = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
            },
            remove: function(n) {
                n.isInterleavedBufferAttribute && (n = n.data);
                const i = t.get(n);
                i && (e.deleteBuffer(i.buffer), t.delete(n))
            },
            update: function(n, i) {
                if (n.isInterleavedBufferAttribute && (n = n.data), n.isGLBufferAttribute) {
                    const e = t.get(n);
                    return void((!e || e.version < n.version) && t.set(n, {
                        buffer: n.buffer,
                        type: n.type,
                        bytesPerElement: n.elementSize,
                        version: n.version
                    }))
                }
                const r = t.get(n);
                if (void 0 === r) t.set(n, function(t, n) {
                    const i = t.array,
                        r = t.usage,
                        a = i.byteLength,
                        s = e.createBuffer();
                    let o;
                    if (e.bindBuffer(n, s), e.bufferData(n, i, r), t.onUploadCallback(), i instanceof Float32Array) o = e.FLOAT;
                    else if (i instanceof Uint16Array) o = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                    else if (i instanceof Int16Array) o = e.SHORT;
                    else if (i instanceof Uint32Array) o = e.UNSIGNED_INT;
                    else if (i instanceof Int32Array) o = e.INT;
                    else if (i instanceof Int8Array) o = e.BYTE;
                    else if (i instanceof Uint8Array) o = e.UNSIGNED_BYTE;
                    else {
                        if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                        o = e.UNSIGNED_BYTE
                    }
                    return {
                        buffer: s,
                        type: o,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: t.version,
                        size: a
                    }
                }(n, i));
                else if (r.version < n.version) {
                    if (r.size !== n.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                    ! function(t, n, i) {
                        const r = n.array,
                            a = n.updateRanges;
                        if (e.bindBuffer(i, t), 0 === a.length) e.bufferSubData(i, 0, r);
                        else {
                            a.sort(((e, t) => e.start - t.start));
                            let t = 0;
                            for (let e = 1; e < a.length; e++) {
                                const n = a[t],
                                    i = a[e];
                                i.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, i.start + i.count - n.start) : (++t, a[t] = i)
                            }
                            a.length = t + 1;
                            for (let t = 0, n = a.length; t < n; t++) {
                                const n = a[t];
                                e.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                            }
                            n.clearUpdateRanges()
                        }
                        n.onUploadCallback()
                    }(r.buffer, n, i), r.version = n.version
                }
            }
        }
    }
    class Oi extends Jn {
        constructor(e = 1, t = 1, n = 1, i = 1) {
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            const r = e / 2,
                a = t / 2,
                s = Math.floor(n),
                o = Math.floor(i),
                l = s + 1,
                c = o + 1,
                h = e / s,
                u = t / o,
                d = [],
                p = [],
                m = [],
                f = [];
            for (let e = 0; e < c; e++) {
                const t = e * u - a;
                for (let n = 0; n < l; n++) {
                    const i = n * h - r;
                    p.push(i, -t, 0), m.push(0, 0, 1), f.push(n / s), f.push(1 - e / o)
                }
            }
            for (let e = 0; e < o; e++)
                for (let t = 0; t < s; t++) {
                    const n = t + l * e,
                        i = t + l * (e + 1),
                        r = t + 1 + l * (e + 1),
                        a = t + 1 + l * e;
                    d.push(n, i, a), d.push(i, r, a)
                }
            this.setIndex(d), this.setAttribute("position", new Wn(p, 3)), this.setAttribute("normal", new Wn(m, 3)), this.setAttribute("uv", new Wn(f, 2))
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
        }
        static fromJSON(e) {
            return new Oi(e.width, e.height, e.widthSegments, e.heightSegments)
        }
    }
    const ki = {
            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
            batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
        },
        Fi = {
            common: {
                diffuse: {
                    value: new In(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Fe
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Fe
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new Fe
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: new Fe
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new Fe
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new Fe
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new Fe
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new Fe
                },
                normalScale: {
                    value: new ke(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new Fe
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new Fe
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new Fe
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new Fe
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new In(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new In(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Fe
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Fe
                }
            },
            sprite: {
                diffuse: {
                    value: new In(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new ke(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Fe
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Fe
                },
                alphaTest: {
                    value: 0
                }
            }
        },
        Bi = {
            basic: {
                uniforms: mi([Fi.common, Fi.specularmap, Fi.envmap, Fi.aomap, Fi.lightmap, Fi.fog]),
                vertexShader: ki.meshbasic_vert,
                fragmentShader: ki.meshbasic_frag
            },
            lambert: {
                uniforms: mi([Fi.common, Fi.specularmap, Fi.envmap, Fi.aomap, Fi.lightmap, Fi.emissivemap, Fi.bumpmap, Fi.normalmap, Fi.displacementmap, Fi.fog, Fi.lights, {
                    emissive: {
                        value: new In(0)
                    }
                }]),
                vertexShader: ki.meshlambert_vert,
                fragmentShader: ki.meshlambert_frag
            },
            phong: {
                uniforms: mi([Fi.common, Fi.specularmap, Fi.envmap, Fi.aomap, Fi.lightmap, Fi.emissivemap, Fi.bumpmap, Fi.normalmap, Fi.displacementmap, Fi.fog, Fi.lights, {
                    emissive: {
                        value: new In(0)
                    },
                    specular: {
                        value: new In(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ki.meshphong_vert,
                fragmentShader: ki.meshphong_frag
            },
            standard: {
                uniforms: mi([Fi.common, Fi.envmap, Fi.aomap, Fi.lightmap, Fi.emissivemap, Fi.bumpmap, Fi.normalmap, Fi.displacementmap, Fi.roughnessmap, Fi.metalnessmap, Fi.fog, Fi.lights, {
                    emissive: {
                        value: new In(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: ki.meshphysical_vert,
                fragmentShader: ki.meshphysical_frag
            },
            toon: {
                uniforms: mi([Fi.common, Fi.aomap, Fi.lightmap, Fi.emissivemap, Fi.bumpmap, Fi.normalmap, Fi.displacementmap, Fi.gradientmap, Fi.fog, Fi.lights, {
                    emissive: {
                        value: new In(0)
                    }
                }]),
                vertexShader: ki.meshtoon_vert,
                fragmentShader: ki.meshtoon_frag
            },
            matcap: {
                uniforms: mi([Fi.common, Fi.bumpmap, Fi.normalmap, Fi.displacementmap, Fi.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: ki.meshmatcap_vert,
                fragmentShader: ki.meshmatcap_frag
            },
            points: {
                uniforms: mi([Fi.points, Fi.fog]),
                vertexShader: ki.points_vert,
                fragmentShader: ki.points_frag
            },
            dashed: {
                uniforms: mi([Fi.common, Fi.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: ki.linedashed_vert,
                fragmentShader: ki.linedashed_frag
            },
            depth: {
                uniforms: mi([Fi.common, Fi.displacementmap]),
                vertexShader: ki.depth_vert,
                fragmentShader: ki.depth_frag
            },
            normal: {
                uniforms: mi([Fi.common, Fi.bumpmap, Fi.normalmap, Fi.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ki.meshnormal_vert,
                fragmentShader: ki.meshnormal_frag
            },
            sprite: {
                uniforms: mi([Fi.sprite, Fi.fog]),
                vertexShader: ki.sprite_vert,
                fragmentShader: ki.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Fe
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: ki.background_vert,
                fragmentShader: ki.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundRotation: {
                        value: new Fe
                    }
                },
                vertexShader: ki.backgroundCube_vert,
                fragmentShader: ki.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: ki.cube_vert,
                fragmentShader: ki.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ki.equirect_vert,
                fragmentShader: ki.equirect_frag
            },
            distanceRGBA: {
                uniforms: mi([Fi.common, Fi.displacementmap, {
                    referencePosition: {
                        value: new ut
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: ki.distanceRGBA_vert,
                fragmentShader: ki.distanceRGBA_frag
            },
            shadow: {
                uniforms: mi([Fi.lights, Fi.fog, {
                    color: {
                        value: new In(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ki.shadow_vert,
                fragmentShader: ki.shadow_frag
            }
        };
    Bi.physical = {
        uniforms: mi([Bi.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatMapTransform: {
                value: new Fe
            },
            clearcoatNormalMap: {
                value: null
            },
            clearcoatNormalMapTransform: {
                value: new Fe
            },
            clearcoatNormalScale: {
                value: new ke(1, 1)
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatRoughnessMapTransform: {
                value: new Fe
            },
            dispersion: {
                value: 0
            },
            iridescence: {
                value: 0
            },
            iridescenceMap: {
                value: null
            },
            iridescenceMapTransform: {
                value: new Fe
            },
            iridescenceIOR: {
                value: 1.3
            },
            iridescenceThicknessMinimum: {
                value: 100
            },
            iridescenceThicknessMaximum: {
                value: 400
            },
            iridescenceThicknessMap: {
                value: null
            },
            iridescenceThicknessMapTransform: {
                value: new Fe
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new In(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenColorMapTransform: {
                value: new Fe
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            sheenRoughnessMapTransform: {
                value: new Fe
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionMapTransform: {
                value: new Fe
            },
            transmissionSamplerSize: {
                value: new ke
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            thicknessMapTransform: {
                value: new Fe
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new In(0)
            },
            specularColor: {
                value: new In(1, 1, 1)
            },
            specularColorMap: {
                value: null
            },
            specularColorMapTransform: {
                value: new Fe
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularIntensityMapTransform: {
                value: new Fe
            },
            anisotropyVector: {
                value: new ke
            },
            anisotropyMap: {
                value: null
            },
            anisotropyMapTransform: {
                value: new Fe
            }
        }]),
        vertexShader: ki.meshphysical_vert,
        fragmentShader: ki.meshphysical_frag
    };
    const zi = {
            r: 0,
            b: 0,
            g: 0
        },
        Hi = new $t,
        Vi = new Ht;

    function Gi(e, t, n, i, r, a, s) {
        const l = new In(0);
        let c, h, u = !0 === a ? 0 : 1,
            d = null,
            p = 0,
            m = null;

        function f(e) {
            let i = !0 === e.isScene ? e.background : null;
            return i && i.isTexture && (i = (e.backgroundBlurriness > 0 ? n : t).get(i)), i
        }

        function g(t, n) {
            t.getRGB(zi, fi(e)), i.buffers.color.setClear(zi.r, zi.g, zi.b, n, s)
        }
        return {
            getClearColor: function() {
                return l
            },
            setClearColor: function(e, t = 1) {
                l.set(e), u = t, g(l, u)
            },
            getClearAlpha: function() {
                return u
            },
            setClearAlpha: function(e) {
                u = e, g(l, u)
            },
            render: function(t) {
                let n = !1;
                const r = f(t);
                null === r ? g(l, u) : r && r.isColor && (g(r, 1), n = !0);
                const a = e.xr.getEnvironmentBlendMode();
                "additive" === a ? i.buffers.color.setClear(0, 0, 0, 1, s) : "alpha-blend" === a && i.buffers.color.setClear(0, 0, 0, 0, s), (e.autoClear || n) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
            },
            addToRenderList: function(t, n) {
                const i = f(n);
                i && (i.isCubeTexture || i.mapping === o) ? (void 0 === h && (h = new hi(new di(1, 1, 1), new _i({
                    name: "BackgroundCubeMaterial",
                    uniforms: pi(Bi.backgroundCube.uniforms),
                    vertexShader: Bi.backgroundCube.vertexShader,
                    fragmentShader: Bi.backgroundCube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }, Object.defineProperty(h.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }), r.update(h)), Hi.copy(n.backgroundRotation), Hi.x *= -1, Hi.y *= -1, Hi.z *= -1, i.isCubeTexture && !1 === i.isRenderTargetTexture && (Hi.y *= -1, Hi.z *= -1), h.material.uniforms.envMap.value = i, h.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Vi.makeRotationFromEuler(Hi)), h.material.toneMapped = qe.getTransfer(i.colorSpace) !== ye, d === i && p === i.version && m === e.toneMapping || (h.material.needsUpdate = !0, d = i, p = i.version, m = e.toneMapping), h.layers.enableAll(), t.unshift(h, h.geometry, h.material, 0, 0, null)) : i && i.isTexture && (void 0 === c && (c = new hi(new Oi(2, 2), new _i({
                    name: "BackgroundMaterial",
                    uniforms: pi(Bi.background.uniforms),
                    vertexShader: Bi.background.vertexShader,
                    fragmentShader: Bi.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), r.update(c)), c.material.uniforms.t2D.value = i, c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, c.material.toneMapped = qe.getTransfer(i.colorSpace) !== ye, !0 === i.matrixAutoUpdate && i.updateMatrix(), c.material.uniforms.uvTransform.value.copy(i.matrix), d === i && p === i.version && m === e.toneMapping || (c.material.needsUpdate = !0, d = i, p = i.version, m = e.toneMapping), c.layers.enableAll(), t.unshift(c, c.geometry, c.material, 0, 0, null))
            }
        }
    }

    function Wi(e, t) {
        const n = e.getParameter(e.MAX_VERTEX_ATTRIBS),
            i = {},
            r = c(null);
        let a = r,
            s = !1;

        function o(t) {
            return e.bindVertexArray(t)
        }

        function l(t) {
            return e.deleteVertexArray(t)
        }

        function c(e) {
            const t = [],
                i = [],
                r = [];
            for (let e = 0; e < n; e++) t[e] = 0, i[e] = 0, r[e] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: t,
                enabledAttributes: i,
                attributeDivisors: r,
                object: e,
                attributes: {},
                index: null
            }
        }

        function h() {
            const e = a.newAttributes;
            for (let t = 0, n = e.length; t < n; t++) e[t] = 0
        }

        function u(e) {
            d(e, 0)
        }

        function d(t, n) {
            const i = a.newAttributes,
                r = a.enabledAttributes,
                s = a.attributeDivisors;
            i[t] = 1, 0 === r[t] && (e.enableVertexAttribArray(t), r[t] = 1), s[t] !== n && (e.vertexAttribDivisor(t, n), s[t] = n)
        }

        function p() {
            const t = a.newAttributes,
                n = a.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
        }

        function m(t, n, i, r, a, s, o) {
            !0 === o ? e.vertexAttribIPointer(t, n, i, a, s) : e.vertexAttribPointer(t, n, i, r, a, s)
        }

        function f() {
            g(), s = !0, a !== r && (a = r, o(a.object))
        }

        function g() {
            r.geometry = null, r.program = null, r.wireframe = !1
        }
        return {
            setup: function(n, r, l, f, g) {
                let _ = !1;
                const v = function(t, n, r) {
                    const a = !0 === r.wireframe;
                    let s = i[t.id];
                    void 0 === s && (s = {}, i[t.id] = s);
                    let o = s[n.id];
                    void 0 === o && (o = {}, s[n.id] = o);
                    let l = o[a];
                    return void 0 === l && (l = c(e.createVertexArray()), o[a] = l), l
                }(f, l, r);
                a !== v && (a = v, o(a.object)), _ = function(e, t, n, i) {
                    const r = a.attributes,
                        s = t.attributes;
                    let o = 0;
                    const l = n.getAttributes();
                    for (const t in l)
                        if (l[t].location >= 0) {
                            const n = r[t];
                            let i = s[t];
                            if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (i = e.instanceColor)), void 0 === n) return !0;
                            if (n.attribute !== i) return !0;
                            if (i && n.data !== i.data) return !0;
                            o++
                        } return a.attributesNum !== o || a.index !== i
                }(n, f, l, g), _ && function(e, t, n, i) {
                    const r = {},
                        s = t.attributes;
                    let o = 0;
                    const l = n.getAttributes();
                    for (const t in l)
                        if (l[t].location >= 0) {
                            let n = s[t];
                            void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                            const i = {};
                            i.attribute = n, n && n.data && (i.data = n.data), r[t] = i, o++
                        } a.attributes = r, a.attributesNum = o, a.index = i
                }(n, f, l, g), null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER), (_ || s) && (s = !1, function(n, i, r, a) {
                    h();
                    const s = a.attributes,
                        o = r.getAttributes(),
                        l = i.defaultAttributeValues;
                    for (const i in o) {
                        const r = o[i];
                        if (r.location >= 0) {
                            let o = s[i];
                            if (void 0 === o && ("instanceMatrix" === i && n.instanceMatrix && (o = n.instanceMatrix), "instanceColor" === i && n.instanceColor && (o = n.instanceColor)), void 0 !== o) {
                                const i = o.normalized,
                                    s = o.itemSize,
                                    l = t.get(o);
                                if (void 0 === l) continue;
                                const c = l.buffer,
                                    h = l.type,
                                    p = l.bytesPerElement,
                                    f = h === e.INT || h === e.UNSIGNED_INT || o.gpuType === x;
                                if (o.isInterleavedBufferAttribute) {
                                    const t = o.data,
                                        l = t.stride,
                                        g = o.offset;
                                    if (t.isInstancedInterleavedBuffer) {
                                        for (let e = 0; e < r.locationSize; e++) d(r.location + e, t.meshPerAttribute);
                                        !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = t.meshPerAttribute * t.count)
                                    } else
                                        for (let e = 0; e < r.locationSize; e++) u(r.location + e);
                                    e.bindBuffer(e.ARRAY_BUFFER, c);
                                    for (let e = 0; e < r.locationSize; e++) m(r.location + e, s / r.locationSize, h, i, l * p, (g + s / r.locationSize * e) * p, f)
                                } else {
                                    if (o.isInstancedBufferAttribute) {
                                        for (let e = 0; e < r.locationSize; e++) d(r.location + e, o.meshPerAttribute);
                                        !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                                    } else
                                        for (let e = 0; e < r.locationSize; e++) u(r.location + e);
                                    e.bindBuffer(e.ARRAY_BUFFER, c);
                                    for (let e = 0; e < r.locationSize; e++) m(r.location + e, s / r.locationSize, h, i, s * p, s / r.locationSize * e * p, f)
                                }
                            } else if (void 0 !== l) {
                                const t = l[i];
                                if (void 0 !== t) switch (t.length) {
                                    case 2:
                                        e.vertexAttrib2fv(r.location, t);
                                        break;
                                    case 3:
                                        e.vertexAttrib3fv(r.location, t);
                                        break;
                                    case 4:
                                        e.vertexAttrib4fv(r.location, t);
                                        break;
                                    default:
                                        e.vertexAttrib1fv(r.location, t)
                                }
                            }
                        }
                    }
                    p()
                }(n, r, l, f), null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer))
            },
            reset: f,
            resetDefaultState: g,
            dispose: function() {
                f();
                for (const e in i) {
                    const t = i[e];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n) l(n[e].object), delete n[e];
                        delete t[e]
                    }
                    delete i[e]
                }
            },
            releaseStatesOfGeometry: function(e) {
                if (void 0 === i[e.id]) return;
                const t = i[e.id];
                for (const e in t) {
                    const n = t[e];
                    for (const e in n) l(n[e].object), delete n[e];
                    delete t[e]
                }
                delete i[e.id]
            },
            releaseStatesOfProgram: function(e) {
                for (const t in i) {
                    const n = i[t];
                    if (void 0 === n[e.id]) continue;
                    const r = n[e.id];
                    for (const e in r) l(r[e].object), delete r[e];
                    delete n[e.id]
                }
            },
            initAttributes: h,
            enableAttribute: u,
            disableUnusedAttributes: p
        }
    }

    function qi(e, t, n) {
        let i;

        function r(t, r, a) {
            0 !== a && (e.drawArraysInstanced(i, t, r, a), n.update(r, i, a))
        }
        this.setMode = function(e) {
            i = e
        }, this.render = function(t, r) {
            e.drawArrays(i, t, r), n.update(r, i, 1)
        }, this.renderInstances = r, this.renderMultiDraw = function(e, r, a) {
            if (0 === a) return;
            t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, a);
            let s = 0;
            for (let e = 0; e < a; e++) s += r[e];
            n.update(s, i, 1)
        }, this.renderMultiDrawInstances = function(e, a, s, o) {
            if (0 === s) return;
            const l = t.get("WEBGL_multi_draw");
            if (null === l)
                for (let t = 0; t < e.length; t++) r(e[t], a[t], o[t]);
            else {
                l.multiDrawArraysInstancedWEBGL(i, e, 0, a, 0, o, 0, s);
                let t = 0;
                for (let e = 0; e < s; e++) t += a[e] * o[e];
                n.update(t, i, 1)
            }
        }
    }

    function Xi(e, t, n, i) {
        let r;

        function a(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        let s = void 0 !== n.precision ? n.precision : "highp";
        const o = a(s);
        o !== s && (s = o);
        const l = !0 === n.logarithmicDepthBuffer,
            c = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control"),
            h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            u = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        return {
            isWebGL2: !0,
            getMaxAnisotropy: function() {
                if (void 0 !== r) return r;
                if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                    const n = t.get("EXT_texture_filter_anisotropic");
                    r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else r = 0;
                return r
            },
            getMaxPrecision: a,
            textureFormatReadable: function(t) {
                return t === R || i.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
            },
            textureTypeReadable: function(n) {
                const r = n === S && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                return !(n !== g && i.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== w && !r)
            },
            precision: s,
            logarithmicDepthBuffer: l,
            reverseDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
            maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
            maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
            maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
            maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
            maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
            vertexTextures: u > 0,
            maxSamples: e.getParameter(e.MAX_SAMPLES)
        }
    }

    function ji(e) {
        const t = this;
        let n = null,
            i = 0,
            r = !1,
            a = !1;
        const s = new Li,
            o = new Fe,
            l = {
                value: null,
                needsUpdate: !1
            };

        function c(e, n, i, r) {
            const a = null !== e ? e.length : 0;
            let c = null;
            if (0 !== a) {
                if (c = l.value, !0 !== r || null === c) {
                    const t = i + 4 * a,
                        r = n.matrixWorldInverse;
                    o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                    for (let t = 0, n = i; t !== a; ++t, n += 4) s.copy(e[t]).applyMatrix4(r, o), s.normal.toArray(c, n), c[n + 3] = s.constant
                }
                l.value = c, l.needsUpdate = !0
            }
            return t.numPlanes = a, t.numIntersection = 0, c
        }
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t) {
            const n = 0 !== e.length || t || 0 !== i || r;
            return r = t, i = e.length, n
        }, this.beginShadows = function() {
            a = !0, c(null)
        }, this.endShadows = function() {
            a = !1
        }, this.setGlobalState = function(e, t) {
            n = c(e, t, 0)
        }, this.setState = function(s, o, h) {
            const u = s.clippingPlanes,
                d = s.clipIntersection,
                p = s.clipShadows,
                m = e.get(s);
            if (!r || null === u || 0 === u.length || a && !p) a ? c(null) : (l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0);
            else {
                const e = a ? 0 : i,
                    t = 4 * e;
                let r = m.clippingState || null;
                l.value = r, r = c(u, o, t, h);
                for (let e = 0; e !== t; ++e) r[e] = n[e];
                m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
            }
        }
    }

    function Yi(e) {
        let t = new WeakMap;

        function n(e, t) {
            return 303 === t ? e.mapping = a : 304 === t && (e.mapping = s), e
        }

        function i(e) {
            const n = e.target;
            n.removeEventListener("dispose", i);
            const r = t.get(n);
            void 0 !== r && (t.delete(n), r.dispose())
        }
        return {
            get: function(r) {
                if (r && r.isTexture) {
                    const a = r.mapping;
                    if (303 === a || 304 === a) {
                        if (t.has(r)) return n(t.get(r).texture, r.mapping);
                        {
                            const a = r.image;
                            if (a && a.height > 0) {
                                const s = new Ei(a.height);
                                return s.fromEquirectangularTexture(e, r), t.set(r, s), r.addEventListener("dispose", i), n(s.texture, r.mapping)
                            }
                            return null
                        }
                    }
                }
                return r
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    class Ki extends vi {
        constructor(e = -1, t = 1, n = 1, i = -1, r = .1, a = 2e3) {
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = a, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        }
        setViewOffset(e, t, n, i, r, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2;
            let r = n - e,
                a = n + e,
                s = i + t,
                o = i - t;
            if (null !== this.view && this.view.enabled) {
                const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += e * this.view.offsetX, a = r + e * this.view.width, s -= t * this.view.offsetY, o = s - t * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    }
    const Zi = [.125, .215, .35, .446, .526, .582],
        $i = new Ki,
        Ji = new In;
    let Qi = null,
        er = 0,
        tr = 0,
        nr = !1;
    const ir = (1 + Math.sqrt(5)) / 2,
        rr = 1 / ir,
        ar = [new ut(-ir, rr, 0), new ut(ir, rr, 0), new ut(-rr, 0, ir), new ut(rr, 0, ir), new ut(0, ir, -rr), new ut(0, ir, rr), new ut(-1, 1, -1), new ut(1, 1, -1), new ut(-1, 1, 1), new ut(1, 1, 1)];
    class sr {
        constructor(e) {
            this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
        }
        fromScene(e, t = 0, n = .1, i = 100) {
            Qi = this._renderer.getRenderTarget(), er = this._renderer.getActiveCubeFace(), tr = this._renderer.getActiveMipmapLevel(), nr = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
            const r = this._allocateTargets();
            return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
        }
        fromEquirectangular(e, t = null) {
            return this._fromTexture(e, t)
        }
        fromCubemap(e, t = null) {
            return this._fromTexture(e, t)
        }
        compileCubemapShader() {
            null === this._cubemapMaterial && (this._cubemapMaterial = hr(), this._compileMaterial(this._cubemapMaterial))
        }
        compileEquirectangularShader() {
            null === this._equirectMaterial && (this._equirectMaterial = cr(), this._compileMaterial(this._equirectMaterial))
        }
        dispose() {
            this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
        }
        _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
        }
        _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
            for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
        }
        _cleanup(e) {
            this._renderer.setRenderTarget(Qi, er, tr), this._renderer.xr.enabled = nr, e.scissorTest = !1, lr(e, 0, 0, e.width, e.height)
        }
        _fromTexture(e, t) {
            e.mapping === a || e.mapping === s ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Qi = this._renderer.getRenderTarget(), er = this._renderer.getActiveCubeFace(), tr = this._renderer.getActiveMipmapLevel(), nr = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
            const n = t || this._allocateTargets();
            return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
        }
        _allocateTargets() {
            const e = 3 * Math.max(this._cubeSize, 112),
                t = 4 * this._cubeSize,
                n = {
                    magFilter: p,
                    minFilter: p,
                    generateMipmaps: !1,
                    type: S,
                    format: R,
                    colorSpace: _e,
                    depthBuffer: !1
                },
                i = or(e, t, n);
            if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = or(e, t, n);
                const {
                    _lodMax: i
                } = this;
                ({
                    sizeLods: this._sizeLods,
                    lodPlanes: this._lodPlanes,
                    sigmas: this._sigmas
                } = function(e) {
                    const t = [],
                        n = [],
                        i = [];
                    let r = e;
                    const a = e - 4 + 1 + Zi.length;
                    for (let s = 0; s < a; s++) {
                        const a = Math.pow(2, r);
                        n.push(a);
                        let o = 1 / a;
                        s > e - 4 ? o = Zi[s - e + 4 - 1] : 0 === s && (o = 0), i.push(o);
                        const l = 1 / (a - 2),
                            c = -l,
                            h = 1 + l,
                            u = [c, c, h, c, h, h, c, c, h, h, c, h],
                            d = 6,
                            p = 6,
                            m = 3,
                            f = 2,
                            g = 1,
                            _ = new Float32Array(m * p * d),
                            v = new Float32Array(f * p * d),
                            y = new Float32Array(g * p * d);
                        for (let e = 0; e < d; e++) {
                            const t = e % 3 * 2 / 3 - 1,
                                n = e > 2 ? 0 : -1,
                                i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                            _.set(i, m * p * e), v.set(u, f * p * e);
                            const r = [e, e, e, e, e, e];
                            y.set(r, g * p * e)
                        }
                        const x = new Jn;
                        x.setAttribute("position", new Hn(_, m)), x.setAttribute("uv", new Hn(v, f)), x.setAttribute("faceIndex", new Hn(y, g)), t.push(x), r > 4 && r--
                    }
                    return {
                        lodPlanes: t,
                        sizeLods: n,
                        sigmas: i
                    }
                }(i)), this._blurMaterial = function(e, t, n) {
                    const i = new Float32Array(20),
                        r = new ut(0, 1, 0);
                    return new _i({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: 20,
                            CUBEUV_TEXEL_WIDTH: 1 / t,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: `${e}.0`
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: i
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: r
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }(i, e, t)
            }
            return i
        }
        _compileMaterial(e) {
            const t = new hi(this._lodPlanes[0], e);
            this._renderer.compile(t, $i)
        }
        _sceneToCubeUV(e, t, n, i) {
            const r = new wi(90, 1, t, n),
                a = [1, -1, 1, 1, 1, 1],
                s = [1, 1, 1, -1, -1, -1],
                o = this._renderer,
                l = o.autoClear,
                c = o.toneMapping;
            o.getClearColor(Ji), o.toneMapping = 0, o.autoClear = !1;
            const h = new Fn({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                }),
                u = new hi(new di, h);
            let d = !1;
            const p = e.background;
            p ? p.isColor && (h.color.copy(p), e.background = null, d = !0) : (h.color.copy(Ji), d = !0);
            for (let t = 0; t < 6; t++) {
                const n = t % 3;
                0 === n ? (r.up.set(0, a[t], 0), r.lookAt(s[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, a[t]), r.lookAt(0, s[t], 0)) : (r.up.set(0, a[t], 0), r.lookAt(0, 0, s[t]));
                const l = this._cubeSize;
                lr(i, n * l, t > 2 ? l : 0, l, l), o.setRenderTarget(i), d && o.render(u, r), o.render(e, r)
            }
            u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, e.background = p
        }
        _textureToCubeUV(e, t) {
            const n = this._renderer,
                i = e.mapping === a || e.mapping === s;
            i ? (null === this._cubemapMaterial && (this._cubemapMaterial = hr()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = cr());
            const r = i ? this._cubemapMaterial : this._equirectMaterial,
                o = new hi(this._lodPlanes[0], r);
            r.uniforms.envMap.value = e;
            const l = this._cubeSize;
            lr(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, $i)
        }
        _applyPMREM(e) {
            const t = this._renderer,
                n = t.autoClear;
            t.autoClear = !1;
            const i = this._lodPlanes.length;
            for (let t = 1; t < i; t++) {
                const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
                    r = ar[(i - t - 1) % ar.length];
                this._blur(e, t - 1, t, n, r)
            }
            t.autoClear = n
        }
        _blur(e, t, n, i, r) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(e, a, t, n, i, "latitudinal", r), this._halfBlur(a, e, n, n, i, "longitudinal", r)
        }
        _halfBlur(e, t, n, i, r, a, s) {
            const o = this._renderer,
                l = this._blurMaterial,
                c = new hi(this._lodPlanes[i], l),
                h = l.uniforms,
                u = this._sizeLods[n] - 1,
                d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                p = r / d,
                m = isFinite(r) ? 1 + Math.floor(3 * p) : 20,
                f = [];
            let g = 0;
            for (let e = 0; e < 20; ++e) {
                const t = e / p,
                    n = Math.exp(-t * t / 2);
                f.push(n), 0 === e ? g += n : e < m && (g += 2 * n)
            }
            for (let e = 0; e < f.length; e++) f[e] = f[e] / g;
            h.envMap.value = e.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === a, s && (h.poleAxis.value = s);
            const {
                _lodMax: _
            } = this;
            h.dTheta.value = d, h.mipInt.value = _ - n;
            const v = this._sizeLods[i];
            lr(t, 3 * v * (i > _ - 4 ? i - _ + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), o.setRenderTarget(t), o.render(c, $i)
        }
    }

    function or(e, t, n) {
        const i = new lt(e, t, n);
        return i.texture.mapping = o, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
    }

    function lr(e, t, n, i, r) {
        e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
    }

    function cr() {
        return new _i({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function hr() {
        return new _i({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function ur(e) {
        let t = new WeakMap,
            n = null;

        function i(e) {
            const n = e.target;
            n.removeEventListener("dispose", i);
            const r = t.get(n);
            void 0 !== r && (t.delete(n), r.dispose())
        }
        return {
            get: function(r) {
                if (r && r.isTexture) {
                    const o = r.mapping,
                        l = 303 === o || 304 === o,
                        c = o === a || o === s;
                    if (l || c) {
                        let a = t.get(r);
                        const s = void 0 !== a ? a.texture.pmremVersion : 0;
                        if (r.isRenderTargetTexture && r.pmremVersion !== s) return null === n && (n = new sr(e)), a = l ? n.fromEquirectangular(r, a) : n.fromCubemap(r, a), a.texture.pmremVersion = r.pmremVersion, t.set(r, a), a.texture;
                        if (void 0 !== a) return a.texture;
                        {
                            const s = r.image;
                            return l && s && s.height > 0 || c && s && function(e) {
                                let t = 0;
                                for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                return 6 === t
                            }(s) ? (null === n && (n = new sr(e)), a = l ? n.fromEquirectangular(r) : n.fromCubemap(r), a.texture.pmremVersion = r.pmremVersion, t.set(r, a), r.addEventListener("dispose", i), a.texture) : null
                        }
                    }
                }
                return r
            },
            dispose: function() {
                t = new WeakMap, null !== n && (n.dispose(), n = null)
            }
        }
    }

    function dr(e) {
        const t = {};

        function n(n) {
            if (void 0 !== t[n]) return t[n];
            let i;
            switch (n) {
                case "WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(n)
            }
            return t[n] = i, i
        }
        return {
            has: function(e) {
                return null !== n(e)
            },
            init: function() {
                n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent")
            },
            get: function(e) {
                const t = n(e);
                return null === t && We("THREE.WebGLRenderer: " + e + " extension not supported."), t
            }
        }
    }

    function pr(e, t, n, i) {
        const r = {},
            a = new WeakMap;

        function s(e) {
            const o = e.target;
            null !== o.index && t.remove(o.index);
            for (const e in o.attributes) t.remove(o.attributes[e]);
            for (const e in o.morphAttributes) {
                const n = o.morphAttributes[e];
                for (let e = 0, i = n.length; e < i; e++) t.remove(n[e])
            }
            o.removeEventListener("dispose", s), delete r[o.id];
            const l = a.get(o);
            l && (t.remove(l), a.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
        }

        function o(e) {
            const n = [],
                i = e.index,
                r = e.attributes.position;
            let s = 0;
            if (null !== i) {
                const e = i.array;
                s = i.version;
                for (let t = 0, i = e.length; t < i; t += 3) {
                    const i = e[t + 0],
                        r = e[t + 1],
                        a = e[t + 2];
                    n.push(i, r, r, a, a, i)
                }
            } else {
                if (void 0 === r) return;
                {
                    const e = r.array;
                    s = r.version;
                    for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                        const e = t + 0,
                            i = t + 1,
                            r = t + 2;
                        n.push(e, i, i, r, r, e)
                    }
                }
            }
            const o = new(ze(n) ? Gn : Vn)(n, 1);
            o.version = s;
            const l = a.get(e);
            l && t.remove(l), a.set(e, o)
        }
        return {
            get: function(e, t) {
                return !0 === r[t.id] || (t.addEventListener("dispose", s), r[t.id] = !0, n.memory.geometries++), t
            },
            update: function(n) {
                const i = n.attributes;
                for (const n in i) t.update(i[n], e.ARRAY_BUFFER);
                const r = n.morphAttributes;
                for (const n in r) {
                    const i = r[n];
                    for (let n = 0, r = i.length; n < r; n++) t.update(i[n], e.ARRAY_BUFFER)
                }
            },
            getWireframeAttribute: function(e) {
                const t = a.get(e);
                if (t) {
                    const n = e.index;
                    null !== n && t.version < n.version && o(e)
                } else o(e);
                return a.get(e)
            }
        }
    }

    function mr(e, t, n) {
        let i, r, a;

        function s(t, s, o) {
            0 !== o && (e.drawElementsInstanced(i, s, r, t * a, o), n.update(s, i, o))
        }
        this.setMode = function(e) {
            i = e
        }, this.setIndex = function(e) {
            r = e.type, a = e.bytesPerElement
        }, this.render = function(t, s) {
            e.drawElements(i, s, r, t * a), n.update(s, i, 1)
        }, this.renderInstances = s, this.renderMultiDraw = function(e, a, s) {
            if (0 === s) return;
            t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, a, 0, r, e, 0, s);
            let o = 0;
            for (let e = 0; e < s; e++) o += a[e];
            n.update(o, i, 1)
        }, this.renderMultiDrawInstances = function(e, o, l, c) {
            if (0 === l) return;
            const h = t.get("WEBGL_multi_draw");
            if (null === h)
                for (let t = 0; t < e.length; t++) s(e[t] / a, o[t], c[t]);
            else {
                h.multiDrawElementsInstancedWEBGL(i, o, 0, r, e, 0, c, 0, l);
                let t = 0;
                for (let e = 0; e < l; e++) t += o[e] * c[e];
                n.update(t, i, 1)
            }
        }
    }

    function fr(e) {
        const t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            },
            update: function(n, i, r) {
                switch (t.calls++, i) {
                    case e.TRIANGLES:
                        t.triangles += r * (n / 3);
                        break;
                    case e.LINES:
                        t.lines += r * (n / 2);
                        break;
                    case e.LINE_STRIP:
                        t.lines += r * (n - 1);
                        break;
                    case e.LINE_LOOP:
                        t.lines += r * n;
                        break;
                    case e.POINTS:
                        t.points += r * n
                }
            }
        }
    }

    function gr(e, t, n) {
        const i = new WeakMap,
            r = new st;
        return {
            update: function(a, s, o) {
                const l = a.morphTargetInfluences,
                    c = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color,
                    h = void 0 !== c ? c.length : 0;
                let u = i.get(s);
                if (void 0 === u || u.count !== h) {
                    void 0 !== u && u.texture.dispose();
                    const d = void 0 !== s.morphAttributes.position,
                        p = void 0 !== s.morphAttributes.normal,
                        m = void 0 !== s.morphAttributes.color,
                        f = s.morphAttributes.position || [],
                        g = s.morphAttributes.normal || [],
                        _ = s.morphAttributes.color || [];
                    let v = 0;
                    !0 === d && (v = 1), !0 === p && (v = 2), !0 === m && (v = 3);
                    let y = s.attributes.position.count * v,
                        x = 1;
                    y > t.maxTextureSize && (x = Math.ceil(y / t.maxTextureSize), y = t.maxTextureSize);
                    const b = new Float32Array(y * x * 4 * h),
                        S = new ct(b, y, x, h);
                    S.type = w, S.needsUpdate = !0;
                    const M = 4 * v;
                    for (let E = 0; E < h; E++) {
                        const A = f[E],
                            R = g[E],
                            C = _[E],
                            L = y * x * 4 * E;
                        for (let P = 0; P < A.count; P++) {
                            const D = P * M;
                            !0 === d && (r.fromBufferAttribute(A, P), b[L + D + 0] = r.x, b[L + D + 1] = r.y, b[L + D + 2] = r.z, b[L + D + 3] = 0), !0 === p && (r.fromBufferAttribute(R, P), b[L + D + 4] = r.x, b[L + D + 5] = r.y, b[L + D + 6] = r.z, b[L + D + 7] = 0), !0 === m && (r.fromBufferAttribute(C, P), b[L + D + 8] = r.x, b[L + D + 9] = r.y, b[L + D + 10] = r.z, b[L + D + 11] = 4 === C.itemSize ? r.w : 1)
                        }
                    }

                    function T() {
                        S.dispose(), i.delete(s), s.removeEventListener("dispose", T)
                    }
                    u = {
                        count: h,
                        texture: S,
                        size: new ke(y, x)
                    }, i.set(s, u), s.addEventListener("dispose", T)
                }
                if (!0 === a.isInstancedMesh && null !== a.morphTexture) o.getUniforms().setValue(e, "morphTexture", a.morphTexture, n);
                else {
                    let U = 0;
                    for (let N = 0; N < l.length; N++) U += l[N];
                    const I = s.morphTargetsRelative ? 1 : 1 - U;
                    o.getUniforms().setValue(e, "morphTargetBaseInfluence", I), o.getUniforms().setValue(e, "morphTargetInfluences", l)
                }
                o.getUniforms().setValue(e, "morphTargetsTexture", u.texture, n), o.getUniforms().setValue(e, "morphTargetsTextureSize", u.size)
            }
        }
    }

    function _r(e, t, n, i) {
        let r = new WeakMap;

        function a(e) {
            const t = e.target;
            t.removeEventListener("dispose", a), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
        }
        return {
            update: function(s) {
                const o = i.render.frame,
                    l = s.geometry,
                    c = t.get(s, l);
                if (r.get(c) !== o && (t.update(c), r.set(c, o)), s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a), r.get(s) !== o && (n.update(s.instanceMatrix, e.ARRAY_BUFFER), null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER), r.set(s, o))), s.isSkinnedMesh) {
                    const e = s.skeleton;
                    r.get(e) !== o && (e.update(), r.set(e, o))
                }
                return c
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }
    class vr extends at {
        constructor(e, t, n, i, r, a, s, o, l, c = 1026) {
            if (c !== C && c !== L) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && c === C && (n = b), void 0 === n && c === L && (n = E), super(null, i, r, a, s, o, c, n, l), this.isDepthTexture = !0, this.image = {
                width: e,
                height: t
            }, this.magFilter = void 0 !== s ? s : u, this.minFilter = void 0 !== o ? o : u, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
        }
        copy(e) {
            return super.copy(e), this.compareFunction = e.compareFunction, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t
        }
    }
    const yr = new at,
        xr = new vr(1, 1),
        br = new ct,
        wr = new class extends at {
            constructor(e = null, t = 1, n = 1, i = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = u, this.minFilter = u, this.wrapR = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        },
        Sr = new Ti,
        Mr = [],
        Tr = [],
        Er = new Float32Array(16),
        Ar = new Float32Array(9),
        Rr = new Float32Array(4);

    function Cr(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const r = t * n;
        let a = Mr[r];
        if (void 0 === a && (a = new Float32Array(r), Mr[r] = a), 0 !== t) {
            i.toArray(a, 0);
            for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(a, r)
        }
        return a
    }

    function Lr(e, t) {
        if (e.length !== t.length) return !1;
        for (let n = 0, i = e.length; n < i; n++)
            if (e[n] !== t[n]) return !1;
        return !0
    }

    function Pr(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
    }

    function Dr(e, t) {
        let n = Tr[t];
        void 0 === n && (n = new Int32Array(t), Tr[t] = n);
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n
    }

    function Ur(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
    }

    function Ir(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
            if (Lr(n, t)) return;
            e.uniform2fv(this.addr, t), Pr(n, t)
        }
    }

    function Nr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
        else {
            if (Lr(n, t)) return;
            e.uniform3fv(this.addr, t), Pr(n, t)
        }
    }

    function Or(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
            if (Lr(n, t)) return;
            e.uniform4fv(this.addr, t), Pr(n, t)
        }
    }

    function kr(e, t) {
        const n = this.cache,
            i = t.elements;
        if (void 0 === i) {
            if (Lr(n, t)) return;
            e.uniformMatrix2fv(this.addr, !1, t), Pr(n, t)
        } else {
            if (Lr(n, i)) return;
            Rr.set(i), e.uniformMatrix2fv(this.addr, !1, Rr), Pr(n, i)
        }
    }

    function Fr(e, t) {
        const n = this.cache,
            i = t.elements;
        if (void 0 === i) {
            if (Lr(n, t)) return;
            e.uniformMatrix3fv(this.addr, !1, t), Pr(n, t)
        } else {
            if (Lr(n, i)) return;
            Ar.set(i), e.uniformMatrix3fv(this.addr, !1, Ar), Pr(n, i)
        }
    }

    function Br(e, t) {
        const n = this.cache,
            i = t.elements;
        if (void 0 === i) {
            if (Lr(n, t)) return;
            e.uniformMatrix4fv(this.addr, !1, t), Pr(n, t)
        } else {
            if (Lr(n, i)) return;
            Er.set(i), e.uniformMatrix4fv(this.addr, !1, Er), Pr(n, i)
        }
    }

    function zr(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
    }

    function Hr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
            if (Lr(n, t)) return;
            e.uniform2iv(this.addr, t), Pr(n, t)
        }
    }

    function Vr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else {
            if (Lr(n, t)) return;
            e.uniform3iv(this.addr, t), Pr(n, t)
        }
    }

    function Gr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
            if (Lr(n, t)) return;
            e.uniform4iv(this.addr, t), Pr(n, t)
        }
    }

    function Wr(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
    }

    function qr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
            if (Lr(n, t)) return;
            e.uniform2uiv(this.addr, t), Pr(n, t)
        }
    }

    function Xr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else {
            if (Lr(n, t)) return;
            e.uniform3uiv(this.addr, t), Pr(n, t)
        }
    }

    function jr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
            if (Lr(n, t)) return;
            e.uniform4uiv(this.addr, t), Pr(n, t)
        }
    }

    function Yr(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        let a;
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), this.type === e.SAMPLER_2D_SHADOW ? (xr.compareFunction = 515, a = xr) : a = yr, n.setTexture2D(t || a, r)
    }

    function Kr(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || wr, r)
    }

    function Zr(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || Sr, r)
    }

    function $r(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || br, r)
    }

    function Jr(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function Qr(e, t) {
        const n = Cr(t, this.size, 2);
        e.uniform2fv(this.addr, n)
    }

    function ea(e, t) {
        const n = Cr(t, this.size, 3);
        e.uniform3fv(this.addr, n)
    }

    function ta(e, t) {
        const n = Cr(t, this.size, 4);
        e.uniform4fv(this.addr, n)
    }

    function na(e, t) {
        const n = Cr(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n)
    }

    function ia(e, t) {
        const n = Cr(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n)
    }

    function ra(e, t) {
        const n = Cr(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n)
    }

    function aa(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function sa(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function oa(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function la(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function ca(e, t) {
        e.uniform1uiv(this.addr, t)
    }

    function ha(e, t) {
        e.uniform2uiv(this.addr, t)
    }

    function ua(e, t) {
        e.uniform3uiv(this.addr, t)
    }

    function da(e, t) {
        e.uniform4uiv(this.addr, t)
    }

    function pa(e, t, n) {
        const i = this.cache,
            r = t.length,
            a = Dr(n, r);
        Lr(i, a) || (e.uniform1iv(this.addr, a), Pr(i, a));
        for (let e = 0; e !== r; ++e) n.setTexture2D(t[e] || yr, a[e])
    }

    function ma(e, t, n) {
        const i = this.cache,
            r = t.length,
            a = Dr(n, r);
        Lr(i, a) || (e.uniform1iv(this.addr, a), Pr(i, a));
        for (let e = 0; e !== r; ++e) n.setTexture3D(t[e] || wr, a[e])
    }

    function fa(e, t, n) {
        const i = this.cache,
            r = t.length,
            a = Dr(n, r);
        Lr(i, a) || (e.uniform1iv(this.addr, a), Pr(i, a));
        for (let e = 0; e !== r; ++e) n.setTextureCube(t[e] || Sr, a[e])
    }

    function ga(e, t, n) {
        const i = this.cache,
            r = t.length,
            a = Dr(n, r);
        Lr(i, a) || (e.uniform1iv(this.addr, a), Pr(i, a));
        for (let e = 0; e !== r; ++e) n.setTexture2DArray(t[e] || br, a[e])
    }
    class _a {
        constructor(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function(e) {
                switch (e) {
                    case 5126:
                        return Ur;
                    case 35664:
                        return Ir;
                    case 35665:
                        return Nr;
                    case 35666:
                        return Or;
                    case 35674:
                        return kr;
                    case 35675:
                        return Fr;
                    case 35676:
                        return Br;
                    case 5124:
                    case 35670:
                        return zr;
                    case 35667:
                    case 35671:
                        return Hr;
                    case 35668:
                    case 35672:
                        return Vr;
                    case 35669:
                    case 35673:
                        return Gr;
                    case 5125:
                        return Wr;
                    case 36294:
                        return qr;
                    case 36295:
                        return Xr;
                    case 36296:
                        return jr;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Yr;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Kr;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Zr;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return $r
                }
            }(t.type)
        }
    }
    class va {
        constructor(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function(e) {
                switch (e) {
                    case 5126:
                        return Jr;
                    case 35664:
                        return Qr;
                    case 35665:
                        return ea;
                    case 35666:
                        return ta;
                    case 35674:
                        return na;
                    case 35675:
                        return ia;
                    case 35676:
                        return ra;
                    case 5124:
                    case 35670:
                        return aa;
                    case 35667:
                    case 35671:
                        return sa;
                    case 35668:
                    case 35672:
                        return oa;
                    case 35669:
                    case 35673:
                        return la;
                    case 5125:
                        return ca;
                    case 36294:
                        return ha;
                    case 36295:
                        return ua;
                    case 36296:
                        return da;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return pa;
                    case 35679:
                    case 36299:
                    case 36307:
                        return ma;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return fa;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return ga
                }
            }(t.type)
        }
    }
    class ya {
        constructor(e) {
            this.id = e, this.seq = [], this.map = {}
        }
        setValue(e, t, n) {
            const i = this.seq;
            for (let r = 0, a = i.length; r !== a; ++r) {
                const a = i[r];
                a.setValue(e, t[a.id], n)
            }
        }
    }
    const xa = /(\w+)(\])?(\[|\.)?/g;

    function ba(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function wa(e, t, n) {
        const i = e.name,
            r = i.length;
        for (xa.lastIndex = 0;;) {
            const a = xa.exec(i),
                s = xa.lastIndex;
            let o = a[1];
            const l = "]" === a[2],
                c = a[3];
            if (l && (o |= 0), void 0 === c || "[" === c && s + 2 === r) {
                ba(n, void 0 === c ? new _a(o, e, t) : new va(o, e, t));
                break
            } {
                let e = n.map[o];
                void 0 === e && (e = new ya(o), ba(n, e)), n = e
            }
        }
    }
    class Sa {
        constructor(e, t) {
            this.seq = [], this.map = {};
            const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
                const n = e.getActiveUniform(t, i);
                wa(n, e.getUniformLocation(t, n.name), this)
            }
        }
        setValue(e, t, n, i) {
            const r = this.map[t];
            void 0 !== r && r.setValue(e, n, i)
        }
        setOptional(e, t, n) {
            const i = t[n];
            void 0 !== i && this.setValue(e, n, i)
        }
        static upload(e, t, n, i) {
            for (let r = 0, a = t.length; r !== a; ++r) {
                const a = t[r],
                    s = n[a.id];
                !1 !== s.needsUpdate && a.setValue(e, s.value, i)
            }
        }
        static seqWithValue(e, t) {
            const n = [];
            for (let i = 0, r = e.length; i !== r; ++i) {
                const r = e[i];
                r.id in t && n.push(r)
            }
            return n
        }
    }

    function Ma(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i
    }
    let Ta = 0;
    const Ea = new Fe;

    function Aa(e, t, n) {
        const i = e.getShaderParameter(t, e.COMPILE_STATUS),
            r = e.getShaderInfoLog(t).trim();
        if (i && "" === r) return "";
        const a = /ERROR: 0:(\d+)/.exec(r);
        if (a) {
            const i = parseInt(a[1]);
            return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                const n = e.split("\n"),
                    i = [],
                    r = Math.max(t - 6, 0),
                    a = Math.min(t + 6, n.length);
                for (let e = r; e < a; e++) {
                    const r = e + 1;
                    i.push(`${r===t?">":" "} ${r}: ${n[e]}`)
                }
                return i.join("\n")
            }(e.getShaderSource(t), i)
        }
        return r
    }

    function Ra(e, t) {
        const n = function(e) {
            qe._getMatrix(Ea, qe.workingColorSpace, e);
            const t = `mat3( ${Ea.elements.map((e=>e.toFixed(4)))} )`;
            switch (qe.getTransfer(e)) {
                case ve:
                    return [t, "LinearTransferOETF"];
                case ye:
                    return [t, "sRGBTransferOETF"];
                default:
                    return [t, "LinearTransferOETF"]
            }
        }(t);
        return [`vec4 ${e}( vec4 value ) {`, `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join("\n")
    }

    function Ca(e, t) {
        let n;
        switch (t) {
            case 1:
            default:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "Cineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 6:
                n = "AgX";
                break;
            case 7:
                n = "Neutral";
                break;
            case 5:
                n = "Custom"
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }
    const La = new ut;

    function Pa(e) {
        return "" !== e
    }

    function Da(e, t) {
        const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }

    function Ua(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    const Ia = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Na(e) {
        return e.replace(Ia, ka)
    }
    const Oa = new Map;

    function ka(e, t) {
        let n = ki[t];
        if (void 0 === n) {
            const e = Oa.get(t);
            if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">");
            n = ki[e]
        }
        return Na(n)
    }
    const Fa = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function Ba(e) {
        return e.replace(Fa, za)
    }

    function za(e, t, n, i) {
        let r = "";
        for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
        return r
    }

    function Ha(e) {
        let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
    }

    function Va(e, t, n, i) {
        const r = e.getContext(),
            l = n.defines;
        let c = n.vertexShader,
            h = n.fragmentShader;
        const u = function(e) {
                let t = "SHADOWMAP_TYPE_BASIC";
                return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
            }(n),
            d = function(e) {
                let t = "ENVMAP_TYPE_CUBE";
                if (e.envMap) switch (e.envMapMode) {
                    case a:
                    case s:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case o:
                        t = "ENVMAP_TYPE_CUBE_UV"
                }
                return t
            }(n),
            p = function(e) {
                let t = "ENVMAP_MODE_REFLECTION";
                return e.envMap && e.envMapMode === s && (t = "ENVMAP_MODE_REFRACTION"), t
            }(n),
            m = function(e) {
                let t = "ENVMAP_BLENDING_NONE";
                if (e.envMap) switch (e.combine) {
                    case 0:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        t = "ENVMAP_BLENDING_ADD"
                }
                return t
            }(n),
            f = function(e) {
                const t = e.envMapCubeUVHeight;
                if (null === t) return null;
                const n = Math.log2(t) - 2,
                    i = 1 / t;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                    texelHeight: i,
                    maxMip: n
                }
            }(n),
            g = function(e) {
                return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Pa).join("\n")
            }(n),
            _ = function(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    !1 !== i && t.push("#define " + n + " " + i)
                }
                return t.join("\n")
            }(l),
            v = r.createProgram();
        let y, x, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, _].filter(Pa).join("\n"), y.length > 0 && (y += "\n"), x = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, _].filter(Pa).join("\n"), x.length > 0 && (x += "\n")) : (y = [Ha(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, _, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Pa).join("\n"), x = [Ha(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, _, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? ki.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ca("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", ki.colorspace_pars_fragment, Ra("linearToOutputTexel", n.outputColorSpace), (qe.getLuminanceCoefficients(La), ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${La.x.toFixed(4)}, ${La.y.toFixed(4)}, ${La.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Pa).join("\n")), c = Na(c), c = Da(c, n), c = Ua(c, n), h = Na(h), h = Da(h, n), h = Ua(h, n), c = Ba(c), h = Ba(h), !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", y = [g, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, x = ["#define varying in", n.glslVersion === we ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === we ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
        const w = b + y + c,
            S = b + x + h,
            M = Ma(r, r.VERTEX_SHADER, w),
            T = Ma(r, r.FRAGMENT_SHADER, S);

        function E(t) {
            if (e.debug.checkShaderErrors) {
                const n = r.getProgramInfoLog(v).trim(),
                    i = r.getShaderInfoLog(M).trim(),
                    a = r.getShaderInfoLog(T).trim();
                let s = !0,
                    o = !0;
                !1 === r.getProgramParameter(v, r.LINK_STATUS) ? (s = !1, "function" == typeof e.debug.onShaderError ? e.debug.onShaderError(r, v, M, T) : (Aa(r, M, "vertex"), Aa(r, T, "fragment"))) : "" !== n || "" !== i && "" !== a || (o = !1), o && (t.diagnostics = {
                    runnable: s,
                    programLog: n,
                    vertexShader: {
                        log: i,
                        prefix: y
                    },
                    fragmentShader: {
                        log: a,
                        prefix: x
                    }
                })
            }
            r.deleteShader(M), r.deleteShader(T), A = new Sa(r, v), R = function(e, t) {
                const n = {},
                    i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                for (let r = 0; r < i; r++) {
                    const i = e.getActiveAttrib(t, r),
                        a = i.name;
                    let s = 1;
                    i.type === e.FLOAT_MAT2 && (s = 2), i.type === e.FLOAT_MAT3 && (s = 3), i.type === e.FLOAT_MAT4 && (s = 4), n[a] = {
                        type: i.type,
                        location: e.getAttribLocation(t, a),
                        locationSize: s
                    }
                }
                return n
            }(r, v)
        }
        let A, R;
        r.attachShader(v, M), r.attachShader(v, T), void 0 !== n.index0AttributeName ? r.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(v, 0, "position"), r.linkProgram(v), this.getUniforms = function() {
            return void 0 === A && E(this), A
        }, this.getAttributes = function() {
            return void 0 === R && E(this), R
        };
        let C = !1 === n.rendererExtensionParallelShaderCompile;
        return this.isReady = function() {
            return !1 === C && (C = r.getProgramParameter(v, 37297)), C
        }, this.destroy = function() {
            i.releaseStatesOfProgram(this), r.deleteProgram(v), this.program = void 0
        }, this.type = n.shaderType, this.name = n.shaderName, this.id = Ta++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = M, this.fragmentShader = T, this
    }
    let Ga = 0;
    class Wa {
        constructor() {
            this.shaderCache = new Map, this.materialCache = new Map
        }
        update(e) {
            const t = e.vertexShader,
                n = e.fragmentShader,
                i = this._getShaderStage(t),
                r = this._getShaderStage(n),
                a = this._getShaderCacheForMaterial(e);
            return !1 === a.has(i) && (a.add(i), i.usedTimes++), !1 === a.has(r) && (a.add(r), r.usedTimes++), this
        }
        remove(e) {
            const t = this.materialCache.get(e);
            for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
            return this.materialCache.delete(e), this
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear()
        }
        _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            let n = t.get(e);
            return void 0 === n && (n = new Set, t.set(e, n)), n
        }
        _getShaderStage(e) {
            const t = this.shaderCache;
            let n = t.get(e);
            return void 0 === n && (n = new qa(e), t.set(e, n)), n
        }
    }
    class qa {
        constructor(e) {
            this.id = Ga++, this.code = e, this.usedTimes = 0
        }
    }

    function Xa(e, t, n, i, r, a, s) {
        const l = new Jt,
            c = new Wa,
            h = new Set,
            u = [],
            d = r.logarithmicDepthBuffer,
            p = r.vertexTextures;
        let m = r.precision;
        const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };

        function g(e) {
            return h.add(e), 0 === e ? "uv" : `uv${e}`
        }
        return {
            getParameters: function(a, l, u, _, v) {
                const y = _.fog,
                    x = v.geometry,
                    b = a.isMeshStandardMaterial ? _.environment : null,
                    w = (a.isMeshStandardMaterial ? n : t).get(a.envMap || b),
                    S = w && w.mapping === o ? w.image.height : null,
                    M = f[a.type];
                null !== a.precision && (m = r.getMaxPrecision(a.precision), a.precision);
                const T = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color,
                    E = void 0 !== T ? T.length : 0;
                let A, R, C, L, P = 0;
                if (void 0 !== x.morphAttributes.position && (P = 1), void 0 !== x.morphAttributes.normal && (P = 2), void 0 !== x.morphAttributes.color && (P = 3), M) {
                    const e = Bi[M];
                    A = e.vertexShader, R = e.fragmentShader
                } else A = a.vertexShader, R = a.fragmentShader, c.update(a), C = c.getVertexShaderID(a), L = c.getFragmentShaderID(a);
                const D = e.getRenderTarget(),
                    U = e.state.buffers.depth.getReversed(),
                    I = !0 === v.isInstancedMesh,
                    N = !0 === v.isBatchedMesh,
                    O = !!a.map,
                    k = !!a.matcap,
                    F = !!w,
                    B = !!a.aoMap,
                    z = !!a.lightMap,
                    H = !!a.bumpMap,
                    V = !!a.normalMap,
                    G = !!a.displacementMap,
                    W = !!a.emissiveMap,
                    q = !!a.metalnessMap,
                    X = !!a.roughnessMap,
                    j = a.anisotropy > 0,
                    Y = a.clearcoat > 0,
                    K = a.dispersion > 0,
                    Z = a.iridescence > 0,
                    $ = a.sheen > 0,
                    J = a.transmission > 0,
                    Q = j && !!a.anisotropyMap,
                    ee = Y && !!a.clearcoatMap,
                    te = Y && !!a.clearcoatNormalMap,
                    ne = Y && !!a.clearcoatRoughnessMap,
                    ie = Z && !!a.iridescenceMap,
                    re = Z && !!a.iridescenceThicknessMap,
                    ae = $ && !!a.sheenColorMap,
                    se = $ && !!a.sheenRoughnessMap,
                    oe = !!a.specularMap,
                    le = !!a.specularColorMap,
                    ce = !!a.specularIntensityMap,
                    he = J && !!a.transmissionMap,
                    ue = J && !!a.thicknessMap,
                    de = !!a.gradientMap,
                    pe = !!a.alphaMap,
                    me = a.alphaTest > 0,
                    fe = !!a.alphaHash,
                    ge = !!a.extensions;
                let ve = 0;
                a.toneMapped && (null !== D && !0 !== D.isXRRenderTarget || (ve = e.toneMapping));
                const xe = {
                    shaderID: M,
                    shaderType: a.type,
                    shaderName: a.name,
                    vertexShader: A,
                    fragmentShader: R,
                    defines: a.defines,
                    customVertexShaderID: C,
                    customFragmentShaderID: L,
                    isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                    glslVersion: a.glslVersion,
                    precision: m,
                    batching: N,
                    batchingColor: N && null !== v._colorsTexture,
                    instancing: I,
                    instancingColor: I && null !== v.instanceColor,
                    instancingMorph: I && null !== v.morphTexture,
                    supportsVertexTextures: p,
                    outputColorSpace: null === D ? e.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : _e,
                    alphaToCoverage: !!a.alphaToCoverage,
                    map: O,
                    matcap: k,
                    envMap: F,
                    envMapMode: F && w.mapping,
                    envMapCubeUVHeight: S,
                    aoMap: B,
                    lightMap: z,
                    bumpMap: H,
                    normalMap: V,
                    displacementMap: p && G,
                    emissiveMap: W,
                    normalMapObjectSpace: V && 1 === a.normalMapType,
                    normalMapTangentSpace: V && 0 === a.normalMapType,
                    metalnessMap: q,
                    roughnessMap: X,
                    anisotropy: j,
                    anisotropyMap: Q,
                    clearcoat: Y,
                    clearcoatMap: ee,
                    clearcoatNormalMap: te,
                    clearcoatRoughnessMap: ne,
                    dispersion: K,
                    iridescence: Z,
                    iridescenceMap: ie,
                    iridescenceThicknessMap: re,
                    sheen: $,
                    sheenColorMap: ae,
                    sheenRoughnessMap: se,
                    specularMap: oe,
                    specularColorMap: le,
                    specularIntensityMap: ce,
                    transmission: J,
                    transmissionMap: he,
                    thicknessMap: ue,
                    gradientMap: de,
                    opaque: !1 === a.transparent && 1 === a.blending && !1 === a.alphaToCoverage,
                    alphaMap: pe,
                    alphaTest: me,
                    alphaHash: fe,
                    combine: a.combine,
                    mapUv: O && g(a.map.channel),
                    aoMapUv: B && g(a.aoMap.channel),
                    lightMapUv: z && g(a.lightMap.channel),
                    bumpMapUv: H && g(a.bumpMap.channel),
                    normalMapUv: V && g(a.normalMap.channel),
                    displacementMapUv: G && g(a.displacementMap.channel),
                    emissiveMapUv: W && g(a.emissiveMap.channel),
                    metalnessMapUv: q && g(a.metalnessMap.channel),
                    roughnessMapUv: X && g(a.roughnessMap.channel),
                    anisotropyMapUv: Q && g(a.anisotropyMap.channel),
                    clearcoatMapUv: ee && g(a.clearcoatMap.channel),
                    clearcoatNormalMapUv: te && g(a.clearcoatNormalMap.channel),
                    clearcoatRoughnessMapUv: ne && g(a.clearcoatRoughnessMap.channel),
                    iridescenceMapUv: ie && g(a.iridescenceMap.channel),
                    iridescenceThicknessMapUv: re && g(a.iridescenceThicknessMap.channel),
                    sheenColorMapUv: ae && g(a.sheenColorMap.channel),
                    sheenRoughnessMapUv: se && g(a.sheenRoughnessMap.channel),
                    specularMapUv: oe && g(a.specularMap.channel),
                    specularColorMapUv: le && g(a.specularColorMap.channel),
                    specularIntensityMapUv: ce && g(a.specularIntensityMap.channel),
                    transmissionMapUv: he && g(a.transmissionMap.channel),
                    thicknessMapUv: ue && g(a.thicknessMap.channel),
                    alphaMapUv: pe && g(a.alphaMap.channel),
                    vertexTangents: !!x.attributes.tangent && (V || j),
                    vertexColors: a.vertexColors,
                    vertexAlphas: !0 === a.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                    pointsUvs: !0 === v.isPoints && !!x.attributes.uv && (O || pe),
                    fog: !!y,
                    useFog: !0 === a.fog,
                    fogExp2: !!y && y.isFogExp2,
                    flatShading: !0 === a.flatShading,
                    sizeAttenuation: !0 === a.sizeAttenuation,
                    logarithmicDepthBuffer: d,
                    reverseDepthBuffer: U,
                    skinning: !0 === v.isSkinnedMesh,
                    morphTargets: void 0 !== x.morphAttributes.position,
                    morphNormals: void 0 !== x.morphAttributes.normal,
                    morphColors: void 0 !== x.morphAttributes.color,
                    morphTargetsCount: E,
                    morphTextureStride: P,
                    numDirLights: l.directional.length,
                    numPointLights: l.point.length,
                    numSpotLights: l.spot.length,
                    numSpotLightMaps: l.spotLightMap.length,
                    numRectAreaLights: l.rectArea.length,
                    numHemiLights: l.hemi.length,
                    numDirLightShadows: l.directionalShadowMap.length,
                    numPointLightShadows: l.pointShadowMap.length,
                    numSpotLightShadows: l.spotShadowMap.length,
                    numSpotLightShadowsWithMaps: l.numSpotLightShadowsWithMaps,
                    numLightProbes: l.numLightProbes,
                    numClippingPlanes: s.numPlanes,
                    numClipIntersection: s.numIntersection,
                    dithering: a.dithering,
                    shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                    shadowMapType: e.shadowMap.type,
                    toneMapping: ve,
                    decodeVideoTexture: O && !0 === a.map.isVideoTexture && qe.getTransfer(a.map.colorSpace) === ye,
                    decodeVideoTextureEmissive: W && !0 === a.emissiveMap.isVideoTexture && qe.getTransfer(a.emissiveMap.colorSpace) === ye,
                    premultipliedAlpha: a.premultipliedAlpha,
                    doubleSided: 2 === a.side,
                    flipSided: 1 === a.side,
                    useDepthPacking: a.depthPacking >= 0,
                    depthPacking: a.depthPacking || 0,
                    index0AttributeName: a.index0AttributeName,
                    extensionClipCullDistance: ge && !0 === a.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                    extensionMultiDraw: (ge && !0 === a.extensions.multiDraw || N) && i.has("WEBGL_multi_draw"),
                    rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                    customProgramCacheKey: a.customProgramCacheKey()
                };
                return xe.vertexUv1s = h.has(1), xe.vertexUv2s = h.has(2), xe.vertexUv3s = h.has(3), h.clear(), xe
            },
            getProgramCacheKey: function(t) {
                const n = [];
                if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                    for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                return !1 === t.isRawShaderMaterial && (function(e, t) {
                    e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.numLightProbes), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking)
                }(n, t), function(e, t) {
                    l.disableAll(), t.supportsVertexTextures && l.enable(0), t.instancing && l.enable(1), t.instancingColor && l.enable(2), t.instancingMorph && l.enable(3), t.matcap && l.enable(4), t.envMap && l.enable(5), t.normalMapObjectSpace && l.enable(6), t.normalMapTangentSpace && l.enable(7), t.clearcoat && l.enable(8), t.iridescence && l.enable(9), t.alphaTest && l.enable(10), t.vertexColors && l.enable(11), t.vertexAlphas && l.enable(12), t.vertexUv1s && l.enable(13), t.vertexUv2s && l.enable(14), t.vertexUv3s && l.enable(15), t.vertexTangents && l.enable(16), t.anisotropy && l.enable(17), t.alphaHash && l.enable(18), t.batching && l.enable(19), t.dispersion && l.enable(20), t.batchingColor && l.enable(21), e.push(l.mask), l.disableAll(), t.fog && l.enable(0), t.useFog && l.enable(1), t.flatShading && l.enable(2), t.logarithmicDepthBuffer && l.enable(3), t.reverseDepthBuffer && l.enable(4), t.skinning && l.enable(5), t.morphTargets && l.enable(6), t.morphNormals && l.enable(7), t.morphColors && l.enable(8), t.premultipliedAlpha && l.enable(9), t.shadowMapEnabled && l.enable(10), t.doubleSided && l.enable(11), t.flipSided && l.enable(12), t.useDepthPacking && l.enable(13), t.dithering && l.enable(14), t.transmission && l.enable(15), t.sheen && l.enable(16), t.opaque && l.enable(17), t.pointsUvs && l.enable(18), t.decodeVideoTexture && l.enable(19), t.decodeVideoTextureEmissive && l.enable(20), t.alphaToCoverage && l.enable(21), e.push(l.mask)
                }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join()
            },
            getUniforms: function(e) {
                const t = f[e.type];
                let n;
                if (t) {
                    const e = Bi[t];
                    n = gi.clone(e.uniforms)
                } else n = e.uniforms;
                return n
            },
            acquireProgram: function(t, n) {
                let i;
                for (let e = 0, t = u.length; e < t; e++) {
                    const t = u[e];
                    if (t.cacheKey === n) {
                        i = t, ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new Va(e, n, t, a), u.push(i)), i
            },
            releaseProgram: function(e) {
                if (0 == --e.usedTimes) {
                    const t = u.indexOf(e);
                    u[t] = u[u.length - 1], u.pop(), e.destroy()
                }
            },
            releaseShaderCache: function(e) {
                c.remove(e)
            },
            programs: u,
            dispose: function() {
                c.dispose()
            }
        }
    }

    function ja() {
        let e = new WeakMap;
        return {
            has: function(t) {
                return e.has(t)
            },
            get: function(t) {
                let n = e.get(t);
                return void 0 === n && (n = {}, e.set(t, n)), n
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, n, i) {
                e.get(t)[n] = i
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function Ya(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function Ka(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function Za() {
        const e = [];
        let t = 0;
        const n = [],
            i = [],
            r = [];

        function a(n, i, r, a, s, o) {
            let l = e[t];
            return void 0 === l ? (l = {
                id: n.id,
                object: n,
                geometry: i,
                material: r,
                groupOrder: a,
                renderOrder: n.renderOrder,
                z: s,
                group: o
            }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = s, l.group = o), t++, l
        }
        return {
            opaque: n,
            transmissive: i,
            transparent: r,
            init: function() {
                t = 0, n.length = 0, i.length = 0, r.length = 0
            },
            push: function(e, t, s, o, l, c) {
                const h = a(e, t, s, o, l, c);
                s.transmission > 0 ? i.push(h) : !0 === s.transparent ? r.push(h) : n.push(h)
            },
            unshift: function(e, t, s, o, l, c) {
                const h = a(e, t, s, o, l, c);
                s.transmission > 0 ? i.unshift(h) : !0 === s.transparent ? r.unshift(h) : n.unshift(h)
            },
            finish: function() {
                for (let n = t, i = e.length; n < i; n++) {
                    const t = e[n];
                    if (null === t.id) break;
                    t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                }
            },
            sort: function(e, t) {
                n.length > 1 && n.sort(e || Ya), i.length > 1 && i.sort(t || Ka), r.length > 1 && r.sort(t || Ka)
            }
        }
    }

    function $a() {
        let e = new WeakMap;
        return {
            get: function(t, n) {
                const i = e.get(t);
                let r;
                return void 0 === i ? (r = new Za, e.set(t, [r])) : n >= i.length ? (r = new Za, i.push(r)) : r = i[n], r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function Ja() {
        const e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let n;
                switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new ut,
                            color: new In
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new ut,
                            direction: new ut,
                            color: new In,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new ut,
                            color: new In,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new ut,
                            skyColor: new In,
                            groundColor: new In
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new In,
                            position: new ut,
                            halfWidth: new ut,
                            halfHeight: new ut
                        }
                }
                return e[t.id] = n, n
            }
        }
    }
    let Qa = 0;

    function es(e, t) {
        return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
    }

    function ts(e) {
        const t = new Ja,
            n = function() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        let n;
                        switch (t.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ke
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ke,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }(),
            i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
        for (let e = 0; e < 9; e++) i.probe.push(new ut);
        const r = new ut,
            a = new Ht,
            s = new Ht;
        return {
            setup: function(r) {
                let a = 0,
                    s = 0,
                    o = 0;
                for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
                let l = 0,
                    c = 0,
                    h = 0,
                    u = 0,
                    d = 0,
                    p = 0,
                    m = 0,
                    f = 0,
                    g = 0,
                    _ = 0,
                    v = 0;
                r.sort(es);
                for (let e = 0, y = r.length; e < y; e++) {
                    const y = r[e],
                        x = y.color,
                        b = y.intensity,
                        w = y.distance,
                        S = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                    if (y.isAmbientLight) a += x.r * b, s += x.g * b, o += x.b * b;
                    else if (y.isLightProbe) {
                        for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(y.sh.coefficients[e], b);
                        v++
                    } else if (y.isDirectionalLight) {
                        const e = t.get(y);
                        if (e.color.copy(y.color).multiplyScalar(y.intensity), y.castShadow) {
                            const e = y.shadow,
                                t = n.get(y);
                            t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, i.directionalShadow[l] = t, i.directionalShadowMap[l] = S, i.directionalShadowMatrix[l] = y.shadow.matrix, p++
                        }
                        i.directional[l] = e, l++
                    } else if (y.isSpotLight) {
                        const e = t.get(y);
                        e.position.setFromMatrixPosition(y.matrixWorld), e.color.copy(x).multiplyScalar(b), e.distance = w, e.coneCos = Math.cos(y.angle), e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), e.decay = y.decay, i.spot[h] = e;
                        const r = y.shadow;
                        if (y.map && (i.spotLightMap[g] = y.map, g++, r.updateMatrices(y), y.castShadow && _++), i.spotLightMatrix[h] = r.matrix, y.castShadow) {
                            const e = n.get(y);
                            e.shadowIntensity = r.intensity, e.shadowBias = r.bias, e.shadowNormalBias = r.normalBias, e.shadowRadius = r.radius, e.shadowMapSize = r.mapSize, i.spotShadow[h] = e, i.spotShadowMap[h] = S, f++
                        }
                        h++
                    } else if (y.isRectAreaLight) {
                        const e = t.get(y);
                        e.color.copy(x).multiplyScalar(b), e.halfWidth.set(.5 * y.width, 0, 0), e.halfHeight.set(0, .5 * y.height, 0), i.rectArea[u] = e, u++
                    } else if (y.isPointLight) {
                        const e = t.get(y);
                        if (e.color.copy(y.color).multiplyScalar(y.intensity), e.distance = y.distance, e.decay = y.decay, y.castShadow) {
                            const e = y.shadow,
                                t = n.get(y);
                            t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, t.shadowCameraNear = e.camera.near, t.shadowCameraFar = e.camera.far, i.pointShadow[c] = t, i.pointShadowMap[c] = S, i.pointShadowMatrix[c] = y.shadow.matrix, m++
                        }
                        i.point[c] = e, c++
                    } else if (y.isHemisphereLight) {
                        const e = t.get(y);
                        e.skyColor.copy(y.color).multiplyScalar(b), e.groundColor.copy(y.groundColor).multiplyScalar(b), i.hemi[d] = e, d++
                    }
                }
                u > 0 && (!0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Fi.LTC_FLOAT_1, i.rectAreaLTC2 = Fi.LTC_FLOAT_2) : (i.rectAreaLTC1 = Fi.LTC_HALF_1, i.rectAreaLTC2 = Fi.LTC_HALF_2)), i.ambient[0] = a, i.ambient[1] = s, i.ambient[2] = o;
                const y = i.hash;
                y.directionalLength === l && y.pointLength === c && y.spotLength === h && y.rectAreaLength === u && y.hemiLength === d && y.numDirectionalShadows === p && y.numPointShadows === m && y.numSpotShadows === f && y.numSpotMaps === g && y.numLightProbes === v || (i.directional.length = l, i.spot.length = h, i.rectArea.length = u, i.point.length = c, i.hemi.length = d, i.directionalShadow.length = p, i.directionalShadowMap.length = p, i.pointShadow.length = m, i.pointShadowMap.length = m, i.spotShadow.length = f, i.spotShadowMap.length = f, i.directionalShadowMatrix.length = p, i.pointShadowMatrix.length = m, i.spotLightMatrix.length = f + g - _, i.spotLightMap.length = g, i.numSpotLightShadowsWithMaps = _, i.numLightProbes = v, y.directionalLength = l, y.pointLength = c, y.spotLength = h, y.rectAreaLength = u, y.hemiLength = d, y.numDirectionalShadows = p, y.numPointShadows = m, y.numSpotShadows = f, y.numSpotMaps = g, y.numLightProbes = v, i.version = Qa++)
            },
            setupView: function(e, t) {
                let n = 0,
                    o = 0,
                    l = 0,
                    c = 0,
                    h = 0;
                const u = t.matrixWorldInverse;
                for (let t = 0, d = e.length; t < d; t++) {
                    const d = e[t];
                    if (d.isDirectionalLight) {
                        const e = i.directional[n];
                        e.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(u), n++
                    } else if (d.isSpotLight) {
                        const e = i.spot[l];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(u), l++
                    } else if (d.isRectAreaLight) {
                        const e = i.rectArea[c];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), s.identity(), a.copy(d.matrixWorld), a.premultiply(u), s.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), c++
                    } else if (d.isPointLight) {
                        const e = i.point[o];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), o++
                    } else if (d.isHemisphereLight) {
                        const e = i.hemi[h];
                        e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), h++
                    }
                }
            },
            state: i
        }
    }

    function ns(e) {
        const t = new ts(e),
            n = [],
            i = [],
            r = {
                lightsArray: n,
                shadowsArray: i,
                camera: null,
                lights: t,
                transmissionRenderTarget: {}
            };
        return {
            init: function(e) {
                r.camera = e, n.length = 0, i.length = 0
            },
            state: r,
            setupLights: function() {
                t.setup(n)
            },
            setupLightsView: function(e) {
                t.setupView(n, e)
            },
            pushLight: function(e) {
                n.push(e)
            },
            pushShadow: function(e) {
                i.push(e)
            }
        }
    }

    function is(e) {
        let t = new WeakMap;
        return {
            get: function(n, i = 0) {
                const r = t.get(n);
                let a;
                return void 0 === r ? (a = new ns(e), t.set(n, [a])) : i >= r.length ? (a = new ns(e), r.push(a)) : a = r[i], a
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    class rs extends kn {
        static get type() {
            return "MeshDepthMaterial"
        }
        constructor(e) {
            super(), this.isMeshDepthMaterial = !0, this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
        }
    }
    class as extends kn {
        static get type() {
            return "MeshDistanceMaterial"
        }
        constructor(e) {
            super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
        }
    }

    function ss(e, t, n) {
        let i = new Ui;
        const r = new ke,
            a = new ke,
            s = new st,
            o = new rs({
                depthPacking: 3201
            }),
            l = new as,
            c = {},
            h = n.maxTextureSize,
            d = {
                0: 1,
                1: 0,
                2: 2
            },
            p = new _i({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new ke
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            }),
            m = p.clone();
        m.defines.HORIZONTAL_PASS = 1;
        const f = new Jn;
        f.setAttribute("position", new Hn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const g = new hi(f, p),
            _ = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
        let v = this.type;

        function y(n, i) {
            const a = t.update(g);
            p.defines.VSM_SAMPLES !== n.blurSamples && (p.defines.VSM_SAMPLES = n.blurSamples, m.defines.VSM_SAMPLES = n.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), null === n.mapPass && (n.mapPass = new lt(r.x, r.y)), p.uniforms.shadow_pass.value = n.map.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, a, p, g, null), m.uniforms.shadow_pass.value = n.mapPass.texture, m.uniforms.resolution.value = n.mapSize, m.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, a, m, g, null)
        }

        function x(t, n, i, r) {
            let a = null;
            const s = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
            if (void 0 !== s) a = s;
            else if (a = !0 === i.isPointLight ? l : o, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                const e = a.uuid,
                    t = n.uuid;
                let i = c[e];
                void 0 === i && (i = {}, c[e] = i);
                let r = i[t];
                void 0 === r && (r = a.clone(), i[t] = r, n.addEventListener("dispose", w)), a = r
            }
            return a.visible = n.visible, a.wireframe = n.wireframe, a.side = 3 === r ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], a.alphaMap = n.alphaMap, a.alphaTest = n.alphaTest, a.map = n.map, a.clipShadows = n.clipShadows, a.clippingPlanes = n.clippingPlanes, a.clipIntersection = n.clipIntersection, a.displacementMap = n.displacementMap, a.displacementScale = n.displacementScale, a.displacementBias = n.displacementBias, a.wireframeLinewidth = n.wireframeLinewidth, a.linewidth = n.linewidth, !0 === i.isPointLight && !0 === a.isMeshDistanceMaterial && (e.properties.get(a).light = i), a
        }

        function b(n, r, a, s, o) {
            if (!1 === n.visible) return;
            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                const i = t.update(n),
                    l = n.material;
                if (Array.isArray(l)) {
                    const t = i.groups;
                    for (let c = 0, h = t.length; c < h; c++) {
                        const h = t[c],
                            u = l[h.materialIndex];
                        if (u && u.visible) {
                            const t = x(n, u, s, o);
                            n.onBeforeShadow(e, n, r, a, i, t, h), e.renderBufferDirect(a, null, i, t, n, h), n.onAfterShadow(e, n, r, a, i, t, h)
                        }
                    }
                } else if (l.visible) {
                    const t = x(n, l, s, o);
                    n.onBeforeShadow(e, n, r, a, i, t, null), e.renderBufferDirect(a, null, i, t, n, null), n.onAfterShadow(e, n, r, a, i, t, null)
                }
            }
            const l = n.children;
            for (let e = 0, t = l.length; e < t; e++) b(l[e], r, a, s, o)
        }

        function w(e) {
            e.target.removeEventListener("dispose", w);
            for (const t in c) {
                const n = c[t],
                    i = e.target.uuid;
                i in n && (n[i].dispose(), delete n[i])
            }
        }
        this.render = function(t, n, o) {
            if (!1 === _.enabled) return;
            if (!1 === _.autoUpdate && !1 === _.needsUpdate) return;
            if (0 === t.length) return;
            const l = e.getRenderTarget(),
                c = e.getActiveCubeFace(),
                d = e.getActiveMipmapLevel(),
                p = e.state;
            p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
            const m = 3 !== v && 3 === this.type,
                f = 3 === v && 3 !== this.type;
            for (let l = 0, c = t.length; l < c; l++) {
                const c = t[l],
                    d = c.shadow;
                if (void 0 === d) continue;
                if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue;
                r.copy(d.mapSize);
                const g = d.getFrameExtents();
                if (r.multiply(g), a.copy(d.mapSize), (r.x > h || r.y > h) && (r.x > h && (a.x = Math.floor(h / g.x), r.x = a.x * g.x, d.mapSize.x = a.x), r.y > h && (a.y = Math.floor(h / g.y), r.y = a.y * g.y, d.mapSize.y = a.y)), null === d.map || !0 === m || !0 === f) {
                    const e = 3 !== this.type ? {
                        minFilter: u,
                        magFilter: u
                    } : {};
                    null !== d.map && d.map.dispose(), d.map = new lt(r.x, r.y, e), d.map.texture.name = c.name + ".shadowMap", d.camera.updateProjectionMatrix()
                }
                e.setRenderTarget(d.map), e.clear();
                const _ = d.getViewportCount();
                for (let e = 0; e < _; e++) {
                    const t = d.getViewport(e);
                    s.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w), p.viewport(s), d.updateMatrices(c, e), i = d.getFrustum(), b(n, o, d.camera, c, this.type)
                }!0 !== d.isPointLightShadow && 3 === this.type && y(d, o), d.needsUpdate = !1
            }
            v = this.type, _.needsUpdate = !1, e.setRenderTarget(l, c, d)
        }
    }
    const os = {
        0: 1,
        2: 6,
        4: 7,
        3: 5,
        1: 0,
        6: 2,
        7: 4,
        5: 3
    };

    function ls(e, t) {
        const n = new function() {
                let t = !1;
                const n = new st;
                let i = null;
                const r = new st(0, 0, 0, 0);
                return {
                    setMask: function(n) {
                        i === n || t || (e.colorMask(n, n, n, n), i = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, i, a, s, o) {
                        !0 === o && (t *= s, i *= s, a *= s), n.set(t, i, a, s), !1 === r.equals(n) && (e.clearColor(t, i, a, s), r.copy(n))
                    },
                    reset: function() {
                        t = !1, i = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            r = new function() {
                let n = !1,
                    i = !1,
                    r = null,
                    a = null,
                    s = null;
                return {
                    setReversed: function(e) {
                        if (i !== e) {
                            const e = t.get("EXT_clip_control");
                            i ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT) : e.clipControlEXT(e.LOWER_LEFT_EXT, e.NEGATIVE_ONE_TO_ONE_EXT);
                            const n = s;
                            s = null, this.setClear(n)
                        }
                        i = e
                    },
                    getReversed: function() {
                        return i
                    },
                    setTest: function(t) {
                        t ? H(e.DEPTH_TEST) : V(e.DEPTH_TEST)
                    },
                    setMask: function(t) {
                        r === t || n || (e.depthMask(t), r = t)
                    },
                    setFunc: function(t) {
                        if (i && (t = os[t]), a !== t) {
                            switch (t) {
                                case 0:
                                    e.depthFunc(e.NEVER);
                                    break;
                                case 1:
                                    e.depthFunc(e.ALWAYS);
                                    break;
                                case 2:
                                    e.depthFunc(e.LESS);
                                    break;
                                case 3:
                                default:
                                    e.depthFunc(e.LEQUAL);
                                    break;
                                case 4:
                                    e.depthFunc(e.EQUAL);
                                    break;
                                case 5:
                                    e.depthFunc(e.GEQUAL);
                                    break;
                                case 6:
                                    e.depthFunc(e.GREATER);
                                    break;
                                case 7:
                                    e.depthFunc(e.NOTEQUAL)
                            }
                            a = t
                        }
                    },
                    setLocked: function(e) {
                        n = e
                    },
                    setClear: function(t) {
                        s !== t && (i && (t = 1 - t), e.clearDepth(t), s = t)
                    },
                    reset: function() {
                        n = !1, r = null, a = null, s = null, i = !1
                    }
                }
            },
            a = new function() {
                let t = !1,
                    n = null,
                    i = null,
                    r = null,
                    a = null,
                    s = null,
                    o = null,
                    l = null,
                    c = null;
                return {
                    setTest: function(n) {
                        t || (n ? H(e.STENCIL_TEST) : V(e.STENCIL_TEST))
                    },
                    setMask: function(i) {
                        n === i || t || (e.stencilMask(i), n = i)
                    },
                    setFunc: function(t, n, s) {
                        i === t && r === n && a === s || (e.stencilFunc(t, n, s), i = t, r = n, a = s)
                    },
                    setOp: function(t, n, i) {
                        s === t && o === n && l === i || (e.stencilOp(t, n, i), s = t, o = n, l = i)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        c !== t && (e.clearStencil(t), c = t)
                    },
                    reset: function() {
                        t = !1, n = null, i = null, r = null, a = null, s = null, o = null, l = null, c = null
                    }
                }
            },
            s = new WeakMap,
            o = new WeakMap;
        let l = {},
            c = {},
            h = new WeakMap,
            u = [],
            d = null,
            p = !1,
            m = null,
            f = null,
            g = null,
            _ = null,
            v = null,
            y = null,
            x = null,
            b = new In(0, 0, 0),
            w = 0,
            S = !1,
            M = null,
            T = null,
            E = null,
            A = null,
            R = null;
        const C = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let L = !1,
            P = 0;
        const D = e.getParameter(e.VERSION); - 1 !== D.indexOf("WebGL") ? (P = parseFloat(/^WebGL (\d)/.exec(D)[1]), L = P >= 1) : -1 !== D.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]), L = P >= 2);
        let U = null,
            I = {};
        const N = e.getParameter(e.SCISSOR_BOX),
            O = e.getParameter(e.VIEWPORT),
            k = (new st).fromArray(N),
            F = (new st).fromArray(O);

        function B(t, n, i, r) {
            const a = new Uint8Array(4),
                s = e.createTexture();
            e.bindTexture(t, s), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
            for (let s = 0; s < i; s++) t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage2D(n + s, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a);
            return s
        }
        const z = {};

        function H(t) {
            !0 !== l[t] && (e.enable(t), l[t] = !0)
        }

        function V(t) {
            !1 !== l[t] && (e.disable(t), l[t] = !1)
        }
        z[e.TEXTURE_2D] = B(e.TEXTURE_2D, e.TEXTURE_2D, 1), z[e.TEXTURE_CUBE_MAP] = B(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), z[e.TEXTURE_2D_ARRAY] = B(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), z[e.TEXTURE_3D] = B(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), n.setClear(0, 0, 0, 1), r.setClear(1), a.setClear(0), H(e.DEPTH_TEST), r.setFunc(3), X(!1), j(1), H(e.CULL_FACE), q(0);
        const G = {
            [i]: e.FUNC_ADD,
            101: e.FUNC_SUBTRACT,
            102: e.FUNC_REVERSE_SUBTRACT
        };
        G[103] = e.MIN, G[104] = e.MAX;
        const W = {
            200: e.ZERO,
            201: e.ONE,
            202: e.SRC_COLOR,
            204: e.SRC_ALPHA,
            210: e.SRC_ALPHA_SATURATE,
            208: e.DST_COLOR,
            206: e.DST_ALPHA,
            203: e.ONE_MINUS_SRC_COLOR,
            205: e.ONE_MINUS_SRC_ALPHA,
            209: e.ONE_MINUS_DST_COLOR,
            207: e.ONE_MINUS_DST_ALPHA,
            211: e.CONSTANT_COLOR,
            212: e.ONE_MINUS_CONSTANT_COLOR,
            213: e.CONSTANT_ALPHA,
            214: e.ONE_MINUS_CONSTANT_ALPHA
        };

        function q(t, n, r, a, s, o, l, c, h, u) {
            if (0 !== t) {
                if (!1 === p && (H(e.BLEND), p = !0), 5 === t) s = s || n, o = o || r, l = l || a, n === f && s === v || (e.blendEquationSeparate(G[n], G[s]), f = n, v = s), r === g && a === _ && o === y && l === x || (e.blendFuncSeparate(W[r], W[a], W[o], W[l]), g = r, _ = a, y = o, x = l), !1 !== c.equals(b) && h === w || (e.blendColor(c.r, c.g, c.b, h), b.copy(c), w = h), m = t, S = !1;
                else if (t !== m || u !== S) {
                    if (f === i && v === i || (e.blendEquation(e.FUNC_ADD), f = i, v = i), u) switch (t) {
                        case 1:
                            e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            e.blendFunc(e.ONE, e.ONE);
                            break;
                        case 3:
                            e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                            break;
                        case 4:
                            e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)
                    } else switch (t) {
                        case 1:
                            e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            e.blendFunc(e.SRC_ALPHA, e.ONE);
                            break;
                        case 3:
                            e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                            break;
                        case 4:
                            e.blendFunc(e.ZERO, e.SRC_COLOR)
                    }
                    g = null, _ = null, y = null, x = null, b.set(0, 0, 0), w = 0, m = t, S = u
                }
            } else !0 === p && (V(e.BLEND), p = !1)
        }

        function X(t) {
            M !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), M = t)
        }

        function j(t) {
            0 !== t ? (H(e.CULL_FACE), t !== T && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : V(e.CULL_FACE), T = t
        }

        function Y(t, n, i) {
            t ? (H(e.POLYGON_OFFSET_FILL), A === n && R === i || (e.polygonOffset(n, i), A = n, R = i)) : V(e.POLYGON_OFFSET_FILL)
        }
        return {
            buffers: {
                color: n,
                depth: r,
                stencil: a
            },
            enable: H,
            disable: V,
            bindFramebuffer: function(t, n) {
                return c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, t === e.DRAW_FRAMEBUFFER && (c[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (c[e.DRAW_FRAMEBUFFER] = n), !0)
            },
            drawBuffers: function(t, n) {
                let i = u,
                    r = !1;
                if (t) {
                    i = h.get(n), void 0 === i && (i = [], h.set(n, i));
                    const a = t.textures;
                    if (i.length !== a.length || i[0] !== e.COLOR_ATTACHMENT0) {
                        for (let t = 0, n = a.length; t < n; t++) i[t] = e.COLOR_ATTACHMENT0 + t;
                        i.length = a.length, r = !0
                    }
                } else i[0] !== e.BACK && (i[0] = e.BACK, r = !0);
                r && e.drawBuffers(i)
            },
            useProgram: function(t) {
                return d !== t && (e.useProgram(t), d = t, !0)
            },
            setBlending: q,
            setMaterial: function(t, i) {
                2 === t.side ? V(e.CULL_FACE) : H(e.CULL_FACE);
                let s = 1 === t.side;
                i && (s = !s), X(s), 1 === t.blending && !1 === t.transparent ? q(0) : q(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha), r.setFunc(t.depthFunc), r.setTest(t.depthTest), r.setMask(t.depthWrite), n.setMask(t.colorWrite);
                const o = t.stencilWrite;
                a.setTest(o), o && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Y(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? H(e.SAMPLE_ALPHA_TO_COVERAGE) : V(e.SAMPLE_ALPHA_TO_COVERAGE)
            },
            setFlipSided: X,
            setCullFace: j,
            setLineWidth: function(t) {
                t !== E && (L && e.lineWidth(t), E = t)
            },
            setPolygonOffset: Y,
            setScissorTest: function(t) {
                t ? H(e.SCISSOR_TEST) : V(e.SCISSOR_TEST)
            },
            activeTexture: function(t) {
                void 0 === t && (t = e.TEXTURE0 + C - 1), U !== t && (e.activeTexture(t), U = t)
            },
            bindTexture: function(t, n, i) {
                void 0 === i && (i = null === U ? e.TEXTURE0 + C - 1 : U);
                let r = I[i];
                void 0 === r && (r = {
                    type: void 0,
                    texture: void 0
                }, I[i] = r), r.type === t && r.texture === n || (U !== i && (e.activeTexture(i), U = i), e.bindTexture(t, n || z[t]), r.type = t, r.texture = n)
            },
            unbindTexture: function() {
                const t = I[U];
                void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {}
            },
            compressedTexImage3D: function() {
                try {
                    e.compressedTexImage3D.apply(e, arguments)
                } catch (e) {}
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {}
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {}
            },
            updateUBOMapping: function(t, n) {
                let i = o.get(n);
                void 0 === i && (i = new WeakMap, o.set(n, i));
                let r = i.get(t);
                void 0 === r && (r = e.getUniformBlockIndex(n, t.name), i.set(t, r))
            },
            uniformBlockBinding: function(t, n) {
                const i = o.get(n).get(t);
                s.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex), s.set(n, i))
            },
            texStorage2D: function() {
                try {
                    e.texStorage2D.apply(e, arguments)
                } catch (e) {}
            },
            texStorage3D: function() {
                try {
                    e.texStorage3D.apply(e, arguments)
                } catch (e) {}
            },
            texSubImage2D: function() {
                try {
                    e.texSubImage2D.apply(e, arguments)
                } catch (e) {}
            },
            texSubImage3D: function() {
                try {
                    e.texSubImage3D.apply(e, arguments)
                } catch (e) {}
            },
            compressedTexSubImage2D: function() {
                try {
                    e.compressedTexSubImage2D.apply(e, arguments)
                } catch (e) {}
            },
            compressedTexSubImage3D: function() {
                try {
                    e.compressedTexSubImage3D.apply(e, arguments)
                } catch (e) {}
            },
            scissor: function(t) {
                !1 === k.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), k.copy(t))
            },
            viewport: function(t) {
                !1 === F.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), F.copy(t))
            },
            reset: function() {
                e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), r.setReversed(!1), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), l = {}, U = null, I = {}, c = {}, h = new WeakMap, u = [], d = null, p = !1, m = null, f = null, g = null, _ = null, v = null, y = null, x = null, b = new In(0, 0, 0), w = 0, S = !1, M = null, T = null, E = null, A = null, R = null, k.set(0, 0, e.canvas.width, e.canvas.height), F.set(0, 0, e.canvas.width, e.canvas.height), n.reset(), r.reset(), a.reset()
            }
        }
    }

    function cs(e, t, n, i) {
        const r = function(e) {
            switch (e) {
                case g:
                case _:
                    return {
                        byteLength: 1, components: 1
                    };
                case y:
                case v:
                case S:
                    return {
                        byteLength: 2, components: 1
                    };
                case M:
                case T:
                    return {
                        byteLength: 2, components: 4
                    };
                case b:
                case x:
                case w:
                    return {
                        byteLength: 4, components: 1
                    };
                case A:
                    return {
                        byteLength: 4, components: 3
                    }
            }
            throw new Error(`Unknown texture type ${e}.`)
        }(i);
        switch (n) {
            case 1021:
            case 1024:
                return e * t;
            case 1025:
                return e * t * 2;
            case P:
            case D:
                return e * t / r.components * r.byteLength;
            case 1030:
            case U:
                return e * t * 2 / r.components * r.byteLength;
            case 1022:
                return e * t * 3 / r.components * r.byteLength;
            case R:
            case I:
                return e * t * 4 / r.components * r.byteLength;
            case N:
            case O:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case k:
            case F:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case z:
            case V:
                return Math.max(e, 16) * Math.max(t, 8) / 4;
            case B:
            case H:
                return Math.max(e, 8) * Math.max(t, 8) / 2;
            case G:
            case W:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case q:
            case X:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case j:
                return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
            case Y:
                return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
            case K:
                return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
            case Z:
                return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
            case $:
                return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
            case J:
                return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
            case Q:
                return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
            case ee:
                return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
            case te:
                return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
            case ne:
                return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
            case ie:
                return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
            case re:
                return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
            case ae:
                return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
            case se:
            case oe:
            case le:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
            case 36283:
            case ce:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
            case he:
            case ue:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
        }
        throw new Error(`Unable to determine texture byte length for ${n} format.`)
    }

    function hs(e, t, n, i, r, a, s) {
        const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
            g = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
            _ = new ke,
            v = new WeakMap;
        let x;
        const S = new WeakMap;
        let M = !1;
        try {
            M = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (e) {}

        function T(e, t) {
            return M ? new OffscreenCanvas(e, t) : He("canvas")
        }

        function A(e, t, n) {
            let i = 1;
            const r = ne(e);
            if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)), i < 1) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                    const n = Math.floor(i * r.width),
                        a = Math.floor(i * r.height);
                    void 0 === x && (x = T(n, a));
                    const s = t ? T(n, a) : x;
                    return s.width = n, s.height = a, s.getContext("2d").drawImage(e, 0, 0, n, a), s
                }
                return e
            }
            return e
        }

        function P(e) {
            return e.generateMipmaps
        }

        function D(t) {
            e.generateMipmap(t)
        }

        function U(t) {
            return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
        }

        function I(n, i, r, a, s = !1) {
            if (null !== n && void 0 !== e[n]) return e[n];
            let o = i;
            if (i === e.RED && (r === e.FLOAT && (o = e.R32F), r === e.HALF_FLOAT && (o = e.R16F), r === e.UNSIGNED_BYTE && (o = e.R8)), i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.R8UI), r === e.UNSIGNED_SHORT && (o = e.R16UI), r === e.UNSIGNED_INT && (o = e.R32UI), r === e.BYTE && (o = e.R8I), r === e.SHORT && (o = e.R16I), r === e.INT && (o = e.R32I)), i === e.RG && (r === e.FLOAT && (o = e.RG32F), r === e.HALF_FLOAT && (o = e.RG16F), r === e.UNSIGNED_BYTE && (o = e.RG8)), i === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RG8UI), r === e.UNSIGNED_SHORT && (o = e.RG16UI), r === e.UNSIGNED_INT && (o = e.RG32UI), r === e.BYTE && (o = e.RG8I), r === e.SHORT && (o = e.RG16I), r === e.INT && (o = e.RG32I)), i === e.RGB_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGB8UI), r === e.UNSIGNED_SHORT && (o = e.RGB16UI), r === e.UNSIGNED_INT && (o = e.RGB32UI), r === e.BYTE && (o = e.RGB8I), r === e.SHORT && (o = e.RGB16I), r === e.INT && (o = e.RGB32I)), i === e.RGBA_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI), r === e.UNSIGNED_SHORT && (o = e.RGBA16UI), r === e.UNSIGNED_INT && (o = e.RGBA32UI), r === e.BYTE && (o = e.RGBA8I), r === e.SHORT && (o = e.RGBA16I), r === e.INT && (o = e.RGBA32I)), i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5), i === e.RGBA) {
                const t = s ? ve : qe.getTransfer(a);
                r === e.FLOAT && (o = e.RGBA32F), r === e.HALF_FLOAT && (o = e.RGBA16F), r === e.UNSIGNED_BYTE && (o = t === ye ? e.SRGB8_ALPHA8 : e.RGBA8), r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4), r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1)
            }
            return o !== e.R16F && o !== e.R32F && o !== e.RG16F && o !== e.RG32F && o !== e.RGBA16F && o !== e.RGBA32F || t.get("EXT_color_buffer_float"), o
        }

        function N(t, n) {
            let i;
            return t ? null === n || n === b || n === E ? i = e.DEPTH24_STENCIL8 : n === w ? i = e.DEPTH32F_STENCIL8 : n === y && (i = e.DEPTH24_STENCIL8) : null === n || n === b || n === E ? i = e.DEPTH_COMPONENT24 : n === w ? i = e.DEPTH_COMPONENT32F : n === y && (i = e.DEPTH_COMPONENT16), i
        }

        function O(e, t) {
            return !0 === P(e) || e.isFramebufferTexture && e.minFilter !== u && e.minFilter !== p ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
        }

        function k(e) {
            const t = e.target;
            t.removeEventListener("dispose", k),
                function(e) {
                    const t = i.get(e);
                    if (void 0 === t.__webglInit) return;
                    const n = e.source,
                        r = S.get(n);
                    if (r) {
                        const i = r[t.__cacheKey];
                        i.usedTimes--, 0 === i.usedTimes && B(e), 0 === Object.keys(r).length && S.delete(n)
                    }
                    i.remove(e)
                }(t), t.isVideoTexture && v.delete(t)
        }

        function F(t) {
            const n = t.target;
            n.removeEventListener("dispose", F),
                function(t) {
                    const n = i.get(t);
                    if (t.depthTexture && (t.depthTexture.dispose(), i.remove(t.depthTexture)), t.isWebGLCubeRenderTarget)
                        for (let t = 0; t < 6; t++) {
                            if (Array.isArray(n.__webglFramebuffer[t]))
                                for (let i = 0; i < n.__webglFramebuffer[t].length; i++) e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                            else e.deleteFramebuffer(n.__webglFramebuffer[t]);
                            n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                        } else {
                            if (Array.isArray(n.__webglFramebuffer))
                                for (let t = 0; t < n.__webglFramebuffer.length; t++) e.deleteFramebuffer(n.__webglFramebuffer[t]);
                            else e.deleteFramebuffer(n.__webglFramebuffer);
                            if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                                for (let t = 0; t < n.__webglColorRenderbuffer.length; t++) n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                            n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                        }
                    const r = t.textures;
                    for (let t = 0, n = r.length; t < n; t++) {
                        const n = i.get(r[t]);
                        n.__webglTexture && (e.deleteTexture(n.__webglTexture), s.memory.textures--), i.remove(r[t])
                    }
                    i.remove(t)
                }(n)
        }

        function B(t) {
            const n = i.get(t);
            e.deleteTexture(n.__webglTexture);
            const r = t.source;
            delete S.get(r)[n.__cacheKey], s.memory.textures--
        }
        let z = 0;

        function H(t, r) {
            const a = i.get(t);
            if (t.isVideoTexture && function(e) {
                    const t = s.render.frame;
                    v.get(e) !== t && (v.set(e, t), e.update())
                }(t), !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) {
                const e = t.image;
                if (null === e);
                else if (!1 !== e.complete) return void j(a, t, r)
            }
            n.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + r)
        }
        const V = {
                [l]: e.REPEAT,
                [c]: e.CLAMP_TO_EDGE,
                [h]: e.MIRRORED_REPEAT
            },
            G = {
                [u]: e.NEAREST,
                1004: e.NEAREST_MIPMAP_NEAREST,
                [d]: e.NEAREST_MIPMAP_LINEAR,
                [p]: e.LINEAR,
                [m]: e.LINEAR_MIPMAP_NEAREST,
                [f]: e.LINEAR_MIPMAP_LINEAR
            },
            W = {
                512: e.NEVER,
                519: e.ALWAYS,
                513: e.LESS,
                515: e.LEQUAL,
                514: e.EQUAL,
                518: e.GEQUAL,
                516: e.GREATER,
                517: e.NOTEQUAL
            };

        function q(n, a) {
            if (a.type === w && !1 === t.has("OES_texture_float_linear") && (a.magFilter === p || a.magFilter === m || a.magFilter === d || a.magFilter === f || a.minFilter === p || a.minFilter === m || a.minFilter === d || a.minFilter), e.texParameteri(n, e.TEXTURE_WRAP_S, V[a.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, V[a.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, V[a.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, G[a.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, G[a.minFilter]), a.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, W[a.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) {
                if (a.magFilter === u) return;
                if (a.minFilter !== d && a.minFilter !== f) return;
                if (a.type === w && !1 === t.has("OES_texture_float_linear")) return;
                if (a.anisotropy > 1 || i.get(a).__currentAnisotropy) {
                    const s = t.get("EXT_texture_filter_anisotropic");
                    e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy
                }
            }
        }

        function X(t, n) {
            let i = !1;
            void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", k));
            const r = n.source;
            let a = S.get(r);
            void 0 === a && (a = {}, S.set(r, a));
            const o = function(e) {
                const t = [];
                return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join()
            }(n);
            if (o !== t.__cacheKey) {
                void 0 === a[o] && (a[o] = {
                    texture: e.createTexture(),
                    usedTimes: 0
                }, s.memory.textures++, i = !0), a[o].usedTimes++;
                const r = a[t.__cacheKey];
                void 0 !== r && (a[t.__cacheKey].usedTimes--, 0 === r.usedTimes && B(n)), t.__cacheKey = o, t.__webglTexture = a[o].texture
            }
            return i
        }

        function j(t, s, o) {
            let l = e.TEXTURE_2D;
            (s.isDataArrayTexture || s.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY), s.isData3DTexture && (l = e.TEXTURE_3D);
            const c = X(t, s),
                h = s.source;
            n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
            const u = i.get(h);
            if (h.version !== u.__version || !0 === c) {
                n.activeTexture(e.TEXTURE0 + o);
                const t = qe.getPrimaries(qe.workingColorSpace),
                    i = s.colorSpace === fe ? null : qe.getPrimaries(s.colorSpace),
                    d = s.colorSpace === fe || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                let p = A(s.image, !1, r.maxTextureSize);
                p = te(s, p);
                const m = a.convert(s.format, s.colorSpace),
                    f = a.convert(s.type);
                let g, _ = I(s.internalFormat, m, f, s.colorSpace, s.isVideoTexture);
                q(l, s);
                const v = s.mipmaps,
                    y = !0 !== s.isVideoTexture,
                    x = void 0 === u.__version || !0 === c,
                    b = h.dataReady,
                    w = O(s, p);
                if (s.isDepthTexture) _ = N(s.format === L, s.type), x && (y ? n.texStorage2D(e.TEXTURE_2D, 1, _, p.width, p.height) : n.texImage2D(e.TEXTURE_2D, 0, _, p.width, p.height, 0, m, f, null));
                else if (s.isDataTexture)
                    if (v.length > 0) {
                        y && x && n.texStorage2D(e.TEXTURE_2D, w, _, v[0].width, v[0].height);
                        for (let t = 0, i = v.length; t < i; t++) g = v[t], y ? b && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, g.width, g.height, m, f, g.data) : n.texImage2D(e.TEXTURE_2D, t, _, g.width, g.height, 0, m, f, g.data);
                        s.generateMipmaps = !1
                    } else y ? (x && n.texStorage2D(e.TEXTURE_2D, w, _, p.width, p.height), b && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p.width, p.height, m, f, p.data)) : n.texImage2D(e.TEXTURE_2D, 0, _, p.width, p.height, 0, m, f, p.data);
                else if (s.isCompressedTexture)
                    if (s.isCompressedArrayTexture) {
                        y && x && n.texStorage3D(e.TEXTURE_2D_ARRAY, w, _, v[0].width, v[0].height, p.depth);
                        for (let t = 0, i = v.length; t < i; t++)
                            if (g = v[t], s.format !== R) {
                                if (null !== m)
                                    if (y) {
                                        if (b)
                                            if (s.layerUpdates.size > 0) {
                                                const i = cs(g.width, g.height, s.format, s.type);
                                                for (const r of s.layerUpdates) {
                                                    const a = g.data.subarray(r * i / g.data.BYTES_PER_ELEMENT, (r + 1) * i / g.data.BYTES_PER_ELEMENT);
                                                    n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, r, g.width, g.height, 1, m, a)
                                                }
                                                s.clearLayerUpdates()
                                            } else n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, g.width, g.height, p.depth, m, g.data)
                                    } else n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, _, g.width, g.height, p.depth, 0, g.data, 0, 0)
                            } else y ? b && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, g.width, g.height, p.depth, m, f, g.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, _, g.width, g.height, p.depth, 0, m, f, g.data)
                    } else {
                        y && x && n.texStorage2D(e.TEXTURE_2D, w, _, v[0].width, v[0].height);
                        for (let t = 0, i = v.length; t < i; t++) g = v[t], s.format !== R ? null !== m && (y ? b && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, g.width, g.height, m, g.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, _, g.width, g.height, 0, g.data)) : y ? b && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, g.width, g.height, m, f, g.data) : n.texImage2D(e.TEXTURE_2D, t, _, g.width, g.height, 0, m, f, g.data)
                    }
                else if (s.isDataArrayTexture)
                    if (y) {
                        if (x && n.texStorage3D(e.TEXTURE_2D_ARRAY, w, _, p.width, p.height, p.depth), b)
                            if (s.layerUpdates.size > 0) {
                                const t = cs(p.width, p.height, s.format, s.type);
                                for (const i of s.layerUpdates) {
                                    const r = p.data.subarray(i * t / p.data.BYTES_PER_ELEMENT, (i + 1) * t / p.data.BYTES_PER_ELEMENT);
                                    n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, i, p.width, p.height, 1, m, f, r)
                                }
                                s.clearLayerUpdates()
                            } else n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, m, f, p.data)
                    } else n.texImage3D(e.TEXTURE_2D_ARRAY, 0, _, p.width, p.height, p.depth, 0, m, f, p.data);
                else if (s.isData3DTexture) y ? (x && n.texStorage3D(e.TEXTURE_3D, w, _, p.width, p.height, p.depth), b && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, m, f, p.data)) : n.texImage3D(e.TEXTURE_3D, 0, _, p.width, p.height, p.depth, 0, m, f, p.data);
                else if (s.isFramebufferTexture) {
                    if (x)
                        if (y) n.texStorage2D(e.TEXTURE_2D, w, _, p.width, p.height);
                        else {
                            let t = p.width,
                                i = p.height;
                            for (let r = 0; r < w; r++) n.texImage2D(e.TEXTURE_2D, r, _, t, i, 0, m, f, null), t >>= 1, i >>= 1
                        }
                } else if (v.length > 0) {
                    if (y && x) {
                        const t = ne(v[0]);
                        n.texStorage2D(e.TEXTURE_2D, w, _, t.width, t.height)
                    }
                    for (let t = 0, i = v.length; t < i; t++) g = v[t], y ? b && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, m, f, g) : n.texImage2D(e.TEXTURE_2D, t, _, m, f, g);
                    s.generateMipmaps = !1
                } else if (y) {
                    if (x) {
                        const t = ne(p);
                        n.texStorage2D(e.TEXTURE_2D, w, _, t.width, t.height)
                    }
                    b && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, m, f, p)
                } else n.texImage2D(e.TEXTURE_2D, 0, _, m, f, p);
                P(s) && D(l), u.__version = h.version, s.onUpdate && s.onUpdate(s)
            }
            t.__version = s.version
        }

        function Y(t, r, s, l, c, h) {
            const u = a.convert(s.format, s.colorSpace),
                d = a.convert(s.type),
                p = I(s.internalFormat, u, d, s.colorSpace),
                m = i.get(r),
                f = i.get(s);
            if (f.__renderTarget = r, !m.__hasExternalTextures) {
                const t = Math.max(1, r.width >> h),
                    i = Math.max(1, r.height >> h);
                c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, h, p, t, i, r.depth, 0, u, d, null) : n.texImage2D(c, h, p, t, i, 0, u, d, null)
            }
            n.bindFramebuffer(e.FRAMEBUFFER, t), ee(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, f.__webglTexture, 0, Q(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, f.__webglTexture, h), n.bindFramebuffer(e.FRAMEBUFFER, null)
        }

        function K(t, n, i) {
            if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer) {
                const r = n.depthTexture,
                    a = r && r.isDepthTexture ? r.type : null,
                    s = N(n.stencilBuffer, a),
                    l = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                    c = Q(n);
                ee(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, s, n.width, n.height) : i ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, s, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, s, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t)
            } else {
                const t = n.textures;
                for (let r = 0; r < t.length; r++) {
                    const s = t[r],
                        l = a.convert(s.format, s.colorSpace),
                        c = a.convert(s.type),
                        h = I(s.internalFormat, l, c, s.colorSpace),
                        u = Q(n);
                    i && !1 === ee(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, u, h, n.width, n.height) : ee(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, u, h, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, h, n.width, n.height)
                }
            }
            e.bindRenderbuffer(e.RENDERBUFFER, null)
        }

        function Z(t) {
            const r = i.get(t),
                a = !0 === t.isWebGLCubeRenderTarget;
            if (r.__boundDepthTexture !== t.depthTexture) {
                const e = t.depthTexture;
                if (r.__depthDisposeCallback && r.__depthDisposeCallback(), e) {
                    const t = () => {
                        delete r.__boundDepthTexture, delete r.__depthDisposeCallback, e.removeEventListener("dispose", t)
                    };
                    e.addEventListener("dispose", t), r.__depthDisposeCallback = t
                }
                r.__boundDepthTexture = e
            }
            if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                if (a) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(t, r) {
                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (n.bindFramebuffer(e.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    const a = i.get(r.depthTexture);
                    a.__renderTarget = r, a.__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), H(r.depthTexture, 0);
                    const s = a.__webglTexture,
                        l = Q(r);
                    if (r.depthTexture.format === C) ee(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0);
                    else {
                        if (r.depthTexture.format !== L) throw new Error("Unknown depthTexture format");
                        ee(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0)
                    }
                }(r.__webglFramebuffer, t)
            } else if (a) {
                r.__webglDepthbuffer = [];
                for (let i = 0; i < 6; i++)
                    if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]), void 0 === r.__webglDepthbuffer[i]) r.__webglDepthbuffer[i] = e.createRenderbuffer(), K(r.__webglDepthbuffer[i], t, !1);
                    else {
                        const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            a = r.__webglDepthbuffer[i];
                        e.bindRenderbuffer(e.RENDERBUFFER, a), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, a)
                    }
            } else if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), void 0 === r.__webglDepthbuffer) r.__webglDepthbuffer = e.createRenderbuffer(), K(r.__webglDepthbuffer, t, !1);
            else {
                const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                    i = r.__webglDepthbuffer;
                e.bindRenderbuffer(e.RENDERBUFFER, i), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i)
            }
            n.bindFramebuffer(e.FRAMEBUFFER, null)
        }
        const $ = [],
            J = [];

        function Q(e) {
            return Math.min(r.maxSamples, e.samples)
        }

        function ee(e) {
            const n = i.get(e);
            return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
        }

        function te(e, t) {
            const n = e.colorSpace;
            return e.format, e.type, !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== _e && n !== fe && qe.getTransfer(n), t
        }

        function ne(e) {
            return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (_.width = e.naturalWidth || e.width, _.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (_.width = e.displayWidth, _.height = e.displayHeight) : (_.width = e.width, _.height = e.height), _
        }
        this.allocateTextureUnit = function() {
            const e = z;
            return r.maxTextures, z += 1, e
        }, this.resetTextureUnits = function() {
            z = 0
        }, this.setTexture2D = H, this.setTexture2DArray = function(t, r) {
            const a = i.get(t);
            t.version > 0 && a.__version !== t.version ? j(a, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + r)
        }, this.setTexture3D = function(t, r) {
            const a = i.get(t);
            t.version > 0 && a.__version !== t.version ? j(a, t, r) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + r)
        }, this.setTextureCube = function(t, s) {
            const o = i.get(t);
            t.version > 0 && o.__version !== t.version ? function(t, s, o) {
                if (6 !== s.image.length) return;
                const l = X(t, s),
                    c = s.source;
                n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
                const h = i.get(c);
                if (c.version !== h.__version || !0 === l) {
                    n.activeTexture(e.TEXTURE0 + o);
                    const t = qe.getPrimaries(qe.workingColorSpace),
                        i = s.colorSpace === fe ? null : qe.getPrimaries(s.colorSpace),
                        u = s.colorSpace === fe || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                    const d = s.isCompressedTexture || s.image[0].isCompressedTexture,
                        p = s.image[0] && s.image[0].isDataTexture,
                        m = [];
                    for (let e = 0; e < 6; e++) m[e] = d || p ? p ? s.image[e].image : s.image[e] : A(s.image[e], !0, r.maxCubemapSize), m[e] = te(s, m[e]);
                    const f = m[0],
                        g = a.convert(s.format, s.colorSpace),
                        _ = a.convert(s.type),
                        v = I(s.internalFormat, g, _, s.colorSpace),
                        y = !0 !== s.isVideoTexture,
                        x = void 0 === h.__version || !0 === l,
                        b = c.dataReady;
                    let w, S = O(s, f);
                    if (q(e.TEXTURE_CUBE_MAP, s), d) {
                        y && x && n.texStorage2D(e.TEXTURE_CUBE_MAP, S, v, f.width, f.height);
                        for (let t = 0; t < 6; t++) {
                            w = m[t].mipmaps;
                            for (let i = 0; i < w.length; i++) {
                                const r = w[i];
                                s.format !== R ? null !== g && (y ? b && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, g, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, v, r.width, r.height, 0, r.data)) : y ? b && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, g, _, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, v, r.width, r.height, 0, g, _, r.data)
                            }
                        }
                    } else {
                        if (w = s.mipmaps, y && x) {
                            w.length > 0 && S++;
                            const t = ne(m[0]);
                            n.texStorage2D(e.TEXTURE_CUBE_MAP, S, v, t.width, t.height)
                        }
                        for (let t = 0; t < 6; t++)
                            if (p) {
                                y ? b && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, m[t].width, m[t].height, g, _, m[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, v, m[t].width, m[t].height, 0, g, _, m[t].data);
                                for (let i = 0; i < w.length; i++) {
                                    const r = w[i].image[t].image;
                                    y ? b && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, g, _, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, v, r.width, r.height, 0, g, _, r.data)
                                }
                            } else {
                                y ? b && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, g, _, m[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, v, g, _, m[t]);
                                for (let i = 0; i < w.length; i++) {
                                    const r = w[i];
                                    y ? b && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, g, _, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, v, g, _, r.image[t])
                                }
                            }
                    }
                    P(s) && D(e.TEXTURE_CUBE_MAP), h.__version = c.version, s.onUpdate && s.onUpdate(s)
                }
                t.__version = s.version
            }(o, t, s) : n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + s)
        }, this.rebindTextures = function(t, n, r) {
            const a = i.get(t);
            void 0 !== n && Y(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== r && Z(t)
        }, this.setupRenderTarget = function(t) {
            const r = t.texture,
                o = i.get(t),
                l = i.get(r);
            t.addEventListener("dispose", F);
            const c = t.textures,
                h = !0 === t.isWebGLCubeRenderTarget,
                u = c.length > 1;
            if (u || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = r.version, s.memory.textures++), h) {
                o.__webglFramebuffer = [];
                for (let t = 0; t < 6; t++)
                    if (r.mipmaps && r.mipmaps.length > 0) {
                        o.__webglFramebuffer[t] = [];
                        for (let n = 0; n < r.mipmaps.length; n++) o.__webglFramebuffer[t][n] = e.createFramebuffer()
                    } else o.__webglFramebuffer[t] = e.createFramebuffer()
            } else {
                if (r.mipmaps && r.mipmaps.length > 0) {
                    o.__webglFramebuffer = [];
                    for (let t = 0; t < r.mipmaps.length; t++) o.__webglFramebuffer[t] = e.createFramebuffer()
                } else o.__webglFramebuffer = e.createFramebuffer();
                if (u)
                    for (let t = 0, n = c.length; t < n; t++) {
                        const n = i.get(c[t]);
                        void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(), s.memory.textures++)
                    }
                if (t.samples > 0 && !1 === ee(t)) {
                    o.__webglMultisampledFramebuffer = e.createFramebuffer(), o.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
                    for (let n = 0; n < c.length; n++) {
                        const i = c[n];
                        o.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[n]);
                        const r = a.convert(i.format, i.colorSpace),
                            s = a.convert(i.type),
                            l = I(i.internalFormat, r, s, i.colorSpace, !0 === t.isXRRenderTarget),
                            h = Q(t);
                        e.renderbufferStorageMultisample(e.RENDERBUFFER, h, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, o.__webglColorRenderbuffer[n])
                    }
                    e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(), K(o.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null)
                }
            }
            if (h) {
                n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture), q(e.TEXTURE_CUBE_MAP, r);
                for (let n = 0; n < 6; n++)
                    if (r.mipmaps && r.mipmaps.length > 0)
                        for (let i = 0; i < r.mipmaps.length; i++) Y(o.__webglFramebuffer[n][i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                    else Y(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                P(r) && D(e.TEXTURE_CUBE_MAP), n.unbindTexture()
            } else if (u) {
                for (let r = 0, a = c.length; r < a; r++) {
                    const a = c[r],
                        s = i.get(a);
                    n.bindTexture(e.TEXTURE_2D, s.__webglTexture), q(e.TEXTURE_2D, a), Y(o.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0), P(a) && D(e.TEXTURE_2D)
                }
                n.unbindTexture()
            } else {
                let i = e.TEXTURE_2D;
                if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), n.bindTexture(i, l.__webglTexture), q(i, r), r.mipmaps && r.mipmaps.length > 0)
                    for (let n = 0; n < r.mipmaps.length; n++) Y(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
                else Y(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
                P(r) && D(i), n.unbindTexture()
            }
            t.depthBuffer && Z(t)
        }, this.updateRenderTargetMipmap = function(e) {
            const t = e.textures;
            for (let r = 0, a = t.length; r < a; r++) {
                const a = t[r];
                if (P(a)) {
                    const t = U(e),
                        r = i.get(a).__webglTexture;
                    n.bindTexture(t, r), D(t), n.unbindTexture()
                }
            }
        }, this.updateMultisampleRenderTarget = function(t) {
            if (t.samples > 0)
                if (!1 === ee(t)) {
                    const r = t.textures,
                        a = t.width,
                        s = t.height;
                    let o = e.COLOR_BUFFER_BIT;
                    const l = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                        c = i.get(t),
                        h = r.length > 1;
                    if (h)
                        for (let t = 0; t < r.length; t++) n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(e.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglFramebuffer);
                    for (let n = 0; n < r.length; n++) {
                        if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)), h) {
                            e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const t = i.get(r[n]).__webglTexture;
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                        }
                        e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, e.NEAREST), !0 === g && ($.length = 0, J.length = 0, $.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && !1 === t.resolveDepthBuffer && ($.push(l), J.push(l), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, J)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, $))
                    }
                    if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), h)
                        for (let t = 0; t < r.length; t++) {
                            n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, c.__webglColorRenderbuffer[t]);
                            const a = i.get(r[t]).__webglTexture;
                            n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0)
                        }
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && g) {
                const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
            }
        }, this.setupDepthRenderbuffer = Z, this.setupFrameBufferTexture = Y, this.useMultisampledRTT = ee
    }

    function us(e, t) {
        return {
            convert: function(n, i = "") {
                let r;
                const a = qe.getTransfer(i);
                if (n === g) return e.UNSIGNED_BYTE;
                if (n === M) return e.UNSIGNED_SHORT_4_4_4_4;
                if (n === T) return e.UNSIGNED_SHORT_5_5_5_1;
                if (n === A) return e.UNSIGNED_INT_5_9_9_9_REV;
                if (n === _) return e.BYTE;
                if (n === v) return e.SHORT;
                if (n === y) return e.UNSIGNED_SHORT;
                if (n === x) return e.INT;
                if (n === b) return e.UNSIGNED_INT;
                if (n === w) return e.FLOAT;
                if (n === S) return e.HALF_FLOAT;
                if (1021 === n) return e.ALPHA;
                if (1022 === n) return e.RGB;
                if (n === R) return e.RGBA;
                if (1024 === n) return e.LUMINANCE;
                if (1025 === n) return e.LUMINANCE_ALPHA;
                if (n === C) return e.DEPTH_COMPONENT;
                if (n === L) return e.DEPTH_STENCIL;
                if (n === P) return e.RED;
                if (n === D) return e.RED_INTEGER;
                if (1030 === n) return e.RG;
                if (n === U) return e.RG_INTEGER;
                if (n === I) return e.RGBA_INTEGER;
                if (n === N || n === O || n === k || n === F)
                    if (a === ye) {
                        if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
                        if (n === N) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (n === O) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (n === k) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (n === F) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    } else {
                        if (r = t.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
                        if (n === N) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (n === O) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (n === k) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (n === F) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    } if (n === B || n === z || n === H || n === V) {
                    if (r = t.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
                    if (n === B) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (n === z) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (n === H) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (n === V) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (n === G || n === W || n === q) {
                    if (r = t.get("WEBGL_compressed_texture_etc"), null === r) return null;
                    if (n === G || n === W) return a === ye ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                    if (n === q) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                }
                if (n === X || n === j || n === Y || n === K || n === Z || n === $ || n === J || n === Q || n === ee || n === te || n === ne || n === ie || n === re || n === ae) {
                    if (r = t.get("WEBGL_compressed_texture_astc"), null === r) return null;
                    if (n === X) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if (n === j) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if (n === Y) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if (n === K) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if (n === Z) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if (n === $) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if (n === J) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if (n === Q) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if (n === ee) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if (n === te) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if (n === ne) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if (n === ie) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if (n === re) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if (n === ae) return a === ye ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                }
                if (n === se || n === oe || n === le) {
                    if (r = t.get("EXT_texture_compression_bptc"), null === r) return null;
                    if (n === se) return a === ye ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                    if (n === oe) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                    if (n === le) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                }
                if (36283 === n || n === ce || n === he || n === ue) {
                    if (r = t.get("EXT_texture_compression_rgtc"), null === r) return null;
                    if (n === se) return r.COMPRESSED_RED_RGTC1_EXT;
                    if (n === ce) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                    if (n === he) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                    if (n === ue) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                }
                return n === E ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
            }
        }
    }
    class ds extends wi {
        constructor(e = []) {
            super(), this.isArrayCamera = !0, this.cameras = e
        }
    }
    class ps extends fn {
        constructor() {
            super(), this.isGroup = !0, this.type = "Group"
        }
    }
    const ms = {
        type: "move"
    };
    class fs {
        constructor() {
            this._targetRay = null, this._grip = null, this._hand = null
        }
        getHandSpace() {
            return null === this._hand && (this._hand = new ps, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand
        }
        getTargetRaySpace() {
            return null === this._targetRay && (this._targetRay = new ps, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ut, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ut), this._targetRay
        }
        getGripSpace() {
            return null === this._grip && (this._grip = new ps, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ut, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ut), this._grip
        }
        dispatchEvent(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
        }
        connect(e) {
            if (e && e.hand) {
                const t = this._hand;
                if (t)
                    for (const n of e.hand.values()) this._getHandJoint(t, n)
            }
            return this.dispatchEvent({
                type: "connected",
                data: e
            }), this
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
        }
        update(e, t, n) {
            let i = null,
                r = null,
                a = null;
            const s = this._targetRay,
                o = this._grip,
                l = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState) {
                if (l && e.hand) {
                    a = !0;
                    for (const i of e.hand.values()) {
                        const e = t.getJointPose(i, n),
                            r = this._getHandJoint(l, i);
                        null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = e.radius), r.visible = null !== e
                    }
                    const i = l.joints["index-finger-tip"],
                        r = l.joints["thumb-tip"],
                        s = i.position.distanceTo(r.position),
                        o = .02,
                        c = .005;
                    l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }))
                } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                null !== s && (i = t.getPose(e.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(ms)))
            }
            return null !== s && (s.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this
        }
        _getHandJoint(e, t) {
            if (void 0 === e.joints[t.jointName]) {
                const n = new ps;
                n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
            }
            return e.joints[t.jointName]
        }
    }
    class gs {
        constructor() {
            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
        }
        init(e, t, n) {
            if (null === this.texture) {
                const i = new at;
                e.properties.get(i).__webglTexture = t.texture, t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i
            }
        }
        getMesh(e) {
            if (null !== this.texture && null === this.mesh) {
                const t = e.cameras[0].viewport,
                    n = new _i({
                        vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                        fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                        uniforms: {
                            depthColor: {
                                value: this.texture
                            },
                            depthWidth: {
                                value: t.z
                            },
                            depthHeight: {
                                value: t.w
                            }
                        }
                    });
                this.mesh = new hi(new Oi(20, 20), n)
            }
            return this.mesh
        }
        reset() {
            this.texture = null, this.mesh = null
        }
        getDepthTexture() {
            return this.texture
        }
    }
    class _s extends Te {
        constructor(e, t) {
            super();
            const n = this;
            let i = null,
                r = 1,
                a = null,
                s = "local-floor",
                o = 1,
                l = null,
                c = null,
                h = null,
                u = null,
                d = null,
                p = null;
            const m = new gs,
                f = t.getContextAttributes();
            let _ = null,
                v = null;
            const y = [],
                x = [],
                w = new ke;
            let S = null;
            const M = new wi;
            M.viewport = new st;
            const T = new wi;
            T.viewport = new st;
            const A = [M, T],
                P = new ds;
            let D = null,
                U = null;

            function I(e) {
                const t = x.indexOf(e.inputSource);
                if (-1 === t) return;
                const n = y[t];
                void 0 !== n && (n.update(e.inputSource, e.frame, l || a), n.dispatchEvent({
                    type: e.type,
                    data: e.inputSource
                }))
            }

            function N() {
                i.removeEventListener("select", I), i.removeEventListener("selectstart", I), i.removeEventListener("selectend", I), i.removeEventListener("squeeze", I), i.removeEventListener("squeezestart", I), i.removeEventListener("squeezeend", I), i.removeEventListener("end", N), i.removeEventListener("inputsourceschange", O);
                for (let e = 0; e < y.length; e++) {
                    const t = x[e];
                    null !== t && (x[e] = null, y[e].disconnect(t))
                }
                D = null, U = null, m.reset(), e.setRenderTarget(_), d = null, u = null, h = null, i = null, v = null, H.stop(), n.isPresenting = !1, e.setPixelRatio(S), e.setSize(w.width, w.height, !1), n.dispatchEvent({
                    type: "sessionend"
                })
            }

            function O(e) {
                for (let t = 0; t < e.removed.length; t++) {
                    const n = e.removed[t],
                        i = x.indexOf(n);
                    i >= 0 && (x[i] = null, y[i].disconnect(n))
                }
                for (let t = 0; t < e.added.length; t++) {
                    const n = e.added[t];
                    let i = x.indexOf(n);
                    if (-1 === i) {
                        for (let e = 0; e < y.length; e++) {
                            if (e >= x.length) {
                                x.push(n), i = e;
                                break
                            }
                            if (null === x[e]) {
                                x[e] = n, i = e;
                                break
                            }
                        }
                        if (-1 === i) break
                    }
                    const r = y[i];
                    r && r.connect(n)
                }
            }
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                let t = y[e];
                return void 0 === t && (t = new fs, y[e] = t), t.getTargetRaySpace()
            }, this.getControllerGrip = function(e) {
                let t = y[e];
                return void 0 === t && (t = new fs, y[e] = t), t.getGripSpace()
            }, this.getHand = function(e) {
                let t = y[e];
                return void 0 === t && (t = new fs, y[e] = t), t.getHandSpace()
            }, this.setFramebufferScaleFactor = function(e) {
                r = e, n.isPresenting
            }, this.setReferenceSpaceType = function(e) {
                s = e, n.isPresenting
            }, this.getReferenceSpace = function() {
                return l || a
            }, this.setReferenceSpace = function(e) {
                l = e
            }, this.getBaseLayer = function() {
                return null !== u ? u : d
            }, this.getBinding = function() {
                return h
            }, this.getFrame = function() {
                return p
            }, this.getSession = function() {
                return i
            }, this.setSession = async function(c) {
                if (i = c, null !== i) {
                    if (_ = e.getRenderTarget(), i.addEventListener("select", I), i.addEventListener("selectstart", I), i.addEventListener("selectend", I), i.addEventListener("squeeze", I), i.addEventListener("squeezestart", I), i.addEventListener("squeezeend", I), i.addEventListener("end", N), i.addEventListener("inputsourceschange", O), !0 !== f.xrCompatible && await t.makeXRCompatible(), S = e.getPixelRatio(), e.getSize(w), void 0 === i.renderState.layers) {
                        const n = {
                            antialias: f.antialias,
                            alpha: !0,
                            depth: f.depth,
                            stencil: f.stencil,
                            framebufferScaleFactor: r
                        };
                        d = new XRWebGLLayer(i, t, n), i.updateRenderState({
                            baseLayer: d
                        }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, !1), v = new lt(d.framebufferWidth, d.framebufferHeight, {
                            format: R,
                            type: g,
                            colorSpace: e.outputColorSpace,
                            stencilBuffer: f.stencil
                        })
                    } else {
                        let n = null,
                            a = null,
                            s = null;
                        f.depth && (s = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = f.stencil ? L : C, a = f.stencil ? E : b);
                        const o = {
                            colorFormat: t.RGBA8,
                            depthFormat: s,
                            scaleFactor: r
                        };
                        h = new XRWebGLBinding(i, t), u = h.createProjectionLayer(o), i.updateRenderState({
                            layers: [u]
                        }), e.setPixelRatio(1), e.setSize(u.textureWidth, u.textureHeight, !1), v = new lt(u.textureWidth, u.textureHeight, {
                            format: R,
                            type: g,
                            depthTexture: new vr(u.textureWidth, u.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, n),
                            stencilBuffer: f.stencil,
                            colorSpace: e.outputColorSpace,
                            samples: f.antialias ? 4 : 0,
                            resolveDepthBuffer: !1 === u.ignoreDepthValues
                        })
                    }
                    v.isXRRenderTarget = !0, this.setFoveation(o), l = null, a = await i.requestReferenceSpace(s), H.setContext(i), H.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }, this.getEnvironmentBlendMode = function() {
                if (null !== i) return i.environmentBlendMode
            }, this.getDepthTexture = function() {
                return m.getDepthTexture()
            };
            const k = new ut,
                F = new ut;

            function B(e, t) {
                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
            }
            this.updateCamera = function(e) {
                if (null === i) return;
                let t = e.near,
                    n = e.far;
                null !== m.texture && (m.depthNear > 0 && (t = m.depthNear), m.depthFar > 0 && (n = m.depthFar)), P.near = T.near = M.near = t, P.far = T.far = M.far = n, D === P.near && U === P.far || (i.updateRenderState({
                    depthNear: P.near,
                    depthFar: P.far
                }), D = P.near, U = P.far), M.layers.mask = 2 | e.layers.mask, T.layers.mask = 4 | e.layers.mask, P.layers.mask = M.layers.mask | T.layers.mask;
                const r = e.parent,
                    a = P.cameras;
                B(P, r);
                for (let e = 0; e < a.length; e++) B(a[e], r);
                2 === a.length ? function(e, t, n) {
                        k.setFromMatrixPosition(t.matrixWorld), F.setFromMatrixPosition(n.matrixWorld);
                        const i = k.distanceTo(F),
                            r = t.projectionMatrix.elements,
                            a = n.projectionMatrix.elements,
                            s = r[14] / (r[10] - 1),
                            o = r[14] / (r[10] + 1),
                            l = (r[9] + 1) / r[5],
                            c = (r[9] - 1) / r[5],
                            h = (r[8] - 1) / r[0],
                            u = (a[8] + 1) / a[0],
                            d = s * h,
                            p = s * u,
                            m = i / (-h + u),
                            f = m * -h;
                        if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(m), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), -1 === r[10]) e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                        else {
                            const t = s + m,
                                n = o + m,
                                r = d - f,
                                a = p + (i - f),
                                h = l * o / n * t,
                                u = c * o / n * t;
                            e.projectionMatrix.makePerspective(r, a, h, u, t, n), e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                        }
                    }(P, M, T) : P.projectionMatrix.copy(M.projectionMatrix),
                    function(e, t, n) {
                        null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld)), e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * Ce * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1)
                    }(e, P, r)
            }, this.getCamera = function() {
                return P
            }, this.getFoveation = function() {
                if (null !== u || null !== d) return o
            }, this.setFoveation = function(e) {
                o = e, null !== u && (u.fixedFoveation = e), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e)
            }, this.hasDepthSensing = function() {
                return null !== m.texture
            }, this.getDepthSensingMesh = function() {
                return m.getMesh(P)
            };
            let z = null;
            const H = new Ii;
            H.setAnimationLoop((function(t, r) {
                if (c = r.getViewerPose(l || a), p = r, null !== c) {
                    const t = c.views;
                    null !== d && (e.setRenderTargetFramebuffer(v, d.framebuffer), e.setRenderTarget(v));
                    let n = !1;
                    t.length !== P.cameras.length && (P.cameras.length = 0, n = !0);
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        let a = null;
                        if (null !== d) a = d.getViewport(r);
                        else {
                            const t = h.getViewSubImage(u, r);
                            a = t.viewport, 0 === i && (e.setRenderTargetTextures(v, t.colorTexture, u.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(v))
                        }
                        let s = A[i];
                        void 0 === s && (s = new wi, s.layers.enable(i), s.viewport = new st, A[i] = s), s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.quaternion, s.scale), s.projectionMatrix.fromArray(r.projectionMatrix), s.projectionMatrixInverse.copy(s.projectionMatrix).invert(), s.viewport.set(a.x, a.y, a.width, a.height), 0 === i && (P.matrix.copy(s.matrix), P.matrix.decompose(P.position, P.quaternion, P.scale)), !0 === n && P.cameras.push(s)
                    }
                    const r = i.enabledFeatures;
                    if (r && r.includes("depth-sensing")) {
                        const n = h.getDepthInformation(t[0]);
                        n && n.isValid && n.texture && m.init(e, n, i.renderState)
                    }
                }
                for (let e = 0; e < y.length; e++) {
                    const t = x[e],
                        n = y[e];
                    null !== t && void 0 !== n && n.update(t, r, l || a)
                }
                z && z(t, r), r.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: r
                }), p = null
            })), this.setAnimationLoop = function(e) {
                z = e
            }, this.dispose = function() {}
        }
    }
    const vs = new $t,
        ys = new Ht;

    function xs(e, t) {
        function n(e, t) {
            !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix)
        }

        function i(e, i) {
            e.opacity.value = i.opacity, i.color && e.diffuse.value.copy(i.color), i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (e.map.value = i.map, n(i.map, e.mapTransform)), i.alphaMap && (e.alphaMap.value = i.alphaMap, n(i.alphaMap, e.alphaMapTransform)), i.bumpMap && (e.bumpMap.value = i.bumpMap, n(i.bumpMap, e.bumpMapTransform), e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, n(i.normalMap, e.normalMapTransform), e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, n(i.displacementMap, e.displacementMapTransform), e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap, n(i.emissiveMap, e.emissiveMapTransform)), i.specularMap && (e.specularMap.value = i.specularMap, n(i.specularMap, e.specularMapTransform)), i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
            const r = t.get(i),
                a = r.envMap,
                s = r.envMapRotation;
            a && (e.envMap.value = a, vs.copy(s), vs.x *= -1, vs.y *= -1, vs.z *= -1, a.isCubeTexture && !1 === a.isRenderTargetTexture && (vs.y *= -1, vs.z *= -1), e.envMapRotation.value.setFromMatrix4(ys.makeRotationFromEuler(vs)), e.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = i.reflectivity, e.ior.value = i.ior, e.refractionRatio.value = i.refractionRatio), i.lightMap && (e.lightMap.value = i.lightMap, e.lightMapIntensity.value = i.lightMapIntensity, n(i.lightMap, e.lightMapTransform)), i.aoMap && (e.aoMap.value = i.aoMap, e.aoMapIntensity.value = i.aoMapIntensity, n(i.aoMap, e.aoMapTransform))
        }
        return {
            refreshFogUniforms: function(t, n) {
                n.color.getRGB(t.fogColor.value, fi(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
            },
            refreshMaterialUniforms: function(e, r, a, s, o) {
                r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r), function(e, t) {
                    t.gradientMap && (e.gradientMap.value = t.gradientMap)
                }(e, r)) : r.isMeshPhongMaterial ? (i(e, r), function(e, t) {
                    e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4)
                }(e, r)) : r.isMeshStandardMaterial ? (i(e, r), function(e, t) {
                    e.metalness.value = t.metalness, t.metalnessMap && (e.metalnessMap.value = t.metalnessMap, n(t.metalnessMap, e.metalnessMapTransform)), e.roughness.value = t.roughness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap, n(t.roughnessMap, e.roughnessMapTransform)), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                }(e, r), r.isMeshPhysicalMaterial && function(e, t, i) {
                    e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), 1 === t.side && e.clearcoatNormalScale.value.negate())), t.dispersion > 0 && (e.dispersion.value = t.dispersion), t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform))), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform)), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform))
                }(e, r, o)) : r.isMeshMatcapMaterial ? (i(e, r), function(e, t) {
                    t.matcap && (e.matcap.value = t.matcap)
                }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r), function(e, n) {
                    const i = t.get(n).light;
                    e.referencePosition.value.setFromMatrixPosition(i.matrixWorld), e.nearDistance.value = i.shadow.camera.near, e.farDistance.value = i.shadow.camera.far
                }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, n(t.map, e.mapTransform))
                }(e, r), r.isLineDashedMaterial && function(e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }(e, r)) : r.isPointsMaterial ? function(e, t, i, r) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * i, e.scale.value = .5 * r, t.map && (e.map.value = t.map, n(t.map, e.uvTransform)), t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                }(e, r, a, s) : r.isSpriteMaterial ? function(e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, n(t.map, e.mapTransform)), t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
            }
        }
    }

    function bs(e, t, n, i) {
        let r = {},
            a = {},
            s = [];
        const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);

        function l(e, t, n, i) {
            const r = e.value,
                a = t + "_" + n;
            if (void 0 === i[a]) return i[a] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0;
            {
                const e = i[a];
                if ("number" == typeof r || "boolean" == typeof r) {
                    if (e !== r) return i[a] = r, !0
                } else if (!1 === e.equals(r)) return e.copy(r), !0
            }
            return !1
        }

        function c(e) {
            const t = {
                boundary: 0,
                storage: 0
            };
            return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture, t
        }

        function h(t) {
            const n = t.target;
            n.removeEventListener("dispose", h);
            const i = s.indexOf(n.__bindingPointIndex);
            s.splice(i, 1), e.deleteBuffer(r[n.id]), delete r[n.id], delete a[n.id]
        }
        return {
            bind: function(e, t) {
                const n = t.program;
                i.uniformBlockBinding(e, n)
            },
            update: function(n, u) {
                let d = r[n.id];
                void 0 === d && (function(e) {
                    const t = e.uniforms;
                    let n = 0;
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = Array.isArray(t[e]) ? t[e] : [t[e]];
                        for (let e = 0, t = i.length; e < t; e++) {
                            const t = i[e],
                                r = Array.isArray(t.value) ? t.value : [t.value];
                            for (let e = 0, i = r.length; e < i; e++) {
                                const i = c(r[e]),
                                    a = n % 16,
                                    s = a % i.boundary,
                                    o = a + s;
                                n += s, 0 !== o && 16 - o < i.storage && (n += 16 - o), t.__data = new Float32Array(i.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = n, n += i.storage
                            }
                        }
                    }
                    const i = n % 16;
                    i > 0 && (n += 16 - i), e.__size = n, e.__cache = {}
                }(n), d = function(t) {
                    const n = function() {
                        for (let e = 0; e < o; e++)
                            if (-1 === s.indexOf(e)) return s.push(e), e;
                        return 0
                    }();
                    t.__bindingPointIndex = n;
                    const i = e.createBuffer(),
                        r = t.__size,
                        a = t.usage;
                    return e.bindBuffer(e.UNIFORM_BUFFER, i), e.bufferData(e.UNIFORM_BUFFER, r, a), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, i), i
                }(n), r[n.id] = d, n.addEventListener("dispose", h));
                const p = u.program;
                i.updateUBOMapping(n, p);
                const m = t.render.frame;
                a[n.id] !== m && (function(t) {
                    const n = r[t.id],
                        i = t.uniforms,
                        a = t.__cache;
                    e.bindBuffer(e.UNIFORM_BUFFER, n);
                    for (let t = 0, n = i.length; t < n; t++) {
                        const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                        for (let i = 0, r = n.length; i < r; i++) {
                            const r = n[i];
                            if (!0 === l(r, t, i, a)) {
                                const t = r.__offset,
                                    n = Array.isArray(r.value) ? r.value : [r.value];
                                let i = 0;
                                for (let a = 0; a < n.length; a++) {
                                    const s = n[a],
                                        o = c(s);
                                    "number" == typeof s || "boolean" == typeof s ? (r.__data[0] = s, e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : s.isMatrix3 ? (r.__data[0] = s.elements[0], r.__data[1] = s.elements[1], r.__data[2] = s.elements[2], r.__data[3] = 0, r.__data[4] = s.elements[3], r.__data[5] = s.elements[4], r.__data[6] = s.elements[5], r.__data[7] = 0, r.__data[8] = s.elements[6], r.__data[9] = s.elements[7], r.__data[10] = s.elements[8], r.__data[11] = 0) : (s.toArray(r.__data, i), i += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                }
                                e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                            }
                        }
                    }
                    e.bindBuffer(e.UNIFORM_BUFFER, null)
                }(n), a[n.id] = m)
            },
            dispose: function() {
                for (const t in r) e.deleteBuffer(r[t]);
                s = [], r = {}, a = {}
            }
        }
    }
    class ws {
        constructor(e = {}) {
            const {
                canvas: t = Ve(),
                context: i = null,
                depth: r = !0,
                stencil: a = !1,
                alpha: s = !1,
                antialias: o = !1,
                premultipliedAlpha: l = !0,
                preserveDrawingBuffer: c = !1,
                powerPreference: h = "default",
                failIfMajorPerformanceCaveat: u = !1,
                reverseDepthBuffer: d = !1
            } = e;
            let p;
            if (this.isWebGLRenderer = !0, null !== i) {
                if ("undefined" != typeof WebGLRenderingContext && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                p = i.getContextAttributes().alpha
            } else p = s;
            const m = new Uint32Array(4),
                _ = new Int32Array(4);
            let v = null,
                x = null;
            const w = [],
                A = [];
            this.domElement = t, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = ge, this.toneMapping = 0, this.toneMappingExposure = 1;
            const R = this;
            let C = !1,
                L = 0,
                P = 0,
                N = null,
                O = -1,
                k = null;
            const F = new st,
                B = new st;
            let z = null;
            const H = new In(0);
            let V = 0,
                G = t.width,
                W = t.height,
                q = 1,
                X = null,
                j = null;
            const Y = new st(0, 0, G, W),
                K = new st(0, 0, G, W);
            let Z = !1;
            const $ = new Ui;
            let J = !1,
                Q = !1;
            const ee = new Ht,
                te = new Ht,
                ne = new ut,
                ie = new st,
                re = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
            let ae = !1;

            function se() {
                return null === N ? q : 1
            }
            let oe, le, ce, he, ue, de, pe, me, fe, ve, ye, xe, be, we, Se, Me, Te, Ee, Ae, Re, Ce, Le, Pe, De, Ue = i;

            function Ie(e, n) {
                return t.getContext(e, n)
            }
            try {
                const e = {
                    alpha: !0,
                    depth: r,
                    stencil: a,
                    antialias: o,
                    premultipliedAlpha: l,
                    preserveDrawingBuffer: c,
                    powerPreference: h,
                    failIfMajorPerformanceCaveat: u
                };
                if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${n}`), t.addEventListener("webglcontextlost", ke, !1), t.addEventListener("webglcontextrestored", Fe, !1), t.addEventListener("webglcontextcreationerror", Be, !1), null === Ue) {
                    const t = "webgl2";
                    if (Ue = Ie(t, e), null === Ue) throw Ie(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
            } catch (e) {
                throw e
            }

            function Ne() {
                oe = new dr(Ue), oe.init(), Le = new us(Ue, oe), le = new Xi(Ue, oe, e, Le), ce = new ls(Ue, oe), le.reverseDepthBuffer && d && ce.buffers.depth.setReversed(!0), he = new fr(Ue), ue = new ja, de = new hs(Ue, oe, ce, ue, le, Le, he), pe = new Yi(R), me = new ur(R), fe = new Ni(Ue), Pe = new Wi(Ue, fe), ve = new pr(Ue, fe, he, Pe), ye = new _r(Ue, ve, fe, he), Ae = new gr(Ue, le, de), Me = new ji(ue), xe = new Xa(R, pe, me, oe, le, Pe, Me), be = new xs(R, ue), we = new $a, Se = new is(oe), Ee = new Gi(R, pe, me, ce, ye, p, l), Te = new ss(R, ye, le), De = new bs(Ue, he, le, ce), Re = new qi(Ue, oe, he), Ce = new mr(Ue, oe, he), he.programs = xe.programs, R.capabilities = le, R.extensions = oe, R.properties = ue, R.renderLists = we, R.shadowMap = Te, R.state = ce, R.info = he
            }
            Ne();
            const Oe = new _s(R, Ue);

            function ke(e) {
                e.preventDefault(), C = !0
            }

            function Fe() {
                C = !1;
                const e = he.autoReset,
                    t = Te.enabled,
                    n = Te.autoUpdate,
                    i = Te.needsUpdate,
                    r = Te.type;
                Ne(), he.autoReset = e, Te.enabled = t, Te.autoUpdate = n, Te.needsUpdate = i, Te.type = r
            }

            function Be(e) {}

            function ze(e) {
                const t = e.target;
                t.removeEventListener("dispose", ze),
                    function(e) {
                        (function(e) {
                            const t = ue.get(e).programs;
                            void 0 !== t && (t.forEach((function(e) {
                                xe.releaseProgram(e)
                            })), e.isShaderMaterial && xe.releaseShaderCache(e))
                        })(e), ue.remove(e)
                    }(t)
            }

            function He(e, t, n) {
                !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1, e.needsUpdate = !0, et(e, t, n), e.side = 0, e.needsUpdate = !0, et(e, t, n), e.side = 2) : et(e, t, n)
            }
            this.xr = Oe, this.getContext = function() {
                return Ue
            }, this.getContextAttributes = function() {
                return Ue.getContextAttributes()
            }, this.forceContextLoss = function() {
                const e = oe.get("WEBGL_lose_context");
                e && e.loseContext()
            }, this.forceContextRestore = function() {
                const e = oe.get("WEBGL_lose_context");
                e && e.restoreContext()
            }, this.getPixelRatio = function() {
                return q
            }, this.setPixelRatio = function(e) {
                void 0 !== e && (q = e, this.setSize(G, W, !1))
            }, this.getSize = function(e) {
                return e.set(G, W)
            }, this.setSize = function(e, n, i = !0) {
                Oe.isPresenting || (G = e, W = n, t.width = Math.floor(e * q), t.height = Math.floor(n * q), !0 === i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
            }, this.getDrawingBufferSize = function(e) {
                return e.set(G * q, W * q).floor()
            }, this.setDrawingBufferSize = function(e, n, i) {
                G = e, W = n, q = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
            }, this.getCurrentViewport = function(e) {
                return e.copy(F)
            }, this.getViewport = function(e) {
                return e.copy(Y)
            }, this.setViewport = function(e, t, n, i) {
                e.isVector4 ? Y.set(e.x, e.y, e.z, e.w) : Y.set(e, t, n, i), ce.viewport(F.copy(Y).multiplyScalar(q).round())
            }, this.getScissor = function(e) {
                return e.copy(K)
            }, this.setScissor = function(e, t, n, i) {
                e.isVector4 ? K.set(e.x, e.y, e.z, e.w) : K.set(e, t, n, i), ce.scissor(B.copy(K).multiplyScalar(q).round())
            }, this.getScissorTest = function() {
                return Z
            }, this.setScissorTest = function(e) {
                ce.setScissorTest(Z = e)
            }, this.setOpaqueSort = function(e) {
                X = e
            }, this.setTransparentSort = function(e) {
                j = e
            }, this.getClearColor = function(e) {
                return e.copy(Ee.getClearColor())
            }, this.setClearColor = function() {
                Ee.setClearColor.apply(Ee, arguments)
            }, this.getClearAlpha = function() {
                return Ee.getClearAlpha()
            }, this.setClearAlpha = function() {
                Ee.setClearAlpha.apply(Ee, arguments)
            }, this.clear = function(e = !0, t = !0, n = !0) {
                let i = 0;
                if (e) {
                    let e = !1;
                    if (null !== N) {
                        const t = N.texture.format;
                        e = t === I || t === U || t === D
                    }
                    if (e) {
                        const e = N.texture.type,
                            t = e === g || e === b || e === y || e === E || e === M || e === T,
                            n = Ee.getClearColor(),
                            i = Ee.getClearAlpha(),
                            r = n.r,
                            a = n.g,
                            s = n.b;
                        t ? (m[0] = r, m[1] = a, m[2] = s, m[3] = i, Ue.clearBufferuiv(Ue.COLOR, 0, m)) : (_[0] = r, _[1] = a, _[2] = s, _[3] = i, Ue.clearBufferiv(Ue.COLOR, 0, _))
                    } else i |= Ue.COLOR_BUFFER_BIT
                }
                t && (i |= Ue.DEPTH_BUFFER_BIT), n && (i |= Ue.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Ue.clear(i)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                t.removeEventListener("webglcontextlost", ke, !1), t.removeEventListener("webglcontextrestored", Fe, !1), t.removeEventListener("webglcontextcreationerror", Be, !1), we.dispose(), Se.dispose(), ue.dispose(), pe.dispose(), me.dispose(), ye.dispose(), Pe.dispose(), De.dispose(), xe.dispose(), Oe.dispose(), Oe.removeEventListener("sessionstart", Xe), Oe.removeEventListener("sessionend", je), Ye.stop()
            }, this.renderBufferDirect = function(e, t, n, i, r, a) {
                null === t && (t = re);
                const s = r.isMesh && r.matrixWorld.determinant() < 0,
                    o = function(e, t, n, i, r) {
                        !0 !== t.isScene && (t = re), de.resetTextureUnits();
                        const a = t.fog,
                            s = i.isMeshStandardMaterial ? t.environment : null,
                            o = null === N ? R.outputColorSpace : !0 === N.isXRRenderTarget ? N.texture.colorSpace : _e,
                            l = (i.isMeshStandardMaterial ? me : pe).get(i.envMap || s),
                            c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                            h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                            u = !!n.morphAttributes.position,
                            d = !!n.morphAttributes.normal,
                            p = !!n.morphAttributes.color;
                        let m = 0;
                        i.toneMapped && (null !== N && !0 !== N.isXRRenderTarget || (m = R.toneMapping));
                        const f = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                            g = void 0 !== f ? f.length : 0,
                            _ = ue.get(i),
                            v = x.state.lights;
                        if (!0 === J && (!0 === Q || e !== k)) {
                            const t = e === k && i.id === O;
                            Me.setState(i, e, t)
                        }
                        let y = !1;
                        i.version === _.__version ? _.needsLights && _.lightsStateVersion !== v.state.version || _.outputColorSpace !== o || r.isBatchedMesh && !1 === _.batching ? y = !0 : r.isBatchedMesh || !0 !== _.batching ? r.isBatchedMesh && !0 === _.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === _.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === _.instancing ? y = !0 : r.isInstancedMesh || !0 !== _.instancing ? r.isSkinnedMesh && !1 === _.skinning ? y = !0 : r.isSkinnedMesh || !0 !== _.skinning ? r.isInstancedMesh && !0 === _.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === _.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === _.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === _.instancingMorph && null !== r.morphTexture || _.envMap !== l || !0 === i.fog && _.fog !== a ? y = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === Me.numPlanes && _.numIntersection === Me.numIntersection ? (_.vertexAlphas !== c || _.vertexTangents !== h || _.morphTargets !== u || _.morphNormals !== d || _.morphColors !== p || _.toneMapping !== m || _.morphTargetsCount !== g) && (y = !0) : y = !0 : y = !0 : y = !0 : y = !0 : (y = !0, _.__version = i.version);
                        let b = _.currentProgram;
                        !0 === y && (b = et(i, t, r));
                        let w = !1,
                            S = !1,
                            M = !1;
                        const T = b.getUniforms(),
                            E = _.uniforms;
                        if (ce.useProgram(b.program) && (w = !0, S = !0, M = !0), i.id !== O && (O = i.id, S = !0), w || k !== e) {
                            ce.buffers.depth.getReversed() ? (ee.copy(e.projectionMatrix), function(e) {
                                const t = e.elements;
                                t[2] = .5 * t[2] + .5 * t[3], t[6] = .5 * t[6] + .5 * t[7], t[10] = .5 * t[10] + .5 * t[11], t[14] = .5 * t[14] + .5 * t[15]
                            }(ee), function(e) {
                                const t = e.elements; - 1 === t[11] ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = 1 - t[14])
                            }(ee), T.setValue(Ue, "projectionMatrix", ee)) : T.setValue(Ue, "projectionMatrix", e.projectionMatrix), T.setValue(Ue, "viewMatrix", e.matrixWorldInverse);
                            const t = T.map.cameraPosition;
                            void 0 !== t && t.setValue(Ue, ne.setFromMatrixPosition(e.matrixWorld)), le.logarithmicDepthBuffer && T.setValue(Ue, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && T.setValue(Ue, "isOrthographic", !0 === e.isOrthographicCamera), k !== e && (k = e, S = !0, M = !0)
                        }
                        if (r.isSkinnedMesh) {
                            T.setOptional(Ue, r, "bindMatrix"), T.setOptional(Ue, r, "bindMatrixInverse");
                            const e = r.skeleton;
                            e && (null === e.boneTexture && e.computeBoneTexture(), T.setValue(Ue, "boneTexture", e.boneTexture, de))
                        }
                        r.isBatchedMesh && (T.setOptional(Ue, r, "batchingTexture"), T.setValue(Ue, "batchingTexture", r._matricesTexture, de), T.setOptional(Ue, r, "batchingIdTexture"), T.setValue(Ue, "batchingIdTexture", r._indirectTexture, de), T.setOptional(Ue, r, "batchingColorTexture"), null !== r._colorsTexture && T.setValue(Ue, "batchingColorTexture", r._colorsTexture, de));
                        const A = n.morphAttributes;
                        var C, L;
                        if (void 0 === A.position && void 0 === A.normal && void 0 === A.color || Ae.update(r, n, b), (S || _.receiveShadow !== r.receiveShadow) && (_.receiveShadow = r.receiveShadow, T.setValue(Ue, "receiveShadow", r.receiveShadow)), i.isMeshGouraudMaterial && null !== i.envMap && (E.envMap.value = l, E.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), i.isMeshStandardMaterial && null === i.envMap && null !== t.environment && (E.envMapIntensity.value = t.environmentIntensity), S && (T.setValue(Ue, "toneMappingExposure", R.toneMappingExposure), _.needsLights && (L = M, (C = E).ambientLightColor.needsUpdate = L, C.lightProbe.needsUpdate = L, C.directionalLights.needsUpdate = L, C.directionalLightShadows.needsUpdate = L, C.pointLights.needsUpdate = L, C.pointLightShadows.needsUpdate = L, C.spotLights.needsUpdate = L, C.spotLightShadows.needsUpdate = L, C.rectAreaLights.needsUpdate = L, C.hemisphereLights.needsUpdate = L), a && !0 === i.fog && be.refreshFogUniforms(E, a), be.refreshMaterialUniforms(E, i, q, W, x.state.transmissionRenderTarget[e.id]), Sa.upload(Ue, tt(_), E, de)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Sa.upload(Ue, tt(_), E, de), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && T.setValue(Ue, "center", r.center), T.setValue(Ue, "modelViewMatrix", r.modelViewMatrix), T.setValue(Ue, "normalMatrix", r.normalMatrix), T.setValue(Ue, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                            const e = i.uniformsGroups;
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                De.update(n, b), De.bind(n, b)
                            }
                        }
                        return b
                    }(e, t, n, i, r);
                ce.setMaterial(i, s);
                let l = n.index,
                    c = 1;
                if (!0 === i.wireframe) {
                    if (l = ve.getWireframeAttribute(n), void 0 === l) return;
                    c = 2
                }
                const h = n.drawRange,
                    u = n.attributes.position;
                let d = h.start * c,
                    p = (h.start + h.count) * c;
                null !== a && (d = Math.max(d, a.start * c), p = Math.min(p, (a.start + a.count) * c)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != u && (d = Math.max(d, 0), p = Math.min(p, u.count));
                const m = p - d;
                if (m < 0 || m === 1 / 0) return;
                let f;
                Pe.setup(r, i, o, n, l);
                let g = Re;
                if (null !== l && (f = fe.get(l), g = Ce, g.setIndex(f)), r.isMesh) !0 === i.wireframe ? (ce.setLineWidth(i.wireframeLinewidth * se()), g.setMode(Ue.LINES)) : g.setMode(Ue.TRIANGLES);
                else if (r.isLine) {
                    let e = i.linewidth;
                    void 0 === e && (e = 1), ce.setLineWidth(e * se()), r.isLineSegments ? g.setMode(Ue.LINES) : r.isLineLoop ? g.setMode(Ue.LINE_LOOP) : g.setMode(Ue.LINE_STRIP)
                } else r.isPoints ? g.setMode(Ue.POINTS) : r.isSprite && g.setMode(Ue.TRIANGLES);
                if (r.isBatchedMesh)
                    if (null !== r._multiDrawInstances) g.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                    else if (oe.get("WEBGL_multi_draw")) g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                else {
                    const e = r._multiDrawStarts,
                        t = r._multiDrawCounts,
                        n = r._multiDrawCount,
                        a = l ? fe.get(l).bytesPerElement : 1,
                        s = ue.get(i).currentProgram.getUniforms();
                    for (let i = 0; i < n; i++) s.setValue(Ue, "_gl_DrawID", i), g.render(e[i] / a, t[i])
                } else if (r.isInstancedMesh) g.renderInstances(d, m, r.count);
                else if (n.isInstancedBufferGeometry) {
                    const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                        t = Math.min(n.instanceCount, e);
                    g.renderInstances(d, m, t)
                } else g.render(d, m)
            }, this.compile = function(e, t, n = null) {
                null === n && (n = e), x = Se.get(n), x.init(t), A.push(x), n.traverseVisible((function(e) {
                    e.isLight && e.layers.test(t.layers) && (x.pushLight(e), e.castShadow && x.pushShadow(e))
                })), e !== n && e.traverseVisible((function(e) {
                    e.isLight && e.layers.test(t.layers) && (x.pushLight(e), e.castShadow && x.pushShadow(e))
                })), x.setupLights();
                const i = new Set;
                return e.traverse((function(e) {
                    if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite)) return;
                    const t = e.material;
                    if (t)
                        if (Array.isArray(t))
                            for (let r = 0; r < t.length; r++) {
                                const a = t[r];
                                He(a, n, e), i.add(a)
                            } else He(t, n, e), i.add(t)
                })), A.pop(), x = null, i
            }, this.compileAsync = function(e, t, n = null) {
                const i = this.compile(e, t, n);
                return new Promise((t => {
                    function n() {
                        i.forEach((function(e) {
                            ue.get(e).currentProgram.isReady() && i.delete(e)
                        })), 0 !== i.size ? setTimeout(n, 10) : t(e)
                    }
                    null !== oe.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                }))
            };
            let Ge = null;

            function Xe() {
                Ye.stop()
            }

            function je() {
                Ye.start()
            }
            const Ye = new Ii;

            function Ke(e, t, n, i) {
                if (!1 === e.visible) return;
                if (e.layers.test(t.layers))
                    if (e.isGroup) n = e.renderOrder;
                    else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                else if (e.isLight) x.pushLight(e), e.castShadow && x.pushShadow(e);
                else if (e.isSprite) {
                    if (!e.frustumCulled || $.intersectsSprite(e)) {
                        i && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(te);
                        const t = ye.update(e),
                            r = e.material;
                        r.visible && v.push(e, t, r, n, ie.z, null)
                    }
                } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || $.intersectsObject(e))) {
                    const t = ye.update(e),
                        r = e.material;
                    if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), ie.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), ie.copy(t.boundingSphere.center)), ie.applyMatrix4(e.matrixWorld).applyMatrix4(te)), Array.isArray(r)) {
                        const i = t.groups;
                        for (let a = 0, s = i.length; a < s; a++) {
                            const s = i[a],
                                o = r[s.materialIndex];
                            o && o.visible && v.push(e, t, o, n, ie.z, s)
                        }
                    } else r.visible && v.push(e, t, r, n, ie.z, null)
                }
                const r = e.children;
                for (let e = 0, a = r.length; e < a; e++) Ke(r[e], t, n, i)
            }

            function Ze(e, t, n, i) {
                const r = e.opaque,
                    a = e.transmissive,
                    s = e.transparent;
                x.setupLightsView(n), !0 === J && Me.setGlobalState(R.clippingPlanes, n), i && ce.viewport(F.copy(i)), r.length > 0 && Je(r, t, n), a.length > 0 && Je(a, t, n), s.length > 0 && Je(s, t, n), ce.buffers.depth.setTest(!0), ce.buffers.depth.setMask(!0), ce.buffers.color.setMask(!0), ce.setPolygonOffset(!1)
            }

            function $e(e, t, n, i) {
                if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
                void 0 === x.state.transmissionRenderTarget[i.id] && (x.state.transmissionRenderTarget[i.id] = new lt(1, 1, {
                    generateMipmaps: !0,
                    type: oe.has("EXT_color_buffer_half_float") || oe.has("EXT_color_buffer_float") ? S : g,
                    minFilter: f,
                    samples: 4,
                    stencilBuffer: a,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: qe.workingColorSpace
                }));
                const r = x.state.transmissionRenderTarget[i.id],
                    s = i.viewport || F;
                r.setSize(s.z, s.w);
                const o = R.getRenderTarget();
                R.setRenderTarget(r), R.getClearColor(H), V = R.getClearAlpha(), V < 1 && R.setClearColor(16777215, .5), R.clear(), ae && Ee.render(n);
                const l = R.toneMapping;
                R.toneMapping = 0;
                const c = i.viewport;
                if (void 0 !== i.viewport && (i.viewport = void 0), x.setupLightsView(i), !0 === J && Me.setGlobalState(R.clippingPlanes, i), Je(e, n, i), de.updateMultisampleRenderTarget(r), de.updateRenderTargetMipmap(r), !1 === oe.has("WEBGL_multisampled_render_to_texture")) {
                    let e = !1;
                    for (let r = 0, a = t.length; r < a; r++) {
                        const a = t[r],
                            s = a.object,
                            o = a.geometry,
                            l = a.material,
                            c = a.group;
                        if (2 === l.side && s.layers.test(i.layers)) {
                            const t = l.side;
                            l.side = 1, l.needsUpdate = !0, Qe(s, n, i, o, l, c), l.side = t, l.needsUpdate = !0, e = !0
                        }
                    }!0 === e && (de.updateMultisampleRenderTarget(r), de.updateRenderTargetMipmap(r))
                }
                R.setRenderTarget(o), R.setClearColor(H, V), void 0 !== c && (i.viewport = c), R.toneMapping = l
            }

            function Je(e, t, n) {
                const i = !0 === t.isScene ? t.overrideMaterial : null;
                for (let r = 0, a = e.length; r < a; r++) {
                    const a = e[r],
                        s = a.object,
                        o = a.geometry,
                        l = null === i ? a.material : i,
                        c = a.group;
                    s.layers.test(n.layers) && Qe(s, t, n, o, l, c)
                }
            }

            function Qe(e, t, n, i, r, a) {
                e.onBeforeRender(R, t, n, i, r, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(R, t, n, i, e, a), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1, r.needsUpdate = !0, R.renderBufferDirect(n, t, i, r, e, a), r.side = 0, r.needsUpdate = !0, R.renderBufferDirect(n, t, i, r, e, a), r.side = 2) : R.renderBufferDirect(n, t, i, r, e, a), e.onAfterRender(R, t, n, i, r, a)
            }

            function et(e, t, n) {
                !0 !== t.isScene && (t = re);
                const i = ue.get(e),
                    r = x.state.lights,
                    a = x.state.shadowsArray,
                    s = r.state.version,
                    o = xe.getParameters(e, r.state, a, t, n),
                    l = xe.getProgramCacheKey(o);
                let c = i.programs;
                i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? me : pe).get(e.envMap || i.environment), i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === c && (e.addEventListener("dispose", ze), c = new Map, i.programs = c);
                let h = c.get(l);
                if (void 0 !== h) {
                    if (i.currentProgram === h && i.lightsStateVersion === s) return nt(e, o), h
                } else o.uniforms = xe.getUniforms(e), e.onBeforeCompile(o, R), h = xe.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                const u = i.uniforms;
                return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = Me.uniform), nt(e, o), i.needsLights = function(e) {
                    return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                }(e), i.lightsStateVersion = s, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotLightMatrix.value = r.state.spotLightMatrix, u.spotLightMap.value = r.state.spotLightMap, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix), i.currentProgram = h, i.uniformsList = null, h
            }

            function tt(e) {
                if (null === e.uniformsList) {
                    const t = e.currentProgram.getUniforms();
                    e.uniformsList = Sa.seqWithValue(t.seq, e.uniforms)
                }
                return e.uniformsList
            }

            function nt(e, t) {
                const n = ue.get(e);
                n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.batchingColor = t.batchingColor, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.instancingMorph = t.instancingMorph, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
            }
            Ye.setAnimationLoop((function(e) {
                Ge && Ge(e)
            })), "undefined" != typeof self && Ye.setContext(self), this.setAnimationLoop = function(e) {
                Ge = e, Oe.setAnimationLoop(e), null === e ? Ye.stop() : Ye.start()
            }, Oe.addEventListener("sessionstart", Xe), Oe.addEventListener("sessionend", je), this.render = function(e, t) {
                if (void 0 !== t && !0 !== t.isCamera) return;
                if (!0 === C) return;
                if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === Oe.enabled && !0 === Oe.isPresenting && (!0 === Oe.cameraAutoUpdate && Oe.updateCamera(t), t = Oe.getCamera()), !0 === e.isScene && e.onBeforeRender(R, e, t, N), x = Se.get(e, A.length), x.init(t), A.push(x), te.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), $.setFromProjectionMatrix(te), Q = this.localClippingEnabled, J = Me.init(this.clippingPlanes, Q), v = we.get(e, w.length), v.init(), w.push(v), !0 === Oe.enabled && !0 === Oe.isPresenting) {
                    const e = R.xr.getDepthSensingMesh();
                    null !== e && Ke(e, t, -1 / 0, R.sortObjects)
                }
                Ke(e, t, 0, R.sortObjects), v.finish(), !0 === R.sortObjects && v.sort(X, j), ae = !1 === Oe.enabled || !1 === Oe.isPresenting || !1 === Oe.hasDepthSensing(), ae && Ee.addToRenderList(v, e), this.info.render.frame++, !0 === J && Me.beginShadows();
                const n = x.state.shadowsArray;
                Te.render(n, e, t), !0 === J && Me.endShadows(), !0 === this.info.autoReset && this.info.reset();
                const i = v.opaque,
                    r = v.transmissive;
                if (x.setupLights(), t.isArrayCamera) {
                    const n = t.cameras;
                    if (r.length > 0)
                        for (let t = 0, a = n.length; t < a; t++) $e(i, r, e, n[t]);
                    ae && Ee.render(e);
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        Ze(v, e, i, i.viewport)
                    }
                } else r.length > 0 && $e(i, r, e, t), ae && Ee.render(e), Ze(v, e, t);
                null !== N && (de.updateMultisampleRenderTarget(N), de.updateRenderTargetMipmap(N)), !0 === e.isScene && e.onAfterRender(R, e, t), Pe.resetDefaultState(), O = -1, k = null, A.pop(), A.length > 0 ? (x = A[A.length - 1], !0 === J && Me.setGlobalState(R.clippingPlanes, x.state.camera)) : x = null, w.pop(), v = w.length > 0 ? w[w.length - 1] : null
            }, this.getActiveCubeFace = function() {
                return L
            }, this.getActiveMipmapLevel = function() {
                return P
            }, this.getRenderTarget = function() {
                return N
            }, this.setRenderTargetTextures = function(e, t, n) {
                ue.get(e.texture).__webglTexture = t, ue.get(e.depthTexture).__webglTexture = n;
                const i = ue.get(e);
                i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === oe.has("WEBGL_multisampled_render_to_texture") && (i.__useRenderToTexture = !1)
            }, this.setRenderTargetFramebuffer = function(e, t) {
                const n = ue.get(e);
                n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
            }, this.setRenderTarget = function(e, t = 0, n = 0) {
                N = e, L = t, P = n;
                let i = !0,
                    r = null,
                    a = !1,
                    s = !1;
                if (e) {
                    const o = ue.get(e);
                    if (void 0 !== o.__useDefaultFramebuffer) ce.bindFramebuffer(Ue.FRAMEBUFFER, null), i = !1;
                    else if (void 0 === o.__webglFramebuffer) de.setupRenderTarget(e);
                    else if (o.__hasExternalTextures) de.rebindTextures(e, ue.get(e.texture).__webglTexture, ue.get(e.depthTexture).__webglTexture);
                    else if (e.depthBuffer) {
                        const t = e.depthTexture;
                        if (o.__boundDepthTexture !== t) {
                            if (null !== t && ue.has(t) && (e.width !== t.image.width || e.height !== t.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                            de.setupDepthRenderbuffer(e)
                        }
                    }
                    const l = e.texture;
                    (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (s = !0);
                    const c = ue.get(e).__webglFramebuffer;
                    e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t], a = !0) : r = e.samples > 0 && !1 === de.useMultisampledRTT(e) ? ue.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, F.copy(e.viewport), B.copy(e.scissor), z = e.scissorTest
                } else F.copy(Y).multiplyScalar(q).floor(), B.copy(K).multiplyScalar(q).floor(), z = Z;
                if (ce.bindFramebuffer(Ue.FRAMEBUFFER, r) && i && ce.drawBuffers(e, r), ce.viewport(F), ce.scissor(B), ce.setScissorTest(z), a) {
                    const i = ue.get(e.texture);
                    Ue.framebufferTexture2D(Ue.FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, Ue.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                } else if (s) {
                    const i = ue.get(e.texture),
                        r = t || 0;
                    Ue.framebufferTextureLayer(Ue.FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                }
                O = -1
            }, this.readRenderTargetPixels = function(e, t, n, i, r, a, s) {
                if (!e || !e.isWebGLRenderTarget) return;
                let o = ue.get(e).__webglFramebuffer;
                if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                    ce.bindFramebuffer(Ue.FRAMEBUFFER, o);
                    try {
                        const s = e.texture,
                            o = s.format,
                            l = s.type;
                        if (!le.textureFormatReadable(o)) return;
                        if (!le.textureTypeReadable(l)) return;
                        t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && Ue.readPixels(t, n, i, r, Le.convert(o), Le.convert(l), a)
                    } finally {
                        const e = null !== N ? ue.get(N).__webglFramebuffer : null;
                        ce.bindFramebuffer(Ue.FRAMEBUFFER, e)
                    }
                }
            }, this.readRenderTargetPixelsAsync = async function(e, t, n, i, r, a, s) {
                if (!e || !e.isWebGLRenderTarget) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let o = ue.get(e).__webglFramebuffer;
                if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                    const s = e.texture,
                        l = s.format,
                        c = s.type;
                    if (!le.textureFormatReadable(l)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!le.textureTypeReadable(c)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    if (t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r) {
                        ce.bindFramebuffer(Ue.FRAMEBUFFER, o);
                        const e = Ue.createBuffer();
                        Ue.bindBuffer(Ue.PIXEL_PACK_BUFFER, e), Ue.bufferData(Ue.PIXEL_PACK_BUFFER, a.byteLength, Ue.STREAM_READ), Ue.readPixels(t, n, i, r, Le.convert(l), Le.convert(c), 0);
                        const s = null !== N ? ue.get(N).__webglFramebuffer : null;
                        ce.bindFramebuffer(Ue.FRAMEBUFFER, s);
                        const h = Ue.fenceSync(Ue.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        return Ue.flush(), await

                        function(e, t, n) {
                            return new Promise((function(n, i) {
                                setTimeout((function r() {
                                    switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                        case e.WAIT_FAILED:
                                            i();
                                            break;
                                        case e.TIMEOUT_EXPIRED:
                                            setTimeout(r, 4);
                                            break;
                                        default:
                                            n()
                                    }
                                }), 4)
                            }))
                        }(Ue, h), Ue.bindBuffer(Ue.PIXEL_PACK_BUFFER, e), Ue.getBufferSubData(Ue.PIXEL_PACK_BUFFER, 0, a), Ue.deleteBuffer(e), Ue.deleteSync(h), a
                    }
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                }
            }, this.copyFramebufferToTexture = function(e, t = null, n = 0) {
                !0 !== e.isTexture && (We("WebGLRenderer: copyFramebufferToTexture function signature has changed."), t = arguments[0] || null, e = arguments[1]);
                const i = Math.pow(2, -n),
                    r = Math.floor(e.image.width * i),
                    a = Math.floor(e.image.height * i),
                    s = null !== t ? t.x : 0,
                    o = null !== t ? t.y : 0;
                de.setTexture2D(e, 0), Ue.copyTexSubImage2D(Ue.TEXTURE_2D, n, 0, 0, s, o, r, a), ce.unbindTexture()
            }, this.copyTextureToTexture = function(e, t, n = null, i = null, r = 0) {
                let a, s, o, l, c, h, u, d, p;
                !0 !== e.isTexture && (We("WebGLRenderer: copyTextureToTexture function signature has changed."), i = arguments[0] || null, e = arguments[1], t = arguments[2], r = arguments[3] || 0, n = null);
                const m = e.isCompressedTexture ? e.mipmaps[r] : e.image;
                null !== n ? (a = n.max.x - n.min.x, s = n.max.y - n.min.y, o = n.isBox3 ? n.max.z - n.min.z : 1, l = n.min.x, c = n.min.y, h = n.isBox3 ? n.min.z : 0) : (a = m.width, s = m.height, o = m.depth || 1, l = 0, c = 0, h = 0), null !== i ? (u = i.x, d = i.y, p = i.z) : (u = 0, d = 0, p = 0);
                const f = Le.convert(t.format),
                    g = Le.convert(t.type);
                let _;
                t.isData3DTexture ? (de.setTexture3D(t, 0), _ = Ue.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (de.setTexture2DArray(t, 0), _ = Ue.TEXTURE_2D_ARRAY) : (de.setTexture2D(t, 0), _ = Ue.TEXTURE_2D), Ue.pixelStorei(Ue.UNPACK_FLIP_Y_WEBGL, t.flipY), Ue.pixelStorei(Ue.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), Ue.pixelStorei(Ue.UNPACK_ALIGNMENT, t.unpackAlignment);
                const v = Ue.getParameter(Ue.UNPACK_ROW_LENGTH),
                    y = Ue.getParameter(Ue.UNPACK_IMAGE_HEIGHT),
                    x = Ue.getParameter(Ue.UNPACK_SKIP_PIXELS),
                    b = Ue.getParameter(Ue.UNPACK_SKIP_ROWS),
                    w = Ue.getParameter(Ue.UNPACK_SKIP_IMAGES);
                Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH, m.width), Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT, m.height), Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS, l), Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS, c), Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES, h);
                const S = e.isDataArrayTexture || e.isData3DTexture,
                    M = t.isDataArrayTexture || t.isData3DTexture;
                if (e.isRenderTargetTexture || e.isDepthTexture) {
                    const n = ue.get(e),
                        i = ue.get(t),
                        m = ue.get(n.__renderTarget),
                        f = ue.get(i.__renderTarget);
                    ce.bindFramebuffer(Ue.READ_FRAMEBUFFER, m.__webglFramebuffer), ce.bindFramebuffer(Ue.DRAW_FRAMEBUFFER, f.__webglFramebuffer);
                    for (let n = 0; n < o; n++) S && Ue.framebufferTextureLayer(Ue.READ_FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, ue.get(e).__webglTexture, r, h + n), e.isDepthTexture ? (M && Ue.framebufferTextureLayer(Ue.DRAW_FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, ue.get(t).__webglTexture, r, p + n), Ue.blitFramebuffer(l, c, a, s, u, d, a, s, Ue.DEPTH_BUFFER_BIT, Ue.NEAREST)) : M ? Ue.copyTexSubImage3D(_, r, u, d, p + n, l, c, a, s) : Ue.copyTexSubImage2D(_, r, u, d, p + n, l, c, a, s);
                    ce.bindFramebuffer(Ue.READ_FRAMEBUFFER, null), ce.bindFramebuffer(Ue.DRAW_FRAMEBUFFER, null)
                } else M ? e.isDataTexture || e.isData3DTexture ? Ue.texSubImage3D(_, r, u, d, p, a, s, o, f, g, m.data) : t.isCompressedArrayTexture ? Ue.compressedTexSubImage3D(_, r, u, d, p, a, s, o, f, m.data) : Ue.texSubImage3D(_, r, u, d, p, a, s, o, f, g, m) : e.isDataTexture ? Ue.texSubImage2D(Ue.TEXTURE_2D, r, u, d, a, s, f, g, m.data) : e.isCompressedTexture ? Ue.compressedTexSubImage2D(Ue.TEXTURE_2D, r, u, d, m.width, m.height, f, m.data) : Ue.texSubImage2D(Ue.TEXTURE_2D, r, u, d, a, s, f, g, m);
                Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH, v), Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT, y), Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS, x), Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS, b), Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES, w), 0 === r && t.generateMipmaps && Ue.generateMipmap(_), ce.unbindTexture()
            }, this.copyTextureToTexture3D = function(e, t, n = null, i = null, r = 0) {
                return !0 !== e.isTexture && (We("WebGLRenderer: copyTextureToTexture3D function signature has changed."), n = arguments[0] || null, i = arguments[1] || null, e = arguments[2], t = arguments[3], r = arguments[4] || 0), We('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(e, t, n, i, r)
            }, this.initRenderTarget = function(e) {
                void 0 === ue.get(e).__webglFramebuffer && de.setupRenderTarget(e)
            }, this.initTexture = function(e) {
                e.isCubeTexture ? de.setTextureCube(e, 0) : e.isData3DTexture ? de.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? de.setTexture2DArray(e, 0) : de.setTexture2D(e, 0), ce.unbindTexture()
            }, this.resetState = function() {
                L = 0, P = 0, N = null, ce.reset(), Pe.reset()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        get coordinateSystem() {
            return Se
        }
        get outputColorSpace() {
            return this._outputColorSpace
        }
        set outputColorSpace(e) {
            this._outputColorSpace = e;
            const t = this.getContext();
            t.drawingBufferColorspace = qe._getDrawingBufferColorSpace(e), t.unpackColorSpace = qe._getUnpackColorSpace()
        }
    }
    class Ss extends fn {
        constructor() {
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new $t, this.environmentIntensity = 1, this.environmentRotation = new $t, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        copy(e, t) {
            return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
        }
    }
    class Ms {
        constructor(e, t) {
            this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = be, this.updateRanges = [], this.version = 0, this.uuid = Le()
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
        }
        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        clone(e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        toJSON(e) {
            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }
    const Ts = new ut;
    class Es {
        constructor(e, t, n, i = !1) {
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i
        }
        get count() {
            return this.data.count
        }
        get array() {
            return this.data.array
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.data.count; t < n; t++) Ts.fromBufferAttribute(this, t), Ts.applyMatrix4(e), this.setXYZ(t, Ts.x, Ts.y, Ts.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Ts.fromBufferAttribute(this, t), Ts.applyNormalMatrix(e), this.setXYZ(t, Ts.x, Ts.y, Ts.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Ts.fromBufferAttribute(this, t), Ts.transformDirection(e), this.setXYZ(t, Ts.x, Ts.y, Ts.z);
            return this
        }
        getComponent(e, t) {
            let n = this.array[e * this.data.stride + this.offset + t];
            return this.normalized && (n = Ie(n, this.array)), n
        }
        setComponent(e, t, n) {
            return this.normalized && (n = Ne(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
        }
        setX(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
        }
        setY(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
        }
        setZ(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
        }
        setW(e, t) {
            return this.normalized && (t = Ne(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
        }
        getX(e) {
            let t = this.data.array[e * this.data.stride + this.offset];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        getY(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 1];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        getZ(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 2];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        getW(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 3];
            return this.normalized && (t = Ie(t, this.array)), t
        }
        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = Ne(t, this.array), n = Ne(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = Ne(t, this.array), n = Ne(n, this.array), i = Ne(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, r) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = Ne(t, this.array), n = Ne(n, this.array), i = Ne(i, this.array), r = Ne(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
        }
        clone(e) {
            if (void 0 === e) {
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                }
                return new Hn(new this.array.constructor(e), this.itemSize, this.normalized)
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Es(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        }
        toJSON(e) {
            if (void 0 === e) {
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: e,
                    normalized: this.normalized
                }
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }
    const As = new ut,
        Rs = new st,
        Cs = new st,
        Ls = new ut,
        Ps = new Ht,
        Ds = new ut,
        Us = new Dt,
        Is = new Ht,
        Ns = new zt;
    class Os extends hi {
        constructor(e, t) {
            super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = r, this.bindMatrix = new Ht, this.bindMatrixInverse = new Ht, this.boundingBox = null, this.boundingSphere = null
        }
        computeBoundingBox() {
            const e = this.geometry;
            null === this.boundingBox && (this.boundingBox = new mt), this.boundingBox.makeEmpty();
            const t = e.getAttribute("position");
            for (let e = 0; e < t.count; e++) this.getVertexPosition(e, Ds), this.boundingBox.expandByPoint(Ds)
        }
        computeBoundingSphere() {
            const e = this.geometry;
            null === this.boundingSphere && (this.boundingSphere = new Dt), this.boundingSphere.makeEmpty();
            const t = e.getAttribute("position");
            for (let e = 0; e < t.count; e++) this.getVertexPosition(e, Ds), this.boundingSphere.expandByPoint(Ds)
        }
        copy(e, t) {
            return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        }
        raycast(e, t) {
            const n = this.material,
                i = this.matrixWorld;
            void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), Us.copy(this.boundingSphere), Us.applyMatrix4(i), !1 !== e.ray.intersectsSphere(Us) && (Is.copy(i).invert(), Ns.copy(e.ray).applyMatrix4(Is), null !== this.boundingBox && !1 === Ns.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Ns)))
        }
        getVertexPosition(e, t) {
            return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
        }
        bind(e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
        }
        pose() {
            this.skeleton.pose()
        }
        normalizeSkinWeights() {
            const e = new st,
                t = this.geometry.attributes.skinWeight;
            for (let n = 0, i = t.count; n < i; n++) {
                e.fromBufferAttribute(t, n);
                const i = 1 / e.manhattanLength();
                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.bindMode === r ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
        }
        applyBoneTransform(e, t) {
            const n = this.skeleton,
                i = this.geometry;
            Rs.fromBufferAttribute(i.attributes.skinIndex, e), Cs.fromBufferAttribute(i.attributes.skinWeight, e), As.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for (let e = 0; e < 4; e++) {
                const i = Cs.getComponent(e);
                if (0 !== i) {
                    const r = Rs.getComponent(e);
                    Ps.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(Ls.copy(As).applyMatrix4(Ps), i)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
    }
    class ks extends fn {
        constructor() {
            super(), this.isBone = !0, this.type = "Bone"
        }
    }
    class Fs extends at {
        constructor(e = null, t = 1, n = 1, i, r, a, s, o, l = 1003, c = 1003, h, u) {
            super(null, a, s, o, l, c, i, r, h, u), this.isDataTexture = !0, this.image = {
                data: e,
                width: t,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    const Bs = new Ht,
        zs = new Ht;
    class Hs {
        constructor(e = [], t = []) {
            this.uuid = Le(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
        }
        init() {
            const e = this.bones,
                t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
            else if (e.length !== t.length) {
                this.boneInverses = [];
                for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Ht)
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const t = new Ht;
                this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
            }
        }
        pose() {
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const t = this.bones[e];
                t && t.matrixWorld.copy(this.boneInverses[e]).invert()
            }
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const t = this.bones[e];
                t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            }
        }
        update() {
            const e = this.bones,
                t = this.boneInverses,
                n = this.boneMatrices,
                i = this.boneTexture;
            for (let i = 0, r = e.length; i < r; i++) {
                const r = e[i] ? e[i].matrixWorld : zs;
                Bs.multiplyMatrices(r, t[i]), Bs.toArray(n, 16 * i)
            }
            null !== i && (i.needsUpdate = !0)
        }
        clone() {
            return new Hs(this.bones, this.boneInverses)
        }
        computeBoneTexture() {
            let e = Math.sqrt(4 * this.bones.length);
            e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const n = new Fs(t, e, e, R, w);
            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
        }
        getBoneByName(e) {
            for (let t = 0, n = this.bones.length; t < n; t++) {
                const n = this.bones[t];
                if (n.name === e) return n
            }
        }
        dispose() {
            null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for (let n = 0, i = e.bones.length; n < i; n++) {
                let i = t[e.bones[n]];
                void 0 === i && (i = new ks), this.bones.push(i), this.boneInverses.push((new Ht).fromArray(e.boneInverses[n]))
            }
            return this.init(), this
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.6,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones,
                n = this.boneInverses;
            for (let i = 0, r = t.length; i < r; i++) {
                const r = t[i];
                e.bones.push(r.uuid);
                const a = n[i];
                e.boneInverses.push(a.toArray())
            }
            return e
        }
    }
    class Vs extends Hn {
        constructor(e, t, n, i = 1) {
            super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
        }
        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
        }
        toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }
    const Gs = new Ht,
        Ws = new Ht,
        qs = [],
        Xs = new mt,
        js = new Ht,
        Ys = new hi,
        Ks = new Dt;
    class Zs extends hi {
        constructor(e, t, n) {
            super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Vs(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
            for (let e = 0; e < n; e++) this.setMatrixAt(e, js)
        }
        computeBoundingBox() {
            const e = this.geometry,
                t = this.count;
            null === this.boundingBox && (this.boundingBox = new mt), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
            for (let n = 0; n < t; n++) this.getMatrixAt(n, Gs), Xs.copy(e.boundingBox).applyMatrix4(Gs), this.boundingBox.union(Xs)
        }
        computeBoundingSphere() {
            const e = this.geometry,
                t = this.count;
            null === this.boundingSphere && (this.boundingSphere = new Dt), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
            for (let n = 0; n < t; n++) this.getMatrixAt(n, Gs), Ks.copy(e.boundingSphere).applyMatrix4(Gs), this.boundingSphere.union(Ks)
        }
        copy(e, t) {
            return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        }
        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, 3 * e)
        }
        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
        }
        getMorphAt(e, t) {
            const n = t.morphTargetInfluences,
                i = this.morphTexture.source.data.data,
                r = e * (n.length + 1) + 1;
            for (let e = 0; e < n.length; e++) n[e] = i[r + e]
        }
        raycast(e, t) {
            const n = this.matrixWorld,
                i = this.count;
            if (Ys.geometry = this.geometry, Ys.material = this.material, void 0 !== Ys.material && (null === this.boundingSphere && this.computeBoundingSphere(), Ks.copy(this.boundingSphere), Ks.applyMatrix4(n), !1 !== e.ray.intersectsSphere(Ks)))
                for (let r = 0; r < i; r++) {
                    this.getMatrixAt(r, Gs), Ws.multiplyMatrices(n, Gs), Ys.matrixWorld = Ws, Ys.raycast(e, qs);
                    for (let e = 0, n = qs.length; e < n; e++) {
                        const n = qs[e];
                        n.instanceId = r, n.object = this, t.push(n)
                    }
                    qs.length = 0
                }
        }
        setColorAt(e, t) {
            null === this.instanceColor && (this.instanceColor = new Vs(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), t.toArray(this.instanceColor.array, 3 * e)
        }
        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        }
        setMorphAt(e, t) {
            const n = t.morphTargetInfluences,
                i = n.length + 1;
            null === this.morphTexture && (this.morphTexture = new Fs(new Float32Array(i * this.count), i, this.count, P, w));
            const r = this.morphTexture.source.data.data;
            let a = 0;
            for (let e = 0; e < n.length; e++) a += n[e];
            const s = this.geometry.morphTargetsRelative ? 1 : 1 - a,
                o = i * e;
            r[o] = s, r.set(n, o + 1)
        }
        updateMorphTargets() {}
        dispose() {
            return this.dispatchEvent({
                type: "dispose"
            }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null), this
        }
    }
    class $s extends kn {
        static get type() {
            return "LineBasicMaterial"
        }
        constructor(e) {
            super(), this.isLineBasicMaterial = !0, this.color = new In(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
        }
    }
    const Js = new ut,
        Qs = new ut,
        eo = new Ht,
        to = new zt,
        no = new Dt,
        io = new ut,
        ro = new ut;
    class ao extends fn {
        constructor(e = new Jn, t = new $s) {
            super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        computeLineDistances() {
            const e = this.geometry;
            if (null === e.index) {
                const t = e.attributes.position,
                    n = [0];
                for (let e = 1, i = t.count; e < i; e++) Js.fromBufferAttribute(t, e - 1), Qs.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += Js.distanceTo(Qs);
                e.setAttribute("lineDistance", new Wn(n, 1))
            }
            return this
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.matrixWorld,
                r = e.params.Line.threshold,
                a = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(), no.copy(n.boundingSphere), no.applyMatrix4(i), no.radius += r, !1 === e.ray.intersectsSphere(no)) return;
            eo.copy(i).invert(), to.copy(e.ray).applyMatrix4(eo);
            const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                o = s * s,
                l = this.isLineSegments ? 2 : 1,
                c = n.index,
                h = n.attributes.position;
            if (null !== c) {
                const n = Math.max(0, a.start),
                    i = Math.min(c.count, a.start + a.count);
                for (let r = n, a = i - 1; r < a; r += l) {
                    const n = c.getX(r),
                        i = c.getX(r + 1),
                        a = so(this, e, to, o, n, i);
                    a && t.push(a)
                }
                if (this.isLineLoop) {
                    const r = c.getX(i - 1),
                        a = c.getX(n),
                        s = so(this, e, to, o, r, a);
                    s && t.push(s)
                }
            } else {
                const n = Math.max(0, a.start),
                    i = Math.min(h.count, a.start + a.count);
                for (let r = n, a = i - 1; r < a; r += l) {
                    const n = so(this, e, to, o, r, r + 1);
                    n && t.push(n)
                }
                if (this.isLineLoop) {
                    const r = so(this, e, to, o, i - 1, n);
                    r && t.push(r)
                }
            }
        }
        updateMorphTargets() {
            const e = this.geometry.morphAttributes,
                t = Object.keys(e);
            if (t.length > 0) {
                const n = e[t[0]];
                if (void 0 !== n) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let e = 0, t = n.length; e < t; e++) {
                        const t = n[e].name || String(e);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                    }
                }
            }
        }
    }

    function so(e, t, n, i, r, a) {
        const s = e.geometry.attributes.position;
        if (Js.fromBufferAttribute(s, r), Qs.fromBufferAttribute(s, a), n.distanceSqToSegment(Js, Qs, io, ro) > i) return;
        io.applyMatrix4(e.matrixWorld);
        const o = t.ray.origin.distanceTo(io);
        return o < t.near || o > t.far ? void 0 : {
            distance: o,
            point: ro.clone().applyMatrix4(e.matrixWorld),
            index: r,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: e
        }
    }
    const oo = new ut,
        lo = new ut;
    class co extends ao {
        constructor(e, t) {
            super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
        }
        computeLineDistances() {
            const e = this.geometry;
            if (null === e.index) {
                const t = e.attributes.position,
                    n = [];
                for (let e = 0, i = t.count; e < i; e += 2) oo.fromBufferAttribute(t, e), lo.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + oo.distanceTo(lo);
                e.setAttribute("lineDistance", new Wn(n, 1))
            }
            return this
        }
    }
    class ho extends ao {
        constructor(e, t) {
            super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
        }
    }
    class uo extends kn {
        static get type() {
            return "PointsMaterial"
        }
        constructor(e) {
            super(), this.isPointsMaterial = !0, this.color = new In(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
        }
    }
    const po = new Ht,
        mo = new zt,
        fo = new Dt,
        go = new ut;
    class _o extends fn {
        constructor(e = new Jn, t = new uo) {
            super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.matrixWorld,
                r = e.params.Points.threshold,
                a = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(), fo.copy(n.boundingSphere), fo.applyMatrix4(i), fo.radius += r, !1 === e.ray.intersectsSphere(fo)) return;
            po.copy(i).invert(), mo.copy(e.ray).applyMatrix4(po);
            const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                o = s * s,
                l = n.index,
                c = n.attributes.position;
            if (null !== l)
                for (let n = Math.max(0, a.start), r = Math.min(l.count, a.start + a.count); n < r; n++) {
                    const r = l.getX(n);
                    go.fromBufferAttribute(c, r), vo(go, r, o, i, e, t, this)
                } else
                    for (let n = Math.max(0, a.start), r = Math.min(c.count, a.start + a.count); n < r; n++) go.fromBufferAttribute(c, n), vo(go, n, o, i, e, t, this)
        }
        updateMorphTargets() {
            const e = this.geometry.morphAttributes,
                t = Object.keys(e);
            if (t.length > 0) {
                const n = e[t[0]];
                if (void 0 !== n) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let e = 0, t = n.length; e < t; e++) {
                        const t = n[e].name || String(e);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                    }
                }
            }
        }
    }

    function vo(e, t, n, i, r, a, s) {
        const o = mo.distanceSqToPoint(e);
        if (o < n) {
            const n = new ut;
            mo.closestPointToPoint(e, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            a.push({
                distance: l,
                distanceToRay: Math.sqrt(o),
                point: n,
                index: t,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: s
            })
        }
    }
    class yo extends Jn {
        constructor(e = 1, t = 32, n = 16, i = 0, r = 2 * Math.PI, a = 0, s = Math.PI) {
            super(), this.type = "SphereGeometry", this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: a,
                thetaLength: s
            }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
            const o = Math.min(a + s, Math.PI);
            let l = 0;
            const c = [],
                h = new ut,
                u = new ut,
                d = [],
                p = [],
                m = [],
                f = [];
            for (let d = 0; d <= n; d++) {
                const g = [],
                    _ = d / n;
                let v = 0;
                0 === d && 0 === a ? v = .5 / t : d === n && o === Math.PI && (v = -.5 / t);
                for (let n = 0; n <= t; n++) {
                    const o = n / t;
                    h.x = -e * Math.cos(i + o * r) * Math.sin(a + _ * s), h.y = e * Math.cos(a + _ * s), h.z = e * Math.sin(i + o * r) * Math.sin(a + _ * s), p.push(h.x, h.y, h.z), u.copy(h).normalize(), m.push(u.x, u.y, u.z), f.push(o + v, 1 - _), g.push(l++)
                }
                c.push(g)
            }
            for (let e = 0; e < n; e++)
                for (let i = 0; i < t; i++) {
                    const t = c[e][i + 1],
                        r = c[e][i],
                        s = c[e + 1][i],
                        l = c[e + 1][i + 1];
                    (0 !== e || a > 0) && d.push(t, r, l), (e !== n - 1 || o < Math.PI) && d.push(r, s, l)
                }
            this.setIndex(d), this.setAttribute("position", new Wn(p, 3)), this.setAttribute("normal", new Wn(m, 3)), this.setAttribute("uv", new Wn(f, 2))
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
        }
        static fromJSON(e) {
            return new yo(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
        }
    }
    class xo extends kn {
        static get type() {
            return "MeshStandardMaterial"
        }
        constructor(e) {
            super(), this.isMeshStandardMaterial = !0, this.defines = {
                STANDARD: ""
            }, this.color = new In(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new In(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $t, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
        }
    }
    class bo extends xo {
        static get type() {
            return "MeshPhysicalMaterial"
        }
        constructor(e) {
            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ke(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return Pe(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                },
                set: function(e) {
                    this.ior = (1 + .4 * e) / (1 - .4 * e)
                }
            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new In(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new In(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new In(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
        }
        get anisotropy() {
            return this._anisotropy
        }
        set anisotropy(e) {
            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
        }
        get clearcoat() {
            return this._clearcoat
        }
        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
        }
        get iridescence() {
            return this._iridescence
        }
        set iridescence(e) {
            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
        }
        get dispersion() {
            return this._dispersion
        }
        set dispersion(e) {
            this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
        }
        get sheen() {
            return this._sheen
        }
        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e
        }
        get transmission() {
            return this._transmission
        }
        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
        }
    }

    function wo(e, t, n) {
        return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
    }

    function So(e) {
        const t = e.length,
            n = new Array(t);
        for (let e = 0; e !== t; ++e) n[e] = e;
        return n.sort((function(t, n) {
            return e[t] - e[n]
        })), n
    }

    function Mo(e, t, n) {
        const i = e.length,
            r = new e.constructor(i);
        for (let a = 0, s = 0; s !== i; ++a) {
            const i = n[a] * t;
            for (let n = 0; n !== t; ++n) r[s++] = e[i + n]
        }
        return r
    }

    function To(e, t, n, i) {
        let r = 1,
            a = e[0];
        for (; void 0 !== a && void 0 === a[i];) a = e[r++];
        if (void 0 === a) return;
        let s = a[i];
        if (void 0 !== s)
            if (Array.isArray(s))
                do {
                    s = a[i], void 0 !== s && (t.push(a.time), n.push.apply(n, s)), a = e[r++]
                } while (void 0 !== a);
            else if (void 0 !== s.toArray)
            do {
                s = a[i], void 0 !== s && (t.push(a.time), s.toArray(n, n.length)), a = e[r++]
            } while (void 0 !== a);
        else
            do {
                s = a[i], void 0 !== s && (t.push(a.time), n.push(s)), a = e[r++]
            } while (void 0 !== a)
    }
    class Eo {
        constructor(e, t, n, i) {
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
        }
        evaluate(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex,
                i = t[n],
                r = t[n - 1];
            e: {
                t: {
                    let a;n: {
                        i: if (!(e < i)) {
                            for (let a = n + 2;;) {
                                if (void 0 === i) {
                                    if (e < r) break i;
                                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                }
                                if (n === a) break;
                                if (r = i, i = t[++n], e < i) break t
                            }
                            a = t.length;
                            break n
                        }if (e >= r) break e;
                        {
                            const s = t[1];
                            e < s && (n = 2, r = s);
                            for (let a = n - 2;;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === a) break;
                                if (i = r, r = t[--n - 1], e >= r) break t
                            }
                            a = n, n = 0
                        }
                    }
                    for (; n < a;) {
                        const i = n + a >>> 1;
                        e < t[i] ? a = i : n = i + 1
                    }
                    if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                    if (void 0 === i) return n = t.length,
                    this._cachedIndex = n,
                    this.copySampleValue_(n - 1)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, e, i)
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                r = e * i;
            for (let e = 0; e !== i; ++e) t[e] = n[r + e];
            return t
        }
        interpolate_() {
            throw new Error("call to abstract method")
        }
        intervalChanged_() {}
    }
    class Ao extends Eo {
        constructor(e, t, n, i) {
            super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: 2400,
                endingEnd: 2400
            }
        }
        intervalChanged_(e, t, n) {
            const i = this.parameterPositions;
            let r = e - 2,
                a = e + 1,
                s = i[r],
                o = i[a];
            if (void 0 === s) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e, s = 2 * t - n;
                    break;
                case 2402:
                    r = i.length - 2, s = t + i[r] - i[r + 1];
                    break;
                default:
                    r = e, s = n
            }
            if (void 0 === o) switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = e, o = 2 * n - t;
                    break;
                case 2402:
                    a = 1, o = n + i[1] - i[0];
                    break;
                default:
                    a = e - 1, o = t
            }
            const l = .5 * (n - t),
                c = this.valueSize;
            this._weightPrev = l / (t - s), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = a * c
        }
        interpolate_(e, t, n, i) {
            const r = this.resultBuffer,
                a = this.sampleValues,
                s = this.valueSize,
                o = e * s,
                l = o - s,
                c = this._offsetPrev,
                h = this._offsetNext,
                u = this._weightPrev,
                d = this._weightNext,
                p = (n - t) / (i - t),
                m = p * p,
                f = m * p,
                g = -u * f + 2 * u * m - u * p,
                _ = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                v = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                y = d * f - d * m;
            for (let e = 0; e !== s; ++e) r[e] = g * a[c + e] + _ * a[l + e] + v * a[o + e] + y * a[h + e];
            return r
        }
    }
    class Ro extends Eo {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            const r = this.resultBuffer,
                a = this.sampleValues,
                s = this.valueSize,
                o = e * s,
                l = o - s,
                c = (n - t) / (i - t),
                h = 1 - c;
            for (let e = 0; e !== s; ++e) r[e] = a[l + e] * h + a[o + e] * c;
            return r
        }
    }
    class Co extends Eo {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1)
        }
    }
    class Lo {
        constructor(e, t, n, i) {
            if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = wo(t, this.TimeBufferType), this.values = wo(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
        }
        static toJSON(e) {
            const t = e.constructor;
            let n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: wo(e.times, Array),
                    values: wo(e.values, Array)
                };
                const t = e.getInterpolation();
                t !== e.DefaultInterpolation && (n.interpolation = t)
            }
            return n.type = e.ValueTypeName, n
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new Co(this.times, this.values, this.getValueSize(), e)
        }
        InterpolantFactoryMethodLinear(e) {
            return new Ro(this.times, this.values, this.getValueSize(), e)
        }
        InterpolantFactoryMethodSmooth(e) {
            return new Ao(this.times, this.values, this.getValueSize(), e)
        }
        setInterpolation(e) {
            let t;
            switch (e) {
                case de:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case pe:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case me:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw new Error(t);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return this
            }
            return this.createInterpolant = t, this
        }
        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return de;
                case this.InterpolantFactoryMethodLinear:
                    return pe;
                case this.InterpolantFactoryMethodSmooth:
                    return me
            }
        }
        getValueSize() {
            return this.values.length / this.times.length
        }
        shift(e) {
            if (0 !== e) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
            }
            return this
        }
        scale(e) {
            if (1 !== e) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
            }
            return this
        }
        trim(e, t) {
            const n = this.times,
                i = n.length;
            let r = 0,
                a = i - 1;
            for (; r !== i && n[r] < e;) ++r;
            for (; - 1 !== a && n[a] > t;) --a;
            if (++a, 0 !== r || a !== i) {
                r >= a && (a = Math.max(a, 1), r = a - 1);
                const e = this.getValueSize();
                this.times = n.slice(r, a), this.values = this.values.slice(r * e, a * e)
            }
            return this
        }
        validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) != 0 && (e = !1);
            const n = this.times,
                i = this.values,
                r = n.length;
            0 === r && (e = !1);
            let a = null;
            for (let t = 0; t !== r; t++) {
                const i = n[t];
                if ("number" == typeof i && isNaN(i)) {
                    e = !1;
                    break
                }
                if (null !== a && a > i) {
                    e = !1;
                    break
                }
                a = i
            }
            if (void 0 !== i && function(e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                }(i))
                for (let t = 0, n = i.length; t !== n; ++t) {
                    const n = i[t];
                    if (isNaN(n)) {
                        e = !1;
                        break
                    }
                }
            return e
        }
        optimize() {
            const e = this.times.slice(),
                t = this.values.slice(),
                n = this.getValueSize(),
                i = this.getInterpolation() === me,
                r = e.length - 1;
            let a = 1;
            for (let s = 1; s < r; ++s) {
                let r = !1;
                const o = e[s];
                if (o !== e[s + 1] && (1 !== s || o !== e[0]))
                    if (i) r = !0;
                    else {
                        const e = s * n,
                            i = e - n,
                            a = e + n;
                        for (let s = 0; s !== n; ++s) {
                            const n = t[e + s];
                            if (n !== t[i + s] || n !== t[a + s]) {
                                r = !0;
                                break
                            }
                        }
                    } if (r) {
                    if (s !== a) {
                        e[a] = e[s];
                        const i = s * n,
                            r = a * n;
                        for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
                    }++a
                }
            }
            if (r > 0) {
                e[a] = e[r];
                for (let e = r * n, i = a * n, s = 0; s !== n; ++s) t[i + s] = t[e + s];
                ++a
            }
            return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this
        }
        clone() {
            const e = this.times.slice(),
                t = this.values.slice(),
                n = new(0, this.constructor)(this.name, e, t);
            return n.createInterpolant = this.createInterpolant, n
        }
    }
    Lo.prototype.TimeBufferType = Float32Array, Lo.prototype.ValueBufferType = Float32Array, Lo.prototype.DefaultInterpolation = pe;
    class Po extends Lo {
        constructor(e, t, n) {
            super(e, t, n)
        }
    }
    Po.prototype.ValueTypeName = "bool", Po.prototype.ValueBufferType = Array, Po.prototype.DefaultInterpolation = de, Po.prototype.InterpolantFactoryMethodLinear = void 0, Po.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Do extends Lo {}
    Do.prototype.ValueTypeName = "color";
    class Uo extends Lo {}
    Uo.prototype.ValueTypeName = "number";
    class Io extends Eo {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            const r = this.resultBuffer,
                a = this.sampleValues,
                s = this.valueSize,
                o = (n - t) / (i - t);
            let l = e * s;
            for (let e = l + s; l !== e; l += 4) ht.slerpFlat(r, 0, a, l - s, a, l, o);
            return r
        }
    }
    class No extends Lo {
        InterpolantFactoryMethodLinear(e) {
            return new Io(this.times, this.values, this.getValueSize(), e)
        }
    }
    No.prototype.ValueTypeName = "quaternion", No.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Oo extends Lo {
        constructor(e, t, n) {
            super(e, t, n)
        }
    }
    Oo.prototype.ValueTypeName = "string", Oo.prototype.ValueBufferType = Array, Oo.prototype.DefaultInterpolation = de, Oo.prototype.InterpolantFactoryMethodLinear = void 0, Oo.prototype.InterpolantFactoryMethodSmooth = void 0;
    class ko extends Lo {}
    ko.prototype.ValueTypeName = "vector";
    class Fo {
        constructor(e = "", t = -1, n = [], i = 2500) {
            this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Le(), this.duration < 0 && this.resetDuration()
        }
        static parse(e) {
            const t = [],
                n = e.tracks,
                i = 1 / (e.fps || 1);
            for (let e = 0, r = n.length; e !== r; ++e) t.push(Bo(n[e]).scale(i));
            const r = new this(e.name, e.duration, t, e.blendMode);
            return r.uuid = e.uuid, r
        }
        static toJSON(e) {
            const t = [],
                n = e.tracks,
                i = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
            for (let e = 0, i = n.length; e !== i; ++e) t.push(Lo.toJSON(n[e]));
            return i
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
            const r = t.length,
                a = [];
            for (let e = 0; e < r; e++) {
                let s = [],
                    o = [];
                s.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
                const l = So(s);
                s = Mo(s, 1, l), o = Mo(o, 1, l), i || 0 !== s[0] || (s.push(r), o.push(o[0])), a.push(new Uo(".morphTargetInfluences[" + t[e].name + "]", s, o).scale(1 / n))
            }
            return new this(e, -1, a)
        }
        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                const t = e;
                n = t.geometry && t.geometry.animations || t.animations
            }
            for (let e = 0; e < n.length; e++)
                if (n[e].name === t) return n[e];
            return null
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
            const i = {},
                r = /^([\w-]*?)([\d]+)$/;
            for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t],
                    a = n.name.match(r);
                if (a && a.length > 1) {
                    const e = a[1];
                    let t = i[e];
                    t || (i[e] = t = []), t.push(n)
                }
            }
            const a = [];
            for (const e in i) a.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
            return a
        }
        static parseAnimation(e, t) {
            if (!e) return null;
            const n = function(e, t, n, i, r) {
                    if (0 !== n.length) {
                        const a = [],
                            s = [];
                        To(n, a, s, i), 0 !== a.length && r.push(new e(t, a, s))
                    }
                },
                i = [],
                r = e.name || "default",
                a = e.fps || 30,
                s = e.blendMode;
            let o = e.length || -1;
            const l = e.hierarchy || [];
            for (let e = 0; e < l.length; e++) {
                const r = l[e].keys;
                if (r && 0 !== r.length)
                    if (r[0].morphTargets) {
                        const e = {};
                        let t;
                        for (t = 0; t < r.length; t++)
                            if (r[t].morphTargets)
                                for (let n = 0; n < r[t].morphTargets.length; n++) e[r[t].morphTargets[n]] = -1;
                        for (const n in e) {
                            const e = [],
                                a = [];
                            for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                const i = r[t];
                                e.push(i.time), a.push(i.morphTarget === n ? 1 : 0)
                            }
                            i.push(new Uo(".morphTargetInfluence[" + n + "]", e, a))
                        }
                        o = e.length * a
                    } else {
                        const a = ".bones[" + t[e].name + "]";
                        n(ko, a + ".position", r, "pos", i), n(No, a + ".quaternion", r, "rot", i), n(ko, a + ".scale", r, "scl", i)
                    }
            }
            return 0 === i.length ? null : new this(r, o, i, s)
        }
        resetDuration() {
            let e = 0;
            for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                const n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e, this
        }
        trim() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        }
        validate() {
            let e = !0;
            for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        }
        optimize() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        }
        clone() {
            const e = [];
            for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new this.constructor(this.name, this.duration, e, this.blendMode)
        }
        toJSON() {
            return this.constructor.toJSON(this)
        }
    }

    function Bo(e) {
        if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const t = function(e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Uo;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return ko;
                case "color":
                    return Do;
                case "quaternion":
                    return No;
                case "bool":
                case "boolean":
                    return Po;
                case "string":
                    return Oo
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            const t = [],
                n = [];
            To(e.keys, t, n, "value"), e.times = t, e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }
    const zo = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled) return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };
    const Ho = new class {
        constructor(e, t, n) {
            const i = this;
            let r, a = !1,
                s = 0,
                o = 0;
            const l = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                o++, !1 === a && void 0 !== i.onStart && i.onStart(e, s, o), a = !0
            }, this.itemEnd = function(e) {
                s++, void 0 !== i.onProgress && i.onProgress(e, s, o), s === o && (a = !1, void 0 !== i.onLoad && i.onLoad())
            }, this.itemError = function(e) {
                void 0 !== i.onError && i.onError(e)
            }, this.resolveURL = function(e) {
                return r ? r(e) : e
            }, this.setURLModifier = function(e) {
                return r = e, this
            }, this.addHandler = function(e, t) {
                return l.push(e, t), this
            }, this.removeHandler = function(e) {
                const t = l.indexOf(e);
                return -1 !== t && l.splice(t, 2), this
            }, this.getHandler = function(e) {
                for (let t = 0, n = l.length; t < n; t += 2) {
                    const n = l[t],
                        i = l[t + 1];
                    if (n.global && (n.lastIndex = 0), n.test(e)) return i
                }
                return null
            }
        }
    };
    class Vo {
        constructor(e) {
            this.manager = void 0 !== e ? e : Ho, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        load() {}
        loadAsync(e, t) {
            const n = this;
            return new Promise((function(i, r) {
                n.load(e, i, t, r)
            }))
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e, this
        }
        setWithCredentials(e) {
            return this.withCredentials = e, this
        }
        setPath(e) {
            return this.path = e, this
        }
        setResourcePath(e) {
            return this.resourcePath = e, this
        }
        setRequestHeader(e) {
            return this.requestHeader = e, this
        }
    }
    Vo.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const Go = {};
    class Wo extends Error {
        constructor(e, t) {
            super(e), this.response = t
        }
    }
    class qo extends Vo {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = zo.get(e);
            if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => {
                t && t(r), this.manager.itemEnd(e)
            }), 0), r;
            if (void 0 !== Go[e]) return void Go[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            Go[e] = [], Go[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            const a = new Request(e, {
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                }),
                s = this.mimeType,
                o = this.responseType;
            fetch(a).then((t => {
                if (200 === t.status || 0 === t.status) {
                    if (t.status, "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                    const n = Go[e],
                        i = t.body.getReader(),
                        r = t.headers.get("X-File-Size") || t.headers.get("Content-Length"),
                        a = r ? parseInt(r) : 0,
                        s = 0 !== a;
                    let o = 0;
                    const l = new ReadableStream({
                        start(e) {
                            ! function t() {
                                i.read().then((({
                                    done: i,
                                    value: r
                                }) => {
                                    if (i) e.close();
                                    else {
                                        o += r.byteLength;
                                        const i = new ProgressEvent("progress", {
                                            lengthComputable: s,
                                            loaded: o,
                                            total: a
                                        });
                                        for (let e = 0, t = n.length; e < t; e++) {
                                            const t = n[e];
                                            t.onProgress && t.onProgress(i)
                                        }
                                        e.enqueue(r), t()
                                    }
                                }), (t => {
                                    e.error(t)
                                }))
                            }()
                        }
                    });
                    return new Response(l)
                }
                throw new Wo(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t)
            })).then((e => {
                switch (o) {
                    case "arraybuffer":
                        return e.arrayBuffer();
                    case "blob":
                        return e.blob();
                    case "document":
                        return e.text().then((e => (new DOMParser).parseFromString(e, s)));
                    case "json":
                        return e.json();
                    default:
                        if (void 0 === s) return e.text();
                        {
                            const t = /charset="?([^;"\s]*)"?/i.exec(s),
                                n = t && t[1] ? t[1].toLowerCase() : void 0,
                                i = new TextDecoder(n);
                            return e.arrayBuffer().then((e => i.decode(e)))
                        }
                }
            })).then((t => {
                zo.add(e, t);
                const n = Go[e];
                delete Go[e];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    i.onLoad && i.onLoad(t)
                }
            })).catch((t => {
                const n = Go[e];
                if (void 0 === n) throw this.manager.itemError(e), t;
                delete Go[e];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    i.onError && i.onError(t)
                }
                this.manager.itemError(e)
            })).finally((() => {
                this.manager.itemEnd(e)
            })), this.manager.itemStart(e)
        }
        setResponseType(e) {
            return this.responseType = e, this
        }
        setMimeType(e) {
            return this.mimeType = e, this
        }
    }
    class Xo extends Vo {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this,
                a = zo.get(e);
            if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function() {
                t && t(a), r.manager.itemEnd(e)
            }), 0), a;
            const s = He("img");

            function o() {
                c(), zo.add(e, this), t && t(this), r.manager.itemEnd(e)
            }

            function l(t) {
                c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
            }

            function c() {
                s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1)
            }
            return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s
        }
    }
    class jo extends Vo {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const r = new at,
                a = new Xo(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function(e) {
                r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
            }), n, i), r
        }
    }
    class Yo extends fn {
        constructor(e, t = 1) {
            super(), this.isLight = !0, this.type = "Light", this.color = new In(e), this.intensity = t
        }
        dispose() {}
        copy(e, t) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t
        }
    }
    const Ko = new Ht,
        Zo = new ut,
        $o = new ut;
    class Jo {
        constructor(e) {
            this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ke(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ht, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ui, this._frameExtents = new ke(1, 1), this._viewportCount = 1, this._viewports = [new st(0, 0, 1, 1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(e) {
            const t = this.camera,
                n = this.matrix;
            Zo.setFromMatrixPosition(e.matrixWorld), t.position.copy(Zo), $o.setFromMatrixPosition(e.target.matrixWorld), t.lookAt($o), t.updateMatrixWorld(), Ko.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ko), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Ko)
        }
        getViewport(e) {
            return this._viewports[e]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }
        copy(e) {
            return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const e = {};
            return 1 !== this.intensity && (e.intensity = this.intensity), 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }
    class Qo extends Jo {
        constructor() {
            super(new wi(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
        }
        updateMatrices(e) {
            const t = this.camera,
                n = 2 * Ce * e.angle * this.focus,
                i = this.mapSize.width / this.mapSize.height,
                r = e.distance || t.far;
            n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
        }
        copy(e) {
            return super.copy(e), this.focus = e.focus, this
        }
    }
    class el extends Yo {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, a = 2) {
            super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(fn.DEFAULT_UP), this.updateMatrix(), this.target = new fn, this.distance = n, this.angle = i, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new Qo
        }
        get power() {
            return this.intensity * Math.PI
        }
        set power(e) {
            this.intensity = e / Math.PI
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }
    const tl = new Ht,
        nl = new ut,
        il = new ut;
    class rl extends Jo {
        constructor() {
            super(new wi(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ke(4, 2), this._viewportCount = 6, this._viewports = [new st(2, 1, 1, 1), new st(0, 1, 1, 1), new st(3, 1, 1, 1), new st(1, 1, 1, 1), new st(3, 0, 1, 1), new st(1, 0, 1, 1)], this._cubeDirections = [new ut(1, 0, 0), new ut(-1, 0, 0), new ut(0, 0, 1), new ut(0, 0, -1), new ut(0, 1, 0), new ut(0, -1, 0)], this._cubeUps = [new ut(0, 1, 0), new ut(0, 1, 0), new ut(0, 1, 0), new ut(0, 1, 0), new ut(0, 0, 1), new ut(0, 0, -1)]
        }
        updateMatrices(e, t = 0) {
            const n = this.camera,
                i = this.matrix,
                r = e.distance || n.far;
            r !== n.far && (n.far = r, n.updateProjectionMatrix()), nl.setFromMatrixPosition(e.matrixWorld), n.position.copy(nl), il.copy(n.position), il.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(il), n.updateMatrixWorld(), i.makeTranslation(-nl.x, -nl.y, -nl.z), tl.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(tl)
        }
    }
    class al extends Yo {
        constructor(e, t, n = 0, i = 2) {
            super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new rl
        }
        get power() {
            return 4 * this.intensity * Math.PI
        }
        set power(e) {
            this.intensity = e / (4 * Math.PI)
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }
    class sl extends Jo {
        constructor() {
            super(new Ki(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
        }
    }
    class ol extends Yo {
        constructor(e, t) {
            super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(fn.DEFAULT_UP), this.updateMatrix(), this.target = new fn, this.shadow = new sl
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }
    class ll extends Yo {
        constructor(e, t) {
            super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
        }
    }
    class cl {
        static decodeText(e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            let t = "";
            for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        }
        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.slice(0, t + 1)
        }
        static resolveURL(e, t) {
            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }
    }
    class hl extends Vo {
        constructor(e) {
            super(e), this.isImageBitmapLoader = !0, this.options = {
                premultiplyAlpha: "none"
            }
        }
        setOptions(e) {
            return this.options = e, this
        }
        load(e, t, n, i) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this,
                a = zo.get(e);
            if (void 0 !== a) return r.manager.itemStart(e), a.then ? void a.then((n => {
                t && t(n), r.manager.itemEnd(e)
            })).catch((e => {
                i && i(e)
            })) : (setTimeout((function() {
                t && t(a), r.manager.itemEnd(e)
            }), 0), a);
            const s = {};
            s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader;
            const o = fetch(e, s).then((function(e) {
                return e.blob()
            })).then((function(e) {
                return createImageBitmap(e, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                }))
            })).then((function(n) {
                return zo.add(e, n), t && t(n), r.manager.itemEnd(e), n
            })).catch((function(t) {
                i && i(t), zo.remove(e), r.manager.itemError(e), r.manager.itemEnd(e)
            }));
            zo.add(e, o), r.manager.itemStart(e)
        }
    }
    const ul = "\\[\\]\\.:\\/",
        dl = new RegExp("[" + ul + "]", "g"),
        pl = "[^" + ul + "]",
        ml = "[^" + ul.replace("\\.", "") + "]",
        fl = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", pl) + /(WCOD+)?/.source.replace("WCOD", ml) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", pl) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", pl) + "$"),
        gl = ["material", "materials", "bones", "map"];
    class _l {
        constructor(e, t, n) {
            this.path = t, this.parsedPath = n || _l.parseTrackName(t), this.node = _l.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new _l.Composite(e, t, n) : new _l(e, t, n)
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(dl, "")
        }
        static parseTrackName(e) {
            const t = fl.exec(e);
            if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                const e = n.nodeName.substring(i + 1); - 1 !== gl.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
            }
            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        }
        static findNode(e, t) {
            if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (void 0 !== n) return n
            }
            if (e.children) {
                const n = function(e) {
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            if (r.name === t || r.uuid === t) return r;
                            const a = n(r.children);
                            if (a) return a
                        }
                        return null
                    },
                    i = n(e.children);
                if (i) return i
            }
            return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName]
        }
        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
        }
        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t)
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t)
        }
        bind() {
            let e = this.node;
            const t = this.parsedPath,
                n = t.objectName,
                i = t.propertyName;
            let r = t.propertyIndex;
            if (e || (e = _l.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return;
            if (n) {
                let i = t.objectIndex;
                switch (n) {
                    case "materials":
                        if (!e.material) return;
                        if (!e.material.materials) return;
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) return;
                        e = e.skeleton.bones;
                        for (let t = 0; t < e.length; t++)
                            if (e[t].name === i) {
                                i = t;
                                break
                            } break;
                    case "map":
                        if ("map" in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material) return;
                        if (!e.material.map) return;
                        e = e.material.map;
                        break;
                    default:
                        if (void 0 === e[n]) return;
                        e = e[n]
                }
                if (void 0 !== i) {
                    if (void 0 === e[i]) return;
                    e = e[i]
                }
            }
            const a = e[i];
            if (void 0 === a) return void t.nodeName;
            let s = this.Versioning.None;
            this.targetObject = e, void 0 !== e.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                    if (!e.geometry) return;
                    if (!e.geometry.morphAttributes) return;
                    void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                }
                o = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
            } else void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }
    _l.Composite = class {
        constructor(e, t, n) {
            const i = n || _l.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, i)
        }
        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            void 0 !== i && i.getValue(e, t)
        }
        setValue(e, t) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
        }
        bind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
        }
        unbind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
        }
    }, _l.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    }, _l.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    }, _l.prototype.GetterByBindingType = [_l.prototype._getValue_direct, _l.prototype._getValue_array, _l.prototype._getValue_arrayElement, _l.prototype._getValue_toArray], _l.prototype.SetterByBindingTypeAndVersioning = [
        [_l.prototype._setValue_direct, _l.prototype._setValue_direct_setNeedsUpdate, _l.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
        [_l.prototype._setValue_array, _l.prototype._setValue_array_setNeedsUpdate, _l.prototype._setValue_array_setMatrixWorldNeedsUpdate],
        [_l.prototype._setValue_arrayElement, _l.prototype._setValue_arrayElement_setNeedsUpdate, _l.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
        [_l.prototype._setValue_fromArray, _l.prototype._setValue_fromArray_setNeedsUpdate, _l.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
    ], new Float32Array(1);
    class vl {
        constructor(e = 1, t = 0, n = 0) {
            return this.radius = e, this.phi = t, this.theta = n, this
        }
        set(e, t, n) {
            return this.radius = e, this.phi = t, this.theta = n, this
        }
        copy(e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
        }
        makeSafe() {
            const e = 1e-6;
            return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
        }
        setFromVector3(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        }
        setFromCartesianCoords(e, t, n) {
            return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Pe(t / this.radius, -1, 1))), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }

    function yl(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function xl(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
    }
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: n
        }
    })), "undefined" != typeof window && (window.__THREE__ || (window.__THREE__ = n));
    var bl, wl, Sl, Ml, Tl, El, Al, Rl, Cl, Ll, Pl, Dl, Ul, Il, Nl, Ol, kl, Fl = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        Bl = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        zl = 1e8,
        Hl = 1e-8,
        Vl = 2 * Math.PI,
        Gl = Vl / 4,
        Wl = 0,
        ql = Math.sqrt,
        Xl = Math.cos,
        jl = Math.sin,
        Yl = function(e) {
            return "string" == typeof e
        },
        Kl = function(e) {
            return "function" == typeof e
        },
        Zl = function(e) {
            return "number" == typeof e
        },
        $l = function(e) {
            return void 0 === e
        },
        Jl = function(e) {
            return "object" == typeof e
        },
        Ql = function(e) {
            return !1 !== e
        },
        ec = function() {
            return "undefined" != typeof window
        },
        tc = function(e) {
            return Kl(e) || Yl(e)
        },
        nc = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
        ic = Array.isArray,
        rc = /(?:-?\.?\d|\.)+/gi,
        ac = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        sc = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        oc = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        lc = /[+-]=-?[.\d]+/,
        cc = /[^,'"\[\]\s]+/gi,
        hc = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        uc = {},
        dc = {},
        pc = function(e) {
            return (dc = Hc(e, uc)) && Hu
        },
        mc = function(e, t) {
            return !t && void 0
        },
        fc = function(e, t) {
            return e && (uc[e] = t) && dc && (dc[e] = t) || uc
        },
        gc = function() {
            return 0
        },
        _c = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        },
        vc = {
            suppressEvents: !0,
            kill: !1
        },
        yc = {
            suppressEvents: !0
        },
        xc = {},
        bc = [],
        wc = {},
        Sc = {},
        Mc = {},
        Tc = 30,
        Ec = [],
        Ac = "",
        Rc = function(e) {
            var t, n, i = e[0];
            if (Jl(i) || Kl(i) || (e = [e]), !(t = (i._gsap || {}).harness)) {
                for (n = Ec.length; n-- && !Ec[n].targetTest(i););
                t = Ec[n]
            }
            for (n = e.length; n--;) e[n] && (e[n]._gsap || (e[n]._gsap = new tu(e[n], t))) || e.splice(n, 1);
            return e
        },
        Cc = function(e) {
            return e._gsap || Rc(vh(e))[0]._gsap
        },
        Lc = function(e, t, n) {
            return (n = e[t]) && Kl(n) ? e[t]() : $l(n) && e.getAttribute && e.getAttribute(t) || n
        },
        Pc = function(e, t) {
            return (e = e.split(",")).forEach(t) || e
        },
        Dc = function(e) {
            return Math.round(1e5 * e) / 1e5 || 0
        },
        Uc = function(e) {
            return Math.round(1e7 * e) / 1e7 || 0
        },
        Ic = function(e, t) {
            var n = t.charAt(0),
                i = parseFloat(t.substr(2));
            return e = parseFloat(e), "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i
        },
        Nc = function(e, t) {
            for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;);
            return i < n
        },
        Oc = function() {
            var e, t, n = bc.length,
                i = bc.slice(0);
            for (wc = {}, bc.length = 0, e = 0; e < n; e++)(t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
        },
        kc = function(e, t, n, i) {
            bc.length && !wl && Oc(), e.render(t, n, i || wl && t < 0 && (e._initted || e._startAt)), bc.length && !wl && Oc()
        },
        Fc = function(e) {
            var t = parseFloat(e);
            return (t || 0 === t) && (e + "").match(cc).length < 2 ? t : Yl(e) ? e.trim() : e
        },
        Bc = function(e) {
            return e
        },
        zc = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        Hc = function(e, t) {
            for (var n in t) e[n] = t[n];
            return e
        },
        Vc = function e(t, n) {
            for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = Jl(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
            return t
        },
        Gc = function(e, t) {
            var n, i = {};
            for (n in e) n in t || (i[n] = e[n]);
            return i
        },
        Wc = function(e) {
            var t, n = e.parent || Ml,
                i = e.keyframes ? (t = ic(e.keyframes), function(e, n) {
                    for (var i in n) i in e || "duration" === i && t || "ease" === i || (e[i] = n[i])
                }) : zc;
            if (Ql(e.inherit))
                for (; n;) i(e, n.vars.defaults), n = n.parent || n._dp;
            return e
        },
        qc = function(e, t, n, i, r) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var a, s = e[i];
            if (r)
                for (a = t[r]; s && s[r] > a;) s = s._prev;
            return s ? (t._next = s._next, s._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = s, t.parent = t._dp = e, t
        },
        Xc = function(e, t, n, i) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var r = t._prev,
                a = t._next;
            r ? r._next = a : e[n] === t && (e[n] = a), a ? a._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null
        },
        jc = function(e, t) {
            e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
        },
        Yc = function(e, t) {
            if (e && (!t || t._end > e._dur || t._start < 0))
                for (var n = e; n;) n._dirty = 1, n = n.parent;
            return e
        },
        Kc = function(e, t, n, i) {
            return e._startAt && (wl ? e._startAt.revert(vc) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
        },
        Zc = function e(t) {
            return !t || t._ts && e(t.parent)
        },
        $c = function(e) {
            return e._repeat ? Jc(e._tTime, e = e.duration() + e._rDelay) * e : 0
        },
        Jc = function(e, t) {
            var n = Math.floor(e = Uc(e / t));
            return e && n === e ? n - 1 : n
        },
        Qc = function(e, t) {
            return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
        },
        eh = function(e) {
            return e._end = Uc(e._start + (e._tDur / Math.abs(e._ts || e._rts || Hl) || 0))
        },
        th = function(e, t) {
            var n = e._dp;
            return n && n.smoothChildTiming && e._ts && (e._start = Uc(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), eh(e), n._dirty || Yc(n, e)), e
        },
        nh = function(e, t) {
            var n;
            if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Qc(e.rawTime(), t), (!t._dur || mh(0, t.totalDuration(), n) - t._tTime > Hl) && t.render(n, !0)), Yc(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                if (e._dur < e.duration())
                    for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                e._zTime = -1e-8
            }
        },
        ih = function(e, t, n, i) {
            return t.parent && jc(t), t._start = Uc((Zl(n) ? n : n || e !== Ml ? uh(e, n, t) : e._time) + t._delay), t._end = Uc(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), qc(e, t, "_first", "_last", e._sort ? "_start" : 0), oh(t) || (e._recent = t), i || nh(e, t), e._ts < 0 && th(e, e._tTime), e
        },
        rh = function(e, t) {
            return uc.ScrollTrigger ? uc.ScrollTrigger.create(t, e) : void 0
        },
        ah = function(e, t, n, i, r) {
            return cu(e, t, r), e._initted ? !n && e._pt && !wl && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && Cl !== Vh.frame ? (bc.push(e), e._lazy = [r, i], 1) : void 0 : 1
        },
        sh = function e(t) {
            var n = t.parent;
            return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
        },
        oh = function(e) {
            var t = e.data;
            return "isFromStart" === t || "isStart" === t
        },
        lh = function(e, t, n, i) {
            var r = e._repeat,
                a = Uc(t) || 0,
                s = e._tTime / e._tDur;
            return s && !i && (e._time *= a / e._dur), e._dur = a, e._tDur = r ? r < 0 ? 1e10 : Uc(a * (r + 1) + e._rDelay * r) : a, s > 0 && !i && th(e, e._tTime = e._tDur * s), e.parent && eh(e), n || Yc(e.parent, e), e
        },
        ch = function(e) {
            return e instanceof iu ? Yc(e) : lh(e, e._dur)
        },
        hh = {
            _start: 0,
            endTime: gc,
            totalDuration: gc
        },
        uh = function e(t, n, i) {
            var r, a, s, o = t.labels,
                l = t._recent || hh,
                c = t.duration() >= zl ? l.endTime(!1) : t._dur;
            return Yl(n) && (isNaN(n) || n in o) ? (a = n.charAt(0), s = "%" === n.substr(-1), r = n.indexOf("="), "<" === a || ">" === a ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === a ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (s ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in o || (o[n] = c), o[n]) : (a = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), s && i && (a = a / 100 * (ic(i) ? i[0] : i).totalDuration()), r > 1 ? e(t, n.substr(0, r - 1), i) + a : c + a)) : null == n ? c : +n
        },
        dh = function(e, t, n) {
            var i, r, a = Zl(t[1]),
                s = (a ? 2 : 1) + (e < 2 ? 0 : 1),
                o = t[s];
            if (a && (o.duration = t[1]), o.parent = n, e) {
                for (i = o, r = n; r && !("immediateRender" in i);) i = r.vars.defaults || {}, r = Ql(r.vars.inherit) && r.parent;
                o.immediateRender = Ql(i.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
            }
            return new mu(t[0], o, t[s + 1])
        },
        ph = function(e, t) {
            return e || 0 === e ? t(e) : t
        },
        mh = function(e, t, n) {
            return n < e ? e : n > t ? t : n
        },
        fh = function(e, t) {
            return Yl(e) && (t = hc.exec(e)) ? t[1] : ""
        },
        gh = [].slice,
        _h = function(e, t) {
            return e && Jl(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Jl(e[0])) && !e.nodeType && e !== Tl
        },
        vh = function(e, t, n) {
            return Sl && !t && Sl.selector ? Sl.selector(e) : !Yl(e) || n || !El && Gh() ? ic(e) ? function(e, t, n) {
                return void 0 === n && (n = []), e.forEach((function(e) {
                    var i;
                    return Yl(e) && !t || _h(e, 1) ? (i = n).push.apply(i, vh(e)) : n.push(e)
                })) || n
            }(e, n) : _h(e) ? gh.call(e, 0) : e ? [e] : [] : gh.call((t || Al).querySelectorAll(e), 0)
        },
        yh = function(e) {
            return e = vh(e)[0] || mc() || {},
                function(t) {
                    var n = e.current || e.nativeElement || e;
                    return vh(t, n.querySelectorAll ? n : n === e ? mc() || Al.createElement("div") : e)
                }
        },
        xh = function(e) {
            return e.sort((function() {
                return .5 - Math.random()
            }))
        },
        bh = function(e) {
            if (Kl(e)) return e;
            var t = Jl(e) ? e : {
                    each: e
                },
                n = Zh(t.ease),
                i = t.from || 0,
                r = parseFloat(t.base) || 0,
                a = {},
                s = i > 0 && i < 1,
                o = isNaN(i) || s,
                l = t.axis,
                c = i,
                h = i;
            return Yl(i) ? c = h = {
                    center: .5,
                    edges: .5,
                    end: 1
                } [i] || 0 : !s && o && (c = i[0], h = i[1]),
                function(e, s, u) {
                    var d, p, m, f, g, _, v, y, x, b = (u || t).length,
                        w = a[b];
                    if (!w) {
                        if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, zl])[1])) {
                            for (v = -zl; v < (v = u[x++].getBoundingClientRect().left) && x < b;);
                            x < b && x--
                        }
                        for (w = a[b] = [], d = o ? Math.min(x, b) * c - .5 : i % x, p = x === zl ? 0 : o ? b * h / x - .5 : i / x | 0, v = 0, y = zl, _ = 0; _ < b; _++) m = _ % x - d, f = p - (_ / x | 0), w[_] = g = l ? Math.abs("y" === l ? f : m) : ql(m * m + f * f), g > v && (v = g), g < y && (y = g);
                        "random" === i && xh(w), w.max = v - y, w.min = y, w.v = b = (parseFloat(t.amount) || parseFloat(t.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1), w.b = b < 0 ? r - b : r, w.u = fh(t.amount || t.each) || 0, n = n && b < 0 ? Yh(n) : n
                    }
                    return b = (w[e] - w.min) / w.max || 0, Uc(w.b + (n ? n(b) : b) * w.v) + w.u
                }
        },
        wh = function(e) {
            var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
            return function(n) {
                var i = Uc(Math.round(parseFloat(n) / e) * e * t);
                return (i - i % 1) / t + (Zl(n) ? 0 : fh(n))
            }
        },
        Sh = function(e, t) {
            var n, i, r = ic(e);
            return !r && Jl(e) && (n = r = e.radius || zl, e.values ? (e = vh(e.values), (i = !Zl(e[0])) && (n *= n)) : e = wh(e.increment)), ph(t, r ? Kl(e) ? function(t) {
                return i = e(t), Math.abs(i - t) <= n ? i : t
            } : function(t) {
                for (var r, a, s = parseFloat(i ? t.x : t), o = parseFloat(i ? t.y : 0), l = zl, c = 0, h = e.length; h--;)(r = i ? (r = e[h].x - s) * r + (a = e[h].y - o) * a : Math.abs(e[h] - s)) < l && (l = r, c = h);
                return c = !n || l <= n ? e[c] : t, i || c === t || Zl(t) ? c : c + fh(t)
            } : wh(e))
        },
        Mh = function(e, t, n, i) {
            return ph(ic(e) ? !t : !0 === n ? !!(n = 0) : !i, (function() {
                return ic(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i
            }))
        },
        Th = function(e, t, n) {
            return ph(n, (function(n) {
                return e[~~t(n)]
            }))
        },
        Eh = function(e) {
            for (var t, n, i, r, a = 0, s = ""; ~(t = e.indexOf("random(", a));) i = e.indexOf(")", t), r = "[" === e.charAt(t + 7), n = e.substr(t + 7, i - t - 7).match(r ? cc : rc), s += e.substr(a, t - a) + Mh(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), a = i + 1;
            return s + e.substr(a, e.length - a)
        },
        Ah = function(e, t, n, i, r) {
            var a = t - e,
                s = i - n;
            return ph(r, (function(t) {
                return n + ((t - e) / a * s || 0)
            }))
        },
        Rh = function(e, t, n) {
            var i, r, a, s = e.labels,
                o = zl;
            for (i in s)(r = s[i] - t) < 0 == !!n && r && o > (r = Math.abs(r)) && (a = i, o = r);
            return a
        },
        Ch = function(e, t, n) {
            var i, r, a, s = e.vars,
                o = s[t],
                l = Sl,
                c = e._ctx;
            if (o) return i = s[t + "Params"], r = s.callbackScope || e, n && bc.length && Oc(), c && (Sl = c), a = i ? o.apply(r, i) : o.call(r), Sl = l, a
        },
        Lh = function(e) {
            return jc(e), e.scrollTrigger && e.scrollTrigger.kill(!!wl), e.progress() < 1 && Ch(e, "onInterrupt"), e
        },
        Ph = [],
        Dh = function(e) {
            if (e)
                if (e = !e.name && e.default || e, ec() || e.headless) {
                    var t = e.name,
                        n = Kl(e),
                        i = t && !n && e.init ? function() {
                            this._props = []
                        } : e,
                        r = {
                            init: gc,
                            render: Su,
                            add: ou,
                            kill: Tu,
                            modifier: Mu,
                            rawVars: 0
                        },
                        a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: yu,
                            aliases: {},
                            register: 0
                        };
                    if (Gh(), e !== i) {
                        if (Sc[t]) return;
                        zc(i, zc(Gc(e, r), a)), Hc(i.prototype, Hc(r, Gc(e, a))), Sc[i.prop = t] = i, e.targetTest && (Ec.push(i), xc[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                    }
                    fc(t, i), e.register && e.register(Hu, i, Ru)
                } else Ph.push(e)
        },
        Uh = 255,
        Ih = {
            aqua: [0, Uh, Uh],
            lime: [0, Uh, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, Uh],
            navy: [0, 0, 128],
            white: [Uh, Uh, Uh],
            olive: [128, 128, 0],
            yellow: [Uh, Uh, 0],
            orange: [Uh, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [Uh, 0, 0],
            pink: [Uh, 192, 203],
            cyan: [0, Uh, Uh],
            transparent: [Uh, Uh, Uh, 0]
        },
        Nh = function(e, t, n) {
            return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * Uh + .5 | 0
        },
        Oh = function(e, t, n) {
            var i, r, a, s, o, l, c, h, u, d, p = e ? Zl(e) ? [e >> 16, e >> 8 & Uh, e & Uh] : 0 : Ih.black;
            if (!p) {
                if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Ih[e]) p = Ih[e];
                else if ("#" === e.charAt(0)) {
                    if (e.length < 6 && (i = e.charAt(1), r = e.charAt(2), a = e.charAt(3), e = "#" + i + i + r + r + a + a + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & Uh, p & Uh, parseInt(e.substr(7), 16) / 255];
                    p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & Uh, e & Uh]
                } else if ("hsl" === e.substr(0, 3))
                    if (p = d = e.match(rc), t) {
                        if (~e.indexOf("=")) return p = e.match(ac), n && p.length < 4 && (p[3] = 1), p
                    } else s = +p[0] % 360 / 360, o = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = Nh(s + 1 / 3, i, r), p[1] = Nh(s, i, r), p[2] = Nh(s - 1 / 3, i, r);
                else p = e.match(rc) || Ih.transparent;
                p = p.map(Number)
            }
            return t && !d && (i = p[0] / Uh, r = p[1] / Uh, a = p[2] / Uh, l = ((c = Math.max(i, r, a)) + (h = Math.min(i, r, a))) / 2, c === h ? s = o = 0 : (u = c - h, o = l > .5 ? u / (2 - c - h) : u / (c + h), s = c === i ? (r - a) / u + (r < a ? 6 : 0) : c === r ? (a - i) / u + 2 : (i - r) / u + 4, s *= 60), p[0] = ~~(s + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
        },
        kh = function(e) {
            var t = [],
                n = [],
                i = -1;
            return e.split(Bh).forEach((function(e) {
                var r = e.match(sc) || [];
                t.push.apply(t, r), n.push(i += r.length + 1)
            })), t.c = n, t
        },
        Fh = function(e, t, n) {
            var i, r, a, s, o = "",
                l = (e + o).match(Bh),
                c = t ? "hsla(" : "rgba(",
                h = 0;
            if (!l) return e;
            if (l = l.map((function(e) {
                    return (e = Oh(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
                })), n && (a = kh(e), (i = n.c).join(o) !== a.c.join(o)))
                for (s = (r = e.replace(Bh, "1").split(sc)).length - 1; h < s; h++) o += r[h] + (~i.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (a.length ? a : l.length ? l : n).shift());
            if (!r)
                for (s = (r = e.split(Bh)).length - 1; h < s; h++) o += r[h] + l[h];
            return o + r[s]
        },
        Bh = function() {
            var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (e in Ih) t += "|" + e + "\\b";
            return new RegExp(t + ")", "gi")
        }(),
        zh = /hsl[a]?\(/,
        Hh = function(e) {
            var t, n = e.join(" ");
            if (Bh.lastIndex = 0, Bh.test(n)) return t = zh.test(n), e[1] = Fh(e[1], t), e[0] = Fh(e[0], t, kh(e[1])), !0
        },
        Vh = function() {
            var e, t, n, i, r, a, s = Date.now,
                o = 500,
                l = 33,
                c = s(),
                h = c,
                u = 1e3 / 240,
                d = u,
                p = [],
                m = function n(m) {
                    var f, g, _, v, y = s() - h,
                        x = !0 === m;
                    if ((y > o || y < 0) && (c += y - l), ((f = (_ = (h += y) - c) - d) > 0 || x) && (v = ++i.frame, r = _ - 1e3 * i.time, i.time = _ /= 1e3, d += f + (f >= u ? 4 : u - f), g = 1), x || (e = t(n)), g)
                        for (a = 0; a < p.length; a++) p[a](_, r, v, m)
                };
            return i = {
                time: 0,
                frame: 0,
                tick: function() {
                    m(!0)
                },
                deltaRatio: function(e) {
                    return r / (1e3 / (e || 60))
                },
                wake: function() {
                    Rl && (!El && ec() && (Tl = El = window, Al = Tl.document || {}, uc.gsap = Hu, (Tl.gsapVersions || (Tl.gsapVersions = [])).push(Hu.version), pc(dc || Tl.GreenSockGlobals || !Tl.gsap && Tl || {}), Ph.forEach(Dh)), n = "undefined" != typeof requestAnimationFrame && requestAnimationFrame, e && i.sleep(), t = n || function(e) {
                        return setTimeout(e, d - 1e3 * i.time + 1 | 0)
                    }, Pl = 1, m(2))
                },
                sleep: function() {
                    (n ? cancelAnimationFrame : clearTimeout)(e), Pl = 0, t = gc
                },
                lagSmoothing: function(e, t) {
                    o = e || 1 / 0, l = Math.min(t || 33, o)
                },
                fps: function(e) {
                    u = 1e3 / (e || 240), d = 1e3 * i.time + u
                },
                add: function(e, t, n) {
                    var r = t ? function(t, n, a, s) {
                        e(t, n, a, s), i.remove(r)
                    } : e;
                    return i.remove(e), p[n ? "unshift" : "push"](r), Gh(), r
                },
                remove: function(e, t) {
                    ~(t = p.indexOf(e)) && p.splice(t, 1) && a >= t && a--
                },
                _listeners: p
            }
        }(),
        Gh = function() {
            return !Pl && Vh.wake()
        },
        Wh = {},
        qh = /^[\d.\-M][\d.\-,\s]/,
        Xh = /["']/g,
        jh = function(e) {
            for (var t, n, i, r = {}, a = e.substr(1, e.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++) n = a[o], t = o !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, t), r[s] = isNaN(i) ? i.replace(Xh, "").trim() : +i, s = n.substr(t + 1).trim();
            return r
        },
        Yh = function(e) {
            return function(t) {
                return 1 - e(1 - t)
            }
        },
        Kh = function e(t, n) {
            for (var i, r = t._first; r;) r instanceof iu ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
        },
        Zh = function(e, t) {
            return e && (Kl(e) ? e : Wh[e] || function(e) {
                var t, n, i, r, a = (e + "").split("("),
                    s = Wh[a[0]];
                return s && a.length > 1 && s.config ? s.config.apply(null, ~e.indexOf("{") ? [jh(a[1])] : (t = e, n = t.indexOf("(") + 1, i = t.indexOf(")"), r = t.indexOf("(", n), t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(Fc)) : Wh._CE && qh.test(e) ? Wh._CE("", e) : s
            }(e)) || t
        },
        $h = function(e, t, n, i) {
            void 0 === n && (n = function(e) {
                return 1 - t(1 - e)
            }), void 0 === i && (i = function(e) {
                return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
            });
            var r, a = {
                easeIn: t,
                easeOut: n,
                easeInOut: i
            };
            return Pc(e, (function(e) {
                for (var t in Wh[e] = uc[e] = a, Wh[r = e.toLowerCase()] = n, a) Wh[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Wh[e + "." + t] = a[t]
            })), a
        },
        Jh = function(e) {
            return function(t) {
                return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
            }
        },
        Qh = function e(t, n, i) {
            var r = n >= 1 ? n : 1,
                a = (i || (t ? 0.3 : 0.45)) / (n < 1 ? n : 1),
                s = a / Vl * (Math.asin(1 / r) || 0),
                o = function(e) {
                    return 1 === e ? 1 : r * Math.pow(2, -10 * e) * jl((e - s) * a) + 1
                },
                l = "out" === t ? o : "in" === t ? function(e) {
                    return 1 - o(1 - e)
                } : Jh(o);
            return a = Vl / a, l.config = function(n, i) {
                return e(t, n, i)
            }, l
        },
        eu = function e(t, n) {
            void 0 === n && (n = 1.70158);
            var i = function(e) {
                    return e ? --e * e * ((n + 1) * e + n) + 1 : 0
                },
                r = "out" === t ? i : "in" === t ? function(e) {
                    return 1 - i(1 - e)
                } : Jh(i);
            return r.config = function(n) {
                return e(t, n)
            }, r
        };
    Pc("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
        var n = t < 5 ? t + 1 : t;
        $h(e + ",Power" + (n - 1), t ? function(e) {
            return Math.pow(e, n)
        } : function(e) {
            return e
        }, (function(e) {
            return 1 - Math.pow(1 - e, n)
        }), (function(e) {
            return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2
        }))
    })), Wh.Linear.easeNone = Wh.none = Wh.Linear.easeIn, $h("Elastic", Qh("in"), Qh("out"), Qh()), Dl = 7.5625, Nl = 2 * (Il = 1 / (Ul = 2.75)), Ol = 2.5 * Il, $h("Bounce", (function(e) {
        return 1 - kl(1 - e)
    }), kl = function(e) {
        return e < Il ? Dl * e * e : e < Nl ? Dl * Math.pow(e - 1.5 / Ul, 2) + .75 : e < Ol ? Dl * (e -= 2.25 / Ul) * e + .9375 : Dl * Math.pow(e - 2.625 / Ul, 2) + .984375
    }), $h("Expo", (function(e) {
        return Math.pow(2, 10 * (e - 1)) * e + e * e * e * e * e * e * (1 - e)
    })), $h("Circ", (function(e) {
        return -(ql(1 - e * e) - 1)
    })), $h("Sine", (function(e) {
        return 1 === e ? 1 : 1 - Xl(e * Gl)
    })), $h("Back", eu("in"), eu("out"), eu()), Wh.SteppedEase = Wh.steps = uc.SteppedEase = {
        config: function(e, t) {
            void 0 === e && (e = 1);
            var n = 1 / e,
                i = e + (t ? 0 : 1),
                r = t ? 1 : 0;
            return function(e) {
                return ((i * mh(0, .99999999, e) | 0) + r) * n
            }
        }
    }, Bl.ease = Wh["quad.out"], Pc("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
        return Ac += e + "," + e + "Params,"
    }));
    var tu = function(e, t) {
            this.id = Wl++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Lc, this.set = t ? t.getSetter : yu
        },
        nu = function() {
            function e(e) {
                this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, lh(this, +e.duration, 1, 1), this.data = e.data, Sl && (this._ctx = Sl, Sl.data.push(this)), Pl || Vh.wake()
            }
            var t = e.prototype;
            return t.delay = function(e) {
                return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
            }, t.duration = function(e) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
            }, t.totalDuration = function(e) {
                return arguments.length ? (this._dirty = 0, lh(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, t.totalTime = function(e, t) {
                if (Gh(), !arguments.length) return this._tTime;
                var n = this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                    for (th(this, e), !n._dp || n.parent || nh(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && ih(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === Hl || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), kc(this, e, t)), this
            }, t.time = function(e, t) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + $c(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
            }, t.totalProgress = function(e, t) {
                return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
            }, t.progress = function(e, t) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + $c(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
            }, t.iteration = function(e, t) {
                var n = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? Jc(this._tTime, n) + 1 : 1
            }, t.timeScale = function(e, t) {
                if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === e) return this;
                var n = this.parent && this._ts ? Qc(this.parent._time, this) : this._tTime;
                return this._rts = +e || 0, this._ts = this._ps || -1e-8 === e ? 0 : this._rts, this.totalTime(mh(-Math.abs(this._delay), this._tDur, n), !1 !== t), eh(this),
                    function(e) {
                        for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                        return e
                    }(this)
            }, t.paused = function(e) {
                return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Gh(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== Hl && (this._tTime -= Hl)))), this) : this._ps
            }, t.startTime = function(e) {
                if (arguments.length) {
                    this._start = e;
                    var t = this.parent || this._dp;
                    return t && (t._sort || !this.parent) && ih(t, this, e - this._delay), this
                }
                return this._start
            }, t.endTime = function(e) {
                return this._start + (Ql(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }, t.rawTime = function(e) {
                var t = this.parent || this._dp;
                return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Qc(t.rawTime(e), this) : this._tTime : this._tTime
            }, t.revert = function(e) {
                void 0 === e && (e = yc);
                var t = wl;
                return wl = e, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e), this.totalTime(-.01, e.suppressEvents)), "nested" !== this.data && !1 !== e.kill && this.kill(), wl = t, this
            }, t.globalTime = function(e) {
                for (var t = this, n = arguments.length ? e : t.rawTime(); t;) n = t._start + n / (Math.abs(t._ts) || 1), t = t._dp;
                return !this.parent && this._sat ? this._sat.globalTime(e) : n
            }, t.repeat = function(e) {
                return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, ch(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }, t.repeatDelay = function(e) {
                if (arguments.length) {
                    var t = this._time;
                    return this._rDelay = e, ch(this), t ? this.time(t) : this
                }
                return this._rDelay
            }, t.yoyo = function(e) {
                return arguments.length ? (this._yoyo = e, this) : this._yoyo
            }, t.seek = function(e, t) {
                return this.totalTime(uh(this, e), Ql(t))
            }, t.restart = function(e, t) {
                return this.play().totalTime(e ? -this._delay : 0, Ql(t)), this._dur || (this._zTime = -1e-8), this
            }, t.play = function(e, t) {
                return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
            }, t.reverse = function(e, t) {
                return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
            }, t.pause = function(e, t) {
                return null != e && this.seek(e, t), this.paused(!0)
            }, t.resume = function() {
                return this.paused(!1)
            }, t.reversed = function(e) {
                return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)), this) : this._rts < 0
            }, t.invalidate = function() {
                return this._initted = this._act = 0, this._zTime = -1e-8, this
            }, t.isActive = function() {
                var e, t = this.parent || this._dp,
                    n = this._start;
                return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - Hl))
            }, t.eventCallback = function(e, t, n) {
                var i = this.vars;
                return arguments.length > 1 ? (t ? (i[e] = t, n && (i[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete i[e], this) : i[e]
            }, t.then = function(e) {
                var t = this;
                return new Promise((function(n) {
                    var i = Kl(e) ? e : Bc,
                        r = function() {
                            var e = t.then;
                            t.then = null, Kl(i) && (i = i(t)) && (i.then || i === t) && (t.then = e), n(i), t.then = e
                        };
                    t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
                }))
            }, t.kill = function() {
                Lh(this)
            }, e
        }();
    zc(nu.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var iu = function(e) {
        function t(t, n) {
            var i;
            return void 0 === t && (t = {}), (i = e.call(this, t) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = Ql(t.sortChildren), Ml && ih(t.parent || Ml, yl(i), n), t.reversed && i.reverse(), t.paused && i.paused(!0), t.scrollTrigger && rh(yl(i), t.scrollTrigger), i
        }
        xl(t, e);
        var n = t.prototype;
        return n.to = function(e, t, n) {
            return dh(0, arguments, this), this
        }, n.from = function(e, t, n) {
            return dh(1, arguments, this), this
        }, n.fromTo = function(e, t, n, i) {
            return dh(2, arguments, this), this
        }, n.set = function(e, t, n) {
            return t.duration = 0, t.parent = this, Wc(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new mu(e, t, uh(this, n), 1), this
        }, n.call = function(e, t, n) {
            return ih(this, mu.delayedCall(0, e, t), n)
        }, n.staggerTo = function(e, t, n, i, r, a, s) {
            return n.duration = t, n.stagger = n.stagger || i, n.onComplete = a, n.onCompleteParams = s, n.parent = this, new mu(e, n, uh(this, r)), this
        }, n.staggerFrom = function(e, t, n, i, r, a, s) {
            return n.runBackwards = 1, Wc(n).immediateRender = Ql(n.immediateRender), this.staggerTo(e, t, n, i, r, a, s)
        }, n.staggerFromTo = function(e, t, n, i, r, a, s, o) {
            return i.startAt = n, Wc(i).immediateRender = Ql(i.immediateRender), this.staggerTo(e, t, i, r, a, s, o)
        }, n.render = function(e, t, n) {
            var i, r, a, s, o, l, c, h, u, d, p, m, f = this._time,
                g = this._dirty ? this.totalDuration() : this._tDur,
                _ = this._dur,
                v = e <= 0 ? 0 : Uc(e),
                y = this._zTime < 0 != e < 0 && (this._initted || !_);
            if (this !== Ml && v > g && e >= 0 && (v = g), v !== this._tTime || n || y) {
                if (f !== this._time && _ && (v += this._time - f, e += this._time - f), i = v, u = this._start, l = !(h = this._ts), y && (_ || (f = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) {
                    if (p = this._yoyo, o = _ + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * o + e, t, n);
                    if (i = Uc(v % o), v === g ? (s = this._repeat, i = _) : ((s = ~~(d = Uc(v / o))) && s === d && (i = _, s--), i > _ && (i = _)), d = Jc(this._tTime, o), !f && this._tTime && d !== s && this._tTime - d * o - this._dur <= 0 && (d = s), p && 1 & s && (i = _ - i, m = 1), s !== d && !this._lock) {
                        var x = p && 1 & d,
                            b = x === (p && 1 & s);
                        if (s < d && (x = !x), f = x ? 0 : v % _ ? _ : v, this._lock = 1, this.render(f || (m ? 0 : Uc(s * o)), t, !_)._lock = 0, this._tTime = v, !t && this.parent && Ch(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), f && f !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (_ = this._dur, g = this._tDur, b && (this._lock = 2, f = x ? _ : -1e-4, this.render(f, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                        Kh(this, m)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(e, t, n) {
                        var i;
                        if (n > t)
                            for (i = e._first; i && i._start <= n;) {
                                if ("isPause" === i.data && i._start > t) return i;
                                i = i._next
                            } else
                                for (i = e._last; i && i._start >= n;) {
                                    if ("isPause" === i.data && i._start < t) return i;
                                    i = i._prev
                                }
                    }(this, Uc(f), Uc(i)), c && (v -= i - (i = c._start))), this._tTime = v, this._time = i, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, f = 0), !f && i && !t && !s && (Ch(this, "onStart"), this._tTime !== v)) return this;
                if (i >= f && e >= 0)
                    for (r = this._first; r;) {
                        if (a = r._next, (r._act || i >= r._start) && r._ts && c !== r) {
                            if (r.parent !== this) return this.render(e, t, n);
                            if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, t, n), i !== this._time || !this._ts && !l) {
                                c = 0, a && (v += this._zTime = -1e-8);
                                break
                            }
                        }
                        r = a
                    } else {
                        r = this._last;
                        for (var w = e < 0 ? e : i; r;) {
                            if (a = r._prev, (r._act || w <= r._end) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(e, t, n);
                                if (r.render(r._ts > 0 ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, t, n || wl && (r._initted || r._startAt)), i !== this._time || !this._ts && !l) {
                                    c = 0, a && (v += this._zTime = w ? -1e-8 : Hl);
                                    break
                                }
                            }
                            r = a
                        }
                    }
                if (c && !t && (this.pause(), c.render(i >= f ? 0 : -1e-8)._zTime = i >= f ? 1 : -1, this._ts)) return this._start = u, eh(this), this.render(e, t, n);
                this._onUpdate && !t && Ch(this, "onUpdate", !0), (v === g && this._tTime >= this.totalDuration() || !v && f) && (u !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((e || !_) && (v === g && this._ts > 0 || !v && this._ts < 0) && jc(this, 1), t || e < 0 && !f || !v && !f && g || (Ch(this, v === g && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < g && this.timeScale() > 0) && this._prom())))
            }
            return this
        }, n.add = function(e, t) {
            var n = this;
            if (Zl(t) || (t = uh(this, t, e)), !(e instanceof nu)) {
                if (ic(e)) return e.forEach((function(e) {
                    return n.add(e, t)
                })), this;
                if (Yl(e)) return this.addLabel(e, t);
                if (!Kl(e)) return this;
                e = mu.delayedCall(0, e)
            }
            return this !== e ? ih(this, e, t) : this
        }, n.getChildren = function(e, t, n, i) {
            void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = -zl);
            for (var r = [], a = this._first; a;) a._start >= i && (a instanceof mu ? t && r.push(a) : (n && r.push(a), e && r.push.apply(r, a.getChildren(!0, t, n)))), a = a._next;
            return r
        }, n.getById = function(e) {
            for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)
                if (t[n].vars.id === e) return t[n]
        }, n.remove = function(e) {
            return Yl(e) ? this.removeLabel(e) : Kl(e) ? this.killTweensOf(e) : (e.parent === this && Xc(this, e), e === this._recent && (this._recent = this._last), Yc(this))
        }, n.totalTime = function(t, n) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Uc(Vh.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime
        }, n.addLabel = function(e, t) {
            return this.labels[e] = uh(this, t), this
        }, n.removeLabel = function(e) {
            return delete this.labels[e], this
        }, n.addPause = function(e, t, n) {
            var i = mu.delayedCall(0, t || gc, n);
            return i.data = "isPause", this._hasPause = 1, ih(this, i, uh(this, e))
        }, n.removePause = function(e) {
            var t = this._first;
            for (e = uh(this, e); t;) t._start === e && "isPause" === t.data && jc(t), t = t._next
        }, n.killTweensOf = function(e, t, n) {
            for (var i = this.getTweensOf(e, n), r = i.length; r--;) ru !== i[r] && i[r].kill(e, t);
            return this
        }, n.getTweensOf = function(e, t) {
            for (var n, i = [], r = vh(e), a = this._first, s = Zl(t); a;) a instanceof mu ? Nc(a._targets, r) && (s ? (!ru || a._initted && a._ts) && a.globalTime(0) <= t && a.globalTime(a.totalDuration()) > t : !t || a.isActive()) && i.push(a) : (n = a.getTweensOf(r, t)).length && i.push.apply(i, n), a = a._next;
            return i
        }, n.tweenTo = function(e, t) {
            t = t || {};
            var n, i = this,
                r = uh(i, e),
                a = t,
                s = a.startAt,
                o = a.onStart,
                l = a.onStartParams,
                c = a.immediateRender,
                h = mu.to(i, zc({
                    ease: t.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration: t.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale()) || Hl,
                    onStart: function() {
                        if (i.pause(), !n) {
                            var e = t.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale());
                            h._dur !== e && lh(h, e, 0, 1).render(h._time, !0, !0), n = 1
                        }
                        o && o.apply(h, l || [])
                    }
                }, t));
            return c ? h.render(0) : h
        }, n.tweenFromTo = function(e, t, n) {
            return this.tweenTo(t, zc({
                startAt: {
                    time: uh(this, e)
                }
            }, n))
        }, n.recent = function() {
            return this._recent
        }, n.nextLabel = function(e) {
            return void 0 === e && (e = this._time), Rh(this, uh(this, e))
        }, n.previousLabel = function(e) {
            return void 0 === e && (e = this._time), Rh(this, uh(this, e), 1)
        }, n.currentLabel = function(e) {
            return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + Hl)
        }, n.shiftChildren = function(e, t, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, a = this.labels; r;) r._start >= n && (r._start += e, r._end += e), r = r._next;
            if (t)
                for (i in a) a[i] >= n && (a[i] += e);
            return Yc(this)
        }, n.invalidate = function(t) {
            var n = this._first;
            for (this._lock = 0; n;) n.invalidate(t), n = n._next;
            return e.prototype.invalidate.call(this, t)
        }, n.clear = function(e) {
            void 0 === e && (e = !0);
            for (var t, n = this._first; n;) t = n._next, this.remove(n), n = t;
            return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), Yc(this)
        }, n.totalDuration = function(e) {
            var t, n, i, r = 0,
                a = this,
                s = a._last,
                o = zl;
            if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -e : e));
            if (a._dirty) {
                for (i = a.parent; s;) t = s._prev, s._dirty && s.totalDuration(), (n = s._start) > o && a._sort && s._ts && !a._lock ? (a._lock = 1, ih(a, s, n - s._delay, 1)._lock = 0) : o = n, n < 0 && s._ts && (r -= n, (!i && !a._dp || i && i.smoothChildTiming) && (a._start += n / a._ts, a._time -= n, a._tTime -= n), a.shiftChildren(-n, !1, -1 / 0), o = 0), s._end > r && s._ts && (r = s._end), s = t;
                lh(a, a === Ml && a._time > r ? a._time : r, 1, 1), a._dirty = 0
            }
            return a._tDur
        }, t.updateRoot = function(e) {
            if (Ml._ts && (kc(Ml, Qc(e, Ml)), Cl = Vh.frame), Vh.frame >= Tc) {
                Tc += Fl.autoSleep || 120;
                var t = Ml._first;
                if ((!t || !t._ts) && Fl.autoSleep && Vh._listeners.length < 2) {
                    for (; t && !t._ts;) t = t._next;
                    t || Vh.sleep()
                }
            }
        }, t
    }(nu);
    zc(iu.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var ru, au, su = function(e, t, n, i, r, a, s) {
            var o, l, c, h, u, d, p, m, f = new Ru(this._pt, e, t, 0, 1, wu, null, r),
                g = 0,
                _ = 0;
            for (f.b = n, f.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = Eh(i)), a && (a(m = [n, i], e, t), n = m[0], i = m[1]), l = n.match(oc) || []; o = oc.exec(i);) h = o[0], u = i.substring(g, o.index), c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1), h !== l[_++] && (d = parseFloat(l[_ - 1]) || 0, f._pt = {
                _next: f._pt,
                p: u || 1 === _ ? u : ",",
                s: d,
                c: "=" === h.charAt(1) ? Ic(d, h) - d : parseFloat(h) - d,
                m: c && c < 4 ? Math.round : 0
            }, g = oc.lastIndex);
            return f.c = g < i.length ? i.substring(g, i.length) : "", f.fp = s, (lc.test(i) || p) && (f.e = 0), this._pt = f, f
        },
        ou = function(e, t, n, i, r, a, s, o, l, c) {
            Kl(i) && (i = i(r || 0, e, a));
            var h, u = e[t],
                d = "get" !== n ? n : Kl(u) ? l ? e[t.indexOf("set") || !Kl(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : u,
                p = Kl(u) ? l ? _u : gu : fu;
            if (Yl(i) && (~i.indexOf("random(") && (i = Eh(i)), "=" === i.charAt(1) && ((h = Ic(d, i) + (fh(d) || 0)) || 0 === h) && (i = h)), !c || d !== i || au) return isNaN(d * i) || "" === i ? su.call(this, e, t, d, i, p, o || Fl.stringFilter, l) : (h = new Ru(this._pt, e, t, +d || 0, i - (d || 0), "boolean" == typeof u ? bu : xu, 0, p), l && (h.fp = l), s && h.modifier(s, this, e), this._pt = h)
        },
        lu = function(e, t, n, i, r, a) {
            var s, o, l, c;
            if (Sc[e] && !1 !== (s = new Sc[e]).init(r, s.rawVars ? t[e] : function(e, t, n, i, r) {
                    if (Kl(e) && (e = uu(e, r, t, n, i)), !Jl(e) || e.style && e.nodeType || ic(e) || nc(e)) return Yl(e) ? uu(e, r, t, n, i) : e;
                    var a, s = {};
                    for (a in e) s[a] = uu(e[a], r, t, n, i);
                    return s
                }(t[e], i, r, a, n), n, i, a) && (n._pt = o = new Ru(n._pt, r, e, 0, 1, s.render, s, 0, s.priority), n !== Ll))
                for (l = n._ptLookup[n._targets.indexOf(r)], c = s._props.length; c--;) l[s._props[c]] = o;
            return s
        },
        cu = function e(t, n, i) {
            var r, a, s, o, l, c, h, u, d, p, m, f, g, _ = t.vars,
                v = _.ease,
                y = _.startAt,
                x = _.immediateRender,
                b = _.lazy,
                w = _.onUpdate,
                S = _.runBackwards,
                M = _.yoyoEase,
                T = _.keyframes,
                E = _.autoRevert,
                A = t._dur,
                R = t._startAt,
                C = t._targets,
                L = t.parent,
                P = L && "nested" === L.data ? L.vars.targets : C,
                D = "auto" === t._overwrite && !bl,
                U = t.timeline;
            if (U && (!T || !v) && (v = "none"), t._ease = Zh(v, Bl.ease), t._yEase = M ? Yh(Zh(!0 === M ? v : M, Bl.ease)) : 0, M && t._yoyo && !t._repeat && (M = t._yEase, t._yEase = t._ease, t._ease = M), t._from = !U && !!_.runBackwards, !U || T && !_.stagger) {
                if (f = (u = C[0] ? Cc(C[0]).harness : 0) && _[u.prop], r = Gc(_, xc), R && (R._zTime < 0 && R.progress(1), n < 0 && S && x && !E ? R.render(-1, !0) : R.revert(S && A ? vc : _c), R._lazy = 0), y) {
                    if (jc(t._startAt = mu.set(C, zc({
                            data: "isStart",
                            overwrite: !1,
                            parent: L,
                            immediateRender: !0,
                            lazy: !R && Ql(b),
                            startAt: null,
                            delay: 0,
                            onUpdate: w && function() {
                                return Ch(t, "onUpdate")
                            },
                            stagger: 0
                        }, y))), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (wl || !x && !E) && t._startAt.revert(vc), x && A && n <= 0 && i <= 0) return void(n && (t._zTime = n))
                } else if (S && A && !R)
                    if (n && (x = !1), s = zc({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: x && !R && Ql(b),
                            immediateRender: x,
                            stagger: 0,
                            parent: L
                        }, r), f && (s[u.prop] = f), jc(t._startAt = mu.set(C, s)), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (wl ? t._startAt.revert(vc) : t._startAt.render(-1, !0)), t._zTime = n, x) {
                        if (!n) return
                    } else e(t._startAt, Hl, Hl);
                for (t._pt = t._ptCache = 0, b = A && Ql(b) || b && !A, a = 0; a < C.length; a++) {
                    if (h = (l = C[a])._gsap || Rc(C)[a]._gsap, t._ptLookup[a] = p = {}, wc[h.id] && bc.length && Oc(), m = P === C ? a : P.indexOf(l), u && !1 !== (d = new u).init(l, f || r, t, m, P) && (t._pt = o = new Ru(t._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function(e) {
                            p[e] = o
                        })), d.priority && (c = 1)), !u || f)
                        for (s in r) Sc[s] && (d = lu(s, r, t, m, l, P)) ? d.priority && (c = 1) : p[s] = o = ou.call(t, l, s, "get", r[s], m, P, 0, _.stringFilter);
                    t._op && t._op[a] && t.kill(l, t._op[a]), D && t._pt && (ru = t, Ml.killTweensOf(l, p, t.globalTime(n)), g = !t.parent, ru = 0), t._pt && b && (wc[h.id] = 1)
                }
                c && Au(t), t._onInit && t._onInit(t)
            }
            t._onUpdate = w, t._initted = (!t._op || t._pt) && !g, T && n <= 0 && U.render(zl, !0, !0)
        },
        hu = function(e, t, n, i) {
            var r, a, s = t.ease || i || "power1.inOut";
            if (ic(t)) a = n[e] || (n[e] = []), t.forEach((function(e, n) {
                return a.push({
                    t: n / (t.length - 1) * 100,
                    v: e,
                    e: s
                })
            }));
            else
                for (r in t) a = n[r] || (n[r] = []), "ease" === r || a.push({
                    t: parseFloat(e),
                    v: t[r],
                    e: s
                })
        },
        uu = function(e, t, n, i, r) {
            return Kl(e) ? e.call(t, n, i, r) : Yl(e) && ~e.indexOf("random(") ? Eh(e) : e
        },
        du = Ac + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        pu = {};
    Pc(du + ",id,stagger,delay,duration,paused,scrollTrigger", (function(e) {
        return pu[e] = 1
    }));
    var mu = function(e) {
        function t(t, n, i, r) {
            var a;
            "number" == typeof n && (i.duration = n, n = i, i = null);
            var s, o, l, c, h, u, d, p, m = (a = e.call(this, r ? n : Wc(n)) || this).vars,
                f = m.duration,
                g = m.delay,
                _ = m.immediateRender,
                v = m.stagger,
                y = m.overwrite,
                x = m.keyframes,
                b = m.defaults,
                w = m.scrollTrigger,
                S = m.yoyoEase,
                M = n.parent || Ml,
                T = (ic(t) || nc(t) ? Zl(t[0]) : "length" in n) ? [t] : vh(t);
            if (a._targets = T.length ? Rc(T) : mc(0, !Fl.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = y, x || v || tc(f) || tc(g)) {
                if (n = a.vars, (s = a.timeline = new iu({
                        data: "nested",
                        defaults: b || {},
                        targets: M && "nested" === M.data ? M.vars.targets : T
                    })).kill(), s.parent = s._dp = yl(a), s._start = 0, v || tc(f) || tc(g)) {
                    if (c = T.length, d = v && bh(v), Jl(v))
                        for (h in v) ~du.indexOf(h) && (p || (p = {}), p[h] = v[h]);
                    for (o = 0; o < c; o++)(l = Gc(n, pu)).stagger = 0, S && (l.yoyoEase = S), p && Hc(l, p), u = T[o], l.duration = +uu(f, yl(a), o, u, T), l.delay = (+uu(g, yl(a), o, u, T) || 0) - a._delay, !v && 1 === c && l.delay && (a._delay = g = l.delay, a._start += g, l.delay = 0), s.to(u, l, d ? d(o, u, T) : 0), s._ease = Wh.none;
                    s.duration() ? f = g = 0 : a.timeline = 0
                } else if (x) {
                    Wc(zc(s.vars.defaults, {
                        ease: "none"
                    })), s._ease = Zh(x.ease || n.ease || "none");
                    var E, A, R, C = 0;
                    if (ic(x)) x.forEach((function(e) {
                        return s.to(T, e, ">")
                    })), s.duration();
                    else {
                        for (h in l = {}, x) "ease" === h || "easeEach" === h || hu(h, x[h], l, x.easeEach);
                        for (h in l)
                            for (E = l[h].sort((function(e, t) {
                                    return e.t - t.t
                                })), C = 0, o = 0; o < E.length; o++)(R = {
                                ease: (A = E[o]).e,
                                duration: (A.t - (o ? E[o - 1].t : 0)) / 100 * f
                            })[h] = A.v, s.to(T, R, C), C += R.duration;
                        s.duration() < f && s.to({}, {
                            duration: f - s.duration()
                        })
                    }
                }
                f || a.duration(f = s.duration())
            } else a.timeline = 0;
            return !0 !== y || bl || (ru = yl(a), Ml.killTweensOf(T), ru = 0), ih(M, yl(a), i), n.reversed && a.reverse(), n.paused && a.paused(!0), (_ || !f && !x && a._start === Uc(M._time) && Ql(_) && Zc(yl(a)) && "nested" !== M.data) && (a._tTime = -1e-8, a.render(Math.max(0, -g) || 0)), w && rh(yl(a), w), a
        }
        xl(t, e);
        var n = t.prototype;
        return n.render = function(e, t, n) {
            var i, r, a, s, o, l, c, h, u, d = this._time,
                p = this._tDur,
                m = this._dur,
                f = e < 0,
                g = e > p - Hl && !f ? p : e < Hl ? 0 : e;
            if (m) {
                if (g !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== f || this._lazy) {
                    if (i = g, h = this.timeline, this._repeat) {
                        if (s = m + this._rDelay, this._repeat < -1 && f) return this.totalTime(100 * s + e, t, n);
                        if (i = Uc(g % s), g === p ? (a = this._repeat, i = m) : (a = ~~(o = Uc(g / s))) && a === o ? (i = m, a--) : i > m && (i = m), (l = this._yoyo && 1 & a) && (u = this._yEase, i = m - i), o = Jc(this._tTime, s), i === d && !n && this._initted && a === o) return this._tTime = g, this;
                        a !== o && (h && this._yEase && Kh(h, l), this.vars.repeatRefresh && !l && !this._lock && i !== s && this._initted && (this._lock = n = 1, this.render(Uc(s * a), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (ah(this, f ? e : i, n, t, g)) return this._tTime = 0, this;
                        if (!(d === this._time || n && this.vars.repeatRefresh && a !== o)) return this;
                        if (m !== this._dur) return this.render(e, t, n)
                    }
                    if (this._tTime = g, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (u || this._ease)(i / m), this._from && (this.ratio = c = 1 - c), i && !d && !t && !a && (Ch(this, "onStart"), this._tTime !== g)) return this;
                    for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                    h && h.render(e < 0 ? e : h._dur * h._ease(i / this._dur), t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (f && Kc(this, e, 0, n), Ch(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !t && this.parent && Ch(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (f && !this._onUpdate && Kc(this, e, 0, !0), (e || !m) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && jc(this, 1), t || f && !d || !(g || d || l) || (Ch(this, g === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < p && this.timeScale() > 0) && this._prom()))
                }
            } else ! function(e, t, n, i) {
                var r, a, s, o = e.ratio,
                    l = t < 0 || !t && (!e._start && sh(e) && (e._initted || !oh(e)) || (e._ts < 0 || e._dp._ts < 0) && !oh(e)) ? 0 : 1,
                    c = e._rDelay,
                    h = 0;
                if (c && e._repeat && (h = mh(0, e._tDur, t), a = Jc(h, c), e._yoyo && 1 & a && (l = 1 - l), a !== Jc(e._tTime, c) && (o = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== o || wl || i || e._zTime === Hl || !t && e._zTime) {
                    if (!e._initted && ah(e, t, i, n, h)) return;
                    for (s = e._zTime, e._zTime = t || (n ? Hl : 0), n || (n = t && !s), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = h, r = e._pt; r;) r.r(l, r.d), r = r._next;
                    t < 0 && Kc(e, t, 0, !0), e._onUpdate && !n && Ch(e, "onUpdate"), h && e._repeat && !n && e.parent && Ch(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && jc(e, 1), n || wl || (Ch(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                } else e._zTime || (e._zTime = t)
            }(this, e, t, n);
            return this
        }, n.targets = function() {
            return this._targets
        }, n.invalidate = function(t) {
            return (!t || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), e.prototype.invalidate.call(this, t)
        }, n.resetTo = function(e, t, n, i, r) {
            Pl || Vh.wake(), this._ts || this.play();
            var a = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
            return this._initted || cu(this, a),
                function(e, t, n, i, r, a, s, o) {
                    var l, c, h, u, d = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                    if (!d)
                        for (d = e._ptCache[t] = [], h = e._ptLookup, u = e._targets.length; u--;) {
                            if ((l = h[u][t]) && l.d && l.d._pt)
                                for (l = l.d._pt; l && l.p !== t && l.fp !== t;) l = l._next;
                            if (!l) return au = 1, e.vars[t] = "+=0", cu(e, s), au = 0, o ? mc() : 1;
                            d.push(l)
                        }
                    for (u = d.length; u--;)(l = (c = d[u])._pt || c).s = !i && 0 !== i || r ? l.s + (i || 0) + a * l.c : i, l.c = n - l.s, c.e && (c.e = Dc(n) + fh(c.e)), c.b && (c.b = l.s + fh(c.b))
                }(this, e, t, n, i, this._ease(a / this._dur), a, r) ? this.resetTo(e, t, n, i, 1) : (th(this, 0), this.parent || qc(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
        }, n.kill = function(e, t) {
            if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? Lh(this) : this.scrollTrigger && this.scrollTrigger.kill(!!wl), this;
            if (this.timeline) {
                var n = this.timeline.totalDuration();
                return this.timeline.killTweensOf(e, t, ru && !0 !== ru.vars.overwrite)._first || Lh(this), this.parent && n !== this.timeline.totalDuration() && lh(this, this._dur * this.timeline._tDur / n, 0, 1), this
            }
            var i, r, a, s, o, l, c, h = this._targets,
                u = e ? vh(e) : h,
                d = this._ptLookup,
                p = this._pt;
            if ((!t || "all" === t) && function(e, t) {
                    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];);
                    return n < 0
                }(h, u)) return "all" === t && (this._pt = 0), Lh(this);
            for (i = this._op = this._op || [], "all" !== t && (Yl(t) && (o = {}, Pc(t, (function(e) {
                    return o[e] = 1
                })), t = o), t = function(e, t) {
                    var n, i, r, a, s = e[0] ? Cc(e[0]).harness : 0,
                        o = s && s.aliases;
                    if (!o) return t;
                    for (i in n = Hc({}, t), o)
                        if (i in n)
                            for (r = (a = o[i].split(",")).length; r--;) n[a[r]] = n[i];
                    return n
                }(h, t)), c = h.length; c--;)
                if (~u.indexOf(h[c]))
                    for (o in r = d[c], "all" === t ? (i[c] = t, s = r, a = {}) : (a = i[c] = i[c] || {}, s = t), s)(l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || Xc(this, l, "_pt"), delete r[o]), "all" !== a && (a[o] = 1);
            return this._initted && !this._pt && p && Lh(this), this
        }, t.to = function(e, n) {
            return new t(e, n, arguments[2])
        }, t.from = function(e, t) {
            return dh(1, arguments)
        }, t.delayedCall = function(e, n, i, r) {
            return new t(n, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: e,
                onComplete: n,
                onReverseComplete: n,
                onCompleteParams: i,
                onReverseCompleteParams: i,
                callbackScope: r
            })
        }, t.fromTo = function(e, t, n) {
            return dh(2, arguments)
        }, t.set = function(e, n) {
            return n.duration = 0, n.repeatDelay || (n.repeat = 0), new t(e, n)
        }, t.killTweensOf = function(e, t, n) {
            return Ml.killTweensOf(e, t, n)
        }, t
    }(nu);
    zc(mu.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), Pc("staggerTo,staggerFrom,staggerFromTo", (function(e) {
        mu[e] = function() {
            var t = new iu,
                n = gh.call(arguments, 0);
            return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
        }
    }));
    var fu = function(e, t, n) {
            return e[t] = n
        },
        gu = function(e, t, n) {
            return e[t](n)
        },
        _u = function(e, t, n, i) {
            return e[t](i.fp, n)
        },
        vu = function(e, t, n) {
            return e.setAttribute(t, n)
        },
        yu = function(e, t) {
            return Kl(e[t]) ? gu : $l(e[t]) && e.setAttribute ? vu : fu
        },
        xu = function(e, t) {
            return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
        },
        bu = function(e, t) {
            return t.set(t.t, t.p, !!(t.s + t.c * e), t)
        },
        wu = function(e, t) {
            var n = t._pt,
                i = "";
            if (!e && t.b) i = t.b;
            else if (1 === e && t.e) i = t.e;
            else {
                for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i, n = n._next;
                i += t.c
            }
            t.set(t.t, t.p, i, t)
        },
        Su = function(e, t) {
            for (var n = t._pt; n;) n.r(e, n.d), n = n._next
        },
        Mu = function(e, t, n, i) {
            for (var r, a = this._pt; a;) r = a._next, a.p === i && a.modifier(e, t, n), a = r
        },
        Tu = function(e) {
            for (var t, n, i = this._pt; i;) n = i._next, i.p === e && !i.op || i.op === e ? Xc(this, i, "_pt") : i.dep || (t = 1), i = n;
            return !t
        },
        Eu = function(e, t, n, i) {
            i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
        },
        Au = function(e) {
            for (var t, n, i, r, a = e._pt; a;) {
                for (t = a._next, n = i; n && n.pr > a.pr;) n = n._next;
                (a._prev = n ? n._prev : r) ? a._prev._next = a: i = a, (a._next = n) ? n._prev = a : r = a, a = t
            }
            e._pt = i
        },
        Ru = function() {
            function e(e, t, n, i, r, a, s, o, l) {
                this.t = t, this.s = i, this.c = r, this.p = n, this.r = a || xu, this.d = s || this, this.set = o || fu, this.pr = l || 0, this._next = e, e && (e._prev = this)
            }
            return e.prototype.modifier = function(e, t, n) {
                this.mSet = this.mSet || this.set, this.set = Eu, this.m = e, this.mt = n, this.tween = t
            }, e
        }();
    Pc(Ac + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
        return xc[e] = 1
    })), uc.TweenMax = uc.TweenLite = mu, uc.TimelineLite = uc.TimelineMax = iu, Ml = new iu({
        sortChildren: !1,
        defaults: Bl,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), Fl.stringFilter = Hh;
    var Cu = [],
        Lu = {},
        Pu = [],
        Du = 0,
        Uu = 0,
        Iu = function(e) {
            return (Lu[e] || Pu).map((function(e) {
                return e()
            }))
        },
        Nu = function() {
            var e = Date.now(),
                t = [];
            e - Du > 2 && (Iu("matchMediaInit"), Cu.forEach((function(e) {
                var n, i, r, a, s = e.queries,
                    o = e.conditions;
                for (i in s)(n = Tl.matchMedia(s[i]).matches) && (r = 1), n !== o[i] && (o[i] = n, a = 1);
                a && (e.revert(), r && t.push(e))
            })), Iu("matchMediaRevert"), t.forEach((function(e) {
                return e.onMatch(e, (function(t) {
                    return e.add(null, t)
                }))
            })), Du = e, Iu("matchMedia"))
        },
        Ou = function() {
            function e(e, t) {
                this.selector = t && yh(t), this.data = [], this._r = [], this.isReverted = !1, this.id = Uu++, e && this.add(e)
            }
            var t = e.prototype;
            return t.add = function(e, t, n) {
                Kl(e) && (n = t, t = e, e = Kl);
                var i = this,
                    r = function() {
                        var e, r = Sl,
                            a = i.selector;
                        return r && r !== i && r.data.push(i), n && (i.selector = yh(n)), Sl = i, e = t.apply(i, arguments), Kl(e) && i._r.push(e), Sl = r, i.selector = a, i.isReverted = !1, e
                    };
                return i.last = r, e === Kl ? r(i, (function(e) {
                    return i.add(null, e)
                })) : e ? i[e] = r : r
            }, t.ignore = function(e) {
                var t = Sl;
                Sl = null, e(this), Sl = t
            }, t.getTweens = function() {
                var t = [];
                return this.data.forEach((function(n) {
                    return n instanceof e ? t.push.apply(t, n.getTweens()) : n instanceof mu && !(n.parent && "nested" === n.parent.data) && t.push(n)
                })), t
            }, t.clear = function() {
                this._r.length = this.data.length = 0
            }, t.kill = function(e, t) {
                var n = this;
                if (e ? function() {
                        for (var t, i = n.getTweens(), r = n.data.length; r--;) "isFlip" === (t = n.data[r]).data && (t.revert(), t.getChildren(!0, !0, !1).forEach((function(e) {
                            return i.splice(i.indexOf(e), 1)
                        })));
                        for (i.map((function(e) {
                                return {
                                    g: e._dur || e._delay || e._sat && !e._sat.vars.immediateRender ? e.globalTime(0) : -1 / 0,
                                    t: e
                                }
                            })).sort((function(e, t) {
                                return t.g - e.g || -1 / 0
                            })).forEach((function(t) {
                                return t.t.revert(e)
                            })), r = n.data.length; r--;)(t = n.data[r]) instanceof iu ? "nested" !== t.data && (t.scrollTrigger && t.scrollTrigger.revert(), t.kill()) : !(t instanceof mu) && t.revert && t.revert(e);
                        n._r.forEach((function(t) {
                            return t(e, n)
                        })), n.isReverted = !0
                    }() : this.data.forEach((function(e) {
                        return e.kill && e.kill()
                    })), this.clear(), t)
                    for (var i = Cu.length; i--;) Cu[i].id === this.id && Cu.splice(i, 1)
            }, t.revert = function(e) {
                this.kill(e || {})
            }, e
        }(),
        ku = function() {
            function e(e) {
                this.contexts = [], this.scope = e, Sl && Sl.data.push(this)
            }
            var t = e.prototype;
            return t.add = function(e, t, n) {
                Jl(e) || (e = {
                    matches: e
                });
                var i, r, a, s = new Ou(0, n || this.scope),
                    o = s.conditions = {};
                for (r in Sl && !s.selector && (s.selector = Sl.selector), this.contexts.push(s), t = s.add("onMatch", t), s.queries = e, e) "all" === r ? a = 1 : (i = Tl.matchMedia(e[r])) && (Cu.indexOf(s) < 0 && Cu.push(s), (o[r] = i.matches) && (a = 1), i.addListener ? i.addListener(Nu) : i.addEventListener("change", Nu));
                return a && t(s, (function(e) {
                    return s.add(null, e)
                })), this
            }, t.revert = function(e) {
                this.kill(e || {})
            }, t.kill = function(e) {
                this.contexts.forEach((function(t) {
                    return t.kill(e, !0)
                }))
            }, e
        }(),
        Fu = {
            registerPlugin: function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                t.forEach((function(e) {
                    return Dh(e)
                }))
            },
            timeline: function(e) {
                return new iu(e)
            },
            getTweensOf: function(e, t) {
                return Ml.getTweensOf(e, t)
            },
            getProperty: function(e, t, n, i) {
                Yl(e) && (e = vh(e)[0]);
                var r = Cc(e || {}).get,
                    a = n ? Bc : Fc;
                return "native" === n && (n = ""), e ? t ? a((Sc[t] && Sc[t].get || r)(e, t, n, i)) : function(t, n, i) {
                    return a((Sc[t] && Sc[t].get || r)(e, t, n, i))
                } : e
            },
            quickSetter: function(e, t, n) {
                if ((e = vh(e)).length > 1) {
                    var i = e.map((function(e) {
                            return Hu.quickSetter(e, t, n)
                        })),
                        r = i.length;
                    return function(e) {
                        for (var t = r; t--;) i[t](e)
                    }
                }
                e = e[0] || {};
                var a = Sc[t],
                    s = Cc(e),
                    o = s.harness && (s.harness.aliases || {})[t] || t,
                    l = a ? function(t) {
                        var i = new a;
                        Ll._pt = 0, i.init(e, n ? t + n : t, Ll, 0, [e]), i.render(1, i), Ll._pt && Su(1, Ll)
                    } : s.set(e, o);
                return a ? l : function(t) {
                    return l(e, o, n ? t + n : t, s, 1)
                }
            },
            quickTo: function(e, t, n) {
                var i, r = Hu.to(e, zc(((i = {})[t] = "+=0.1", i.paused = !0, i.stagger = 0, i), n || {})),
                    a = function(e, n, i) {
                        return r.resetTo(t, e, n, i)
                    };
                return a.tween = r, a
            },
            isTweening: function(e) {
                return Ml.getTweensOf(e, !0).length > 0
            },
            defaults: function(e) {
                return e && e.ease && (e.ease = Zh(e.ease, Bl.ease)), Vc(Bl, e || {})
            },
            config: function(e) {
                return Vc(Fl, e || {})
            },
            registerEffect: function(e) {
                var t = e.name,
                    n = e.effect,
                    i = e.plugins,
                    r = e.defaults,
                    a = e.extendTimeline;
                (i || "").split(",").forEach((function(e) {
                    return e && !Sc[e] && !uc[e] && mc()
                })), Mc[t] = function(e, t, i) {
                    return n(vh(e), zc(t || {}, r), i)
                }, a && (iu.prototype[t] = function(e, n, i) {
                    return this.add(Mc[t](e, Jl(n) ? n : (i = n) && {}, this), i)
                })
            },
            registerEase: function(e, t) {
                Wh[e] = Zh(t)
            },
            parseEase: function(e, t) {
                return arguments.length ? Zh(e, t) : Wh
            },
            getById: function(e) {
                return Ml.getById(e)
            },
            exportRoot: function(e, t) {
                void 0 === e && (e = {});
                var n, i, r = new iu(e);
                for (r.smoothChildTiming = Ql(e.smoothChildTiming), Ml.remove(r), r._dp = 0, r._time = r._tTime = Ml._time, n = Ml._first; n;) i = n._next, !t && !n._dur && n instanceof mu && n.vars.onComplete === n._targets[0] || ih(r, n, n._start - n._delay), n = i;
                return ih(Ml, r, 0), r
            },
            context: function(e, t) {
                return e ? new Ou(e, t) : Sl
            },
            matchMedia: function(e) {
                return new ku(e)
            },
            matchMediaRefresh: function() {
                return Cu.forEach((function(e) {
                    var t, n, i = e.conditions;
                    for (n in i) i[n] && (i[n] = !1, t = 1);
                    t && e.revert()
                })) || Nu()
            },
            addEventListener: function(e, t) {
                var n = Lu[e] || (Lu[e] = []);
                ~n.indexOf(t) || n.push(t)
            },
            removeEventListener: function(e, t) {
                var n = Lu[e],
                    i = n && n.indexOf(t);
                i >= 0 && n.splice(i, 1)
            },
            utils: {
                wrap: function e(t, n, i) {
                    var r = n - t;
                    return ic(t) ? Th(t, e(0, t.length), n) : ph(i, (function(e) {
                        return (r + (e - t) % r) % r + t
                    }))
                },
                wrapYoyo: function e(t, n, i) {
                    var r = n - t,
                        a = 2 * r;
                    return ic(t) ? Th(t, e(0, t.length - 1), n) : ph(i, (function(e) {
                        return t + ((e = (a + (e - t) % a) % a || 0) > r ? a - e : e)
                    }))
                },
                distribute: bh,
                random: Mh,
                snap: Sh,
                normalize: function(e, t, n) {
                    return Ah(e, t, 0, 1, n)
                },
                getUnit: fh,
                clamp: function(e, t, n) {
                    return ph(n, (function(n) {
                        return mh(e, t, n)
                    }))
                },
                splitColor: Oh,
                toArray: vh,
                selector: yh,
                mapRange: Ah,
                pipe: function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    return function(e) {
                        return t.reduce((function(e, t) {
                            return t(e)
                        }), e)
                    }
                },
                unitize: function(e, t) {
                    return function(n) {
                        return e(parseFloat(n)) + (t || fh(n))
                    }
                },
                interpolate: function e(t, n, i, r) {
                    var a = isNaN(t + n) ? 0 : function(e) {
                        return (1 - e) * t + e * n
                    };
                    if (!a) {
                        var s, o, l, c, h, u = Yl(t),
                            d = {};
                        if (!0 === i && (r = 1) && (i = null), u) t = {
                            p: t
                        }, n = {
                            p: n
                        };
                        else if (ic(t) && !ic(n)) {
                            for (l = [], c = t.length, h = c - 2, o = 1; o < c; o++) l.push(e(t[o - 1], t[o]));
                            c--, a = function(e) {
                                e *= c;
                                var t = Math.min(h, ~~e);
                                return l[t](e - t)
                            }, i = n
                        } else r || (t = Hc(ic(t) ? [] : {}, t));
                        if (!l) {
                            for (s in n) ou.call(d, t, s, "get", n[s]);
                            a = function(e) {
                                return Su(e, d) || (u ? t.p : t)
                            }
                        }
                    }
                    return ph(i, a)
                },
                shuffle: xh
            },
            install: pc,
            effects: Mc,
            ticker: Vh,
            updateRoot: iu.updateRoot,
            plugins: Sc,
            globalTimeline: Ml,
            core: {
                PropTween: Ru,
                globals: fc,
                Tween: mu,
                Timeline: iu,
                Animation: nu,
                getCache: Cc,
                _removeLinkedListItem: Xc,
                reverting: function() {
                    return wl
                },
                context: function(e) {
                    return e && Sl && (Sl.data.push(e), e._ctx = Sl), Sl
                },
                suppressOverwrites: function(e) {
                    return bl = e
                }
            }
        };
    Pc("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
        return Fu[e] = mu[e]
    })), Vh.add(iu.updateRoot), Ll = Fu.to({}, {
        duration: 0
    });
    var Bu = function(e, t) {
            for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
            return n
        },
        zu = function(e, t) {
            return {
                name: e,
                rawVars: 1,
                init: function(e, n, i) {
                    i._onInit = function(e) {
                        var i, r;
                        if (Yl(n) && (i = {}, Pc(n, (function(e) {
                                return i[e] = 1
                            })), n = i), t) {
                            for (r in i = {}, n) i[r] = t(n[r]);
                            n = i
                        }! function(e, t) {
                            var n, i, r, a = e._targets;
                            for (n in t)
                                for (i = a.length; i--;)(r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = Bu(r, n)), r && r.modifier && r.modifier(t[n], e, a[i], n))
                        }(e, n)
                    }
                }
            }
        },
        Hu = Fu.registerPlugin({
            name: "attr",
            init: function(e, t, n, i, r) {
                var a, s, o;
                for (a in this.tween = n, t) o = e.getAttribute(a) || "", (s = this.add(e, "setAttribute", (o || 0) + "", t[a], i, r, 0, 0, a)).op = a, s.b = o, this._props.push(a)
            },
            render: function(e, t) {
                for (var n = t._pt; n;) wl ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next
            }
        }, {
            name: "endArray",
            init: function(e, t) {
                for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
            }
        }, zu("roundProps", wh), zu("modifiers"), zu("snap", Sh)) || Fu;
    mu.version = iu.version = Hu.version = "3.12.7", Rl = 1, ec() && Gh(), Wh.Power0, Wh.Power1, Wh.Power2, Wh.Power3, Wh.Power4, Wh.Linear, Wh.Quad, Wh.Cubic, Wh.Quart, Wh.Quint, Wh.Strong, Wh.Elastic, Wh.Back, Wh.SteppedEase, Wh.Bounce, Wh.Sine, Wh.Expo, Wh.Circ;
    var Vu, Gu, Wu, qu, Xu, ju, Yu, Ku, Zu = {},
        $u = 180 / Math.PI,
        Ju = Math.PI / 180,
        Qu = Math.atan2,
        ed = /([A-Z])/g,
        td = /(left|right|width|margin|padding|x)/i,
        nd = /[\s,\(]\S/,
        id = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        rd = function(e, t) {
            return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        },
        ad = function(e, t) {
            return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        },
        sd = function(e, t) {
            return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
        },
        od = function(e, t) {
            var n = t.s + t.c * e;
            t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
        },
        ld = function(e, t) {
            return t.set(t.t, t.p, e ? t.e : t.b, t)
        },
        cd = function(e, t) {
            return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
        },
        hd = function(e, t, n) {
            return e.style[t] = n
        },
        ud = function(e, t, n) {
            return e.style.setProperty(t, n)
        },
        dd = function(e, t, n) {
            return e._gsap[t] = n
        },
        pd = function(e, t, n) {
            return e._gsap.scaleX = e._gsap.scaleY = n
        },
        md = function(e, t, n, i, r) {
            var a = e._gsap;
            a.scaleX = a.scaleY = n, a.renderTransform(r, a)
        },
        fd = function(e, t, n, i, r) {
            var a = e._gsap;
            a[t] = n, a.renderTransform(r, a)
        },
        gd = "transform",
        _d = gd + "Origin",
        vd = function e(t, n) {
            var i = this,
                r = this.target,
                a = r.style,
                s = r._gsap;
            if (t in Zu && a) {
                if (this.tfm = this.tfm || {}, "transform" === t) return id.transform.split(",").forEach((function(t) {
                    return e.call(i, t, n)
                }));
                if (~(t = id[t] || t).indexOf(",") ? t.split(",").forEach((function(e) {
                        return i.tfm[e] = Od(r, e)
                    })) : this.tfm[t] = s.x ? s[t] : Od(r, t), t === _d && (this.tfm.zOrigin = s.zOrigin), this.props.indexOf(gd) >= 0) return;
                s.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(_d, n, "")), t = gd
            }(a || n) && this.props.push(t, n, a[t])
        },
        yd = function(e) {
            e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
        },
        xd = function() {
            var e, t, n = this.props,
                i = this.target,
                r = i.style,
                a = i._gsap;
            for (e = 0; e < n.length; e += 3) n[e + 1] ? 2 === n[e + 1] ? i[n[e]](n[e + 2]) : i[n[e]] = n[e + 2] : n[e + 2] ? r[n[e]] = n[e + 2] : r.removeProperty("--" === n[e].substr(0, 2) ? n[e] : n[e].replace(ed, "-$1").toLowerCase());
            if (this.tfm) {
                for (t in this.tfm) a[t] = this.tfm[t];
                a.svg && (a.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (e = Yu()) && e.isStart || r[gd] || (yd(r), a.zOrigin && r[_d] && (r[_d] += " " + a.zOrigin + "px", a.zOrigin = 0, a.renderTransform()), a.uncache = 1)
            }
        },
        bd = function(e, t) {
            var n = {
                target: e,
                props: [],
                revert: xd,
                save: vd
            };
            return e._gsap || Hu.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach((function(e) {
                return n.save(e)
            })), n
        },
        wd = function(e, t) {
            var n = Gu.createElementNS ? Gu.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Gu.createElement(e);
            return n && n.style ? n : Gu.createElement(e)
        },
        Sd = function e(t, n, i) {
            var r = getComputedStyle(t);
            return r[n] || r.getPropertyValue(n.replace(ed, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, Td(n) || n, 1) || ""
        },
        Md = "O,Moz,ms,Ms,Webkit".split(","),
        Td = function(e, t, n) {
            var i = (t || Xu).style,
                r = 5;
            if (e in i && !n) return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(Md[r] + e in i););
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Md[r] : "") + e
        },
        Ed = function() {
            "undefined" != typeof window && window.document && (Vu = window, Gu = Vu.document, Wu = Gu.documentElement, Xu = wd("div") || {
                style: {}
            }, wd("div"), gd = Td(gd), _d = gd + "Origin", Xu.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ku = !!Td("perspective"), Yu = Hu.core.reverting, qu = 1)
        },
        Ad = function(e) {
            var t, n = e.ownerSVGElement,
                i = wd("svg", n && n.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                r = e.cloneNode(!0);
            r.style.display = "block", i.appendChild(r), Wu.appendChild(i);
            try {
                t = r.getBBox()
            } catch (e) {}
            return i.removeChild(r), Wu.removeChild(i), t
        },
        Rd = function(e, t) {
            for (var n = t.length; n--;)
                if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
        },
        Cd = function(e) {
            var t, n;
            try {
                t = e.getBBox()
            } catch (i) {
                t = Ad(e), n = 1
            }
            return t && (t.width || t.height) || n || (t = Ad(e)), !t || t.width || t.x || t.y ? t : {
                x: +Rd(e, ["x", "cx", "x1"]) || 0,
                y: +Rd(e, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        },
        Ld = function(e) {
            return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !Cd(e))
        },
        Pd = function(e, t) {
            if (t) {
                var n, i = e.style;
                t in Zu && t !== _d && (t = gd), i.removeProperty ? ("ms" !== (n = t.substr(0, 2)) && "webkit" !== t.substr(0, 6) || (t = "-" + t), i.removeProperty("--" === n ? t : t.replace(ed, "-$1").toLowerCase())) : i.removeAttribute(t)
            }
        },
        Dd = function(e, t, n, i, r, a) {
            var s = new Ru(e._pt, t, n, 0, 1, a ? cd : ld);
            return e._pt = s, s.b = i, s.e = r, e._props.push(n), s
        },
        Ud = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        Id = {
            grid: 1,
            flex: 1
        },
        Nd = function e(t, n, i, r) {
            var a, s, o, l, c = parseFloat(i) || 0,
                h = (i + "").trim().substr((c + "").length) || "px",
                u = Xu.style,
                d = td.test(n),
                p = "svg" === t.tagName.toLowerCase(),
                m = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                f = 100,
                g = "px" === r,
                _ = "%" === r;
            if (r === h || !c || Ud[r] || Ud[h]) return c;
            if ("px" !== h && !g && (c = e(t, n, i, "px")), l = t.getCTM && Ld(t), (_ || "%" === h) && (Zu[n] || ~n.indexOf("adius"))) return a = l ? t.getBBox()[d ? "width" : "height"] : t[m], Dc(_ ? c / a * f : c / 100 * a);
            if (u[d ? "width" : "height"] = f + (g ? h : r), s = "rem" !== r && ~n.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode, l && (s = (t.ownerSVGElement || {}).parentNode), s && s !== Gu && s.appendChild || (s = Gu.body), (o = s._gsap) && _ && o.width && d && o.time === Vh.time && !o.uncache) return Dc(c / o.width * f);
            if (!_ || "height" !== n && "width" !== n)(_ || "%" === h) && !Id[Sd(s, "display")] && (u.position = Sd(t, "position")), s === t && (u.position = "static"), s.appendChild(Xu), a = Xu[m], s.removeChild(Xu), u.position = "absolute";
            else {
                var v = t.style[n];
                t.style[n] = f + r, a = t[m], v ? t.style[n] = v : Pd(t, n)
            }
            return d && _ && ((o = Cc(s)).time = Vh.time, o.width = s[m]), Dc(g ? a * c / f : a && c ? f / a * c : 0)
        },
        Od = function(e, t, n, i) {
            var r;
            return qu || Ed(), t in id && "transform" !== t && ~(t = id[t]).indexOf(",") && (t = t.split(",")[0]), Zu[t] && "transform" !== t ? (r = jd(e, i), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : Yd(Sd(e, _d)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = zd[t] && zd[t](e, t, n) || Sd(e, t) || Lc(e, t) || ("opacity" === t ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? Nd(e, t, r, n) + n : r
        },
        kd = function(e, t, n, i) {
            if (!n || "none" === n) {
                var r = Td(t, e, 1),
                    a = r && Sd(e, r, 1);
                a && a !== n ? (t = r, n = a) : "borderColor" === t && (n = Sd(e, "borderTopColor"))
            }
            var s, o, l, c, h, u, d, p, m, f, g, _ = new Ru(this._pt, e.style, t, 0, 1, wu),
                v = 0,
                y = 0;
            if (_.b = n, _.e = i, n += "", "auto" == (i += "") && (u = e.style[t], e.style[t] = i, i = Sd(e, t) || i, u ? e.style[t] = u : Pd(e, t)), Hh(s = [n, i]), i = s[1], l = (n = s[0]).match(sc) || [], (i.match(sc) || []).length) {
                for (; o = sc.exec(i);) d = o[0], m = i.substring(v, o.index), h ? h = (h + 1) % 5 : "rgba(" !== m.substr(-5) && "hsla(" !== m.substr(-5) || (h = 1), d !== (u = l[y++] || "") && (c = parseFloat(u) || 0, g = u.substr((c + "").length), "=" === d.charAt(1) && (d = Ic(c, d) + g), p = parseFloat(d), f = d.substr((p + "").length), v = sc.lastIndex - f.length, f || (f = f || Fl.units[t] || g, v === i.length && (i += f, _.e += f)), g !== f && (c = Nd(e, t, u, f) || 0), _._pt = {
                    _next: _._pt,
                    p: m || 1 === y ? m : ",",
                    s: c,
                    c: p - c,
                    m: h && h < 4 || "zIndex" === t ? Math.round : 0
                });
                _.c = v < i.length ? i.substring(v, i.length) : ""
            } else _.r = "display" === t && "none" === i ? cd : ld;
            return lc.test(i) && (_.e = 0), this._pt = _, _
        },
        Fd = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        Bd = function(e, t) {
            if (t.tween && t.tween._time === t.tween._dur) {
                var n, i, r, a = t.t,
                    s = a.style,
                    o = t.u,
                    l = a._gsap;
                if ("all" === o || !0 === o) s.cssText = "", i = 1;
                else
                    for (r = (o = o.split(",")).length; --r > -1;) n = o[r], Zu[n] && (i = 1, n = "transformOrigin" === n ? _d : gd), Pd(a, n);
                i && (Pd(a, gd), l && (l.svg && a.removeAttribute("transform"), s.scale = s.rotate = s.translate = "none", jd(a, 1), l.uncache = 1, yd(s)))
            }
        },
        zd = {
            clearProps: function(e, t, n, i, r) {
                if ("isFromStart" !== r.data) {
                    var a = e._pt = new Ru(e._pt, t, n, 0, 0, Bd);
                    return a.u = i, a.pr = -10, a.tween = r, e._props.push(n), 1
                }
            }
        },
        Hd = [1, 0, 0, 1, 0, 0],
        Vd = {},
        Gd = function(e) {
            return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
        },
        Wd = function(e) {
            var t = Sd(e, gd);
            return Gd(t) ? Hd : t.substr(7).match(ac).map(Dc)
        },
        qd = function(e, t) {
            var n, i, r, a, s = e._gsap || Cc(e),
                o = e.style,
                l = Wd(e);
            return s.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Hd : l : (l !== Hd || e.offsetParent || e === Wu || s.svg || (r = o.display, o.display = "block", (n = e.parentNode) && (e.offsetParent || e.getBoundingClientRect().width) || (a = 1, i = e.nextElementSibling, Wu.appendChild(e)), l = Wd(e), r ? o.display = r : Pd(e, "display"), a && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : Wu.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        },
        Xd = function(e, t, n, i, r, a) {
            var s, o, l, c = e._gsap,
                h = r || qd(e, !0),
                u = c.xOrigin || 0,
                d = c.yOrigin || 0,
                p = c.xOffset || 0,
                m = c.yOffset || 0,
                f = h[0],
                g = h[1],
                _ = h[2],
                v = h[3],
                y = h[4],
                x = h[5],
                b = t.split(" "),
                w = parseFloat(b[0]) || 0,
                S = parseFloat(b[1]) || 0;
            n ? h !== Hd && (o = f * v - g * _) && (l = w * (-g / o) + S * (f / o) - (f * x - g * y) / o, w = w * (v / o) + S * (-_ / o) + (_ * x - v * y) / o, S = l) : (w = (s = Cd(e)).x + (~b[0].indexOf("%") ? w / 100 * s.width : w), S = s.y + (~(b[1] || b[0]).indexOf("%") ? S / 100 * s.height : S)), i || !1 !== i && c.smooth ? (y = w - u, x = S - d, c.xOffset = p + (y * f + x * _) - y, c.yOffset = m + (y * g + x * v) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = w, c.yOrigin = S, c.smooth = !!i, c.origin = t, c.originIsAbsolute = !!n, e.style[_d] = "0px 0px", a && (Dd(a, c, "xOrigin", u, w), Dd(a, c, "yOrigin", d, S), Dd(a, c, "xOffset", p, c.xOffset), Dd(a, c, "yOffset", m, c.yOffset)), e.setAttribute("data-svg-origin", w + " " + S)
        },
        jd = function(e, t) {
            var n = e._gsap || new tu(e);
            if ("x" in n && !t && !n.uncache) return n;
            var i, r, a, s, o, l, c, h, u, d, p, m, f, g, _, v, y, x, b, w, S, M, T, E, A, R, C, L, P, D, U, I, N = e.style,
                O = n.scaleX < 0,
                k = "px",
                F = "deg",
                B = getComputedStyle(e),
                z = Sd(e, _d) || "0";
            return i = r = a = l = c = h = u = d = p = 0, s = o = 1, n.svg = !(!e.getCTM || !Ld(e)), B.translate && ("none" === B.translate && "none" === B.scale && "none" === B.rotate || (N[gd] = ("none" !== B.translate ? "translate3d(" + (B.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== B.rotate ? "rotate(" + B.rotate + ") " : "") + ("none" !== B.scale ? "scale(" + B.scale.split(" ").join(",") + ") " : "") + ("none" !== B[gd] ? B[gd] : "")), N.scale = N.rotate = N.translate = "none"), g = qd(e, n.svg), n.svg && (n.uncache ? (A = e.getBBox(), z = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px", E = "") : E = !t && e.getAttribute("data-svg-origin"), Xd(e, E || z, !!E || n.originIsAbsolute, !1 !== n.smooth, g)), m = n.xOrigin || 0, f = n.yOrigin || 0, g !== Hd && (x = g[0], b = g[1], w = g[2], S = g[3], i = M = g[4], r = T = g[5], 6 === g.length ? (s = Math.sqrt(x * x + b * b), o = Math.sqrt(S * S + w * w), l = x || b ? Qu(b, x) * $u : 0, (u = w || S ? Qu(w, S) * $u + l : 0) && (o *= Math.abs(Math.cos(u * Ju))), n.svg && (i -= m - (m * x + f * w), r -= f - (m * b + f * S))) : (I = g[6], D = g[7], C = g[8], L = g[9], P = g[10], U = g[11], i = g[12], r = g[13], a = g[14], c = (_ = Qu(I, P)) * $u, _ && (E = M * (v = Math.cos(-_)) + C * (y = Math.sin(-_)), A = T * v + L * y, R = I * v + P * y, C = M * -y + C * v, L = T * -y + L * v, P = I * -y + P * v, U = D * -y + U * v, M = E, T = A, I = R), h = (_ = Qu(-w, P)) * $u, _ && (v = Math.cos(-_), U = S * (y = Math.sin(-_)) + U * v, x = E = x * v - C * y, b = A = b * v - L * y, w = R = w * v - P * y), l = (_ = Qu(b, x)) * $u, _ && (E = x * (v = Math.cos(_)) + b * (y = Math.sin(_)), A = M * v + T * y, b = b * v - x * y, T = T * v - M * y, x = E, M = A), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, h = 180 - h), s = Dc(Math.sqrt(x * x + b * b + w * w)), o = Dc(Math.sqrt(T * T + I * I)), _ = Qu(M, T), u = Math.abs(_) > 2e-4 ? _ * $u : 0, p = U ? 1 / (U < 0 ? -U : U) : 0), n.svg && (E = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !Gd(Sd(e, gd)), E && e.setAttribute("transform", E))), Math.abs(u) > 90 && Math.abs(u) < 270 && (O ? (s *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, u += u <= 0 ? 180 : -180)), t = t || n.uncache, n.x = i - ((n.xPercent = i && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + k, n.y = r - ((n.yPercent = r && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + k, n.z = a + k, n.scaleX = Dc(s), n.scaleY = Dc(o), n.rotation = Dc(l) + F, n.rotationX = Dc(c) + F, n.rotationY = Dc(h) + F, n.skewX = u + F, n.skewY = d + F, n.transformPerspective = p + k, (n.zOrigin = parseFloat(z.split(" ")[2]) || !t && n.zOrigin || 0) && (N[_d] = Yd(z)), n.xOffset = n.yOffset = 0, n.force3D = Fl.force3D, n.renderTransform = n.svg ? tp : Ku ? ep : Zd, n.uncache = 0, n
        },
        Yd = function(e) {
            return (e = e.split(" "))[0] + " " + e[1]
        },
        Kd = function(e, t, n) {
            var i = fh(t);
            return Dc(parseFloat(t) + parseFloat(Nd(e, "x", n + "px", i))) + i
        },
        Zd = function(e, t) {
            t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, ep(e, t)
        },
        $d = "0deg",
        Jd = "0px",
        Qd = ") ",
        ep = function(e, t) {
            var n = t || this,
                i = n.xPercent,
                r = n.yPercent,
                a = n.x,
                s = n.y,
                o = n.z,
                l = n.rotation,
                c = n.rotationY,
                h = n.rotationX,
                u = n.skewX,
                d = n.skewY,
                p = n.scaleX,
                m = n.scaleY,
                f = n.transformPerspective,
                g = n.force3D,
                _ = n.target,
                v = n.zOrigin,
                y = "",
                x = "auto" === g && e && 1 !== e || !0 === g;
            if (v && (h !== $d || c !== $d)) {
                var b, w = parseFloat(c) * Ju,
                    S = Math.sin(w),
                    M = Math.cos(w);
                w = parseFloat(h) * Ju, b = Math.cos(w), a = Kd(_, a, S * b * -v), s = Kd(_, s, -Math.sin(w) * -v), o = Kd(_, o, M * b * -v + v)
            }
            f !== Jd && (y += "perspective(" + f + Qd), (i || r) && (y += "translate(" + i + "%, " + r + "%) "), (x || a !== Jd || s !== Jd || o !== Jd) && (y += o !== Jd || x ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + Qd), l !== $d && (y += "rotate(" + l + Qd), c !== $d && (y += "rotateY(" + c + Qd), h !== $d && (y += "rotateX(" + h + Qd), u === $d && d === $d || (y += "skew(" + u + ", " + d + Qd), 1 === p && 1 === m || (y += "scale(" + p + ", " + m + Qd), _.style[gd] = y || "translate(0, 0)"
        },
        tp = function(e, t) {
            var n, i, r, a, s, o = t || this,
                l = o.xPercent,
                c = o.yPercent,
                h = o.x,
                u = o.y,
                d = o.rotation,
                p = o.skewX,
                m = o.skewY,
                f = o.scaleX,
                g = o.scaleY,
                _ = o.target,
                v = o.xOrigin,
                y = o.yOrigin,
                x = o.xOffset,
                b = o.yOffset,
                w = o.forceCSS,
                S = parseFloat(h),
                M = parseFloat(u);
            d = parseFloat(d), p = parseFloat(p), (m = parseFloat(m)) && (p += m = parseFloat(m), d += m), d || p ? (d *= Ju, p *= Ju, n = Math.cos(d) * f, i = Math.sin(d) * f, r = Math.sin(d - p) * -g, a = Math.cos(d - p) * g, p && (m *= Ju, s = Math.tan(p - m), r *= s = Math.sqrt(1 + s * s), a *= s, m && (s = Math.tan(m), n *= s = Math.sqrt(1 + s * s), i *= s)), n = Dc(n), i = Dc(i), r = Dc(r), a = Dc(a)) : (n = f, a = g, i = r = 0), (S && !~(h + "").indexOf("px") || M && !~(u + "").indexOf("px")) && (S = Nd(_, "x", h, "px"), M = Nd(_, "y", u, "px")), (v || y || x || b) && (S = Dc(S + v - (v * n + y * r) + x), M = Dc(M + y - (v * i + y * a) + b)), (l || c) && (s = _.getBBox(), S = Dc(S + l / 100 * s.width), M = Dc(M + c / 100 * s.height)), s = "matrix(" + n + "," + i + "," + r + "," + a + "," + S + "," + M + ")", _.setAttribute("transform", s), w && (_.style[gd] = s)
        },
        np = function(e, t, n, i, r) {
            var a, s, o = 360,
                l = Yl(r),
                c = parseFloat(r) * (l && ~r.indexOf("rad") ? $u : 1) - i,
                h = i + c + "deg";
            return l && ("short" === (a = r.split("_")[1]) && (c %= o) != c % 180 && (c += c < 0 ? o : -360), "cw" === a && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === a && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)), e._pt = s = new Ru(e._pt, t, n, i, c, ad), s.e = h, s.u = "deg", e._props.push(n), s
        },
        ip = function(e, t) {
            for (var n in t) e[n] = t[n];
            return e
        },
        rp = function(e, t, n) {
            var i, r, a, s, o, l, c, h = ip({}, n._gsap),
                u = n.style;
            for (r in h.svg ? (a = n.getAttribute("transform"), n.setAttribute("transform", ""), u[gd] = t, i = jd(n, 1), Pd(n, gd), n.setAttribute("transform", a)) : (a = getComputedStyle(n)[gd], u[gd] = t, i = jd(n, 1), u[gd] = a), Zu)(a = h[r]) !== (s = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = fh(a) !== (c = fh(s)) ? Nd(n, r, a, c) : parseFloat(a), l = parseFloat(s), e._pt = new Ru(e._pt, i, r, o, l - o, rd), e._pt.u = c || 0, e._props.push(r));
            ip(i, h)
        };
    Pc("padding,margin,Width,Radius", (function(e, t) {
        var n = "Top",
            i = "Right",
            r = "Bottom",
            a = "Left",
            s = (t < 3 ? [n, i, r, a] : [n + a, n + i, r + i, r + a]).map((function(n) {
                return t < 2 ? e + n : "border" + n + e
            }));
        zd[t > 1 ? "border" + e : e] = function(e, t, n, i, r) {
            var a, o;
            if (arguments.length < 4) return a = s.map((function(t) {
                return Od(e, t, n)
            })), 5 === (o = a.join(" ")).split(a[0]).length ? a[0] : o;
            a = (i + "").split(" "), o = {}, s.forEach((function(e, t) {
                return o[e] = a[t] = a[t] || a[(t - 1) / 2 | 0]
            })), e.init(t, o, r)
        }
    }));
    var ap, sp, op = {
        name: "css",
        register: Ed,
        targetTest: function(e) {
            return e.style && e.nodeType
        },
        init: function(e, t, n, i, r) {
            var a, s, o, l, c, h, u, d, p, m, f, g, _, v, y, x, b, w, S, M, T = this._props,
                E = e.style,
                A = n.vars.startAt;
            for (u in qu || Ed(), this.styles = this.styles || bd(e), x = this.styles.props, this.tween = n, t)
                if ("autoRound" !== u && (s = t[u], !Sc[u] || !lu(u, t, n, i, e, r)))
                    if (c = typeof s, h = zd[u], "function" === c && (c = typeof(s = s.call(n, i, e, r))), "string" === c && ~s.indexOf("random(") && (s = Eh(s)), h) h(this, e, u, s, n) && (y = 1);
                    else if ("--" === u.substr(0, 2)) a = (getComputedStyle(e).getPropertyValue(u) + "").trim(), s += "", Bh.lastIndex = 0, Bh.test(a) || (d = fh(a), p = fh(s)), p ? d !== p && (a = Nd(e, u, a, p) + p) : d && (s += d), this.add(E, "setProperty", a, s, i, r, 0, 0, u), T.push(u), x.push(u, 0, E[u]);
            else if ("undefined" !== c) {
                if (A && u in A ? (a = "function" == typeof A[u] ? A[u].call(n, i, e, r) : A[u], Yl(a) && ~a.indexOf("random(") && (a = Eh(a)), fh(a + "") || "auto" === a || (a += Fl.units[u] || fh(Od(e, u)) || ""), "=" === (a + "").charAt(1) && (a = Od(e, u))) : a = Od(e, u), l = parseFloat(a), (m = "string" === c && "=" === s.charAt(1) && s.substr(0, 2)) && (s = s.substr(2)), o = parseFloat(s), u in id && ("autoAlpha" === u && (1 === l && "hidden" === Od(e, "visibility") && o && (l = 0), x.push("visibility", 0, E.visibility), Dd(this, E, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== u && "transform" !== u && ~(u = id[u]).indexOf(",") && (u = u.split(",")[0])), f = u in Zu)
                    if (this.styles.save(u), g || ((_ = e._gsap).renderTransform && !t.parseTransform || jd(e, t.parseTransform), v = !1 !== t.smoothOrigin && _.smooth, (g = this._pt = new Ru(this._pt, E, gd, 0, 1, _.renderTransform, _, 0, -1)).dep = 1), "scale" === u) this._pt = new Ru(this._pt, _, "scaleY", _.scaleY, (m ? Ic(_.scaleY, m + o) : o) - _.scaleY || 0, rd), this._pt.u = 0, T.push("scaleY", u), u += "X";
                    else {
                        if ("transformOrigin" === u) {
                            x.push(_d, 0, E[_d]), w = void 0, S = void 0, M = void 0, S = (w = (b = s).split(" "))[0], M = w[1] || "50%", "top" !== S && "bottom" !== S && "left" !== M && "right" !== M || (b = S, S = M, M = b), w[0] = Fd[S] || S, w[1] = Fd[M] || M, s = w.join(" "), _.svg ? Xd(e, s, 0, v, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== _.zOrigin && Dd(this, _, "zOrigin", _.zOrigin, p), Dd(this, E, u, Yd(a), Yd(s)));
                            continue
                        }
                        if ("svgOrigin" === u) {
                            Xd(e, s, 1, v, 0, this);
                            continue
                        }
                        if (u in Vd) {
                            np(this, _, u, l, m ? Ic(l, m + s) : s);
                            continue
                        }
                        if ("smoothOrigin" === u) {
                            Dd(this, _, "smooth", _.smooth, s);
                            continue
                        }
                        if ("force3D" === u) {
                            _[u] = s;
                            continue
                        }
                        if ("transform" === u) {
                            rp(this, s, e);
                            continue
                        }
                    }
                else u in E || (u = Td(u) || u);
                if (f || (o || 0 === o) && (l || 0 === l) && !nd.test(s) && u in E) o || (o = 0), (d = (a + "").substr((l + "").length)) !== (p = fh(s) || (u in Fl.units ? Fl.units[u] : d)) && (l = Nd(e, u, a, p)), this._pt = new Ru(this._pt, f ? _ : E, u, l, (m ? Ic(l, m + o) : o) - l, f || "px" !== p && "zIndex" !== u || !1 === t.autoRound ? rd : od), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = a, this._pt.r = sd);
                else if (u in E) kd.call(this, e, u, a, m ? m + s : s);
                else if (u in e) this.add(e, u, a || e[u], m ? m + s : s, i, r);
                else if ("parseTransform" !== u) continue;
                f || (u in E ? x.push(u, 0, E[u]) : "function" == typeof e[u] ? x.push(u, 2, e[u]()) : x.push(u, 1, a || e[u])), T.push(u)
            }
            y && Au(this)
        },
        render: function(e, t) {
            if (t.tween._time || !Yu())
                for (var n = t._pt; n;) n.r(e, n.d), n = n._next;
            else t.styles.revert()
        },
        get: Od,
        aliases: id,
        getSetter: function(e, t, n) {
            var i = id[t];
            return i && i.indexOf(",") < 0 && (t = i), t in Zu && t !== _d && (e._gsap.x || Od(e, "x")) ? n && ju === n ? "scale" === t ? pd : dd : (ju = n || {}) && ("scale" === t ? md : fd) : e.style && !$l(e.style[t]) ? hd : ~t.indexOf("-") ? ud : yu(e, t)
        },
        core: {
            _removeProperty: Pd,
            _getMatrix: qd
        }
    };
    Hu.utils.checkPrefix = Td, Hu.core.getStyleSaver = bd, sp = Pc("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (ap = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
        Zu[e] = 1
    })), Pc(ap, (function(e) {
        Fl.units[e] = "deg", Vd[e] = 1
    })), id[sp[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + ap, Pc("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
        var t = e.split(":");
        id[t[1]] = sp[t[0]]
    })), Pc("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
        Fl.units[e] = "px"
    })), Hu.registerPlugin(op);
    var lp = Hu.registerPlugin(op) || Hu;

    function cp(e, t) {
        if (0 === t) return e;
        if (2 === t || 1 === t) {
            let n = e.getIndex();
            if (null === n) {
                const t = [],
                    i = e.getAttribute("position");
                if (void 0 === i) return e;
                for (let e = 0; e < i.count; e++) t.push(e);
                e.setIndex(t), n = e.getIndex()
            }
            const i = n.count - 2,
                r = [];
            if (2 === t)
                for (let e = 1; e <= i; e++) r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
            else
                for (let e = 0; e < i; e++) e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
            r.length;
            const a = e.clone();
            return a.setIndex(r), a.clearGroups(), a
        }
        return e
    }
    lp.core.Tween;
    class hp extends Vo {
        constructor(e) {
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                return new gp(e)
            })), this.register((function(e) {
                return new _p(e)
            })), this.register((function(e) {
                return new Ep(e)
            })), this.register((function(e) {
                return new Ap(e)
            })), this.register((function(e) {
                return new Rp(e)
            })), this.register((function(e) {
                return new yp(e)
            })), this.register((function(e) {
                return new xp(e)
            })), this.register((function(e) {
                return new bp(e)
            })), this.register((function(e) {
                return new wp(e)
            })), this.register((function(e) {
                return new fp(e)
            })), this.register((function(e) {
                return new Sp(e)
            })), this.register((function(e) {
                return new vp(e)
            })), this.register((function(e) {
                return new Tp(e)
            })), this.register((function(e) {
                return new Mp(e)
            })), this.register((function(e) {
                return new pp(e)
            })), this.register((function(e) {
                return new Cp(e)
            })), this.register((function(e) {
                return new Lp(e)
            }))
        }
        load(e, t, n, i) {
            const r = this;
            let a;
            if ("" !== this.resourcePath) a = this.resourcePath;
            else if ("" !== this.path) {
                const t = cl.extractUrlBase(e);
                a = cl.resolveURL(t, this.path)
            } else a = cl.extractUrlBase(e);
            this.manager.itemStart(e);
            const s = function(t) {
                    i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                },
                o = new qo(this.manager);
            o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
                try {
                    r.parse(n, a, (function(n) {
                        t(n), r.manager.itemEnd(e)
                    }), s)
                } catch (e) {
                    s(e)
                }
            }), n, s)
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this
        }
        register(e) {
            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
        }
        unregister(e) {
            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }
        parse(e, t, n, i) {
            let r;
            const a = {},
                s = {},
                o = new TextDecoder;
            if ("string" == typeof e) r = JSON.parse(e);
            else if (e instanceof ArrayBuffer)
                if (o.decode(new Uint8Array(e, 0, 4)) === Pp) {
                    try {
                        a[dp.KHR_BINARY_GLTF] = new Dp(e)
                    } catch (e) {
                        return void(i && i(e))
                    }
                    r = JSON.parse(a[dp.KHR_BINARY_GLTF].content)
                } else r = JSON.parse(o.decode(e));
            else r = e;
            if (void 0 === r.asset || r.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
            const l = new em(r, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for (let e = 0; e < this.pluginCallbacks.length; e++) {
                const t = this.pluginCallbacks[e](l);
                t.name, s[t.name] = t, a[t.name] = !0
            }
            if (r.extensionsUsed)
                for (let e = 0; e < r.extensionsUsed.length; ++e) {
                    const t = r.extensionsUsed[e],
                        n = r.extensionsRequired || [];
                    switch (t) {
                        case dp.KHR_MATERIALS_UNLIT:
                            a[t] = new mp;
                            break;
                        case dp.KHR_DRACO_MESH_COMPRESSION:
                            a[t] = new Up(r, this.dracoLoader);
                            break;
                        case dp.KHR_TEXTURE_TRANSFORM:
                            a[t] = new Ip;
                            break;
                        case dp.KHR_MESH_QUANTIZATION:
                            a[t] = new Np;
                            break;
                        default:
                            n.indexOf(t) >= 0 && s[t]
                    }
                }
            l.setExtensions(a), l.setPlugins(s), l.parse(n, i)
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise((function(i, r) {
                n.parse(e, t, i, r)
            }))
        }
    }

    function up() {
        let e = {};
        return {
            get: function(t) {
                return e[t]
            },
            add: function(t, n) {
                e[t] = n
            },
            remove: function(t) {
                delete e[t]
            },
            removeAll: function() {
                e = {}
            }
        }
    }
    const dp = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class pp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            }
        }
        _markDefs() {
            const e = this.parser,
                t = this.parser.json.nodes || [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
            }
        }
        _loadLight(e) {
            const t = this.parser,
                n = "light:" + e;
            let i = t.cache.get(n);
            if (i) return i;
            const r = t.json,
                a = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
            let s;
            const o = new In(16777215);
            void 0 !== a.color && o.setRGB(a.color[0], a.color[1], a.color[2], _e);
            const l = void 0 !== a.range ? a.range : 0;
            switch (a.type) {
                case "directional":
                    s = new ol(o), s.target.position.set(0, 0, -1), s.add(s.target);
                    break;
                case "point":
                    s = new al(o), s.distance = l;
                    break;
                case "spot":
                    s = new el(o), s.distance = l, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, s.angle = a.spot.outerConeAngle, s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, s.target.position.set(0, 0, -1), s.add(s.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
            }
            return s.position.set(0, 0, 0), s.decay = 2, Yp(s, a), void 0 !== a.intensity && (s.intensity = a.intensity), s.name = t.createUniqueName(a.name || "light_" + e), i = Promise.resolve(s), t.cache.add(n, i), i
        }
        getDependency(e, t) {
            if ("light" === e) return this._loadLight(t)
        }
        createNodeAttachment(e) {
            const t = this,
                n = this.parser,
                i = n.json.nodes[e],
                r = (i.extensions && i.extensions[this.name] || {}).light;
            return void 0 === r ? null : this._loadLight(r).then((function(e) {
                return n._getNodeRef(t.cache, r, e)
            }))
        }
    }
    class mp {
        constructor() {
            this.name = dp.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
            return Fn
        }
        extendParams(e, t, n) {
            const i = [];
            e.color = new In(1, 1, 1), e.opacity = 1;
            const r = t.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const t = r.baseColorFactor;
                    e.color.setRGB(t[0], t[1], t[2], _e), e.opacity = t[3]
                }
                void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, ge))
            }
            return Promise.all(i)
        }
    }
    class fp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_EMISSIVE_STRENGTH
        }
        extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const i = n.extensions[this.name].emissiveStrength;
            return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve()
        }
    }
    class gp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
                const e = a.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new ke(e, e)
            }
            return Promise.all(r)
        }
    }
    class _p {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_DISPERSION
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const i = n.extensions[this.name];
            return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0, Promise.resolve()
        }
    }
    class vp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_IRIDESCENCE
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor), void 0 !== a.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), void 0 !== a.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r)
        }
    }
    class yp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_SHEEN
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [];
            t.sheenColor = new In(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const a = i.extensions[this.name];
            if (void 0 !== a.sheenColorFactor) {
                const e = a.sheenColorFactor;
                t.sheenColor.setRGB(e[0], e[1], e[2], _e)
            }
            return void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, ge)), void 0 !== a.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r)
        }
    }
    class xp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r)
        }
    }
    class bp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_VOLUME
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
            const s = a.attenuationColor || [1, 1, 1];
            return t.attenuationColor = (new In).setRGB(s[0], s[1], s[2], _e), Promise.all(r)
        }
    }
    class wp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_IOR
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const i = n.extensions[this.name];
            return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
        }
    }
    class Sp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_SPECULAR
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
            const s = a.specularColorFactor || [1, 1, 1];
            return t.specularColor = (new In).setRGB(s[0], s[1], s[2], _e), void 0 !== a.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, ge)), Promise.all(r)
        }
    }
    class Mp {
        constructor(e) {
            this.parser = e, this.name = dp.EXT_MATERIALS_BUMP
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            return t.bumpScale = void 0 !== a.bumpFactor ? a.bumpFactor : 1, void 0 !== a.bumpTexture && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r)
        }
    }
    class Tp {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_MATERIALS_ANISOTROPY
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? bo : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength), void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation), void 0 !== a.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r)
        }
    }
    class Ep {
        constructor(e) {
            this.parser = e, this.name = dp.KHR_TEXTURE_BASISU
        }
        loadTexture(e) {
            const t = this.parser,
                n = t.json,
                i = n.textures[e];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const r = i.extensions[this.name],
                a = t.options.ktx2Loader;
            if (!a) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return t.loadTextureImage(e, r.source, a)
        }
    }
    class Ap {
        constructor(e) {
            this.parser = e, this.name = dp.EXT_TEXTURE_WEBP, this.isSupported = null
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                i = n.json,
                r = i.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const a = r.extensions[t],
                s = i.images[a.source];
            let o = n.textureLoader;
            if (s.uri) {
                const e = n.options.manager.getHandler(s.uri);
                null !== e && (o = e)
            }
            return this.detectSupport().then((function(r) {
                if (r) return n.loadTextureImage(e, a.source, o);
                if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(e)
            }))
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise((function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                    e(1 === t.height)
                }
            }))), this.isSupported
        }
    }
    class Rp {
        constructor(e) {
            this.parser = e, this.name = dp.EXT_TEXTURE_AVIF, this.isSupported = null
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                i = n.json,
                r = i.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const a = r.extensions[t],
                s = i.images[a.source];
            let o = n.textureLoader;
            if (s.uri) {
                const e = n.options.manager.getHandler(s.uri);
                null !== e && (o = e)
            }
            return this.detectSupport().then((function(r) {
                if (r) return n.loadTextureImage(e, a.source, o);
                if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                return n.loadTexture(e)
            }))
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise((function(e) {
                const t = new Image;
                t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                    e(1 === t.height)
                }
            }))), this.isSupported
        }
    }
    class Cp {
        constructor(e) {
            this.name = dp.EXT_MESHOPT_COMPRESSION, this.parser = e
        }
        loadBufferView(e) {
            const t = this.parser.json,
                n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const e = n.extensions[this.name],
                    i = this.parser.getDependency("buffer", e.buffer),
                    r = this.parser.options.meshoptDecoder;
                if (!r || !r.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return i.then((function(t) {
                    const n = e.byteOffset || 0,
                        i = e.byteLength || 0,
                        a = e.count,
                        s = e.byteStride,
                        o = new Uint8Array(t, n, i);
                    return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(a, s, o, e.mode, e.filter).then((function(e) {
                        return e.buffer
                    })) : r.ready.then((function() {
                        const t = new ArrayBuffer(a * s);
                        return r.decodeGltfBuffer(new Uint8Array(t), a, s, o, e.mode, e.filter), t
                    }))
                }))
            }
            return null
        }
    }
    class Lp {
        constructor(e) {
            this.name = dp.EXT_MESH_GPU_INSTANCING, this.parser = e
        }
        createNodeMesh(e) {
            const t = this.parser.json,
                n = t.nodes[e];
            if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
            const i = t.meshes[n.mesh];
            for (const e of i.primitives)
                if (e.mode !== Bp.TRIANGLES && e.mode !== Bp.TRIANGLE_STRIP && e.mode !== Bp.TRIANGLE_FAN && void 0 !== e.mode) return null;
            const r = n.extensions[this.name].attributes,
                a = [],
                s = {};
            for (const e in r) a.push(this.parser.getDependency("accessor", r[e]).then((t => (s[e] = t, s[e]))));
            return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((e => {
                const t = e.pop(),
                    n = t.isGroup ? t.children : [t],
                    i = e[0].count,
                    r = [];
                for (const e of n) {
                    const t = new Ht,
                        n = new ut,
                        a = new ht,
                        o = new ut(1, 1, 1),
                        l = new Zs(e.geometry, e.material, i);
                    for (let e = 0; e < i; e++) s.TRANSLATION && n.fromBufferAttribute(s.TRANSLATION, e), s.ROTATION && a.fromBufferAttribute(s.ROTATION, e), s.SCALE && o.fromBufferAttribute(s.SCALE, e), l.setMatrixAt(e, t.compose(n, a, o));
                    for (const t in s)
                        if ("_COLOR_0" === t) {
                            const e = s[t];
                            l.instanceColor = new Vs(e.array, e.itemSize, e.normalized)
                        } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, s[t]);
                    fn.prototype.copy.call(l, e), this.parser.assignFinalMaterial(l), r.push(l)
                }
                return t.isGroup ? (t.clear(), t.add(...r), t) : r[0]
            })))
        }
    }
    const Pp = "glTF";
    class Dp {
        constructor(e) {
            this.name = dp.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, 12),
                n = new TextDecoder;
            if (this.header = {
                    magic: n.decode(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                }, this.header.magic !== Pp) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const i = this.header.length - 12,
                r = new DataView(e, 12);
            let a = 0;
            for (; a < i;) {
                const t = r.getUint32(a, !0);
                a += 4;
                const i = r.getUint32(a, !0);
                if (a += 4, 1313821514 === i) {
                    const i = new Uint8Array(e, 12 + a, t);
                    this.content = n.decode(i)
                } else if (5130562 === i) {
                    const n = 12 + a;
                    this.body = e.slice(n, n + t)
                }
                a += t
            }
            if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }
    class Up {
        constructor(e, t) {
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = dp.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
        }
        decodePrimitive(e, t) {
            const n = this.json,
                i = this.dracoLoader,
                r = e.extensions[this.name].bufferView,
                a = e.extensions[this.name].attributes,
                s = {},
                o = {},
                l = {};
            for (const e in a) {
                const t = Wp[e] || e.toLowerCase();
                s[t] = a[e]
            }
            for (const t in e.attributes) {
                const i = Wp[t] || t.toLowerCase();
                if (void 0 !== a[t]) {
                    const r = n.accessors[e.attributes[t]],
                        a = zp[r.componentType];
                    l[i] = a.name, o[i] = !0 === r.normalized
                }
            }
            return t.getDependency("bufferView", r).then((function(e) {
                return new Promise((function(t, n) {
                    i.decodeDracoFile(e, (function(e) {
                        for (const t in e.attributes) {
                            const n = e.attributes[t],
                                i = o[t];
                            void 0 !== i && (n.normalized = i)
                        }
                        t(e)
                    }), s, l, _e, n)
                }))
            }))
        }
    }
    class Ip {
        constructor() {
            this.name = dp.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(e, t) {
            return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e
        }
    }
    class Np {
        constructor() {
            this.name = dp.KHR_MESH_QUANTIZATION
        }
    }
    class Op extends Eo {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                r = e * i * 3 + i;
            for (let e = 0; e !== i; e++) t[e] = n[r + e];
            return t
        }
        interpolate_(e, t, n, i) {
            const r = this.resultBuffer,
                a = this.sampleValues,
                s = this.valueSize,
                o = 2 * s,
                l = 3 * s,
                c = i - t,
                h = (n - t) / c,
                u = h * h,
                d = u * h,
                p = e * l,
                m = p - l,
                f = -2 * d + 3 * u,
                g = d - u,
                _ = 1 - f,
                v = g - u + h;
            for (let e = 0; e !== s; e++) {
                const t = a[m + e + s],
                    n = a[m + e + o] * c,
                    i = a[p + e + s],
                    l = a[p + e] * c;
                r[e] = _ * t + v * n + f * i + g * l
            }
            return r
        }
    }
    const kp = new ht;
    class Fp extends Op {
        interpolate_(e, t, n, i) {
            const r = super.interpolate_(e, t, n, i);
            return kp.fromArray(r).normalize().toArray(r), r
        }
    }
    const Bp = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        },
        zp = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        Hp = {
            9728: u,
            9729: p,
            9984: 1004,
            9985: m,
            9986: d,
            9987: f
        },
        Vp = {
            33071: c,
            33648: h,
            10497: l
        },
        Gp = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        Wp = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        },
        qp = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        },
        Xp = {
            CUBICSPLINE: void 0,
            LINEAR: pe,
            STEP: de
        };

    function jp(e, t, n) {
        for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
    }

    function Yp(e, t) {
        void 0 !== t.extras && "object" == typeof t.extras && Object.assign(e.userData, t.extras)
    }

    function Kp(e, t) {
        if (e.updateMorphTargets(), void 0 !== t.weights)
            for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
            const n = t.extras.targetNames;
            if (e.morphTargetInfluences.length === n.length) {
                e.morphTargetDictionary = {};
                for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
            }
        }
    }

    function Zp(e) {
        let t;
        const n = e.extensions && e.extensions[dp.KHR_DRACO_MESH_COMPRESSION];
        if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + $p(n.attributes) : e.indices + ":" + $p(e.attributes) + ":" + e.mode, void 0 !== e.targets)
            for (let n = 0, i = e.targets.length; n < i; n++) t += ":" + $p(e.targets[n]);
        return t
    }

    function $p(e) {
        let t = "";
        const n = Object.keys(e).sort();
        for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
        return t
    }

    function Jp(e) {
        switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }
    const Qp = new Ht;
    class em {
        constructor(e = {}, t = {}) {
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new up, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            let n = !1,
                i = -1,
                r = !1,
                a = -1;
            if ("undefined" != typeof navigator) {
                const e = navigator.userAgent;
                n = !0 === /^((?!chrome|android).)*safari/i.test(e);
                const t = e.match(/Version\/(\d+)/);
                i = n && t ? parseInt(t[1], 10) : -1, r = e.indexOf("Firefox") > -1, a = r ? e.match(/Firefox\/([0-9]+)\./)[1] : -1
            }
            "undefined" == typeof createImageBitmap || n && i < 17 || r && a < 98 ? this.textureLoader = new jo(this.options.manager) : this.textureLoader = new hl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new qo(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(e) {
            this.extensions = e
        }
        setPlugins(e) {
            this.plugins = e
        }
        parse(e, t) {
            const n = this,
                i = this.json,
                r = this.extensions;
            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function(e) {
                return e._markDefs && e._markDefs()
            })), Promise.all(this._invokeAll((function(e) {
                return e.beforeRoot && e.beforeRoot()
            }))).then((function() {
                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
            })).then((function(t) {
                const a = {
                    scene: t[0][i.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                return jp(r, a, i), Yp(a, i), Promise.all(n._invokeAll((function(e) {
                    return e.afterRoot && e.afterRoot(a)
                }))).then((function() {
                    for (const e of a.scenes) e.updateMatrixWorld();
                    e(a)
                }))
            })).catch(t)
        }
        _markDefs() {
            const e = this.json.nodes || [],
                t = this.json.skins || [],
                n = this.json.meshes || [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n].joints;
                for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0
            }
            for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
            }
        }
        _addNodeRef(e, t) {
            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const i = n.clone(),
                r = (e, t) => {
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [n, i] of e.children.entries()) r(i, t.children[n])
                };
            return r(n, i), i.name += "_instance_" + e.uses[t]++, i
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let n = 0; n < t.length; n++) {
                const i = e(t[n]);
                if (i) return i
            }
            return null
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const r = e(t[i]);
                r && n.push(r)
            }
            return n
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let i = this.cache.get(n);
            if (!i) {
                switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this._invokeOne((function(e) {
                            return e.loadNode && e.loadNode(t)
                        }));
                        break;
                    case "mesh":
                        i = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }));
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }));
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }));
                        break;
                    case "texture":
                        i = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }));
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this._invokeOne((function(e) {
                            return e.loadAnimation && e.loadAnimation(t)
                        }));
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne((function(n) {
                                return n != this && n.getDependency && n.getDependency(e, t)
                            })), !i) throw new Error("Unknown type: " + e)
                }
                this.cache.add(n, i)
            }
            return i
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this,
                    i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                t = Promise.all(i.map((function(t, i) {
                    return n.getDependency(e, i)
                }))), this.cache.add(e, t)
            }
            return t
        }
        loadBuffer(e) {
            const t = this.json.buffers[e],
                n = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[dp.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise((function(e, r) {
                n.load(cl.resolveURL(t.uri, i.path), e, void 0, (function() {
                    r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                }))
            }))
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then((function(e) {
                const n = t.byteLength || 0,
                    i = t.byteOffset || 0;
                return e.slice(i, i + n)
            }))
        }
        loadAccessor(e) {
            const t = this,
                n = this.json,
                i = this.json.accessors[e];
            if (void 0 === i.bufferView && void 0 === i.sparse) {
                const e = Gp[i.type],
                    t = zp[i.componentType],
                    n = !0 === i.normalized,
                    r = new t(i.count * e);
                return Promise.resolve(new Hn(r, e, n))
            }
            const r = [];
            return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(e) {
                const r = e[0],
                    a = Gp[i.type],
                    s = zp[i.componentType],
                    o = s.BYTES_PER_ELEMENT,
                    l = o * a,
                    c = i.byteOffset || 0,
                    h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                    u = !0 === i.normalized;
                let d, p;
                if (h && h !== l) {
                    const e = Math.floor(c / h),
                        n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                    let l = t.cache.get(n);
                    l || (d = new s(r, e * h, i.count * h / o), l = new Ms(d, h / o), t.cache.add(n, l)), p = new Es(l, a, c % h / o, u)
                } else d = null === r ? new s(i.count * a) : new s(r, c, i.count * a), p = new Hn(d, a, u);
                if (void 0 !== i.sparse) {
                    const t = Gp.SCALAR,
                        n = zp[i.sparse.indices.componentType],
                        o = i.sparse.indices.byteOffset || 0,
                        l = i.sparse.values.byteOffset || 0,
                        c = new n(e[1], o, i.sparse.count * t),
                        h = new s(e[2], l, i.sparse.count * a);
                    null !== r && (p = new Hn(p.array.slice(), p.itemSize, p.normalized)), p.normalized = !1;
                    for (let e = 0, t = c.length; e < t; e++) {
                        const t = c[e];
                        if (p.setX(t, h[e * a]), a >= 2 && p.setY(t, h[e * a + 1]), a >= 3 && p.setZ(t, h[e * a + 2]), a >= 4 && p.setW(t, h[e * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                    p.normalized = u
                }
                return p
            }))
        }
        loadTexture(e) {
            const t = this.json,
                n = this.options,
                i = t.textures[e].source,
                r = t.images[i];
            let a = this.textureLoader;
            if (r.uri) {
                const e = n.manager.getHandler(r.uri);
                null !== e && (a = e)
            }
            return this.loadTextureImage(e, i, a)
        }
        loadTextureImage(e, t, n) {
            const i = this,
                r = this.json,
                a = r.textures[e],
                s = r.images[t],
                o = (s.uri || s.bufferView) + ":" + a.sampler;
            if (this.textureCache[o]) return this.textureCache[o];
            const c = this.loadImageSource(t, n).then((function(t) {
                t.flipY = !1, t.name = a.name || s.name || "", "" === t.name && "string" == typeof s.uri && !1 === s.uri.startsWith("data:image/") && (t.name = s.uri);
                const n = (r.samplers || {})[a.sampler] || {};
                return t.magFilter = Hp[n.magFilter] || p, t.minFilter = Hp[n.minFilter] || f, t.wrapS = Vp[n.wrapS] || l, t.wrapT = Vp[n.wrapT] || l, t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== u && t.minFilter !== p, i.associations.set(t, {
                    textures: e
                }), t
            })).catch((function() {
                return null
            }));
            return this.textureCache[o] = c, c
        }
        loadImageSource(e, t) {
            const n = this.json,
                i = this.options;
            if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
            const r = n.images[e],
                a = self.URL || self.webkitURL;
            let s = r.uri || "",
                o = !1;
            if (void 0 !== r.bufferView) s = this.getDependency("bufferView", r.bufferView).then((function(e) {
                o = !0;
                const t = new Blob([e], {
                    type: r.mimeType
                });
                return s = a.createObjectURL(t), s
            }));
            else if (void 0 === r.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const l = Promise.resolve(s).then((function(e) {
                return new Promise((function(n, r) {
                    let a = n;
                    !0 === t.isImageBitmapLoader && (a = function(e) {
                        const t = new at(e);
                        t.needsUpdate = !0, n(t)
                    }), t.load(cl.resolveURL(e, i.path), a, void 0, r)
                }))
            })).then((function(e) {
                var t;
                return !0 === o && a.revokeObjectURL(s), Yp(e, r), e.userData.mimeType = r.mimeType || ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"), e
            })).catch((function(e) {
                throw e
            }));
            return this.sourceCache[e] = l, l
        }
        assignTexture(e, t, n, i) {
            const r = this;
            return this.getDependency("texture", n.index).then((function(a) {
                if (!a) return null;
                if (void 0 !== n.texCoord && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord), r.extensions[dp.KHR_TEXTURE_TRANSFORM]) {
                    const e = void 0 !== n.extensions ? n.extensions[dp.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (e) {
                        const t = r.associations.get(a);
                        a = r.extensions[dp.KHR_TEXTURE_TRANSFORM].extendTexture(a, e), r.associations.set(a, t)
                    }
                }
                return void 0 !== i && (a.colorSpace = i), e[t] = a, a
            }))
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const i = void 0 === t.attributes.tangent,
                r = void 0 !== t.attributes.color,
                a = void 0 === t.attributes.normal;
            if (e.isPoints) {
                const e = "PointsMaterial:" + n.uuid;
                let t = this.cache.get(e);
                t || (t = new uo, kn.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
            } else if (e.isLine) {
                const e = "LineBasicMaterial:" + n.uuid;
                let t = this.cache.get(e);
                t || (t = new $s, kn.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t
            }
            if (i || r || a) {
                let e = "ClonedMaterial:" + n.uuid + ":";
                i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), a && (e += "flat-shading:");
                let t = this.cache.get(e);
                t || (t = n.clone(), r && (t.vertexColors = !0), a && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
            }
            e.material = n
        }
        getMaterialType() {
            return xo
        }
        loadMaterial(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                r = n.materials[e];
            let a;
            const s = {},
                o = [];
            if ((r.extensions || {})[dp.KHR_MATERIALS_UNLIT]) {
                const e = i[dp.KHR_MATERIALS_UNLIT];
                a = e.getMaterialType(), o.push(e.extendParams(s, r, t))
            } else {
                const n = r.pbrMetallicRoughness || {};
                if (s.color = new In(1, 1, 1), s.opacity = 1, Array.isArray(n.baseColorFactor)) {
                    const e = n.baseColorFactor;
                    s.color.setRGB(e[0], e[1], e[2], _e), s.opacity = e[3]
                }
                void 0 !== n.baseColorTexture && o.push(t.assignTexture(s, "map", n.baseColorTexture, ge)), s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, s.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (o.push(t.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)), o.push(t.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture))), a = this._invokeOne((function(t) {
                    return t.getMaterialType && t.getMaterialType(e)
                })), o.push(Promise.all(this._invokeAll((function(t) {
                    return t.extendMaterialParams && t.extendMaterialParams(e, s)
                }))))
            }!0 === r.doubleSided && (s.side = 2);
            const l = r.alphaMode || "OPAQUE";
            if ("BLEND" === l ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, "MASK" === l && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && a !== Fn && (o.push(t.assignTexture(s, "normalMap", r.normalTexture)), s.normalScale = new ke(1, 1), void 0 !== r.normalTexture.scale)) {
                const e = r.normalTexture.scale;
                s.normalScale.set(e, e)
            }
            if (void 0 !== r.occlusionTexture && a !== Fn && (o.push(t.assignTexture(s, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && a !== Fn) {
                const e = r.emissiveFactor;
                s.emissive = (new In).setRGB(e[0], e[1], e[2], _e)
            }
            return void 0 !== r.emissiveTexture && a !== Fn && o.push(t.assignTexture(s, "emissiveMap", r.emissiveTexture, ge)), Promise.all(o).then((function() {
                const n = new a(s);
                return r.name && (n.name = r.name), Yp(n, r), t.associations.set(n, {
                    materials: e
                }), r.extensions && jp(i, n, r), n
            }))
        }
        createUniqueName(e) {
            const t = _l.sanitizeNodeName(e || "");
            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
        }
        loadGeometries(e) {
            const t = this,
                n = this.extensions,
                i = this.primitiveCache;

            function r(e) {
                return n[dp.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                    return tm(n, e, t)
                }))
            }
            const a = [];
            for (let n = 0, s = e.length; n < s; n++) {
                const s = e[n],
                    o = Zp(s),
                    l = i[o];
                if (l) a.push(l.promise);
                else {
                    let e;
                    e = s.extensions && s.extensions[dp.KHR_DRACO_MESH_COMPRESSION] ? r(s) : tm(new Jn, s, t), i[o] = {
                        primitive: s,
                        promise: e
                    }, a.push(e)
                }
            }
            return Promise.all(a)
        }
        loadMesh(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                r = n.meshes[e],
                a = r.primitives,
                s = [];
            for (let e = 0, t = a.length; e < t; e++) {
                const t = void 0 === a[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new xo({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0
                })), o.DefaultMaterial) : this.getDependency("material", a[e].material);
                s.push(t)
            }
            var o;
            return s.push(t.loadGeometries(a)), Promise.all(s).then((function(n) {
                const s = n.slice(0, n.length - 1),
                    o = n[n.length - 1],
                    l = [];
                for (let n = 0, c = o.length; n < c; n++) {
                    const c = o[n],
                        h = a[n];
                    let u;
                    const d = s[n];
                    if (h.mode === Bp.TRIANGLES || h.mode === Bp.TRIANGLE_STRIP || h.mode === Bp.TRIANGLE_FAN || void 0 === h.mode) u = !0 === r.isSkinnedMesh ? new Os(c, d) : new hi(c, d), !0 === u.isSkinnedMesh && u.normalizeSkinWeights(), h.mode === Bp.TRIANGLE_STRIP ? u.geometry = cp(u.geometry, 1) : h.mode === Bp.TRIANGLE_FAN && (u.geometry = cp(u.geometry, 2));
                    else if (h.mode === Bp.LINES) u = new co(c, d);
                    else if (h.mode === Bp.LINE_STRIP) u = new ao(c, d);
                    else if (h.mode === Bp.LINE_LOOP) u = new ho(c, d);
                    else {
                        if (h.mode !== Bp.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                        u = new _o(c, d)
                    }
                    Object.keys(u.geometry.morphAttributes).length > 0 && Kp(u, r), u.name = t.createUniqueName(r.name || "mesh_" + e), Yp(u, r), h.extensions && jp(i, u, h), t.assignFinalMaterial(u), l.push(u)
                }
                for (let n = 0, i = l.length; n < i; n++) t.associations.set(l[n], {
                    meshes: e,
                    primitives: n
                });
                if (1 === l.length) return r.extensions && jp(i, l[0], r), l[0];
                const c = new ps;
                r.extensions && jp(i, c, r), t.associations.set(c, {
                    meshes: e
                });
                for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                return c
            }))
        }
        loadCamera(e) {
            let t;
            const n = this.json.cameras[e],
                i = n[n.type];
            if (i) return "perspective" === n.type ? t = new wi(Oe.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new Ki(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Yp(t, n), Promise.resolve(t)
        }
        loadSkin(e) {
            const t = this.json.skins[e],
                n = [];
            for (let e = 0, i = t.joints.length; e < i; e++) n.push(this._loadNodeShallow(t.joints[e]));
            return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function(e) {
                const t = e.pop(),
                    n = e,
                    i = [],
                    r = [];
                for (let e = 0, a = n.length; e < a; e++) {
                    const a = n[e];
                    if (a) {
                        i.push(a);
                        const n = new Ht;
                        null !== t && n.fromArray(t.array, 16 * e), r.push(n)
                    }
                }
                return new Hs(i, r)
            }))
        }
        loadAnimation(e) {
            const t = this.json,
                n = this,
                i = t.animations[e],
                r = i.name ? i.name : "animation_" + e,
                a = [],
                s = [],
                o = [],
                l = [],
                c = [];
            for (let e = 0, t = i.channels.length; e < t; e++) {
                const t = i.channels[e],
                    n = i.samplers[t.sampler],
                    r = t.target,
                    h = r.node,
                    u = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
                    d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                void 0 !== r.node && (a.push(this.getDependency("node", h)), s.push(this.getDependency("accessor", u)), o.push(this.getDependency("accessor", d)), l.push(n), c.push(r))
            }
            return Promise.all([Promise.all(a), Promise.all(s), Promise.all(o), Promise.all(l), Promise.all(c)]).then((function(e) {
                const t = e[0],
                    i = e[1],
                    a = e[2],
                    s = e[3],
                    o = e[4],
                    l = [];
                for (let e = 0, r = t.length; e < r; e++) {
                    const r = t[e],
                        c = i[e],
                        h = a[e],
                        u = s[e],
                        d = o[e];
                    if (void 0 === r) continue;
                    r.updateMatrix && r.updateMatrix();
                    const p = n._createAnimationTracks(r, c, h, u, d);
                    if (p)
                        for (let e = 0; e < p.length; e++) l.push(p[e])
                }
                return new Fo(r, void 0, l)
            }))
        }
        createNodeMesh(e) {
            const t = this.json,
                n = this,
                i = t.nodes[e];
            return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                const t = n._getNodeRef(n.meshCache, i.mesh, e);
                return void 0 !== i.weights && t.traverse((function(e) {
                    if (e.isMesh)
                        for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
                })), t
            }))
        }
        loadNode(e) {
            const t = this,
                n = this.json.nodes[e],
                i = t._loadNodeShallow(e),
                r = [],
                a = n.children || [];
            for (let e = 0, n = a.length; e < n; e++) r.push(t.getDependency("node", a[e]));
            const s = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
            return Promise.all([i, Promise.all(r), s]).then((function(e) {
                const t = e[0],
                    n = e[1],
                    i = e[2];
                null !== i && t.traverse((function(e) {
                    e.isSkinnedMesh && e.bind(i, Qp)
                }));
                for (let e = 0, i = n.length; e < i; e++) t.add(n[e]);
                return t
            }))
        }
        _loadNodeShallow(e) {
            const t = this.json,
                n = this.extensions,
                i = this;
            if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
            const r = t.nodes[e],
                a = r.name ? i.createUniqueName(r.name) : "",
                s = [],
                o = i._invokeOne((function(t) {
                    return t.createNodeMesh && t.createNodeMesh(e)
                }));
            return o && s.push(o), void 0 !== r.camera && s.push(i.getDependency("camera", r.camera).then((function(e) {
                return i._getNodeRef(i.cameraCache, r.camera, e)
            }))), i._invokeAll((function(t) {
                return t.createNodeAttachment && t.createNodeAttachment(e)
            })).forEach((function(e) {
                s.push(e)
            })), this.nodeCache[e] = Promise.all(s).then((function(t) {
                let s;
                if (s = !0 === r.isBone ? new ks : t.length > 1 ? new ps : 1 === t.length ? t[0] : new fn, s !== t[0])
                    for (let e = 0, n = t.length; e < n; e++) s.add(t[e]);
                if (r.name && (s.userData.name = r.name, s.name = a), Yp(s, r), r.extensions && jp(n, s, r), void 0 !== r.matrix) {
                    const e = new Ht;
                    e.fromArray(r.matrix), s.applyMatrix4(e)
                } else void 0 !== r.translation && s.position.fromArray(r.translation), void 0 !== r.rotation && s.quaternion.fromArray(r.rotation), void 0 !== r.scale && s.scale.fromArray(r.scale);
                return i.associations.has(s) || i.associations.set(s, {}), i.associations.get(s).nodes = e, s
            })), this.nodeCache[e]
        }
        loadScene(e) {
            const t = this.extensions,
                n = this.json.scenes[e],
                i = this,
                r = new ps;
            n.name && (r.name = i.createUniqueName(n.name)), Yp(r, n), n.extensions && jp(t, r, n);
            const a = n.nodes || [],
                s = [];
            for (let e = 0, t = a.length; e < t; e++) s.push(i.getDependency("node", a[e]));
            return Promise.all(s).then((function(e) {
                for (let t = 0, n = e.length; t < n; t++) r.add(e[t]);
                return i.associations = (e => {
                    const t = new Map;
                    for (const [e, n] of i.associations)(e instanceof kn || e instanceof at) && t.set(e, n);
                    return e.traverse((e => {
                        const n = i.associations.get(e);
                        null != n && t.set(e, n)
                    })), t
                })(r), r
            }))
        }
        _createAnimationTracks(e, t, n, i, r) {
            const a = [],
                s = e.name ? e.name : e.uuid,
                o = [];
            let l;
            switch (qp[r.path] === qp.weights ? e.traverse((function(e) {
                    e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid)
                })) : o.push(s), qp[r.path]) {
                case qp.weights:
                    l = Uo;
                    break;
                case qp.rotation:
                    l = No;
                    break;
                case qp.position:
                case qp.scale:
                    l = ko;
                    break;
                default:
                    l = 1 === n.itemSize ? Uo : ko
            }
            const c = void 0 !== i.interpolation ? Xp[i.interpolation] : pe,
                h = this._getArrayFromAccessor(n);
            for (let e = 0, n = o.length; e < n; e++) {
                const n = new l(o[e] + "." + qp[r.path], t.array, h, c);
                "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n), a.push(n)
            }
            return a
        }
        _getArrayFromAccessor(e) {
            let t = e.array;
            if (e.normalized) {
                const e = Jp(t.constructor),
                    n = new Float32Array(t.length);
                for (let i = 0, r = t.length; i < r; i++) n[i] = t[i] * e;
                t = n
            }
            return t
        }
        _createCubicSplineTrackInterpolant(e) {
            e.createInterpolant = function(e) {
                return new(this instanceof No ? Fp : Op)(this.times, this.values, this.getValueSize() / 3, e)
            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
        }
    }

    function tm(e, t, n) {
        const i = t.attributes,
            r = [];

        function a(t, i) {
            return n.getDependency("accessor", t).then((function(t) {
                e.setAttribute(i, t)
            }))
        }
        for (const t in i) {
            const n = Wp[t] || t.toLowerCase();
            n in e.attributes || r.push(a(i[t], n))
        }
        if (void 0 !== t.indices && !e.index) {
            const i = n.getDependency("accessor", t.indices).then((function(t) {
                e.setIndex(t)
            }));
            r.push(i)
        }
        return qe.workingColorSpace, Yp(e, t),
            function(e, t, n) {
                const i = t.attributes,
                    r = new mt;
                if (void 0 === i.POSITION) return;
                {
                    const e = n.json.accessors[i.POSITION],
                        t = e.min,
                        a = e.max;
                    if (void 0 === t || void 0 === a) return;
                    if (r.set(new ut(t[0], t[1], t[2]), new ut(a[0], a[1], a[2])), e.normalized) {
                        const t = Jp(zp[e.componentType]);
                        r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                    }
                }
                const a = t.targets;
                if (void 0 !== a) {
                    const e = new ut,
                        t = new ut;
                    for (let i = 0, r = a.length; i < r; i++) {
                        const r = a[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION],
                                a = i.min,
                                s = i.max;
                            if (void 0 !== a && void 0 !== s) {
                                if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))), t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))), t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))), i.normalized) {
                                    const e = Jp(zp[i.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            }
                        }
                    }
                    r.expandByVector(e)
                }
                e.boundingBox = r;
                const s = new Dt;
                r.getCenter(s.center), s.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = s
            }(e, t, n), Promise.all(r).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let i = !1,
                        r = !1,
                        a = !1;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (a = !0), i && r && a) break
                    }
                    if (!i && !r && !a) return Promise.resolve(e);
                    const s = [],
                        o = [],
                        l = [];
                    for (let c = 0, h = t.length; c < h; c++) {
                        const h = t[c];
                        if (i) {
                            const t = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                            s.push(t)
                        }
                        if (r) {
                            const t = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                            o.push(t)
                        }
                        if (a) {
                            const t = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : e.attributes.color;
                            l.push(t)
                        }
                    }
                    return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then((function(t) {
                        const n = t[0],
                            s = t[1],
                            o = t[2];
                        return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = s), a && (e.morphAttributes.color = o), e.morphTargetsRelative = !0, e
                    }))
                }(e, t.targets, n) : e
            }))
    }
    const nm = new WeakMap;
    class im extends Vo {
        constructor(e) {
            super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
            }, this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
            }
        }
        setDecoderPath(e) {
            return this.decoderPath = e, this
        }
        setDecoderConfig(e) {
            return this.decoderConfig = e, this
        }
        setWorkerLimit(e) {
            return this.workerLimit = e, this
        }
        load(e, t, n, i) {
            const r = new qo(this.manager);
            r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (e => {
                this.parse(e, t, i)
            }), n, i)
        }
        parse(e, t, n = (() => {})) {
            this.decodeDracoFile(e, t, null, null, ge, n).catch(n)
        }
        decodeDracoFile(e, t, n, i, r = _e, a = (() => {})) {
            const s = {
                attributeIDs: n || this.defaultAttributeIDs,
                attributeTypes: i || this.defaultAttributeTypes,
                useUniqueIDs: !!n,
                vertexColorSpace: r
            };
            return this.decodeGeometry(e, s).then(t).catch(a)
        }
        decodeGeometry(e, t) {
            const n = JSON.stringify(t);
            if (nm.has(e)) {
                const t = nm.get(e);
                if (t.key === n) return t.promise;
                if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
            }
            let i;
            const r = this.workerNextTaskID++,
                a = e.byteLength,
                s = this._getWorker(r, a).then((n => (i = n, new Promise(((n, a) => {
                    i._callbacks[r] = {
                        resolve: n,
                        reject: a
                    }, i.postMessage({
                        type: "decode",
                        id: r,
                        taskConfig: t,
                        buffer: e
                    }, [e])
                }))))).then((e => this._createGeometry(e.geometry)));
            return s.catch((() => !0)).then((() => {
                i && r && this._releaseTask(i, r)
            })), nm.set(e, {
                key: n,
                promise: s
            }), s
        }
        _createGeometry(e) {
            const t = new Jn;
            e.index && t.setIndex(new Hn(e.index.array, 1));
            for (let n = 0; n < e.attributes.length; n++) {
                const i = e.attributes[n],
                    r = i.name,
                    a = i.array,
                    s = i.itemSize,
                    o = new Hn(a, s);
                "color" === r && (this._assignVertexColorSpace(o, i.vertexColorSpace), o.normalized = a instanceof Float32Array == 0), t.setAttribute(r, o)
            }
            return t
        }
        _assignVertexColorSpace(e, t) {
            if (t !== ge) return;
            const n = new In;
            for (let t = 0, i = e.count; t < i; t++) n.fromBufferAttribute(e, t), qe.toWorkingColorSpace(n, ge), e.setXYZ(t, n.r, n.g, n.b)
        }
        _loadLibrary(e, t) {
            const n = new qo(this.manager);
            return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, i) => {
                n.load(e, t, void 0, i)
            }))
        }
        preload() {
            return this._initDecoder(), this
        }
        _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                t = [];
            return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                const n = t[0];
                e || (this.decoderConfig.wasmBinary = t[1]);
                const i = rm.toString(),
                    r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                this.workerSourceURL = URL.createObjectURL(new Blob([r]))
            })), this.decoderPending
        }
        _getWorker(e, t) {
            return this._initDecoder().then((() => {
                if (this.workerPool.length < this.workerLimit) {
                    const e = new Worker(this.workerSourceURL);
                    e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                    }), e.onmessage = function(t) {
                        const n = t.data;
                        switch (n.type) {
                            case "decode":
                                e._callbacks[n.id].resolve(n);
                                break;
                            case "error":
                                e._callbacks[n.id].reject(n)
                        }
                    }, this.workerPool.push(e)
                } else this.workerPool.sort((function(e, t) {
                    return e._taskLoad > t._taskLoad ? -1 : 1
                }));
                const n = this.workerPool[this.workerPool.length - 1];
                return n._taskCosts[e] = t, n._taskLoad += t, n
            }))
        }
        _releaseTask(e, t) {
            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
        }
        debug() {}
        dispose() {
            for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
            return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
        }
    }

    function rm() {
        let e, t;

        function n(e, t, n, i, r, a) {
            const s = a.num_components(),
                o = n.num_points() * s,
                l = o * r.BYTES_PER_ELEMENT,
                c = function(e, t) {
                    switch (t) {
                        case Float32Array:
                            return e.DT_FLOAT32;
                        case Int8Array:
                            return e.DT_INT8;
                        case Int16Array:
                            return e.DT_INT16;
                        case Int32Array:
                            return e.DT_INT32;
                        case Uint8Array:
                            return e.DT_UINT8;
                        case Uint16Array:
                            return e.DT_UINT16;
                        case Uint32Array:
                            return e.DT_UINT32
                    }
                }(e, r),
                h = e._malloc(l);
            t.GetAttributeDataArrayForAllPoints(n, a, c, l, h);
            const u = new r(e.HEAPF32.buffer, h, o).slice();
            return e._free(h), {
                name: i,
                array: u,
                itemSize: s
            }
        }
        onmessage = function(i) {
            const r = i.data;
            switch (r.type) {
                case "init":
                    e = r.decoderConfig, t = new Promise((function(t) {
                        e.onModuleLoaded = function(e) {
                            t({
                                draco: e
                            })
                        }, DracoDecoderModule(e)
                    }));
                    break;
                case "decode":
                    const i = r.buffer,
                        a = r.taskConfig;
                    t.then((e => {
                        const t = e.draco,
                            s = new t.Decoder;
                        try {
                            const e = function(e, t, i, r) {
                                    const a = r.attributeIDs,
                                        s = r.attributeTypes;
                                    let o, l;
                                    const c = t.GetEncodedGeometryType(i);
                                    if (c === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeArrayToMesh(i, i.byteLength, o);
                                    else {
                                        if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                        o = new e.PointCloud, l = t.DecodeArrayToPointCloud(i, i.byteLength, o)
                                    }
                                    if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                    const h = {
                                        index: null,
                                        attributes: []
                                    };
                                    for (const i in a) {
                                        const l = self[s[i]];
                                        let c, u;
                                        if (r.useUniqueIDs) u = a[i], c = t.GetAttributeByUniqueId(o, u);
                                        else {
                                            if (u = t.GetAttributeId(o, e[a[i]]), -1 === u) continue;
                                            c = t.GetAttribute(o, u)
                                        }
                                        const d = n(e, t, o, i, l, c);
                                        "color" === i && (d.vertexColorSpace = r.vertexColorSpace), h.attributes.push(d)
                                    }
                                    return c === e.TRIANGULAR_MESH && (h.index = function(e, t, n) {
                                        const i = 3 * n.num_faces(),
                                            r = 4 * i,
                                            a = e._malloc(r);
                                        t.GetTrianglesUInt32Array(n, r, a);
                                        const s = new Uint32Array(e.HEAPF32.buffer, a, i).slice();
                                        return e._free(a), {
                                            array: s,
                                            itemSize: 1
                                        }
                                    }(e, t, o)), e.destroy(o), h
                                }(t, s, new Int8Array(i), a),
                                o = e.attributes.map((e => e.array.buffer));
                            e.index && o.push(e.index.array.buffer), self.postMessage({
                                type: "decode",
                                id: r.id,
                                geometry: e
                            }, o)
                        } catch (e) {
                            self.postMessage({
                                type: "error",
                                id: r.id,
                                error: e.message
                            })
                        } finally {
                            t.destroy(s)
                        }
                    }))
            }
        }
    }

    function am(e) {
        return am = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }, am(e)
    }

    function sm() {
        sm = function() {
            return t
        };
        var e, t = {},
            n = Object.prototype,
            i = n.hasOwnProperty,
            r = Object.defineProperty || function(e, t, n) {
                e[t] = n.value
            },
            a = "function" == typeof Symbol ? Symbol : {},
            s = a.iterator || "@@iterator",
            o = a.asyncIterator || "@@asyncIterator",
            l = a.toStringTag || "@@toStringTag";

        function c(e, t, n) {
            return Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }), e[t]
        }
        try {
            c({}, "")
        } catch (e) {
            c = function(e, t, n) {
                return e[t] = n
            }
        }

        function h(e, t, n, i) {
            var a = t && t.prototype instanceof _ ? t : _,
                s = Object.create(a.prototype),
                o = new L(i || []);
            return r(s, "_invoke", {
                value: E(e, n, o)
            }), s
        }

        function u(e, t, n) {
            try {
                return {
                    type: "normal",
                    arg: e.call(t, n)
                }
            } catch (e) {
                return {
                    type: "throw",
                    arg: e
                }
            }
        }
        t.wrap = h;
        var d = "suspendedStart",
            p = "suspendedYield",
            m = "executing",
            f = "completed",
            g = {};

        function _() {}

        function v() {}

        function y() {}
        var x = {};
        c(x, s, (function() {
            return this
        }));
        var b = Object.getPrototypeOf,
            w = b && b(b(P([])));
        w && w !== n && i.call(w, s) && (x = w);
        var S = y.prototype = _.prototype = Object.create(x);

        function M(e) {
            ["next", "throw", "return"].forEach((function(t) {
                c(e, t, (function(e) {
                    return this._invoke(t, e)
                }))
            }))
        }

        function T(e, t) {
            function n(r, a, s, o) {
                var l = u(e[r], e, a);
                if ("throw" !== l.type) {
                    var c = l.arg,
                        h = c.value;
                    return h && "object" == am(h) && i.call(h, "__await") ? t.resolve(h.__await).then((function(e) {
                        n("next", e, s, o)
                    }), (function(e) {
                        n("throw", e, s, o)
                    })) : t.resolve(h).then((function(e) {
                        c.value = e, s(c)
                    }), (function(e) {
                        return n("throw", e, s, o)
                    }))
                }
                o(l.arg)
            }
            var a;
            r(this, "_invoke", {
                value: function(e, i) {
                    function r() {
                        return new t((function(t, r) {
                            n(e, i, t, r)
                        }))
                    }
                    return a = a ? a.then(r, r) : r()
                }
            })
        }

        function E(t, n, i) {
            var r = d;
            return function(a, s) {
                if (r === m) throw Error("Generator is already running");
                if (r === f) {
                    if ("throw" === a) throw s;
                    return {
                        value: e,
                        done: !0
                    }
                }
                for (i.method = a, i.arg = s;;) {
                    var o = i.delegate;
                    if (o) {
                        var l = A(o, i);
                        if (l) {
                            if (l === g) continue;
                            return l
                        }
                    }
                    if ("next" === i.method) i.sent = i._sent = i.arg;
                    else if ("throw" === i.method) {
                        if (r === d) throw r = f, i.arg;
                        i.dispatchException(i.arg)
                    } else "return" === i.method && i.abrupt("return", i.arg);
                    r = m;
                    var c = u(t, n, i);
                    if ("normal" === c.type) {
                        if (r = i.done ? f : p, c.arg === g) continue;
                        return {
                            value: c.arg,
                            done: i.done
                        }
                    }
                    "throw" === c.type && (r = f, i.method = "throw", i.arg = c.arg)
                }
            }
        }

        function A(t, n) {
            var i = n.method,
                r = t.iterator[i];
            if (r === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", n.arg = e, A(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), g;
            var a = u(r, t.iterator, n.arg);
            if ("throw" === a.type) return n.method = "throw", n.arg = a.arg, n.delegate = null, g;
            var s = a.arg;
            return s ? s.done ? (n[t.resultName] = s.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, g) : s : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
        }

        function R(e) {
            var t = {
                tryLoc: e[0]
            };
            1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
        }

        function C(e) {
            var t = e.completion || {};
            t.type = "normal", delete t.arg, e.completion = t
        }

        function L(e) {
            this.tryEntries = [{
                tryLoc: "root"
            }], e.forEach(R, this), this.reset(!0)
        }

        function P(t) {
            if (t || "" === t) {
                var n = t[s];
                if (n) return n.call(t);
                if ("function" == typeof t.next) return t;
                if (!isNaN(t.length)) {
                    var r = -1,
                        a = function n() {
                            for (; ++r < t.length;)
                                if (i.call(t, r)) return n.value = t[r], n.done = !1, n;
                            return n.value = e, n.done = !0, n
                        };
                    return a.next = a
                }
            }
            throw new TypeError(am(t) + " is not iterable")
        }
        return v.prototype = y, r(S, "constructor", {
            value: y,
            configurable: !0
        }), r(y, "constructor", {
            value: v,
            configurable: !0
        }), v.displayName = c(y, l, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
        }, t.mark = function(e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, c(e, l, "GeneratorFunction")), e.prototype = Object.create(S), e
        }, t.awrap = function(e) {
            return {
                __await: e
            }
        }, M(T.prototype), c(T.prototype, o, (function() {
            return this
        })), t.AsyncIterator = T, t.async = function(e, n, i, r, a) {
            void 0 === a && (a = Promise);
            var s = new T(h(e, n, i, r), a);
            return t.isGeneratorFunction(n) ? s : s.next().then((function(e) {
                return e.done ? e.value : s.next()
            }))
        }, M(S), c(S, l, "Generator"), c(S, s, (function() {
            return this
        })), c(S, "toString", (function() {
            return "[object Generator]"
        })), t.keys = function(e) {
            var t = Object(e),
                n = [];
            for (var i in t) n.push(i);
            return n.reverse(),
                function e() {
                    for (; n.length;) {
                        var i = n.pop();
                        if (i in t) return e.value = i, e.done = !1, e
                    }
                    return e.done = !0, e
                }
        }, t.values = P, L.prototype = {
            constructor: L,
            reset: function(t) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(C), !t)
                    for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
            },
            stop: function() {
                this.done = !0;
                var e = this.tryEntries[0].completion;
                if ("throw" === e.type) throw e.arg;
                return this.rval
            },
            dispatchException: function(t) {
                if (this.done) throw t;
                var n = this;

                function r(i, r) {
                    return o.type = "throw", o.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r
                }
                for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                    var s = this.tryEntries[a],
                        o = s.completion;
                    if ("root" === s.tryLoc) return r("end");
                    if (s.tryLoc <= this.prev) {
                        var l = i.call(s, "catchLoc"),
                            c = i.call(s, "finallyLoc");
                        if (l && c) {
                            if (this.prev < s.catchLoc) return r(s.catchLoc, !0);
                            if (this.prev < s.finallyLoc) return r(s.finallyLoc)
                        } else if (l) {
                            if (this.prev < s.catchLoc) return r(s.catchLoc, !0)
                        } else {
                            if (!c) throw Error("try statement without catch or finally");
                            if (this.prev < s.finallyLoc) return r(s.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(e, t) {
                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                    var r = this.tryEntries[n];
                    if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                        var a = r;
                        break
                    }
                }
                a && ("break" === e || "continue" === e) && a.tryLoc <= t && t <= a.finallyLoc && (a = null);
                var s = a ? a.completion : {};
                return s.type = e, s.arg = t, a ? (this.method = "next", this.next = a.finallyLoc, g) : this.complete(s)
            },
            complete: function(e, t) {
                if ("throw" === e.type) throw e.arg;
                return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
            },
            finish: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var n = this.tryEntries[t];
                    if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), C(n), g
                }
            },
            catch: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var n = this.tryEntries[t];
                    if (n.tryLoc === e) {
                        var i = n.completion;
                        if ("throw" === i.type) {
                            var r = i.arg;
                            C(n)
                        }
                        return r
                    }
                }
                throw Error("illegal catch attempt")
            },
            delegateYield: function(t, n, i) {
                return this.delegate = {
                    iterator: P(t),
                    resultName: n,
                    nextLoc: i
                }, "next" === this.method && (this.arg = e), g
            }
        }, t
    }

    function om(e, t, n, i, r, a, s) {
        try {
            var o = e[a](s),
                l = o.value
        } catch (e) {
            return void n(e)
        }
        o.done ? t(l) : Promise.resolve(l).then(i, r)
    }

    function lm(e) {
        return function() {
            var t = this,
                n = arguments;
            return new Promise((function(i, r) {
                var a = e.apply(t, n);

                function s(e) {
                    om(a, i, r, s, o, "next", e)
                }

                function o(e) {
                    om(a, i, r, s, o, "throw", e)
                }
                s(void 0)
            }))
        }
    }

    function cm(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }))), n.push.apply(n, i)
        }
        return n
    }

    function hm(e, t, n) {
        return (t = dm(t)) in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function um(e, t) {
        for (var n = 0; n < t.length; n++) {
            var i = t[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, dm(i.key), i)
        }
    }

    function dm(e) {
        var t = function(e, t) {
            if ("object" != am(e) || !e) return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var i = n.call(e, "string");
                if ("object" != am(i)) return i;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e);
        return "symbol" == am(t) ? t : t + ""
    }
    var pm = function() {
        return e = function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.container = t, this.config = function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? cm(Object(n), !0).forEach((function(t) {
                        hm(e, t, n[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cm(Object(n)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                    }))
                }
                return e
            }({
                texturePath: "/textures/2506/250117_Backyard_Tour_XL8_BedroomPrimary_01.jpg",
                modelPath: "/assets/xl8.glb",
                decoderPath: "/decoders/draco/",
                backgroundColor: "#e0ded4",
                azimuthAngle: 0,
                polarAngle: 90,
                fov: 75
            }, n), this.scene = null, this.camera = null, this.renderer = null, this.panoramaMesh = null, this.textureLoader = new jo, this.gltfLoader = new hp;
            var i = new im;
            i.setDecoderPath(this.config.decoderPath), this.gltfLoader.setDRACOLoader(i);
            var r = Oe.clamp(Oe.degToRad(this.config.polarAngle), .1, Math.PI - .1),
                a = Oe.degToRad(this.config.azimuthAngle);
            this.cameraSpherical = new vl(10, r, a), this.cameraTarget = new ut(0, 0, 0), this.animationId = null, this.model = null
        }, t = [{
            key: "init",
            value: (r = lm(sm().mark((function e() {
                var t;
                return sm().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.prev = 0, "static" === window.getComputedStyle(this.container).position && (this.container.style.position = "relative"), this.setupScene(), this.setupCamera(), this.setupRenderer(), e.next = 7, Promise.all([this.loadPanorama(), this.loadModel()]);
                        case 7:
                            this.onWindowResize(), this.addEventListeners(), this.animate(), e.next = 17;
                            break;
                        case 12:
                            throw e.prev = 12, e.t0 = e.catch(0), "Error creating WebGL context." !== e.t0.message && ((t = document.createElement("div")).style.cssText = "\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: 50%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\ttransform: translate(-50%, -50%);\n\t\t\t\t\ttext-align: center;\n\t\t\t\t\tcolor: #333;\n\t\t\t\t\tfont-family: system-ui, -apple-system, sans-serif;\n\t\t\t\t\tpadding: 20px;\n\t\t\t\t", t.innerHTML = "<p>Failed to load 3D tour. Please try refreshing the page.</p>", this.container.appendChild(t)), e.t0;
                        case 17:
                        case "end":
                            return e.stop()
                    }
                }), e, this, [
                    [0, 12]
                ])
            }))), function() {
                return r.apply(this, arguments)
            })
        }, {
            key: "setupScene",
            value: function() {
                this.scene = new Ss, this.scene.background = new In(this.config.backgroundColor);
                var e = new ll(16777215, 1);
                this.scene.add(e)
            }
        }, {
            key: "setupCamera",
            value: function() {
                var e = this.container.clientWidth / this.container.clientHeight;
                this.camera = new wi(this.config.fov, e, .1, 1e3), this.updateCameraPosition()
            }
        }, {
            key: "setupRenderer",
            value: function() {
                try {
                    if (this.renderer = new ws({
                            antialias: !0,
                            alpha: !0,
                            premultipliedAlpha: !0,
                            failIfMajorPerformanceCaveat: !1,
                            powerPreference: "default"
                        }), null === this.renderer.getContext()) throw new Error("WebGL context is null");
                    this.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1)), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.renderer.physicallyCorrectLights = !0, this.renderer.outputColorSpace = ge, this.renderer.toneMapping = 0, this.renderer.toneMappingExposure = 1, this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.renderer.domElement.style.display = "block", this.container.appendChild(this.renderer.domElement)
                } catch (t) {
                    var e = document.createElement("div");
                    throw e.style.cssText = "\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 50%;\n\t\t\t\tleft: 50%;\n\t\t\t\ttransform: translate(-50%, -50%);\n\t\t\t\ttext-align: center;\n\t\t\t\tcolor: #333;\n\t\t\t\tfont-family: system-ui, -apple-system, sans-serif;\n\t\t\t\tpadding: 20px;\n\t\t\t\tmax-width: 80%;\n\t\t\t", e.innerHTML = "\n\t\t\t\t<h3>3D Tour Unavailable</h3>\n\t\t\t\t<p>Your device or browser doesn't support WebGL, which is required for the 3D tour.</p>\n\t\t\t\t<p>Please try using a modern browser like Chrome, Firefox, Safari, or Edge.</p>\n\t\t\t", this.container.appendChild(e), new Error("Error creating WebGL context.")
                }
            }
        }, {
            key: "loadPanorama",
            value: (i = lm(sm().mark((function e() {
                var t, n, i, r, a;
                return sm().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return t = this.config.texturePath, window.innerWidth <= 768 && t && t.includes("2506/") && (n = t.replace("2506/", "2506/mobile/"), t = n), e.next = 5, this.textureLoader.loadAsync(t);
                        case 5:
                            (i = e.sent).anisotropy = this.renderer.capabilities.getMaxAnisotropy(), i.generateMipmaps = !0, i.minFilter = 1008, i.magFilter = 1006, (r = new yo(500, 60, 40)).scale(-1, 1, 1), a = new _i({
                                uniforms: {
                                    map: {
                                        value: i
                                    },
                                    ambientLightColor: {
                                        value: new In(16777215)
                                    },
                                    ambientLightIntensity: {
                                        value: 1
                                    }
                                },
                                vertexShader: "\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t}\n\t\t\t",
                                fragmentShader: "\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec3 ambientLightColor;\n\t\t\t\tuniform float ambientLightIntensity;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 texColor = texture2D(map, vUv);\n\t\t\t\t\tvec3 ambient = ambientLightColor * ambientLightIntensity;\n\t\t\t\t\tvec3 finalColor = texColor.rgb * ambient;\n\t\t\t\t\tgl_FragColor = vec4(finalColor, texColor.a);\n\t\t\t\t}\n\t\t\t",
                                side: 2
                            }), this.panoramaMesh = new hi(r, a), this.scene.add(this.panoramaMesh);
                        case 15:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return i.apply(this, arguments)
            })
        }, {
            key: "loadModel",
            value: (n = lm(sm().mark((function e() {
                var t;
                return sm().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null !== this.config.modelPath) {
                                e.next = 2;
                                break
                            }
                            return e.abrupt("return");
                        case 2:
                            return e.next = 4, this.gltfLoader.loadAsync(this.config.modelPath);
                        case 4:
                            t = e.sent, this.model = t.scene, this.model.visible = !1, this.scene.add(this.model);
                        case 8:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return n.apply(this, arguments)
            })
        }, {
            key: "setCameraAngle",
            value: function(e, t) {
                this.cameraSpherical.phi = Oe.clamp(e, .1, Math.PI - .1), this.cameraSpherical.theta = t, this.updateCameraPosition()
            }
        }, {
            key: "setCameraAngleDegrees",
            value: function(e, t) {
                var n = Oe.degToRad(e),
                    i = Oe.degToRad(t);
                this.setCameraAngle(n, i)
            }
        }, {
            key: "updateCameraPosition",
            value: function() {
                this.camera.position.setFromSpherical(this.cameraSpherical), this.camera.position.add(this.cameraTarget), this.camera.lookAt(this.cameraTarget)
            }
        }, {
            key: "toggleModel",
            value: function(e) {
                null !== this.model && (this.model.visible = e)
            }
        }, {
            key: "animateCameraTo",
            value: function(e, t) {
                var n = this,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                this.cameraSpherical.phi, this.cameraSpherical.theta, lp.to(this.cameraSpherical, {
                    phi: e,
                    theta: t,
                    duration: i,
                    ease: "power2.inOut",
                    onUpdate: function() {
                        n.updateCameraPosition()
                    }
                })
            }
        }, {
            key: "onWindowResize",
            value: function() {
                var e = this.container.getBoundingClientRect(),
                    t = e.width,
                    n = e.height;
                this.camera.aspect = t / n, this.camera.updateProjectionMatrix(), this.renderer.setSize(t, n)
            }
        }, {
            key: "addEventListeners",
            value: function() {
                var e = this;
                this.resizeHandler = function() {
                    return e.onWindowResize()
                }, window.addEventListener("resize", this.resizeHandler), void 0 !== window.ResizeObserver && (this.resizeObserver = new ResizeObserver((function() {
                    e.onWindowResize()
                })), this.resizeObserver.observe(this.container))
            }
        }, {
            key: "animate",
            value: function() {
                var e = this;
                this.animationId = requestAnimationFrame((function() {
                    return e.animate()
                })), this.renderer.render(this.scene, this.camera)
            }
        }, {
            key: "destroy",
            value: function() {
                null !== this.animationId && cancelAnimationFrame(this.animationId), void 0 !== this.resizeHandler && window.removeEventListener("resize", this.resizeHandler), void 0 !== this.resizeObserver && this.resizeObserver.disconnect(), null !== this.panoramaMesh && (this.panoramaMesh.geometry.dispose(), this.panoramaMesh.material.uniforms && this.panoramaMesh.material.uniforms.map && this.panoramaMesh.material.uniforms.map.value && this.panoramaMesh.material.uniforms.map.value.dispose(), this.panoramaMesh.material.dispose()), null !== this.renderer && (this.renderer.dispose(), this.container.removeChild(this.renderer.domElement))
            }
        }, {
            key: "getCameraAngles",
            value: function() {
                return {
                    phi: this.cameraSpherical.phi,
                    theta: this.cameraSpherical.theta
                }
            }
        }, {
            key: "getFOV",
            value: function() {
                return this.camera.fov
            }
        }, {
            key: "setFOV",
            value: function(e) {
                var t = this,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .5;
                if ("number" == typeof e)
                    if (!1 === (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1])) this.camera.fov = e, this.camera.updateProjectionMatrix();
                    else {
                        var i = {
                            value: this.camera.fov
                        };
                        lp.to(i, {
                            value: e,
                            duration: n,
                            ease: "power2.inOut",
                            onUpdate: function() {
                                t.camera.fov = i.value, t.camera.updateProjectionMatrix()
                            }
                        })
                    }
            }
        }], t && um(e.prototype, t), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e;
        var e, t, n, i, r
    }();
    SimplePanorama = t.SimplePanoramaScene
})(), "complete" === document.readyState && document.body.classList.add("complete"), document.addEventListener("DOMContentLoaded", (() => {
    document.body.classList.add("interactive")
})), window.addEventListener("load", (() => {
    document.body.classList.add("complete")
}), {
    once: !0
}), createDestroy(/^(\/|\/backyard|\/backyard\/)$/, (function() {
    const e = [Backyard.xl10(), Backyard.intro(), Backyard.introCarousel(), Backyard.invertNavigation(), Backyard.loadImagesLazily(), Backyard.threeSizes(), Backyard.createInteriorPhotoCards(), Backyard.createALotCanHappenCards(), Backyard.createBentoCardDetails(), Backyard.createJealousy(), Backyard.createBirds(), Backyard.createTourBanner()];
    return function() {
        e.forEach((e => {
            e()
        }))
    }
})), createDestroy(/^\/backyard\/configure.*/, (function() {
    return createApplication("configurator", {}, "/assets/javascripts/configurator/bundle/index.js")
}), "router:did-update-content"), createDestroy(/^\/showrooms\/events.*|^\/events.*/, (function() {
    return createApplication("event")
}), "router:did-update-content"), createDestroy(/^\/backyard\/faq.*/, (function() {
    const e = [Backyard.invertNavigation(), Backyard.createFaqMenu()];
    return function() {
        e.forEach((e => {
            e()
        }))
    }
})), createDestroy(/^\/backyard\/financing.*/, (async function() {
    const e = [Backyard.invertNavigation()],
        t = await createApplication("financing");
    return () => {
        e.forEach((e => e())), t()
    }
}), "router:did-update-content"), window.getYourRate = function(e) {
    e && (e.preventDefault(), e.stopPropagation()), gtag("event", "financing_get_your_rate"), window.dispatchEvent(new Event("financing:rate-modal"))
}, createDestroy(/^\/backyard\/how-it-works.*/, (function() {
    const e = [Backyard.invertNavigation(), Backyard.loadImagesLazily()],
        t = document.querySelector(".how-it-works-step-8-video");

    function n(e) {
        Tooltip.show("expand", "Expand", e.clientX, e.clientY)
    }

    function i() {
        Tooltip.hide()
    }
    return null !== t && (t.addEventListener("mousemove", n), t.addEventListener("mouseleave", i)),
        function() {
            null !== t && (t.removeEventListener("mousemove", n), t.removeEventListener("mouseleave", i)), e.forEach((e => {
                e()
            }))
        }
}));
const Insights = {
    createPagination() {
        const e = document.querySelector(".insights-pagination");
        if (null === e || !0 === e.dataset.init) return () => {};
        e.dataset.init = !0;
        let t = 0;
        const n = document.querySelector(".insights-index-list"),
            [i, r] = Array.from(e.querySelectorAll("a"));

        function a(a) {
            if (a < 0) return;
            if (a > e.dataset.numberOfPages - 1) return;
            t = a;
            const s = Date.now();
            e.classList.add("insights-pagination-loading"), n.classList.add("insights-index-list-will-change");
            (window.fetchWithRetry || fetch)(`/insights/${t+1}.data`, {}, {
                maxRetries: 2,
                onRetry: (e, t) => {
                    console.info(`Retrying page fetch (attempt ${e}):`, t.message)
                }
            }).then((e => e.text())).then((t => {
                ! function(t, i) {
                    const r = 200 - (Date.now() - t);
                    setTimeout((() => {
                        n.innerHTML = i;
                        const t = window.scrollY + document.querySelector(".insights-index-list").getBoundingClientRect().top - .25 * window.innerHeight;
                        window.scrollTo({
                            top: t,
                            behavior: "smooth"
                        }), n.classList.remove("insights-index-list-will-change"), e.classList.remove("insights-pagination-loading")
                    }), r)
                }(s, t)
            })).catch((t => {
                console.error("Failed to fetch page data:", t), e.classList.remove("insights-pagination-loading"), n.classList.remove("insights-index-list-will-change"), n.innerHTML = '<p class="error-message">Failed to load content. Please try again.</p>'
            })), i.classList.toggle("insights-pagination-hidden", 0 === t), r.classList.toggle("insights-pagination-hidden", t === e.dataset.numberOfPages - 1);
            const o = `${t+1}`;
            history.pushState(null, document.title, 0 === t ? "/insights" : `/insights?page=${o}`), e.querySelector("select").value = o, e.querySelector(".insights-pagination-selector-current").innerHTML = o
        }

        function s(e) {
            e.preventDefault();
            const n = e.target.closest("a");
            if (null === n || void 0 === n.dataset || void 0 === n.dataset.direction) return;
            const i = parseInt(n.dataset.direction);
            !0 !== isNaN(i) && a(t + i)
        } [i, r].forEach((e => {
            e.addEventListener("click", s)
        })), e.querySelector("select").addEventListener("change", (function(e) {
            a(parseInt(e.target.value) - 1)
        }));
        const o = new URLSearchParams(document.location.search);
        return o.has("page") && a((parseInt(o.get("page")) || 1) - 1),
            function() {}
    },
    createLineupModules() {
        const e = Array.from(document.querySelectorAll(".insights-module-lineup")).map((function(e) {
            const t = e.querySelector(".insights-module-lineup-container"),
                n = e.querySelectorAll(".insights-module-lineup-control"),
                i = e.querySelector(".insights-module-lineup-model");

            function r() {
                n[0].classList.toggle("insights-module-lineup-control-visible", t.scrollLeft > i.clientWidth), n[1].classList.toggle("insights-module-lineup-control-visible", t.scrollLeft < t.scrollWidth - window.innerWidth - i.clientWidth)
            }
            return n.forEach(((e, n) => {
                    e.addEventListener("click", (function() {
                        t.scrollTo({
                            left: 0 === n ? 0 : t.scrollWidth,
                            behavior: "smooth"
                        })
                    }))
                })), t.addEventListener("scroll", r), window.addEventListener("resize", r), r(),
                function() {
                    window.removeEventListener("resize", r)
                }
        }));
        return function() {
            e.forEach((e => {
                e()
            }))
        }
    },
    createGuidesNavigation() {
        const e = document.querySelector(".guides-navigation");
        return null === e ? () => {} : (e.querySelectorAll("a").forEach((e => {
            e.addEventListener("click", (function(t) {
                if (t.preventDefault(), void 0 === e.href || "string" != typeof e.href) return;
                const n = e.href.indexOf("#");
                if (-1 === n) return;
                const i = e.href.substring(n + 1);
                if (0 === i.length) return;
                const r = document.getElementById(i);
                null !== r && window.scrollTo({
                    top: r.getBoundingClientRect().top + window.scrollY,
                    behavior: "smooth"
                })
            }))
        })), function() {})
    }
};
createDestroy(/^\/insights.*/, (function() {
    const e = [Backyard.invertNavigation(), Backyard.loadImagesLazily(), Insights.createPagination(), Insights.createLineupModules(), Insights.createGuidesNavigation()];
    return function() {
        e.forEach((e => {
            e()
        }))
    }
})), (() => {
    const e = {
        "/news/time-names-backyard-a-best-invention-of-2024": {
            title: "TIME names Samara’s Backyard a Best Invention of 2024 — News — Samara",
            description: "Each year, TIME honors genius ideas and products that are changing how we live, work, play, and think about what’s possible. We’re proud to announce that this year, Backyard has been recognized as one of TIME’s Best Inventions of 2024.",
            class_names: "newsroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/newsroom/internal",
            position: 14,
            share_sheet_image_id: "7e59efa2-59ea-4288-8dea-05bb7cdfb800"
        },
        "/news/there-s-more-to-love-with-backyard-xl-10": {
            title: "There’s more to love with Backyard XL 10 — News — Samara",
            description: "Backyard just got bigger. We’re excited to unveil Backyard XL 10, the latest and largest addition to Samara’s ADU lineup.",
            class_names: "newsroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/newsroom/internal",
            position: 13,
            share_sheet_image_id: "b1ae142b-b246-4501-20f1-f1350a84c300"
        },
        "/news/samara-launches-proprietary-financing-product-to-bring-more-space-to-millions-of-homeowners": {
            title: "Samara Launches Proprietary Financing Product to  Bring More Space to Millions of Homeowners — News — Samara",
            description: "REDWOOD CITY, CALIFORNIA  — Today, Samara Finance, LLC, a wholly-owned subsidiary of Samara, announced it launched a first-of-its-kind financing product, making it easier for homeowners to finance Backyard, its accessory dwelling unit (ADU). Now, Samara uniquely manages the ADU process from conception to completion, handling everything from product design and prefab manufacturing, to permitting, delivery and installation, to financing. The new financing option makes it possible for homeowners to add flexible space to their homes with competitive rates. This enables the company to accelerate expansion and deliver more units in 2024 and beyond.",
            class_names: "newsroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/newsroom/internal",
            position: 12,
            share_sheet_image_id: "c5700752-823e-4522-f805-a3a788b63400"
        },
        "/news/introducing-backyard-xl": {
            title: "Introducing Backyard XL 8 — News — Samara",
            description: "We’re proud to unveil Backyard XL 8, our latest ADU model that makes it easy for homeowners to add more flexible living space to their existing properties. With two bedrooms and two bathrooms, the luxe 800-square-foot home provides ample space with larger appliances, and premium amenities.",
            class_names: "newsroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/newsroom/internal",
            position: 11,
            share_sheet_image_id: "4f02d289-169f-4ab4-50e7-edb29cfa4300"
        },
        "/news/samara-acquires-factory-to-scale-manufacturing-of-backyard": {
            title: "Samara Acquires Factory to Scale Manufacturing of Backyard  as Demand for ADUs Soars in California — News — Samara",
            description: "REDWOOD CITY, CALIFORNIA — Today, Samara announced it has acquired a factory that brings the manufacturing of its high-quality accessory dwelling unit (ADU), Backyard, completely in house. Located in Mexicali, Mexico, the factory gives Samara more control over the quality standard of Backyard, shortens delivery timelines, accelerates product development and enables the company to meet rising customer demand in California and beyond.",
            class_names: "newsroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/newsroom/internal",
            position: 10,
            share_sheet_image_id: "dd6932ff-e29e-410b-b2e6-4f23130e1e00"
        },
        "/news/samara-raises-41-million-to-bring-high-quality-adus-to-every-backyard-in-california-and-beyond": {
            title: "Samara raises $41 million to bring high quality ADUs to every backyard in California and beyond — News — Samara",
            description: "We’re excited to announce our $41M Series A round, led by Thrive Capital with participation from leading VC firms and angel investors. This latest funding will allow us to scale our brand, product offerings, team, and much needed manufacturing capacity to unlock growth and bring high quality accessory dwelling units (ADUs) to every backyard in California and beyond.",
            class_names: "newsroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/newsroom/internal",
            position: 9,
            share_sheet_image_id: "59ee21f7-d5a4-4592-e873-b16c86b7ea00"
        },
        "/insights/how-we-built-a-fire-resistant-ADU": {
            title: "How We Built a Fire-Resistant ADU — Samara",
            description: "California shapes how we think about building. To create high-performing homes built for today and tomorrow, we've carefully selected materials and made practical design decisions for longevity—choices that naturally create inherent fire resistance.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 14,
            share_sheet_image_id: "93578295-abea-42a3-500e-969069e49200"
        },
        "/insights/can-hoas-block-adu-construction-in-california": {
            title: "Can HOAs Block ADU Construction in California? Understanding Your Rights — Samara",
            description: "If you’re considering building an ADU and belong to an HOA, you might wonder about potential restrictions or requirements. Here’s what you need to know about your rights and the limits of HOA authority over ADU construction.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 13,
            share_sheet_image_id: "2b76073a-ab8d-4488-6ebc-af6a19c92700"
        },
        "/insights/how-to-finance-an-adu": {
            title: "How to Finance an ADU — Samara",
            description: "Homeowners can tap into a variety of funding resources to build an ADU. Use this guide to explore how to finance an ADU to add value to your property. ",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 12,
            share_sheet_image_id: "7b4af13f-4e79-4bc5-81c9-8e245b224e00"
        },
        "/insights/how-big-can-an-adu-be-in-california": {
            title: "How Many Bedrooms Can an ADU in California Have? — Samara",
            description: "The number of bedrooms in your new ADU will influence the final design. Learn how many bedrooms your ADU should have to maximize your experience.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 11,
            share_sheet_image_id: "8a85faee-0714-4c7c-eb3c-712f65391800"
        },
        "/insights/2025-accessory-dwelling-unit-handbook": {
            title: "California’s New ADU Handbook: What’s Changed for 2025 — Samara",
            description: "",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 10,
            share_sheet_image_id: "7fd63db2-b177-45ea-299d-1dd0804d2d00"
        },
        "/insights/report-adus-win-over-california-homeowners": {
            title: "Report: ADUs Win Over California Homeowners — Samara",
            description: "We recently surveyed California homeowners on how they felt about ADUs. While regulatory complexities remain the top concern, an overwhelming 87% of homeowners welcome or accept ADUs in their neighborhoods.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 9,
            share_sheet_image_id: "6b07990f-4555-423d-b568-2b6f43dbcd00"
        },
        "/insights/how-to-get-an-adu-permit": {
            title: "How to Get an ADU Permit in California — Samara",
            description: "Simplify the ADU permit process in California with this easy guide. Learn about zoning, building permits, and more to get your ADU project started.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 8,
            share_sheet_image_id: "e96ecaec-e24a-42e1-5f4f-f02dc7047100"
        },
        "/insights/adu-cost-california": {
            title: "How Much Does It Cost To Build an ADU in California? — Samara",
            description: "Before you design and build an ADU, consider the costs and benefits. Tally up how much an ADU costs in California and if it fits your budget.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 7,
            share_sheet_image_id: "0cbd6443-3673-4085-e6b4-44e240261e00"
        },
        "/insights/adu-california": {
            title: "What Is Considered an ADU in California? — Samara",
            description: "Building an ADU can offer homeowners many benefits despite the initial investment. Find out what's considered an ADU in the state of California. ",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 6,
            share_sheet_image_id: "e0a07661-bd4d-4453-36fa-d68eabbf0300"
        },
        "/insights/adu-california-grant": {
            title: "How To Get an ADU Grant in California — Samara",
            description: "An ADU California grant can help you build your accessory dwelling unit. Learn how to get an ADU grant in California to offset the associated costs.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 5,
            share_sheet_image_id: "4e095cd5-6432-4dd8-42de-02f965b60400"
        },
        "/backyard/guides/bay-area-adu": {
            title: "The Complete Bay Area ADU Requirements Guide — Samara",
            description: "Learn the rules and regulations for building an ADU in the Bay Area so your journey from proposal to permit goes as smoothly as possible.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 16,
            share_sheet_image_id: "b5179a48-48f8-4a17-81eb-8a5da9b19900"
        },
        "/backyard/guides/burlingame-adu": {
            title: "The Complete Burlingame ADU Requirements Guide — Samara",
            description: "A clear guide to Burlingame’s ADU rules, including size, height, setbacks, zoning, parking, and how many units you can build.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 15,
            share_sheet_image_id: "08a44d59-17fb-41ca-f1b5-15eae2eb5c00"
        },
        "/backyard/guides/saratoga-adu": {
            title: "The Complete Saratoga ADU Requirements Guide — Samara",
            description: "Find out what’s allowed when building an ADU in Saratoga, including size, setbacks, parking, and zoning rules, plus how Samara can help you through the process.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 14,
            share_sheet_image_id: "5aa3b561-1b8d-4156-ff2b-eb030aed1700"
        },
        "/backyard/guides/adu-calabasas": {
            title: "The Complete Calabasas ADU Requirements Guide — Samara",
            description: "A clear guide to Calabasas ADU rules, covering size, height, setbacks, zoning, parking, and how many units are allowed per property.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 13,
            share_sheet_image_id: "43b07275-c075-45da-b298-934b72bc7600"
        },
        "/backyard/guides/thousand-oaks-adu": {
            title: "The Complete Thousand Oaks ADU Requirements Guide — Samara",
            description: "Learn the key ADU regulations in Thousand Oaks, including size, zoning, and parking requirements—plus how Samara can help you navigate the process.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 12,
            share_sheet_image_id: "8d84cf08-0d95-4a91-6bae-4f9d09343300"
        },
        "/backyard/guides/adu-in-los-gatos": {
            title: "The Complete Los Gatos ADU Requirements Guide — Samara",
            description: "A complete and current guide to ADU rules in Los Gatos, including size, height, setbacks, parking, design, and how many units you can build.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 11,
            share_sheet_image_id: "bb576003-2447-4d91-5083-33e0005e6200"
        },
        "/backyard/guides/ventura-county-adu": {
            title: "The Complete Ventura County ADU Requirements Guide — Samara",
            description: "Learn the key ADU regulations in Ventura County, including size, zoning, and permitting requirements—plus how Samara can help you navigate the process.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 10,
            share_sheet_image_id: "f6c5177d-90d6-4926-3942-7b0d63e67d00"
        },
        "/backyard/guides/orange-county-adu": {
            title: "The Complete Orange County ADU Requirements Guide — Samara",
            description: "A practical guide to ADU requirements in Orange County, including size limits, zoning rules, and how to navigate the permitting process with Samara.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 9,
            share_sheet_image_id: "ce2295aa-0c92-4ad2-d202-a7a422d77a00"
        },
        "/backyard/guides/palo-alto-adu": {
            title: "The Complete Palo Alto ADU Requirements Guide — Samara",
            description: "A clear overview of Palo Alto ADU rules, from zoning and size limits to design and parking requirements, plus how to get started with Samara.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 8,
            share_sheet_image_id: "76faf420-49ce-4e54-247c-bd89dea3b400"
        },
        "/backyard/guides/marin-county-adu": {
            title: "The Complete Marin County ADU Requirements Guide — Samara",
            description: "Learn about Marin County ADU regulations so that your journey from proposal to permit is as smooth and efficient as possible.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 7,
            share_sheet_image_id: "0c59cc9e-11d0-4b8f-39d8-5f6192a73100"
        },
        "/backyard/guides/cupertino-adu": {
            title: "The Complete Cupertino ADU Requirements Guide — Samara",
            description: "Learn Cupertino’s ADU regulations and permitting process, including size limits and zoning rules, in our streamlined requirements guide.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 6,
            share_sheet_image_id: "cb164fb1-4e71-4396-95f8-2c7154f06600"
        },
        "/backyard/guides/santa-rosa-adu": {
            title: "The Complete Santa Rosa ADU Requirements Guide — Samara",
            description: "Learn all about Santa Rosa ADU rules and regulations so you can make your journey from proposal to permit as smooth as possible. ",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 5,
            share_sheet_image_id: "92a57b28-5ad7-43f9-d3e9-e0da4556e800"
        },
        "/backyard/guides/san-mateo-adu": {
            title: "The Complete San Mateo ADU Requirements Guide — Samara",
            description: "Learn about San Mateo’s ADU standards so your ADU building process is as simple and straightforward as possible. ",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 4,
            share_sheet_image_id: "ddbedbdf-2363-49a4-d87f-a7a74b34a600"
        },
        "/backyard/guides/santa-barbara-adu": {
            title: "The Complete Santa Barbara ADU Requirements Guide — Samara",
            description: "Learn all about Santa Barbara ADU regulations so you can make your journey from proposal to permit as smooth as possible. ",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 3,
            share_sheet_image_id: "a91f5a15-11dc-4fca-54d1-b267f20ca900"
        },
        "/backyard/guides/santa-clara-adu": {
            title: "The Complete Santa Clara ADU Requirements Guide — Samara",
            description: "Learn the regulations and requirements for building an ADU in Santa Clara, California, and how to get started with Samara. ",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 2,
            share_sheet_image_id: "d8684a7b-a3a3-4420-87de-28a30b633100"
        },
        "/backyard/guides/santa-cruz-adu": {
            title: "The Complete Santa Cruz ADU Requirements Guide — Samara",
            description: "Learn the basic regulations and requirements for building an ADU in the city of Santa Cruz and how to get started with Samara.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 1,
            share_sheet_image_id: "a0bb7522-be2c-4a34-a03a-224b8502ba00"
        },
        "/backyard/guides/carlsbad-adu": {
            title: "The Complete Carlsbad ADU Requirements Guide — Samara",
            description: "Discover everything you need to know about Carlsbad ADU regulations and how to make the process smooth and straightforward with Samara. ",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: 0,
            share_sheet_image_id: "60821965-4392-499c-182a-d171f978f300"
        },
        "/backyard/guides/walnut-creek-adu": {
            title: "The Complete Walnut Creek ADU Requirements Guide — Samara",
            description: "Learn the ins and outs of Walnut Creek’s ADU regulations so your building process is as smooth and streamlined as possible.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: -1,
            share_sheet_image_id: "3b6dd46e-e4d9-422e-86d0-cc282266cc00"
        },
        "/backyard/guides/alameda-adu": {
            title: "The Complete Alameda ADU Requirements Guide — Samara",
            description: "An up-to-date overview of Alameda’s ADU rules, including limits on size, height, setbacks, zoning, parking, and how many units are allowed.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: -2,
            share_sheet_image_id: "e2ac5ebf-540a-4827-274c-cfe85a0f6f00"
        },
        "/backyard/guides/adu-builder-fremont": {
            title: "The Complete Fremont ADU Requirements Guide — Samara",
            description: "Detailed ADU guidelines for Fremont homeowners, including what’s allowed by state law, how local permitting works, and how many units you can build per lot.",
            class_names: "backyard insights insights-post",
            theme_color: "#000000",
            navigation_inverted: !1,
            partial_name: "partials/pages/insights/post",
            position: -3,
            share_sheet_image_id: "079a0bdd-8cb2-4661-ea82-21be8825d900"
        },
        "/": {
            title: "Samara - Backyard Homes and ADUs",
            description: "Discover Samara's Backyard homes and ADUs. Elevated design, expertly crafted. Fast and easy installation. Solar-powered and future-ready.",
            class_names: "backyard",
            theme_color: "#000000",
            navigation_inverted: !0,
            position: 28,
            partial_name: "partials/pages/backyard/backyard",
            share_sheet_image_id: "4422b17d-6e18-4bbb-6e87-102fb9821c00"
        },
        "/backyard": {
            title: "Samara - Backyard Homes and ADUs",
            description: "Discover Samara's Backyard homes and ADUs. Elevated design, expertly crafted. Fast and easy installation. Solar-powered and future-ready.",
            class_names: "backyard",
            theme_color: "#000000",
            navigation_inverted: !0,
            position: 27,
            partial_name: "partials/pages/backyard/backyard",
            share_sheet_image_id: "dee522f0-e339-4516-1e61-0cb9fb83b300"
        },
        "/backyard/models": {
            title: "Backyard - ADU Models - Samara",
            description: "Explore the full lineup of Samara's Backyard ADU models, including studio, one bedroom, and two bedroom layouts ranging from 420 to 950 square feet.",
            class_names: "backyard backyard-models backyard-models-index",
            theme_color: "#000000",
            navigation_inverted: !0,
            position: 26,
            partial_name: "partials/pages/backyard/models",
            share_sheet_image_id: "28663ada-d1e4-451f-90af-131a0b1e1700"
        },
        "/backyard/how-it-works": {
            title: "Backyard – How It Works – Samara",
            description: "Learn how easy it is to install an accessory dwelling unit from Samara. From configuration to completion in as few as seven months.",
            class_names: "backyard how-it-works",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 25,
            partial_name: "partials/pages/backyard/how-it-works",
            share_sheet_image_id: "26440ce7-ba39-472d-0fec-c1d99823a500"
        },
        "/backyard/financing": {
            title: "ADU Financing in California - Samara",
            description: "Explore tailored ADU financing options in California with Samara, offering affordable, efficient solutions to help you finance your backyard home.",
            class_names: "backyard financing",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 24,
            partial_name: "partials/pages/financing",
            share_sheet_image_id: null
        },
        "/backyard/faq": {
            title: "Backyard – Frequently Asked Questions – Samara",
            description: "Find answers to the most asked questions about Backyard: building regulations, financial planning, construction, and more.",
            class_names: "backyard faq",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 23,
            partial_name: "partials/pages/backyard/faq",
            share_sheet_image_id: "525b3d2c-6270-4ef5-d824-ecd2f4edd000"
        },
        "/backyard/studio": {
            title: "Backyard Studio - Prefab Studio ADU - Samara",
            description: "Samara's prefab studio ADU is a small but mighty 420 sq. ft., featuring high cathedral ceilings, clever storage, and a fully-equipped kitchen designed for comfort and style. ",
            class_names: "backyard backyard-models backyard-models-studio",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 22,
            partial_name: "partials/pages/backyard/models/studio",
            share_sheet_image_id: "b60fe753-3258-4d18-aebf-200d8305f300"
        },
        "/backyard/one-bedroom": {
            title: "Backyard One Bedroom - 1 Bedroom ADU - Samara",
            description: "Samara’s 1 bedroom ADU features a spacious bathroom, ample storage, and a next-gen electric kitchen. It's the perfect blend of style and functionality in 540 square feet.",
            class_names: "backyard backyard-models backyard-models-onebed",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 21,
            partial_name: "partials/pages/backyard/models/onebed",
            share_sheet_image_id: "f30ce6f7-e670-4bf3-82cc-d33910a66a00"
        },
        "/backyard/two-bedroom": {
            title: "Backyard Two Bedroom - 2 Bedroom ADU - Samara",
            description: "Samara's 2 bedroom ADU offers 690 sq. ft. of flexible living space perfect for hosting guests, working from home, or generating rental income. Call it the ultimate flex.",
            class_names: "backyard backyard-models backyard-models-twobed",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 20,
            partial_name: "partials/pages/backyard/models/twobed",
            share_sheet_image_id: "13bf7b1a-901d-432f-bc02-e9978ee59500"
        },
        "/backyard/xl-8": {
            title: "Backyard XL 8 - 800 sq. ft. ADU - Samara",
            description: "Learn more about Backyard XL 8, Samara’s 800 sq. ft. ADU featuring two bedrooms and two baths, larger appliances, and plenty of storage. Perfect for whatever use you can dream up.",
            class_names: "backyard backyard-models backyard-models-xl",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 19,
            partial_name: "partials/pages/backyard/models/xl-8",
            share_sheet_image_id: "b9f187b1-bc1b-42f7-9973-e781d980ac00"
        },
        "/backyard/xl-10": {
            title: "Backyard XL 10 - 2 Bedroom, 2 Bath ADU - Samara",
            description: "Backyard XL 10 is Samara’s spacious 2 bedroom, 2 bath ADU with an upsized kitchen and living room and 950 sq. ft. of flexible space.",
            class_names: "backyard backyard-models backyard-models-xl-10",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 18,
            partial_name: "partials/pages/backyard/models/xl-10",
            share_sheet_image_id: "b851ca06-c7b5-4c2a-e2da-68d097780f00"
        },
        "/backyard/compare": {
            title: "Compare Backyard Models – Samara",
            description: "Compare the full lineup of Samara's Backyard ADU models, including studio, one bedroom, and two bedroom layouts ranging from 420 to 950 square feet.",
            class_names: "backyard backyard-compare",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 17,
            partial_name: "partials/pages/backyard/compare",
            share_sheet_image_id: null
        },
        "/backyard/configure": {
            title: "Customize Backyard – Samara",
            description: "Customize and get a quote for Samara's Backyard ADU. Elevated design, expertly crafted. Fast and easy installation. Solar-powered and future-ready.",
            class_names: "backyard configurator",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 16,
            partial_name: "partials/pages/backyard/configure",
            share_sheet_image_id: "a02d2050-630d-403d-d386-ccb3506c2300"
        },
        "/backyard/guides": {
            title: "California ADU Requirement Guides – Samara",
            description: "You’ll need a permit from your local planning department to build an ADU. Learn about the rules and regulations governing ADU construction across California and see what's required in your area.",
            class_names: "",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 15,
            partial_name: "partials/pages/insights/guides",
            share_sheet_image_id: null
        },
        "/news": {
            title: "News – Samara",
            description: "Read the latest news about Samara.",
            class_names: "newsroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 14,
            partial_name: "partials/pages/newsroom/newsroom",
            share_sheet_image_id: "7fd49401-f728-4c12-0229-3fe7abf62900"
        },
        "/insights": {
            title: "Insights — Samara",
            description: "",
            class_names: "backyard insights insights-index",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 13,
            partial_name: "partials/pages/insights/index",
            share_sheet_image_id: null
        },
        "/insights/life-with-backyard-meet-the-kurodas": {
            title: "Life with Backyard: Meet the Kurodas - Samara",
            description: "The Kurodas give us a tour of their cozy Backyard, built to help them stay close to family.",
            class_names: "backyard insights insights-story",
            theme_color: "#000000",
            navigation_inverted: !0,
            position: 12,
            partial_name: "partials/pages/insights",
            share_sheet_image_id: "4fc66bdc-2449-4d2d-d7f5-1dc35f7fd400"
        },
        "/jobs": {
            title: "Jobs – Samara",
            description: "Join Samara to help create new ways of living that help people dream bigger.",
            class_names: "jobs",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 11,
            partial_name: "partials/pages/jobs/jobs",
            share_sheet_image_id: "69bca2cb-e628-48ad-c8fc-ebd743b2c700"
        },
        "/showrooms": {
            title: "Showrooms – Samara",
            description: "Tour Backyard in person at an our San Francisco Bay Area and Los Angeles showrooms. Learn more about our locations and book a private tour.",
            class_names: "backyard showroom",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 10,
            partial_name: "partials/pages/showroom/showroom",
            share_sheet_image_id: "7f28da8b-6ec2-423a-f3a8-8a5e7ffa4500"
        },
        "/showrooms/redwood-city": {
            title: "Redwood City Showroom – Samara",
            description: "Tour Backyard in person at Samara Redwood City. Find our hours and learn how to book a private tour.",
            class_names: "backyard showroom tour",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 9,
            partial_name: "partials/pages/showroom/redwood-city",
            share_sheet_image_id: "8e379157-712c-4bea-a50a-38c36767db00"
        },
        "/showrooms/redwood-city/visit": {
            title: "Schedule Your Showroom Visit – Samara",
            description: "Tour Backyard in person at Samara Redwood City. Find our hours and learn how to book a private tour.",
            class_names: "backyard showroom tour",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 8,
            partial_name: "partials/pages/showroom/visit",
            share_sheet_image_id: "6b07701e-267e-4d6f-b0ea-a32fd8c27a00"
        },
        "/showrooms/thousand-oaks": {
            title: "Thousand Oaks Pop-up Showroom – Samara",
            description: "Tour Backyard in person at Samara Thousand Oaks. Find our hours and learn how to book a private tour.",
            class_names: "backyard showroom tour",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 7,
            partial_name: "partials/pages/showroom/thousand-oaks",
            share_sheet_image_id: "00cc326f-f637-4227-f98d-dff49167c900"
        },
        "/showrooms/thousand-oaks/visit": {
            title: "Schedule Your Showroom Visit – Samara",
            description: "",
            class_names: "",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 6,
            partial_name: "partials/pages/showroom/visit",
            share_sheet_image_id: null
        },
        "/developers": {
            title: "Samara for Developers",
            description: "Unlock the potential of your parcel with Backyard Multiunit.",
            class_names: "multiunit backyard",
            theme_color: "#000000",
            navigation_inverted: !0,
            position: 5,
            partial_name: "partials/pages/multiunit",
            share_sheet_image_id: "a6119568-ae31-44e7-e7a6-ad201ad8a500"
        },
        "/yoshino": {
            title: "Yoshino – Samara",
            description: "",
            class_names: "yoshino",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 4,
            partial_name: "partials/pages/yoshino",
            share_sheet_image_id: "c0af00a8-c2aa-41a5-8568-e8167fc15800"
        },
        "/terms-of-service": {
            title: "Terms of Service – Samara",
            description: "",
            class_names: "legal",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 3,
            partial_name: "partials/pages/terms-of-service",
            share_sheet_image_id: "834edb4b-cd31-423c-4ed3-1accf2066200"
        },
        "/privacy-policy": {
            title: "Privacy Policy – Samara",
            description: null,
            class_names: "legal",
            theme_color: "#000000",
            navigation_inverted: !1,
            position: 2,
            partial_name: "partials/pages/privacy-policy",
            share_sheet_image_id: "94f4f098-aa84-4d11-1b87-65836380a800"
        },
        "/la-fires": {
            title: "Support for Homeowners in Fire-Affected Southern California Communities – Samara",
            description: "Following the devastating fires across Los Angeles and Ventura counties, we're making our ADUs more accessible to homeowners in Los Angeles, Ventura, San Bernardino, Orange, Riverside, and San Diego counties through community recovery pricing. Learn about support options and timing.",
            class_names: "socal-wildfires",
            theme_color: "#000000",
            navigation_inverted: !0,
            position: 1,
            partial_name: "partials/pages/socal-wildfires",
            share_sheet_image_id: null
        }
    };
    let t = [],
        n = !1;

    function i() {
        n = t.length > 0, t.forEach((e => {
            e.element.parentElement || document.body.appendChild(e.element), (e.x + e.vx < 0 && e.vx < 0 || e.x + e.vx + 2 * e.radius > window.innerWidth && e.vx > 0) && (e.vx *= -1), (e.y + e.vy < 0 && e.vy < 0 || e.y + e.vy + 2 * e.radius > window.innerHeight && e.vy > 0) && (e.vy *= -1), (e.vx < -.5 || e.vx > .5) && (e.vx *= .99), (e.vy < -.5 || e.vy > .5) && (e.vy *= .99), e.x += e.vx, e.y += e.vy, e.x = Math.min(Math.max(e.x, 0), window.innerWidth - 2 * e.radius), e.y = Math.min(Math.max(e.y, 0), window.innerHeight - 2 * e.radius), e.element.style.transform = `translate3d(${e.x}px, ${e.y}px, 0)`
        })), t.length && requestAnimationFrame(i)
    }
    createDestroy(/^\/jobs.*/, (function() {
        if (t.length) return;
        const r = Object.keys(e).filter((e => e.startsWith("/jobs/"))).length;
        return t = [], Array(r).fill(null).forEach((() => {
                setTimeout((() => {
                    const e = function() {
                        const e = document.querySelector(".jobs .jobs");
                        if (!e) return;
                        const t = e.classList.contains("empty"),
                            n = Math.random() * (window.innerWidth - 7),
                            i = Math.random() * (window.innerHeight - 7),
                            r = 2 * Math.random() - 1,
                            a = 2 * Math.random() - 1,
                            s = Math.sqrt(r * r + a * a),
                            o = r / s * .5,
                            l = a / s * .5,
                            c = document.createElement("div");
                        return c.className = "dot", c.style.width = "14px", c.style.height = "14px", c.style.opacity = t ? 0.3 : null, {
                            x: n,
                            y: i,
                            vx: o,
                            vy: l,
                            radius: 7,
                            element: c
                        }
                    }();
                    void 0 !== e && t.push(e), n || i()
                }), 500 * Math.random() * r)
            })),
            function() {
                t.forEach((e => {
                    e.element && document.body.removeChild(e.element)
                })), t = []
            }
    }), "router:did-update-content")
})(), createDestroy(/^\/backyard\/.*/, (function() {
    const e = [Backyard.invertNavigation(), Backyard.loadImagesLazily(), Backyard.createInteriorPhotoCards(), function() {
        const e = document.querySelector(".backyard-models-floorplan-dimensions-image");
        return null === e ? () => {} : (e.addEventListener("mousemove", (function(e) {
            Tooltip.show("globe", "Tour in 3D", e.clientX, e.clientY)
        })), e.addEventListener("mouseleave", (function() {
            Tooltip.hide()
        })), function() {})
    }()];
    return function() {
        e.forEach((e => {
            e()
        }))
    }
})), createDestroy(/^\/developers.*/, (function() {
    return document.querySelector("nav .backyard-configure.multiunit").addEventListener("click", (function(e) {
        e.stopPropagation(), e.preventDefault();
        const t = document.querySelector(".multiunit-hr").getBoundingClientRect();
        window.scrollTo({
            top: window.scrollY + t.top,
            behavior: "smooth"
        })
    })), createApplication("multiunit")
}), "router:did-update-content"), createDestroy(/^\/news/, (function() {
    const e = [Backyard.invertNavigation()];
    return function() {
        e.forEach((e => {
            e()
        }))
    }
})), (() => {
    function e(e) {
        e.classList.add("newsroom-internal-feedback-visible"), setTimeout((() => {
            e.classList.remove("newsroom-internal-feedback-visible")
        }), 3e3)
    }
    globalThis.Newsroom = {
        copyText(t) {
            t.preventDefault();
            const n = document.querySelector("h1").innerText,
                i = Array.from(document.querySelectorAll("time, .newsroom-internal-body p, .newsroom-internal-body h2, .newsroom-internal-body h3, .newsroom-internal-body blockquote, .newsroom-internal-body li")).map((e => "LI" === e.nodeName ? `\n- ${e.innerText}\n` : `\n${e.innerText}\n`)).join("");
            navigator.clipboard.writeText(`${n}\n${i}`), e("button" === t.target.nodeName ? t.target : t.target.closest("button"))
        },
        downloadImages(e) {
            e.preventDefault(), document.querySelectorAll(".newsroom img[data-downloadable]").forEach(((e, t) => {
                setTimeout((() => {
                    const n = document.createElement("a");
                    n.href = e.src, n.target = "_blank";
                    const i = location.pathname.split("/"),
                        r = i[i.length - 1];
                    n.download = `${r}-${t}.jpg`, n.click()
                }), 100 * t)
            }))
        },
        copyLink(t) {
            navigator.clipboard.writeText(location.href), e(t.target)
        }
    }
})(), createDestroy(/^(\/showrooms|\/showrooms\/|\/showrooms\/.*)$/, (function() {
    const e = Date.now();
    document.querySelectorAll(".showroom-events").forEach((t => {
        const n = Showroom.events.filter((e => e.showroom === t.dataset.showroom));
        t.dataset.numberOfEvents = n.filter((t => Date.parse(t.start_at) > e)).length, t.querySelectorAll("li").forEach((t => {
            t.hidden = Date.parse(t.dataset.startAt) <= e
        }))
    }));
    const t = Backyard.loadImagesLazily();
    return function() {
        t()
    }
}), "router:did-update-content"), createDestroy(/^\/showrooms\/.*\/visit.*/, (function() {
    return createApplication("showroom")
}), "router:did-update-content"), globalThis.Showroom = {
    events: [{
        title: "3/22 Open House: Thousand Oaks",
        slug: "250322-open-house-thousand-oaks",
        showroom: "thousand-oaks",
        image_id: "e4aabca4-37ec-4044-9765-999dc9224a00",
        location_title: "",
        location_url: "",
        description: 'Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.\r\n\r\nWe’re located in the business center parking lot at the corner of Lakeview Canyon Road and Via Merida, across from Los Robles Hospital.\r\n\r\nPlease use these coordinates rather than the address to avoid being directed to the wrong side of the property: [34°09\'20.5"N 118°49\'00.6"W](https://maps.app.goo.gl/t1HqAGXTd5eZneik6){:target="_blank"}.',
        start_at: "2025-03-22T11:00:00.000+00:00",
        end_at: "2025-03-22T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "3/1 Open House: Thousand Oaks",
        slug: "250301-open-house-thousand-oaks",
        showroom: "thousand-oaks",
        image_id: null,
        location_title: "",
        location_url: "",
        description: 'Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.\r\n\r\nWe’re located in the business center parking lot at the corner of Lakeview Canyon Road and Via Merida, across from Los Robles Hospital.\r\n\r\nPlease use these coordinates rather than the address to avoid being directed to the wrong side of the property: [34°09\'20.5"N 118°49\'00.6"W](https://maps.app.goo.gl/t1HqAGXTd5eZneik6){:target="_blank"}.',
        start_at: "2025-03-01T11:00:00.000+00:00",
        end_at: "2025-03-02T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "3/8 Open House: Redwood City",
        slug: "250308-open-house-redwood-city",
        showroom: "redwood-city",
        image_id: "7e9efdfe-4862-4df1-4c2d-491086a4f600",
        location_title: "",
        location_url: "",
        description: "Drop by Samara Redwood City for a coffee and learn what the hype around Backyard is all about. Tour a Backyard Studio unit, check out our materials, and get answers to your questions from our team of specialists.",
        start_at: "2025-03-08T11:00:00.000+00:00",
        end_at: "2025-03-08T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "February Open House: Thousand Oaks",
        slug: "250215-open-house-thousand-oaks",
        showroom: "thousand-oaks",
        image_id: null,
        location_title: "",
        location_url: "",
        description: 'Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.\r\n\r\nWe’re located in the business center parking lot at the corner of Lakeview Canyon Road and Via Merida, across from Los Robles Hospital.\r\n\r\nPlease use these coordinates rather than the address to avoid being directed to the wrong side of the property: [34°09\'20.5"N 118°49\'00.6"W](https://maps.app.goo.gl/t1HqAGXTd5eZneik6){:target="_blank"}.',
        start_at: "2025-02-15T11:00:00.000+00:00",
        end_at: "2025-02-15T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "Fremont ADU Crane-in Block Party",
        slug: "250117-fremont-crane-in",
        showroom: "",
        image_id: "4309a528-a149-4008-54f7-8ba34f888a00",
        location_title: "Vogel Court, Fremont",
        location_url: "",
        description: "You’re invited to our prefab ADU crane-in block party in Fremont!\r\n\r\n- Watch Samara’s Backyard ADU get installed in minutes\r\n- Enjoy free boba and pan-Asian bites\r\n- Meet the Samara team and get a free same-day site assessment\r\n\r\nPlease RSVP for the crane-in schedule.",
        start_at: "2025-01-17T10:00:00.000+00:00",
        end_at: "2025-01-17T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "January Open House: Thousand Oaks",
        slug: "250125-open-house-thousand-oaks",
        showroom: "thousand-oaks",
        image_id: null,
        location_title: "",
        location_url: "",
        description: 'Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.\r\n\r\nWe’re located in the business center parking lot at the corner of Lakeview Canyon Road and Via Merida, across from Los Robles Hospital.\r\n\r\nPlease use these coordinates rather than the address to avoid being directed to the wrong side of the property: [34°09\'20.5"N 118°49\'00.6"W](https://maps.app.goo.gl/t1HqAGXTd5eZneik6){:target="_blank"}.',
        start_at: "2025-01-25T11:00:00.000+00:00",
        end_at: "2025-01-25T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "Capitola ADU Crane-in Block Party",
        slug: "241031-capitola-crane-in",
        showroom: "",
        image_id: "71c5e6a6-ce39-43f6-b5e2-e222b6987400",
        location_title: "1605 38th Ave, Capitola",
        location_url: "",
        description: "You’re invited to our prefab ADU crane-in block party in Capitola!\r\n\r\n- Watch Samara’s Backyard ADU get installed in minutes\r\n- Enjoy free farm-to-table bites from Pretty Good Advice\r\n- Meet the Samara team and get a free same-day site assessment\r\n\r\nPlease RSVP for the address and crane-in schedule.",
        start_at: "2024-10-31T10:00:00.000+00:00",
        end_at: "2024-10-31T13:00:00.000+00:00",
        is_published: !1
    }, {
        title: "January Open House: Thousand Oaks (rescheduled)",
        slug: "250111-open-house-thousand-oaks",
        showroom: "thousand-oaks",
        image_id: null,
        location_title: "",
        location_url: "",
        description: 'Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.\r\n\r\nWe’re located in the business center parking lot at the corner of Lakeview Canyon Road and Via Merida, across from Los Robles Hospital.\r\n\r\nPlease use these coordinates rather than the address to avoid being directed to the wrong side of the property: [34°09\'20.5"N 118°49\'00.6"W](https://maps.app.goo.gl/t1HqAGXTd5eZneik6){:target="_blank"}.',
        start_at: "2025-01-11T11:00:00.000+00:00",
        end_at: "2025-01-11T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "San Jose ADU Crane-in Block Party",
        slug: "241001-san-jose-crane-in",
        showroom: "",
        image_id: "b974dd5a-8992-4dd1-bad6-f953307f7600",
        location_title: "San Jose",
        location_url: "",
        description: "You’re invited to our prefab ADU crane-in block party in San Jose!\r\n\r\n- Watch Samara’s Backyard ADU get installed in minutes\r\n- Enjoy free boba and pan-Asian bites\r\n- Meet the Samara team and get a free same-day site assessment\r\n\r\nPlease RSVP for the address and crane-in schedule.",
        start_at: "2024-10-01T12:00:00.000+00:00",
        end_at: "2024-10-01T13:30:00.000+00:00",
        is_published: !1
    }, {
        title: "September Open House: Thousand Oaks",
        slug: "240921-open-house-thousand-oaks",
        showroom: "thousand-oaks",
        image_id: "b2866365-2525-496c-6348-e24581312900",
        location_title: "",
        location_url: "",
        description: "Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.",
        start_at: "2024-09-21T11:00:00.000+00:00",
        end_at: "2024-09-21T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "Open House: Thousand Oaks",
        slug: "open-house-thousand-oaks-240720",
        showroom: "thousand-oaks",
        image_id: null,
        location_title: "",
        location_url: "",
        description: "Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.",
        start_at: "2024-07-20T11:00:00.000+00:00",
        end_at: "2024-07-20T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "Livestream: Backyard 101 with Scott Wilson",
        slug: "livestream-backyard-101-with-scott-wilson-240605",
        showroom: "",
        image_id: "20ae49ce-5676-4b2d-8600-8e7e6f950b00",
        location_title: "Online (Zoom Meeting)",
        location_url: "",
        description: "Join Samara’s VP of Revenue, Scott Wilson, to get a crash course on Backyard, Samara's flagship accessory dwelling unit (ADU).\r\n\r\nIn this hourlong, interactive livestream he’ll cover:\r\n\r\n- Why ADUs are so popular, the laws around them, and the steps to get one\r\n- What sets Samara ADUs apart in design, quality, service, sustainability and manufacturing\r\n- ADU costs and how to finance them\r\n- Background on the Samara team, our factory in Mexico, and more",
        start_at: "2024-06-05T19:30:00.000+00:00",
        end_at: "2024-06-05T20:30:00.000+00:00",
        is_published: !1
    }, {
        title: "Webinar: Introducing Samara's Real Estate Partner Program",
        slug: "webinar-introducing-samaras-real-estate-partner-program",
        showroom: "redwood-city",
        image_id: "e3d2c7e0-3089-4414-9b55-234fed4b2b00",
        location_title: "Online (Zoom Meeting)",
        location_url: "",
        description: "For real estate professionals. Join our webinar to learn about Backyard, Samara's flagship accessory dwelling unit (ADU), and how to boost your income through our real estate partner program.\r\n\r\nWe'll cover:\r\n\r\n- ADU basics: why they're popular, what they cost, market insights, and more\r\n- Backyard 101: what sets Samara ADUs apart in design, quality, service, and sustainability\r\n- How to enroll in our partner program and our partner referral benefits\r\n\r\nReserve your spot today and build the future of housing in California with us!",
        start_at: "2024-04-26T13:00:00.000+00:00",
        end_at: "2024-04-26T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "Open House: Discover Backyard",
        slug: "open-house-discover-backyard",
        showroom: "redwood-city",
        image_id: null,
        location_title: null,
        location_url: null,
        description: "Drop by Samara Redwood City for a coffee and learn what the hype around Backyard is all about. Tour a Backyard Studio unit, check out our materials, and get answers to your questions from our team of specialists.",
        start_at: "2024-01-20T13:00:00.000+00:00",
        end_at: "2024-01-20T16:00:00.000+00:00",
        is_published: !1
    }, {
        title: "Watsonville Crane-in Event",
        slug: "watsonville-crane-in-event",
        showroom: "",
        image_id: "23012e6f-8477-4d63-179f-4040ab711900",
        location_title: "Watsonville, CA",
        location_url: "",
        description: "We’d love to see you at our crane-in event in Watsonville!\r\n\r\n- Watch Samara’s Backyard ADU get installed in minutes\r\n- Enjoy music, coffee, and other refreshments\r\n- Meet the Samara team and get a free site assessment\r\n\r\nPlease RSVP for the complete address and day-of schedule.\r\n",
        start_at: "2024-05-07T10:30:00.000+00:00",
        end_at: "2024-05-07T12:00:00.000+00:00",
        is_published: !1
    }, {
        title: "Open House: Thousand Oaks",
        slug: "open-house-thousand-oaks-240511",
        showroom: "thousand-oaks",
        image_id: null,
        location_title: "",
        location_url: "",
        description: "Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.",
        start_at: "2024-05-11T11:00:00.000+00:00",
        end_at: "2024-05-11T14:00:00.000+00:00",
        is_published: !1
    }, {
        title: "August Open House: Thousand Oaks",
        slug: "august-2024-open-house-thousand-oaks",
        showroom: "thousand-oaks",
        image_id: null,
        location_title: "",
        location_url: "",
        description: "Drop by our Thousand Oaks pop-up and tour our stunning one-bedroom Backyard unit. Light refreshments and great vibes guaranteed.\r\n",
        start_at: "2024-08-10T11:00:00.000+00:00",
        end_at: "2024-08-10T14:00:00.000+00:00",
        is_published: !1
    }],
    jumpTo(e) {
        const t = document.getElementById(e).getBoundingClientRect(),
            n = window.innerWidth <= 768 ? 100 : 120;
        window.scrollTo({
            top: t.top - n,
            behavior: "smooth"
        })
    }
}, createDestroy(/^\/la-fires/, (function() {
    const e = [Backyard.invertNavigation()];
    return function() {
        e.forEach((e => {
            e()
        }))
    }
})), globalThis.gtag = globalThis.gtag || console.info, window.getQuickEstimate = function(e, t = {}) {
    e.preventDefault(), e.stopPropagation(), gtag("event", "hello_get_quick_estimate");
    const n = {
        subject: 8
    };
    if (void 0 !== window.statsig) try {
        const e = window.statsig.getExperiment("hello-cta-october-24");
        null != e && void 0 !== e.groupName && (n.marketingNotes = e.groupName)
    } catch (e) {
        console.info("Statsig experiment not available")
    }
    Contact.show({
        page: "hello",
        data: n,
        ...t
    })
}, document.addEventListener("DOMContentLoaded", (() => {
    document.body.classList.remove("no-javascript")
}));
//# sourceMappingURL=index.js.map