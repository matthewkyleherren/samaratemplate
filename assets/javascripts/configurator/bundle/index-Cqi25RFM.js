function t() {}! function () {
    const t = {
        NODE_ENV: "production",
        MAPBOX_ACCESS_TOKEN: "pk.eyJ1Ijoic2FtYXJhLXdlYm1hc3RlciIsImEiOiJjbDc0bTY3NjMwNmh2M3VudG5sc2hxOGp2In0.DHQc2ZACY-ksnoPFXEP9qg"
    };
    try {
        if (process) return process.env = Object.assign({}, process.env), void Object.assign(process.env, t)
    } catch (t) {}
    globalThis.process = {
        env: t
    }
}();
const e = t => t;

function n(t) {
    return t()
}

function r() {
    return Object.create(null)
}

function i(t) {
    t.forEach(n)
}

function o(t) {
    return "function" == typeof t
}

function a(t, e) {
    return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t
}
let s;

function l(t, e) {
    return t === e || (s || (s = document.createElement("a")), s.href = e, t === s.href)
}

function c(e, ...n) {
    if (null == e) {
        for (const t of n) t(void 0);
        return t
    }
    const r = e.subscribe(...n);
    return r.unsubscribe ? () => r.unsubscribe() : r
}

function u(t) {
    let e;
    return c(t, (t => e = t))(), e
}

function h(t, e, n) {
    t.$$.on_destroy.push(c(e, n))
}

function d(t, e, n, r) {
    if (t) {
        const i = p(t, e, n, r);
        return t[0](i)
    }
}

function p(t, e, n, r) {
    return t[1] && r ? function (t, e) {
        for (const n in e) t[n] = e[n];
        return t
    }(n.ctx.slice(), t[1](r(e))) : n.ctx
}

function f(t, e, n, r) {
    if (t[2] && r) {
        const i = t[2](r(n));
        if (void 0 === e.dirty) return i;
        if ("object" == typeof i) {
            const t = [],
                n = Math.max(e.dirty.length, i.length);
            for (let r = 0; r < n; r += 1) t[r] = e.dirty[r] | i[r];
            return t
        }
        return e.dirty | i
    }
    return e.dirty
}

function m(t, e, n, r, i, o) {
    if (i) {
        const a = p(e, n, r, o);
        t.p(a, i)
    }
}

function g(t) {
    if (t.ctx.length > 32) {
        const e = [],
            n = t.ctx.length / 32;
        for (let t = 0; t < n; t++) e[t] = -1;
        return e
    }
    return -1
}

function A(t) {
    return null == t ? "" : t
}

function v(t) {
    const e = "string" == typeof t && t.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
    return e ? [parseFloat(e[1]), e[2] || "px"] : [t, "px"]
}
const _ = "undefined" != typeof window;
let y = _ ? () => window.performance.now() : () => Date.now(),
    E = _ ? t => requestAnimationFrame(t) : t;
const x = new Set;

function b(t) {
    x.forEach((e => {
        e.c(t) || (x.delete(e), e.f())
    })), 0 !== x.size && E(b)
}

function w(t) {
    let e;
    return 0 === x.size && E(b), {
        promise: new Promise((n => {
            x.add(e = {
                c: t,
                f: n
            })
        })),
        abort() {
            x.delete(e)
        }
    }
}
const C = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;

function S(t, e) {
    t.appendChild(e)
}

function I(t) {
    if (!t) return document;
    const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;
    return e && e.host ? e : t.ownerDocument
}

function M(t) {
    const e = L("style");
    return e.textContent = "/* empty */",
        function (t, e) {
            S(t.head || t, e), e.sheet
        }(I(t), e), e.sheet
}

function T(t, e, n) {
    t.insertBefore(e, n || null)
}

function B(t) {
    t.parentNode && t.parentNode.removeChild(t)
}

function R(t, e) {
    for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e)
}

function L(t) {
    return document.createElement(t)
}

function D(t) {
    return document.createElementNS("http://www.w3.org/2000/svg", t)
}

function P(t) {
    return document.createTextNode(t)
}

function O() {
    return P(" ")
}

function k() {
    return P("")
}

function U(t, e, n, r) {
    return t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r)
}

function N(t, e, n) {
    null == n ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n)
}

function F(t, e) {
    e = "" + e, t.data !== e && (t.data = e)
}

function Q(t, e) {
    t.value = null == e ? "" : e
}

function $(t, e, n, r) {
    null == n ? t.style.removeProperty(e) : t.style.setProperty(e, n, "")
}

function G(t, e, n) {
    for (let n = 0; n < t.options.length; n += 1) {
        const r = t.options[n];
        if (r.__value === e) return void(r.selected = !0)
    }
    n && void 0 === e || (t.selectedIndex = -1)
}

function H(t, e, n) {
    t.classList.toggle(e, !!n)
}

function z(t, e, {
    bubbles: n = !1,
    cancelable: r = !1
} = {}) {
    return new CustomEvent(t, {
        detail: e,
        bubbles: n,
        cancelable: r
    })
}
class V {
    is_svg = !1;
    e = void 0;
    n = void 0;
    t = void 0;
    a = void 0;
    constructor(t = !1) {
        this.is_svg = t, this.e = this.n = null
    }
    c(t) {
        this.h(t)
    }
    m(t, e, n = null) {
        this.e || (this.is_svg ? this.e = D(e.nodeName) : this.e = L(11 === e.nodeType ? "TEMPLATE" : e.nodeName), this.t = "TEMPLATE" !== e.tagName ? e : e.content, this.c(t)), this.i(n)
    }
    h(t) {
        this.e.innerHTML = t, this.n = Array.from("TEMPLATE" === this.e.nodeName ? this.e.content.childNodes : this.e.childNodes)
    }
    i(t) {
        for (let e = 0; e < this.n.length; e += 1) T(this.t, this.n[e], t)
    }
    p(t) {
        this.d(), this.h(t), this.i(this.a)
    }
    d() {
        this.n.forEach(B)
    }
}
const W = new Map;
let j, X = 0;

function q(t, e, n, r, i, o, a, s = 0) {
    const l = 16.666 / r;
    let c = "{\n";
    for (let t = 0; t <= 1; t += l) {
        const r = e + (n - e) * o(t);
        c += 100 * t + `%{${a(r,1-r)}}\n`
    }
    const u = c + `100% {${a(n,1-n)}}\n}`,
        h = `__svelte_${function(t){let e=5381,n=t.length;for(;n--;)e=(e<<5)-e^t.charCodeAt(n);return e>>>0}(u)}_${s}`,
        d = I(t),
        {
            stylesheet: p,
            rules: f
        } = W.get(d) || function (t, e) {
            const n = {
                stylesheet: M(e),
                rules: {}
            };
            return W.set(t, n), n
        }(d, t);
    f[h] || (f[h] = !0, p.insertRule(`@keyframes ${h} ${u}`, p.cssRules.length));
    const m = t.style.animation || "";
    return t.style.animation = `${m?`${m}, `:""}${h} ${r}ms linear ${i}ms 1 both`, X += 1, h
}

function Y(t, e) {
    const n = (t.style.animation || "").split(", "),
        r = n.filter(e ? t => t.indexOf(e) < 0 : t => -1 === t.indexOf("__svelte")),
        i = n.length - r.length;
    i && (t.style.animation = r.join(", "), X -= i, X || E((() => {
        X || (W.forEach((t => {
            const {
                ownerNode: e
            } = t.stylesheet;
            e && B(e)
        })), W.clear())
    })))
}

function K(t) {
    j = t
}

function J() {
    if (!j) throw new Error("Function called outside component initialization");
    return j
}

function Z(t) {
    J().$$.on_mount.push(t)
}

function tt(t) {
    J().$$.after_update.push(t)
}

function et(t) {
    J().$$.on_destroy.push(t)
}

function nt() {
    const t = J();
    return (e, n, {
        cancelable: r = !1
    } = {}) => {
        const i = t.$$.callbacks[e];
        if (i) {
            const o = z(e, n, {
                cancelable: r
            });
            return i.slice().forEach((e => {
                e.call(t, o)
            })), !o.defaultPrevented
        }
        return !0
    }
}

function rt(t, e) {
    return J().$$.context.set(t, e), e
}
const it = [],
    ot = [];
let at = [];
const st = [],
    lt = Promise.resolve();
let ct = !1;

function ut(t) {
    at.push(t)
}

function ht(t) {
    st.push(t)
}
const dt = new Set;
let pt, ft = 0;

function mt() {
    if (0 !== ft) return;
    const t = j;
    do {
        try {
            for (; ft < it.length;) {
                const t = it[ft];
                ft++, K(t), gt(t.$$)
            }
        } catch (t) {
            throw it.length = 0, ft = 0, t
        }
        for (K(null), it.length = 0, ft = 0; ot.length;) ot.pop()();
        for (let t = 0; t < at.length; t += 1) {
            const e = at[t];
            dt.has(e) || (dt.add(e), e())
        }
        at.length = 0
    } while (it.length);
    for (; st.length;) st.pop()();
    ct = !1, dt.clear(), K(t)
}

function gt(t) {
    if (null !== t.fragment) {
        t.update(), i(t.before_update);
        const e = t.dirty;
        t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(ut)
    }
}

function At() {
    return pt || (pt = Promise.resolve(), pt.then((() => {
        pt = null
    }))), pt
}

function vt(t, e, n) {
    t.dispatchEvent(z(`${e?"intro":"outro"}${n}`))
}
const _t = new Set;
let yt;

function Et() {
    yt = {
        r: 0,
        c: [],
        p: yt
    }
}

function xt() {
    yt.r || i(yt.c), yt = yt.p
}

function bt(t, e) {
    t && t.i && (_t.delete(t), t.i(e))
}

function wt(t, e, n, r) {
    if (t && t.o) {
        if (_t.has(t)) return;
        _t.add(t), yt.c.push((() => {
            _t.delete(t), r && (n && t.d(1), r())
        })), t.o(e)
    } else r && r()
}
const Ct = {
    duration: 0
};

function St(t) {
    return void 0 !== t?.length ? t : Array.from(t)
}

function It(t, e, n) {
    const r = t.$$.props[e];
    void 0 !== r && (t.$$.bound[r] = n, n(t.$$.ctx[r]))
}

function Mt(t) {
    t && t.c()
}

function Tt(t, e, r) {
    const {
        fragment: a,
        after_update: s
    } = t.$$;
    a && a.m(e, r), ut((() => {
        const e = t.$$.on_mount.map(n).filter(o);
        t.$$.on_destroy ? t.$$.on_destroy.push(...e) : i(e), t.$$.on_mount = []
    })), s.forEach(ut)
}

function Bt(t, e) {
    const n = t.$$;
    null !== n.fragment && (! function (t) {
        const e = [],
            n = [];
        at.forEach((r => -1 === t.indexOf(r) ? e.push(r) : n.push(r))), n.forEach((t => t())), at = e
    }(n.after_update), i(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = [])
}

function Rt(t, e) {
    -1 === t.$$.dirty[0] && (it.push(t), ct || (ct = !0, lt.then(mt)), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31
}

function Lt(e, n, o, a, s, l, c = null, u = [-1]) {
    const h = j;
    K(e);
    const d = e.$$ = {
        fragment: null,
        ctx: [],
        props: l,
        update: t,
        not_equal: s,
        bound: r(),
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(n.context || (h ? h.$$.context : [])),
        callbacks: r(),
        dirty: u,
        skip_bound: !1,
        root: n.target || h.$$.root
    };
    c && c(d.root);
    let p = !1;
    if (d.ctx = o ? o(e, n.props || {}, ((t, n, ...r) => {
            const i = r.length ? r[0] : n;
            return d.ctx && s(d.ctx[t], d.ctx[t] = i) && (!d.skip_bound && d.bound[t] && d.bound[t](i), p && Rt(e, t)), n
        })) : [], d.update(), p = !0, i(d.before_update), d.fragment = !!a && a(d.ctx), n.target) {
        if (n.hydrate) {
            const t = function (t) {
                return Array.from(t.childNodes)
            }(n.target);
            d.fragment && d.fragment.l(t), t.forEach(B)
        } else d.fragment && d.fragment.c();
        n.intro && bt(e.$$.fragment), Tt(e, n.target, n.anchor), mt()
    }
    K(h)
}
class Dt {
    $$ = void 0;
    $$set = void 0;
    $destroy() {
        Bt(this, 1), this.$destroy = t
    }
    $on(e, n) {
        if (!o(n)) return t;
        const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
        return r.push(n), () => {
            const t = r.indexOf(n); - 1 !== t && r.splice(t, 1)
        }
    }
    $set(t) {
        var e;
        this.$$set && (e = t, 0 !== Object.keys(e).length) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
    }
}

function Pt(t) {
    const e = t - 1;
    return e * e * e + 1
}

function Ot(t, {
    delay: e = 0,
    duration: n = 400,
    easing: r = Pt,
    x: i = 0,
    y: o = 0,
    opacity: a = 0
} = {}) {
    const s = getComputedStyle(t),
        l = +s.opacity,
        c = "none" === s.transform ? "" : s.transform,
        u = l * (1 - a),
        [h, d] = v(i),
        [p, f] = v(o);
    return {
        delay: e,
        duration: n,
        easing: r,
        css: (t, e) => `\n\t\t\ttransform: ${c} translate(${(1-t)*h}${d}, ${(1-t)*p}${f});\n\t\t\topacity: ${l-u*e}`
    }
}

function kt(t) {
    let e;
    const n = t[9].default,
        r = d(n, t, t[8], null);
    return {
        c() {
            r && r.c()
        },
        m(t, n) {
            r && r.m(t, n), e = !0
        },
        p(t, i) {
            r && r.p && (!e || 256 & i) && m(r, n, t, t[8], e ? f(n, t[8], i, null) : g(t[8]), null)
        },
        i(t) {
            e || (bt(r, t), e = !0)
        },
        o(t) {
            wt(r, t), e = !1
        },
        d(t) {
            r && r.d(t)
        }
    }
}

function Ut(n) {
    let r, a, s, l;
    const c = n[9].default,
        u = d(c, n, n[8], null);
    return {
        c() {
            r = L("div"), u && u.c(), N(r, "class", "svelte-1qe6l86")
        },
        m(t, e) {
            T(t, r, e), u && u.m(r, null), l = !0
        },
        p(t, e) {
            n = t, u && u.p && (!l || 256 & e) && m(u, c, n, n[8], l ? f(c, n[8], e, null) : g(n[8]), null)
        },
        i(i) {
            l || (bt(u, i), ut((() => {
                l && (s && s.end(1), a = function (n, r, i) {
                    const a = {
                        direction: "in"
                    };
                    let s, l, c = r(n, i, a),
                        u = !1,
                        h = 0;

                    function d() {
                        s && Y(n, s)
                    }

                    function p() {
                        const {
                            delay: r = 0,
                            duration: i = 300,
                            easing: o = e,
                            tick: a = t,
                            css: p
                        } = c || Ct;
                        p && (s = q(n, 0, 1, i, r, o, p, h++)), a(0, 1);
                        const f = y() + r,
                            m = f + i;
                        l && l.abort(), u = !0, ut((() => vt(n, !0, "start"))), l = w((t => {
                            if (u) {
                                if (t >= m) return a(1, 0), vt(n, !0, "end"), d(), u = !1;
                                if (t >= f) {
                                    const e = o((t - f) / i);
                                    a(e, 1 - e)
                                }
                            }
                            return u
                        }))
                    }
                    let f = !1;
                    return {
                        start() {
                            f || (f = !0, Y(n), o(c) ? (c = c(a), At().then(p)) : p())
                        },
                        invalidate() {
                            f = !1
                        },
                        end() {
                            u && (d(), u = !1)
                        }
                    }
                }(r, Ot, n[3]), a.start())
            })), l = !0)
        },
        o(c) {
            wt(u, c), a && a.invalidate(), s = function (n, r, a) {
                const s = {
                    direction: "out"
                };
                let l, c = r(n, a, s),
                    u = !0;
                const h = yt;
                let d;

                function p() {
                    const {
                        delay: r = 0,
                        duration: o = 300,
                        easing: a = e,
                        tick: s = t,
                        css: p
                    } = c || Ct;
                    p && (l = q(n, 1, 0, o, r, a, p));
                    const f = y() + r,
                        m = f + o;
                    ut((() => vt(n, !1, "start"))), "inert" in n && (d = n.inert, n.inert = !0), w((t => {
                        if (u) {
                            if (t >= m) return s(0, 1), vt(n, !1, "end"), --h.r || i(h.c), !1;
                            if (t >= f) {
                                const e = a((t - f) / o);
                                s(1 - e, e)
                            }
                        }
                        return u
                    }))
                }
                return h.r += 1, o(c) ? At().then((() => {
                    c = c(s), p()
                })) : p(), {
                    end(t) {
                        t && "inert" in n && (n.inert = d), t && c.tick && c.tick(1, 0), u && (l && Y(n, l), u = !1)
                    }
                }
            }(r, Ot, n[2]), l = !1
        },
        d(t) {
            t && B(r), u && u.d(t), t && s && s.end()
        }
    }
}

function Nt(t) {
    let e, n, r, i;
    const o = [Ut, kt],
        a = [];

    function s(t, e) {
        return t[1] && !t[4] ? 0 : 1
    }
    return e = s(t), n = a[e] = o[e](t), {
        c() {
            n.c(), r = k()
        },
        m(t, n) {
            a[e].m(t, n), T(t, r, n), i = !0
        },
        p(t, i) {
            let l = e;
            e = s(t), e === l ? a[e].p(t, i) : (Et(), wt(a[l], 1, 1, (() => {
                a[l] = null
            })), xt(), n = a[e], n ? n.p(t, i) : (n = a[e] = o[e](t), n.c()), bt(n, 1), n.m(r.parentNode, r))
        },
        i(t) {
            i || (bt(n), i = !0)
        },
        o(t) {
            wt(n), i = !1
        },
        d(t) {
            t && B(r), a[e].d(t)
        }
    }
}

function Ft(e) {
    let n, r, i = e[0],
        o = Nt(e);
    return {
        c() {
            o.c(), n = k()
        },
        m(t, e) {
            o.m(t, e), T(t, n, e), r = !0
        },
        p(e, [r]) {
            1 & r && a(i, i = e[0]) ? (Et(), wt(o, 1, 1, t), xt(), o = Nt(e), o.c(), bt(o, 1), o.m(n.parentNode, n)) : o.p(e, r)
        },
        i(t) {
            r || (bt(o), r = !0)
        },
        o(t) {
            wt(o), r = !1
        },
        d(t) {
            t && B(n), o.d(t)
        }
    }
}

function Qt(t, e, n) {
    let r, i, o, a, {
            $$slots: s = {},
            $$scope: l
        } = e,
        {
            index: c
        } = e,
        {
            isEnabled: u = !0
        } = e,
        {
            shouldControlGlobalScroll: h = !1
        } = e,
        d = !0 === window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    var p;
    return p = () => {
        h && (document.documentElement.style.overflow = "clip", setTimeout((() => {
            window.scrollTo(0, 0)
        }), 300), setTimeout((() => {
            document.documentElement.style.overflow = null
        }), 600))
    }, J().$$.before_update.push(p), tt((() => {
        n(6, a = c)
    })), t.$$set = t => {
        "index" in t && n(0, c = t.index), "isEnabled" in t && n(1, u = t.isEnabled), "shouldControlGlobalScroll" in t && n(5, h = t.shouldControlGlobalScroll), "$$scope" in t && n(8, l = t.$$scope)
    }, t.$$.update = () => {
        65 & t.$$.dirty && n(7, r = c < a ? -1 : 1), 128 & t.$$.dirty && n(3, i = {
            delay: 300,
            duration: 400,
            x: 10 * r
        }), 128 & t.$$.dirty && n(2, o = {
            duration: 200,
            x: -10 * r
        })
    }, [c, u, o, i, d, h, a, r, l, s]
}
"undefined" != typeof window && (window.__svelte || (window.__svelte = {
    v: new Set
})).v.add("4"), (() => {
    var t = {
            486: function (t, e, n) {
                var r;
                /**
                 * @license
                 * Lodash <https://lodash.com/>
                 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
                 * Released under MIT license <https://lodash.com/license>
                 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                 */
                t = n.nmd(t),
                    function () {
                        var i, o = "Expected a function",
                            a = "__lodash_hash_undefined__",
                            s = "__lodash_placeholder__",
                            l = 32,
                            c = 128,
                            u = 256,
                            h = 1 / 0,
                            d = 9007199254740991,
                            p = NaN,
                            f = 4294967295,
                            m = [
                                ["ary", c],
                                ["bind", 1],
                                ["bindKey", 2],
                                ["curry", 8],
                                ["curryRight", 16],
                                ["flip", 512],
                                ["partial", l],
                                ["partialRight", 64],
                                ["rearg", u]
                            ],
                            g = "[object Arguments]",
                            A = "[object Array]",
                            v = "[object Boolean]",
                            _ = "[object Date]",
                            y = "[object Error]",
                            E = "[object Function]",
                            x = "[object GeneratorFunction]",
                            b = "[object Map]",
                            w = "[object Number]",
                            C = "[object Object]",
                            S = "[object Promise]",
                            I = "[object RegExp]",
                            M = "[object Set]",
                            T = "[object String]",
                            B = "[object Symbol]",
                            R = "[object WeakMap]",
                            L = "[object ArrayBuffer]",
                            D = "[object DataView]",
                            P = "[object Float32Array]",
                            O = "[object Float64Array]",
                            k = "[object Int8Array]",
                            U = "[object Int16Array]",
                            N = "[object Int32Array]",
                            F = "[object Uint8Array]",
                            Q = "[object Uint8ClampedArray]",
                            $ = "[object Uint16Array]",
                            G = "[object Uint32Array]",
                            H = /\b__p \+= '';/g,
                            z = /\b(__p \+=) '' \+/g,
                            V = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                            W = /&(?:amp|lt|gt|quot|#39);/g,
                            j = /[&<>"']/g,
                            X = RegExp(W.source),
                            q = RegExp(j.source),
                            Y = /<%-([\s\S]+?)%>/g,
                            K = /<%([\s\S]+?)%>/g,
                            J = /<%=([\s\S]+?)%>/g,
                            Z = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                            tt = /^\w*$/,
                            et = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                            nt = /[\\^$.*+?()[\]{}|]/g,
                            rt = RegExp(nt.source),
                            it = /^\s+/,
                            ot = /\s/,
                            at = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                            st = /\{\n\/\* \[wrapped with (.+)\] \*/,
                            lt = /,? & /,
                            ct = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                            ut = /[()=,{}\[\]\/\s]/,
                            ht = /\\(\\)?/g,
                            dt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                            pt = /\w*$/,
                            ft = /^[-+]0x[0-9a-f]+$/i,
                            mt = /^0b[01]+$/i,
                            gt = /^\[object .+?Constructor\]$/,
                            At = /^0o[0-7]+$/i,
                            vt = /^(?:0|[1-9]\d*)$/,
                            _t = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                            yt = /($^)/,
                            Et = /['\n\r\u2028\u2029\\]/g,
                            xt = "\\ud800-\\udfff",
                            bt = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
                            wt = "\\u2700-\\u27bf",
                            Ct = "a-z\\xdf-\\xf6\\xf8-\\xff",
                            St = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                            It = "\\ufe0e\\ufe0f",
                            Mt = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                            Tt = "['’]",
                            Bt = "[" + xt + "]",
                            Rt = "[" + Mt + "]",
                            Lt = "[" + bt + "]",
                            Dt = "\\d+",
                            Pt = "[" + wt + "]",
                            Ot = "[" + Ct + "]",
                            kt = "[^" + xt + Mt + Dt + wt + Ct + St + "]",
                            Ut = "\\ud83c[\\udffb-\\udfff]",
                            Nt = "[^" + xt + "]",
                            Ft = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                            Qt = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                            $t = "[" + St + "]",
                            Gt = "\\u200d",
                            Ht = "(?:" + Ot + "|" + kt + ")",
                            zt = "(?:" + $t + "|" + kt + ")",
                            Vt = "(?:['’](?:d|ll|m|re|s|t|ve))?",
                            Wt = "(?:['’](?:D|LL|M|RE|S|T|VE))?",
                            jt = "(?:" + Lt + "|" + Ut + ")" + "?",
                            Xt = "[" + It + "]?",
                            qt = Xt + jt + ("(?:" + Gt + "(?:" + [Nt, Ft, Qt].join("|") + ")" + Xt + jt + ")*"),
                            Yt = "(?:" + [Pt, Ft, Qt].join("|") + ")" + qt,
                            Kt = "(?:" + [Nt + Lt + "?", Lt, Ft, Qt, Bt].join("|") + ")",
                            Jt = RegExp(Tt, "g"),
                            Zt = RegExp(Lt, "g"),
                            te = RegExp(Ut + "(?=" + Ut + ")|" + Kt + qt, "g"),
                            ee = RegExp([$t + "?" + Ot + "+" + Vt + "(?=" + [Rt, $t, "$"].join("|") + ")", zt + "+" + Wt + "(?=" + [Rt, $t + Ht, "$"].join("|") + ")", $t + "?" + Ht + "+" + Vt, $t + "+" + Wt, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Dt, Yt].join("|"), "g"),
                            ne = RegExp("[" + Gt + xt + bt + It + "]"),
                            re = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                            ie = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                            oe = -1,
                            ae = {};
                        ae[P] = ae[O] = ae[k] = ae[U] = ae[N] = ae[F] = ae[Q] = ae[$] = ae[G] = !0, ae[g] = ae[A] = ae[L] = ae[v] = ae[D] = ae[_] = ae[y] = ae[E] = ae[b] = ae[w] = ae[C] = ae[I] = ae[M] = ae[T] = ae[R] = !1;
                        var se = {};
                        se[g] = se[A] = se[L] = se[D] = se[v] = se[_] = se[P] = se[O] = se[k] = se[U] = se[N] = se[b] = se[w] = se[C] = se[I] = se[M] = se[T] = se[B] = se[F] = se[Q] = se[$] = se[G] = !0, se[y] = se[E] = se[R] = !1;
                        var le = {
                                "\\": "\\",
                                "'": "'",
                                "\n": "n",
                                "\r": "r",
                                "\u2028": "u2028",
                                "\u2029": "u2029"
                            },
                            ce = parseFloat,
                            ue = parseInt,
                            he = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                            de = "object" == typeof self && self && self.Object === Object && self,
                            pe = he || de || Function("return this")(),
                            fe = e && !e.nodeType && e,
                            me = fe && t && !t.nodeType && t,
                            ge = me && me.exports === fe,
                            Ae = ge && he.process,
                            ve = function () {
                                try {
                                    var t = me && me.require && me.require("util").types;
                                    return t || Ae && Ae.binding && Ae.binding("util")
                                } catch (t) {}
                            }(),
                            _e = ve && ve.isArrayBuffer,
                            ye = ve && ve.isDate,
                            Ee = ve && ve.isMap,
                            xe = ve && ve.isRegExp,
                            be = ve && ve.isSet,
                            we = ve && ve.isTypedArray;

                        function Ce(t, e, n) {
                            switch (n.length) {
                                case 0:
                                    return t.call(e);
                                case 1:
                                    return t.call(e, n[0]);
                                case 2:
                                    return t.call(e, n[0], n[1]);
                                case 3:
                                    return t.call(e, n[0], n[1], n[2])
                            }
                            return t.apply(e, n)
                        }

                        function Se(t, e, n, r) {
                            for (var i = -1, o = null == t ? 0 : t.length; ++i < o;) {
                                var a = t[i];
                                e(r, a, n(a), t)
                            }
                            return r
                        }

                        function Ie(t, e) {
                            for (var n = -1, r = null == t ? 0 : t.length; ++n < r && !1 !== e(t[n], n, t););
                            return t
                        }

                        function Me(t, e) {
                            for (var n = null == t ? 0 : t.length; n-- && !1 !== e(t[n], n, t););
                            return t
                        }

                        function Te(t, e) {
                            for (var n = -1, r = null == t ? 0 : t.length; ++n < r;)
                                if (!e(t[n], n, t)) return !1;
                            return !0
                        }

                        function Be(t, e) {
                            for (var n = -1, r = null == t ? 0 : t.length, i = 0, o = []; ++n < r;) {
                                var a = t[n];
                                e(a, n, t) && (o[i++] = a)
                            }
                            return o
                        }

                        function Re(t, e) {
                            return !!(null == t ? 0 : t.length) && $e(t, e, 0) > -1
                        }

                        function Le(t, e, n) {
                            for (var r = -1, i = null == t ? 0 : t.length; ++r < i;)
                                if (n(e, t[r])) return !0;
                            return !1
                        }

                        function De(t, e) {
                            for (var n = -1, r = null == t ? 0 : t.length, i = Array(r); ++n < r;) i[n] = e(t[n], n, t);
                            return i
                        }

                        function Pe(t, e) {
                            for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
                            return t
                        }

                        function Oe(t, e, n, r) {
                            var i = -1,
                                o = null == t ? 0 : t.length;
                            for (r && o && (n = t[++i]); ++i < o;) n = e(n, t[i], i, t);
                            return n
                        }

                        function ke(t, e, n, r) {
                            var i = null == t ? 0 : t.length;
                            for (r && i && (n = t[--i]); i--;) n = e(n, t[i], i, t);
                            return n
                        }

                        function Ue(t, e) {
                            for (var n = -1, r = null == t ? 0 : t.length; ++n < r;)
                                if (e(t[n], n, t)) return !0;
                            return !1
                        }
                        var Ne = Ve("length");

                        function Fe(t, e, n) {
                            var r;
                            return n(t, (function (t, n, i) {
                                if (e(t, n, i)) return r = n, !1
                            })), r
                        }

                        function Qe(t, e, n, r) {
                            for (var i = t.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i;)
                                if (e(t[o], o, t)) return o;
                            return -1
                        }

                        function $e(t, e, n) {
                            return e == e ? function (t, e, n) {
                                var r = n - 1,
                                    i = t.length;
                                for (; ++r < i;)
                                    if (t[r] === e) return r;
                                return -1
                            }(t, e, n) : Qe(t, He, n)
                        }

                        function Ge(t, e, n, r) {
                            for (var i = n - 1, o = t.length; ++i < o;)
                                if (r(t[i], e)) return i;
                            return -1
                        }

                        function He(t) {
                            return t != t
                        }

                        function ze(t, e) {
                            var n = null == t ? 0 : t.length;
                            return n ? Xe(t, e) / n : p
                        }

                        function Ve(t) {
                            return function (e) {
                                return null == e ? i : e[t]
                            }
                        }

                        function We(t) {
                            return function (e) {
                                return null == t ? i : t[e]
                            }
                        }

                        function je(t, e, n, r, i) {
                            return i(t, (function (t, i, o) {
                                n = r ? (r = !1, t) : e(n, t, i, o)
                            })), n
                        }

                        function Xe(t, e) {
                            for (var n, r = -1, o = t.length; ++r < o;) {
                                var a = e(t[r]);
                                a !== i && (n = n === i ? a : n + a)
                            }
                            return n
                        }

                        function qe(t, e) {
                            for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
                            return r
                        }

                        function Ye(t) {
                            return t ? t.slice(0, fn(t) + 1).replace(it, "") : t
                        }

                        function Ke(t) {
                            return function (e) {
                                return t(e)
                            }
                        }

                        function Je(t, e) {
                            return De(e, (function (e) {
                                return t[e]
                            }))
                        }

                        function Ze(t, e) {
                            return t.has(e)
                        }

                        function tn(t, e) {
                            for (var n = -1, r = t.length; ++n < r && $e(e, t[n], 0) > -1;);
                            return n
                        }

                        function en(t, e) {
                            for (var n = t.length; n-- && $e(e, t[n], 0) > -1;);
                            return n
                        }
                        var nn = We({
                                "À": "A",
                                "Á": "A",
                                "Â": "A",
                                "Ã": "A",
                                "Ä": "A",
                                "Å": "A",
                                "à": "a",
                                "á": "a",
                                "â": "a",
                                "ã": "a",
                                "ä": "a",
                                "å": "a",
                                "Ç": "C",
                                "ç": "c",
                                "Ð": "D",
                                "ð": "d",
                                "È": "E",
                                "É": "E",
                                "Ê": "E",
                                "Ë": "E",
                                "è": "e",
                                "é": "e",
                                "ê": "e",
                                "ë": "e",
                                "Ì": "I",
                                "Í": "I",
                                "Î": "I",
                                "Ï": "I",
                                "ì": "i",
                                "í": "i",
                                "î": "i",
                                "ï": "i",
                                "Ñ": "N",
                                "ñ": "n",
                                "Ò": "O",
                                "Ó": "O",
                                "Ô": "O",
                                "Õ": "O",
                                "Ö": "O",
                                "Ø": "O",
                                "ò": "o",
                                "ó": "o",
                                "ô": "o",
                                "õ": "o",
                                "ö": "o",
                                "ø": "o",
                                "Ù": "U",
                                "Ú": "U",
                                "Û": "U",
                                "Ü": "U",
                                "ù": "u",
                                "ú": "u",
                                "û": "u",
                                "ü": "u",
                                "Ý": "Y",
                                "ý": "y",
                                "ÿ": "y",
                                "Æ": "Ae",
                                "æ": "ae",
                                "Þ": "Th",
                                "þ": "th",
                                "ß": "ss",
                                "Ā": "A",
                                "Ă": "A",
                                "Ą": "A",
                                "ā": "a",
                                "ă": "a",
                                "ą": "a",
                                "Ć": "C",
                                "Ĉ": "C",
                                "Ċ": "C",
                                "Č": "C",
                                "ć": "c",
                                "ĉ": "c",
                                "ċ": "c",
                                "č": "c",
                                "Ď": "D",
                                "Đ": "D",
                                "ď": "d",
                                "đ": "d",
                                "Ē": "E",
                                "Ĕ": "E",
                                "Ė": "E",
                                "Ę": "E",
                                "Ě": "E",
                                "ē": "e",
                                "ĕ": "e",
                                "ė": "e",
                                "ę": "e",
                                "ě": "e",
                                "Ĝ": "G",
                                "Ğ": "G",
                                "Ġ": "G",
                                "Ģ": "G",
                                "ĝ": "g",
                                "ğ": "g",
                                "ġ": "g",
                                "ģ": "g",
                                "Ĥ": "H",
                                "Ħ": "H",
                                "ĥ": "h",
                                "ħ": "h",
                                "Ĩ": "I",
                                "Ī": "I",
                                "Ĭ": "I",
                                "Į": "I",
                                "İ": "I",
                                "ĩ": "i",
                                "ī": "i",
                                "ĭ": "i",
                                "į": "i",
                                "ı": "i",
                                "Ĵ": "J",
                                "ĵ": "j",
                                "Ķ": "K",
                                "ķ": "k",
                                "ĸ": "k",
                                "Ĺ": "L",
                                "Ļ": "L",
                                "Ľ": "L",
                                "Ŀ": "L",
                                "Ł": "L",
                                "ĺ": "l",
                                "ļ": "l",
                                "ľ": "l",
                                "ŀ": "l",
                                "ł": "l",
                                "Ń": "N",
                                "Ņ": "N",
                                "Ň": "N",
                                "Ŋ": "N",
                                "ń": "n",
                                "ņ": "n",
                                "ň": "n",
                                "ŋ": "n",
                                "Ō": "O",
                                "Ŏ": "O",
                                "Ő": "O",
                                "ō": "o",
                                "ŏ": "o",
                                "ő": "o",
                                "Ŕ": "R",
                                "Ŗ": "R",
                                "Ř": "R",
                                "ŕ": "r",
                                "ŗ": "r",
                                "ř": "r",
                                "Ś": "S",
                                "Ŝ": "S",
                                "Ş": "S",
                                "Š": "S",
                                "ś": "s",
                                "ŝ": "s",
                                "ş": "s",
                                "š": "s",
                                "Ţ": "T",
                                "Ť": "T",
                                "Ŧ": "T",
                                "ţ": "t",
                                "ť": "t",
                                "ŧ": "t",
                                "Ũ": "U",
                                "Ū": "U",
                                "Ŭ": "U",
                                "Ů": "U",
                                "Ű": "U",
                                "Ų": "U",
                                "ũ": "u",
                                "ū": "u",
                                "ŭ": "u",
                                "ů": "u",
                                "ű": "u",
                                "ų": "u",
                                "Ŵ": "W",
                                "ŵ": "w",
                                "Ŷ": "Y",
                                "ŷ": "y",
                                "Ÿ": "Y",
                                "Ź": "Z",
                                "Ż": "Z",
                                "Ž": "Z",
                                "ź": "z",
                                "ż": "z",
                                "ž": "z",
                                "Ĳ": "IJ",
                                "ĳ": "ij",
                                "Œ": "Oe",
                                "œ": "oe",
                                "ŉ": "'n",
                                "ſ": "s"
                            }),
                            rn = We({
                                "&": "&amp;",
                                "<": "&lt;",
                                ">": "&gt;",
                                '"': "&quot;",
                                "'": "&#39;"
                            });

                        function on(t) {
                            return "\\" + le[t]
                        }

                        function an(t) {
                            return ne.test(t)
                        }

                        function sn(t) {
                            var e = -1,
                                n = Array(t.size);
                            return t.forEach((function (t, r) {
                                n[++e] = [r, t]
                            })), n
                        }

                        function ln(t, e) {
                            return function (n) {
                                return t(e(n))
                            }
                        }

                        function cn(t, e) {
                            for (var n = -1, r = t.length, i = 0, o = []; ++n < r;) {
                                var a = t[n];
                                a !== e && a !== s || (t[n] = s, o[i++] = n)
                            }
                            return o
                        }

                        function un(t) {
                            var e = -1,
                                n = Array(t.size);
                            return t.forEach((function (t) {
                                n[++e] = t
                            })), n
                        }

                        function hn(t) {
                            var e = -1,
                                n = Array(t.size);
                            return t.forEach((function (t) {
                                n[++e] = [t, t]
                            })), n
                        }

                        function dn(t) {
                            return an(t) ? function (t) {
                                var e = te.lastIndex = 0;
                                for (; te.test(t);) ++e;
                                return e
                            }(t) : Ne(t)
                        }

                        function pn(t) {
                            return an(t) ? function (t) {
                                return t.match(te) || []
                            }(t) : function (t) {
                                return t.split("")
                            }(t)
                        }

                        function fn(t) {
                            for (var e = t.length; e-- && ot.test(t.charAt(e)););
                            return e
                        }
                        var mn = We({
                            "&amp;": "&",
                            "&lt;": "<",
                            "&gt;": ">",
                            "&quot;": '"',
                            "&#39;": "'"
                        });
                        var gn = function t(e) {
                            var n, r = (e = null == e ? pe : gn.defaults(pe.Object(), e, gn.pick(pe, ie))).Array,
                                ot = e.Date,
                                xt = e.Error,
                                bt = e.Function,
                                wt = e.Math,
                                Ct = e.Object,
                                St = e.RegExp,
                                It = e.String,
                                Mt = e.TypeError,
                                Tt = r.prototype,
                                Bt = bt.prototype,
                                Rt = Ct.prototype,
                                Lt = e["__core-js_shared__"],
                                Dt = Bt.toString,
                                Pt = Rt.hasOwnProperty,
                                Ot = 0,
                                kt = (n = /[^.]+$/.exec(Lt && Lt.keys && Lt.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "",
                                Ut = Rt.toString,
                                Nt = Dt.call(Ct),
                                Ft = pe._,
                                Qt = St("^" + Dt.call(Pt).replace(nt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                                $t = ge ? e.Buffer : i,
                                Gt = e.Symbol,
                                Ht = e.Uint8Array,
                                zt = $t ? $t.allocUnsafe : i,
                                Vt = ln(Ct.getPrototypeOf, Ct),
                                Wt = Ct.create,
                                jt = Rt.propertyIsEnumerable,
                                Xt = Tt.splice,
                                qt = Gt ? Gt.isConcatSpreadable : i,
                                Yt = Gt ? Gt.iterator : i,
                                Kt = Gt ? Gt.toStringTag : i,
                                te = function () {
                                    try {
                                        var t = uo(Ct, "defineProperty");
                                        return t({}, "", {}), t
                                    } catch (t) {}
                                }(),
                                ne = e.clearTimeout !== pe.clearTimeout && e.clearTimeout,
                                le = ot && ot.now !== pe.Date.now && ot.now,
                                he = e.setTimeout !== pe.setTimeout && e.setTimeout,
                                de = wt.ceil,
                                fe = wt.floor,
                                me = Ct.getOwnPropertySymbols,
                                Ae = $t ? $t.isBuffer : i,
                                ve = e.isFinite,
                                Ne = Tt.join,
                                We = ln(Ct.keys, Ct),
                                An = wt.max,
                                vn = wt.min,
                                _n = ot.now,
                                yn = e.parseInt,
                                En = wt.random,
                                xn = Tt.reverse,
                                bn = uo(e, "DataView"),
                                wn = uo(e, "Map"),
                                Cn = uo(e, "Promise"),
                                Sn = uo(e, "Set"),
                                In = uo(e, "WeakMap"),
                                Mn = uo(Ct, "create"),
                                Tn = In && new In,
                                Bn = {},
                                Rn = Uo(bn),
                                Ln = Uo(wn),
                                Dn = Uo(Cn),
                                Pn = Uo(Sn),
                                On = Uo(In),
                                kn = Gt ? Gt.prototype : i,
                                Un = kn ? kn.valueOf : i,
                                Nn = kn ? kn.toString : i;

                            function Fn(t) {
                                if (ts(t) && !Ha(t) && !(t instanceof Hn)) {
                                    if (t instanceof Gn) return t;
                                    if (Pt.call(t, "__wrapped__")) return No(t)
                                }
                                return new Gn(t)
                            }
                            var Qn = function () {
                                function t() {}
                                return function (e) {
                                    if (!Za(e)) return {};
                                    if (Wt) return Wt(e);
                                    t.prototype = e;
                                    var n = new t;
                                    return t.prototype = i, n
                                }
                            }();

                            function $n() {}

                            function Gn(t, e) {
                                this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!e, this.__index__ = 0, this.__values__ = i
                            }

                            function Hn(t) {
                                this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = f, this.__views__ = []
                            }

                            function zn(t) {
                                var e = -1,
                                    n = null == t ? 0 : t.length;
                                for (this.clear(); ++e < n;) {
                                    var r = t[e];
                                    this.set(r[0], r[1])
                                }
                            }

                            function Vn(t) {
                                var e = -1,
                                    n = null == t ? 0 : t.length;
                                for (this.clear(); ++e < n;) {
                                    var r = t[e];
                                    this.set(r[0], r[1])
                                }
                            }

                            function Wn(t) {
                                var e = -1,
                                    n = null == t ? 0 : t.length;
                                for (this.clear(); ++e < n;) {
                                    var r = t[e];
                                    this.set(r[0], r[1])
                                }
                            }

                            function jn(t) {
                                var e = -1,
                                    n = null == t ? 0 : t.length;
                                for (this.__data__ = new Wn; ++e < n;) this.add(t[e])
                            }

                            function Xn(t) {
                                var e = this.__data__ = new Vn(t);
                                this.size = e.size
                            }

                            function qn(t, e) {
                                var n = Ha(t),
                                    r = !n && Ga(t),
                                    i = !n && !r && ja(t),
                                    o = !n && !r && !i && ls(t),
                                    a = n || r || i || o,
                                    s = a ? qe(t.length, It) : [],
                                    l = s.length;
                                for (var c in t) !e && !Pt.call(t, c) || a && ("length" == c || i && ("offset" == c || "parent" == c) || o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || vo(c, l)) || s.push(c);
                                return s
                            }

                            function Yn(t) {
                                var e = t.length;
                                return e ? t[jr(0, e - 1)] : i
                            }

                            function Kn(t, e) {
                                return Po(Mi(t), ar(e, 0, t.length))
                            }

                            function Jn(t) {
                                return Po(Mi(t))
                            }

                            function Zn(t, e, n) {
                                (n !== i && !Fa(t[e], n) || n === i && !(e in t)) && ir(t, e, n)
                            }

                            function tr(t, e, n) {
                                var r = t[e];
                                Pt.call(t, e) && Fa(r, n) && (n !== i || e in t) || ir(t, e, n)
                            }

                            function er(t, e) {
                                for (var n = t.length; n--;)
                                    if (Fa(t[n][0], e)) return n;
                                return -1
                            }

                            function nr(t, e, n, r) {
                                return hr(t, (function (t, i, o) {
                                    e(r, t, n(t), o)
                                })), r
                            }

                            function rr(t, e) {
                                return t && Ti(e, Bs(e), t)
                            }

                            function ir(t, e, n) {
                                "__proto__" == e && te ? te(t, e, {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: n,
                                    writable: !0
                                }) : t[e] = n
                            }

                            function or(t, e) {
                                for (var n = -1, o = e.length, a = r(o), s = null == t; ++n < o;) a[n] = s ? i : Cs(t, e[n]);
                                return a
                            }

                            function ar(t, e, n) {
                                return t == t && (n !== i && (t = t <= n ? t : n), e !== i && (t = t >= e ? t : e)), t
                            }

                            function sr(t, e, n, r, o, a) {
                                var s, l = 1 & e,
                                    c = 2 & e,
                                    u = 4 & e;
                                if (n && (s = o ? n(t, r, o, a) : n(t)), s !== i) return s;
                                if (!Za(t)) return t;
                                var h = Ha(t);
                                if (h) {
                                    if (s = function (t) {
                                            var e = t.length,
                                                n = new t.constructor(e);
                                            e && "string" == typeof t[0] && Pt.call(t, "index") && (n.index = t.index, n.input = t.input);
                                            return n
                                        }(t), !l) return Mi(t, s)
                                } else {
                                    var d = fo(t),
                                        p = d == E || d == x;
                                    if (ja(t)) return xi(t, l);
                                    if (d == C || d == g || p && !o) {
                                        if (s = c || p ? {} : go(t), !l) return c ? function (t, e) {
                                            return Ti(t, po(t), e)
                                        }(t, function (t, e) {
                                            return t && Ti(e, Rs(e), t)
                                        }(s, t)) : function (t, e) {
                                            return Ti(t, ho(t), e)
                                        }(t, rr(s, t))
                                    } else {
                                        if (!se[d]) return o ? t : {};
                                        s = function (t, e, n) {
                                            var r = t.constructor;
                                            switch (e) {
                                                case L:
                                                    return bi(t);
                                                case v:
                                                case _:
                                                    return new r(+t);
                                                case D:
                                                    return function (t, e) {
                                                        var n = e ? bi(t.buffer) : t.buffer;
                                                        return new t.constructor(n, t.byteOffset, t.byteLength)
                                                    }(t, n);
                                                case P:
                                                case O:
                                                case k:
                                                case U:
                                                case N:
                                                case F:
                                                case Q:
                                                case $:
                                                case G:
                                                    return wi(t, n);
                                                case b:
                                                    return new r;
                                                case w:
                                                case T:
                                                    return new r(t);
                                                case I:
                                                    return function (t) {
                                                        var e = new t.constructor(t.source, pt.exec(t));
                                                        return e.lastIndex = t.lastIndex, e
                                                    }(t);
                                                case M:
                                                    return new r;
                                                case B:
                                                    return i = t, Un ? Ct(Un.call(i)) : {}
                                            }
                                            var i
                                        }(t, d, l)
                                    }
                                }
                                a || (a = new Xn);
                                var f = a.get(t);
                                if (f) return f;
                                a.set(t, s), os(t) ? t.forEach((function (r) {
                                    s.add(sr(r, e, n, r, t, a))
                                })) : es(t) && t.forEach((function (r, i) {
                                    s.set(i, sr(r, e, n, i, t, a))
                                }));
                                var m = h ? i : (u ? c ? ro : no : c ? Rs : Bs)(t);
                                return Ie(m || t, (function (r, i) {
                                    m && (r = t[i = r]), tr(s, i, sr(r, e, n, i, t, a))
                                })), s
                            }

                            function lr(t, e, n) {
                                var r = n.length;
                                if (null == t) return !r;
                                for (t = Ct(t); r--;) {
                                    var o = n[r],
                                        a = e[o],
                                        s = t[o];
                                    if (s === i && !(o in t) || !a(s)) return !1
                                }
                                return !0
                            }

                            function cr(t, e, n) {
                                if ("function" != typeof t) throw new Mt(o);
                                return Bo((function () {
                                    t.apply(i, n)
                                }), e)
                            }

                            function ur(t, e, n, r) {
                                var i = -1,
                                    o = Re,
                                    a = !0,
                                    s = t.length,
                                    l = [],
                                    c = e.length;
                                if (!s) return l;
                                n && (e = De(e, Ke(n))), r ? (o = Le, a = !1) : e.length >= 200 && (o = Ze, a = !1, e = new jn(e));
                                t: for (; ++i < s;) {
                                    var u = t[i],
                                        h = null == n ? u : n(u);
                                    if (u = r || 0 !== u ? u : 0, a && h == h) {
                                        for (var d = c; d--;)
                                            if (e[d] === h) continue t;
                                        l.push(u)
                                    } else o(e, h, r) || l.push(u)
                                }
                                return l
                            }
                            Fn.templateSettings = {
                                escape: Y,
                                evaluate: K,
                                interpolate: J,
                                variable: "",
                                imports: {
                                    _: Fn
                                }
                            }, Fn.prototype = $n.prototype, Fn.prototype.constructor = Fn, Gn.prototype = Qn($n.prototype), Gn.prototype.constructor = Gn, Hn.prototype = Qn($n.prototype), Hn.prototype.constructor = Hn, zn.prototype.clear = function () {
                                this.__data__ = Mn ? Mn(null) : {}, this.size = 0
                            }, zn.prototype.delete = function (t) {
                                var e = this.has(t) && delete this.__data__[t];
                                return this.size -= e ? 1 : 0, e
                            }, zn.prototype.get = function (t) {
                                var e = this.__data__;
                                if (Mn) {
                                    var n = e[t];
                                    return n === a ? i : n
                                }
                                return Pt.call(e, t) ? e[t] : i
                            }, zn.prototype.has = function (t) {
                                var e = this.__data__;
                                return Mn ? e[t] !== i : Pt.call(e, t)
                            }, zn.prototype.set = function (t, e) {
                                var n = this.__data__;
                                return this.size += this.has(t) ? 0 : 1, n[t] = Mn && e === i ? a : e, this
                            }, Vn.prototype.clear = function () {
                                this.__data__ = [], this.size = 0
                            }, Vn.prototype.delete = function (t) {
                                var e = this.__data__,
                                    n = er(e, t);
                                return !(n < 0) && (n == e.length - 1 ? e.pop() : Xt.call(e, n, 1), --this.size, !0)
                            }, Vn.prototype.get = function (t) {
                                var e = this.__data__,
                                    n = er(e, t);
                                return n < 0 ? i : e[n][1]
                            }, Vn.prototype.has = function (t) {
                                return er(this.__data__, t) > -1
                            }, Vn.prototype.set = function (t, e) {
                                var n = this.__data__,
                                    r = er(n, t);
                                return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
                            }, Wn.prototype.clear = function () {
                                this.size = 0, this.__data__ = {
                                    hash: new zn,
                                    map: new(wn || Vn),
                                    string: new zn
                                }
                            }, Wn.prototype.delete = function (t) {
                                var e = lo(this, t).delete(t);
                                return this.size -= e ? 1 : 0, e
                            }, Wn.prototype.get = function (t) {
                                return lo(this, t).get(t)
                            }, Wn.prototype.has = function (t) {
                                return lo(this, t).has(t)
                            }, Wn.prototype.set = function (t, e) {
                                var n = lo(this, t),
                                    r = n.size;
                                return n.set(t, e), this.size += n.size == r ? 0 : 1, this
                            }, jn.prototype.add = jn.prototype.push = function (t) {
                                return this.__data__.set(t, a), this
                            }, jn.prototype.has = function (t) {
                                return this.__data__.has(t)
                            }, Xn.prototype.clear = function () {
                                this.__data__ = new Vn, this.size = 0
                            }, Xn.prototype.delete = function (t) {
                                var e = this.__data__,
                                    n = e.delete(t);
                                return this.size = e.size, n
                            }, Xn.prototype.get = function (t) {
                                return this.__data__.get(t)
                            }, Xn.prototype.has = function (t) {
                                return this.__data__.has(t)
                            }, Xn.prototype.set = function (t, e) {
                                var n = this.__data__;
                                if (n instanceof Vn) {
                                    var r = n.__data__;
                                    if (!wn || r.length < 199) return r.push([t, e]), this.size = ++n.size, this;
                                    n = this.__data__ = new Wn(r)
                                }
                                return n.set(t, e), this.size = n.size, this
                            };
                            var hr = Li(_r),
                                dr = Li(yr, !0);

                            function pr(t, e) {
                                var n = !0;
                                return hr(t, (function (t, r, i) {
                                    return n = !!e(t, r, i)
                                })), n
                            }

                            function fr(t, e, n) {
                                for (var r = -1, o = t.length; ++r < o;) {
                                    var a = t[r],
                                        s = e(a);
                                    if (null != s && (l === i ? s == s && !ss(s) : n(s, l))) var l = s,
                                        c = a
                                }
                                return c
                            }

                            function mr(t, e) {
                                var n = [];
                                return hr(t, (function (t, r, i) {
                                    e(t, r, i) && n.push(t)
                                })), n
                            }

                            function gr(t, e, n, r, i) {
                                var o = -1,
                                    a = t.length;
                                for (n || (n = Ao), i || (i = []); ++o < a;) {
                                    var s = t[o];
                                    e > 0 && n(s) ? e > 1 ? gr(s, e - 1, n, r, i) : Pe(i, s) : r || (i[i.length] = s)
                                }
                                return i
                            }
                            var Ar = Di(),
                                vr = Di(!0);

                            function _r(t, e) {
                                return t && Ar(t, e, Bs)
                            }

                            function yr(t, e) {
                                return t && vr(t, e, Bs)
                            }

                            function Er(t, e) {
                                return Be(e, (function (e) {
                                    return Ya(t[e])
                                }))
                            }

                            function xr(t, e) {
                                for (var n = 0, r = (e = vi(e, t)).length; null != t && n < r;) t = t[ko(e[n++])];
                                return n && n == r ? t : i
                            }

                            function br(t, e, n) {
                                var r = e(t);
                                return Ha(t) ? r : Pe(r, n(t))
                            }

                            function wr(t) {
                                return null == t ? t === i ? "[object Undefined]" : "[object Null]" : Kt && Kt in Ct(t) ? function (t) {
                                    var e = Pt.call(t, Kt),
                                        n = t[Kt];
                                    try {
                                        t[Kt] = i;
                                        var r = !0
                                    } catch (t) {}
                                    var o = Ut.call(t);
                                    r && (e ? t[Kt] = n : delete t[Kt]);
                                    return o
                                }(t) : function (t) {
                                    return Ut.call(t)
                                }(t)
                            }

                            function Cr(t, e) {
                                return t > e
                            }

                            function Sr(t, e) {
                                return null != t && Pt.call(t, e)
                            }

                            function Ir(t, e) {
                                return null != t && e in Ct(t)
                            }

                            function Mr(t, e, n) {
                                for (var o = n ? Le : Re, a = t[0].length, s = t.length, l = s, c = r(s), u = 1 / 0, h = []; l--;) {
                                    var d = t[l];
                                    l && e && (d = De(d, Ke(e))), u = vn(d.length, u), c[l] = !n && (e || a >= 120 && d.length >= 120) ? new jn(l && d) : i
                                }
                                d = t[0];
                                var p = -1,
                                    f = c[0];
                                t: for (; ++p < a && h.length < u;) {
                                    var m = d[p],
                                        g = e ? e(m) : m;
                                    if (m = n || 0 !== m ? m : 0, !(f ? Ze(f, g) : o(h, g, n))) {
                                        for (l = s; --l;) {
                                            var A = c[l];
                                            if (!(A ? Ze(A, g) : o(t[l], g, n))) continue t
                                        }
                                        f && f.push(g), h.push(m)
                                    }
                                }
                                return h
                            }

                            function Tr(t, e, n) {
                                var r = null == (t = Io(t, e = vi(e, t))) ? t : t[ko(qo(e))];
                                return null == r ? i : Ce(r, t, n)
                            }

                            function Br(t) {
                                return ts(t) && wr(t) == g
                            }

                            function Rr(t, e, n, r, o) {
                                return t === e || (null == t || null == e || !ts(t) && !ts(e) ? t != t && e != e : function (t, e, n, r, o, a) {
                                    var s = Ha(t),
                                        l = Ha(e),
                                        c = s ? A : fo(t),
                                        u = l ? A : fo(e),
                                        h = (c = c == g ? C : c) == C,
                                        d = (u = u == g ? C : u) == C,
                                        p = c == u;
                                    if (p && ja(t)) {
                                        if (!ja(e)) return !1;
                                        s = !0, h = !1
                                    }
                                    if (p && !h) return a || (a = new Xn), s || ls(t) ? to(t, e, n, r, o, a) : function (t, e, n, r, i, o, a) {
                                        switch (n) {
                                            case D:
                                                if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                                                t = t.buffer, e = e.buffer;
                                            case L:
                                                return !(t.byteLength != e.byteLength || !o(new Ht(t), new Ht(e)));
                                            case v:
                                            case _:
                                            case w:
                                                return Fa(+t, +e);
                                            case y:
                                                return t.name == e.name && t.message == e.message;
                                            case I:
                                            case T:
                                                return t == e + "";
                                            case b:
                                                var s = sn;
                                            case M:
                                                var l = 1 & r;
                                                if (s || (s = un), t.size != e.size && !l) return !1;
                                                var c = a.get(t);
                                                if (c) return c == e;
                                                r |= 2, a.set(t, e);
                                                var u = to(s(t), s(e), r, i, o, a);
                                                return a.delete(t), u;
                                            case B:
                                                if (Un) return Un.call(t) == Un.call(e)
                                        }
                                        return !1
                                    }(t, e, c, n, r, o, a);
                                    if (!(1 & n)) {
                                        var f = h && Pt.call(t, "__wrapped__"),
                                            m = d && Pt.call(e, "__wrapped__");
                                        if (f || m) {
                                            var E = f ? t.value() : t,
                                                x = m ? e.value() : e;
                                            return a || (a = new Xn), o(E, x, n, r, a)
                                        }
                                    }
                                    if (!p) return !1;
                                    return a || (a = new Xn),
                                        function (t, e, n, r, o, a) {
                                            var s = 1 & n,
                                                l = no(t),
                                                c = l.length,
                                                u = no(e),
                                                h = u.length;
                                            if (c != h && !s) return !1;
                                            var d = c;
                                            for (; d--;) {
                                                var p = l[d];
                                                if (!(s ? p in e : Pt.call(e, p))) return !1
                                            }
                                            var f = a.get(t),
                                                m = a.get(e);
                                            if (f && m) return f == e && m == t;
                                            var g = !0;
                                            a.set(t, e), a.set(e, t);
                                            var A = s;
                                            for (; ++d < c;) {
                                                var v = t[p = l[d]],
                                                    _ = e[p];
                                                if (r) var y = s ? r(_, v, p, e, t, a) : r(v, _, p, t, e, a);
                                                if (!(y === i ? v === _ || o(v, _, n, r, a) : y)) {
                                                    g = !1;
                                                    break
                                                }
                                                A || (A = "constructor" == p)
                                            }
                                            if (g && !A) {
                                                var E = t.constructor,
                                                    x = e.constructor;
                                                E == x || !("constructor" in t) || !("constructor" in e) || "function" == typeof E && E instanceof E && "function" == typeof x && x instanceof x || (g = !1)
                                            }
                                            return a.delete(t), a.delete(e), g
                                        }(t, e, n, r, o, a)
                                }(t, e, n, r, Rr, o))
                            }

                            function Lr(t, e, n, r) {
                                var o = n.length,
                                    a = o,
                                    s = !r;
                                if (null == t) return !a;
                                for (t = Ct(t); o--;) {
                                    var l = n[o];
                                    if (s && l[2] ? l[1] !== t[l[0]] : !(l[0] in t)) return !1
                                }
                                for (; ++o < a;) {
                                    var c = (l = n[o])[0],
                                        u = t[c],
                                        h = l[1];
                                    if (s && l[2]) {
                                        if (u === i && !(c in t)) return !1
                                    } else {
                                        var d = new Xn;
                                        if (r) var p = r(u, h, c, t, e, d);
                                        if (!(p === i ? Rr(h, u, 3, r, d) : p)) return !1
                                    }
                                }
                                return !0
                            }

                            function Dr(t) {
                                return !(!Za(t) || (e = t, kt && kt in e)) && (Ya(t) ? Qt : gt).test(Uo(t));
                                var e
                            }

                            function Pr(t) {
                                return "function" == typeof t ? t : null == t ? nl : "object" == typeof t ? Ha(t) ? Qr(t[0], t[1]) : Fr(t) : hl(t)
                            }

                            function Or(t) {
                                if (!bo(t)) return We(t);
                                var e = [];
                                for (var n in Ct(t)) Pt.call(t, n) && "constructor" != n && e.push(n);
                                return e
                            }

                            function kr(t) {
                                if (!Za(t)) return function (t) {
                                    var e = [];
                                    if (null != t)
                                        for (var n in Ct(t)) e.push(n);
                                    return e
                                }(t);
                                var e = bo(t),
                                    n = [];
                                for (var r in t)("constructor" != r || !e && Pt.call(t, r)) && n.push(r);
                                return n
                            }

                            function Ur(t, e) {
                                return t < e
                            }

                            function Nr(t, e) {
                                var n = -1,
                                    i = Va(t) ? r(t.length) : [];
                                return hr(t, (function (t, r, o) {
                                    i[++n] = e(t, r, o)
                                })), i
                            }

                            function Fr(t) {
                                var e = co(t);
                                return 1 == e.length && e[0][2] ? Co(e[0][0], e[0][1]) : function (n) {
                                    return n === t || Lr(n, t, e)
                                }
                            }

                            function Qr(t, e) {
                                return yo(t) && wo(e) ? Co(ko(t), e) : function (n) {
                                    var r = Cs(n, t);
                                    return r === i && r === e ? Ss(n, t) : Rr(e, r, 3)
                                }
                            }

                            function $r(t, e, n, r, o) {
                                t !== e && Ar(e, (function (a, s) {
                                    if (o || (o = new Xn), Za(a)) ! function (t, e, n, r, o, a, s) {
                                        var l = Mo(t, n),
                                            c = Mo(e, n),
                                            u = s.get(c);
                                        if (u) return void Zn(t, n, u);
                                        var h = a ? a(l, c, n + "", t, e, s) : i,
                                            d = h === i;
                                        if (d) {
                                            var p = Ha(c),
                                                f = !p && ja(c),
                                                m = !p && !f && ls(c);
                                            h = c, p || f || m ? Ha(l) ? h = l : Wa(l) ? h = Mi(l) : f ? (d = !1, h = xi(c, !0)) : m ? (d = !1, h = wi(c, !0)) : h = [] : rs(c) || Ga(c) ? (h = l, Ga(l) ? h = gs(l) : Za(l) && !Ya(l) || (h = go(c))) : d = !1
                                        }
                                        d && (s.set(c, h), o(h, c, r, a, s), s.delete(c));
                                        Zn(t, n, h)
                                    }(t, e, s, n, $r, r, o);
                                    else {
                                        var l = r ? r(Mo(t, s), a, s + "", t, e, o) : i;
                                        l === i && (l = a), Zn(t, s, l)
                                    }
                                }), Rs)
                            }

                            function Gr(t, e) {
                                var n = t.length;
                                if (n) return vo(e += e < 0 ? n : 0, n) ? t[e] : i
                            }

                            function Hr(t, e, n) {
                                e = e.length ? De(e, (function (t) {
                                    return Ha(t) ? function (e) {
                                        return xr(e, 1 === t.length ? t[0] : t)
                                    } : t
                                })) : [nl];
                                var r = -1;
                                e = De(e, Ke(so()));
                                var i = Nr(t, (function (t, n, i) {
                                    var o = De(e, (function (e) {
                                        return e(t)
                                    }));
                                    return {
                                        criteria: o,
                                        index: ++r,
                                        value: t
                                    }
                                }));
                                return function (t, e) {
                                    var n = t.length;
                                    for (t.sort(e); n--;) t[n] = t[n].value;
                                    return t
                                }(i, (function (t, e) {
                                    return function (t, e, n) {
                                        var r = -1,
                                            i = t.criteria,
                                            o = e.criteria,
                                            a = i.length,
                                            s = n.length;
                                        for (; ++r < a;) {
                                            var l = Ci(i[r], o[r]);
                                            if (l) return r >= s ? l : l * ("desc" == n[r] ? -1 : 1)
                                        }
                                        return t.index - e.index
                                    }(t, e, n)
                                }))
                            }

                            function zr(t, e, n) {
                                for (var r = -1, i = e.length, o = {}; ++r < i;) {
                                    var a = e[r],
                                        s = xr(t, a);
                                    n(s, a) && Jr(o, vi(a, t), s)
                                }
                                return o
                            }

                            function Vr(t, e, n, r) {
                                var i = r ? Ge : $e,
                                    o = -1,
                                    a = e.length,
                                    s = t;
                                for (t === e && (e = Mi(e)), n && (s = De(t, Ke(n))); ++o < a;)
                                    for (var l = 0, c = e[o], u = n ? n(c) : c;
                                        (l = i(s, u, l, r)) > -1;) s !== t && Xt.call(s, l, 1), Xt.call(t, l, 1);
                                return t
                            }

                            function Wr(t, e) {
                                for (var n = t ? e.length : 0, r = n - 1; n--;) {
                                    var i = e[n];
                                    if (n == r || i !== o) {
                                        var o = i;
                                        vo(i) ? Xt.call(t, i, 1) : ui(t, i)
                                    }
                                }
                                return t
                            }

                            function jr(t, e) {
                                return t + fe(En() * (e - t + 1))
                            }

                            function Xr(t, e) {
                                var n = "";
                                if (!t || e < 1 || e > d) return n;
                                do {
                                    e % 2 && (n += t), (e = fe(e / 2)) && (t += t)
                                } while (e);
                                return n
                            }

                            function qr(t, e) {
                                return Ro(So(t, e, nl), t + "")
                            }

                            function Yr(t) {
                                return Yn(Fs(t))
                            }

                            function Kr(t, e) {
                                var n = Fs(t);
                                return Po(n, ar(e, 0, n.length))
                            }

                            function Jr(t, e, n, r) {
                                if (!Za(t)) return t;
                                for (var o = -1, a = (e = vi(e, t)).length, s = a - 1, l = t; null != l && ++o < a;) {
                                    var c = ko(e[o]),
                                        u = n;
                                    if ("__proto__" === c || "constructor" === c || "prototype" === c) return t;
                                    if (o != s) {
                                        var h = l[c];
                                        (u = r ? r(h, c, l) : i) === i && (u = Za(h) ? h : vo(e[o + 1]) ? [] : {})
                                    }
                                    tr(l, c, u), l = l[c]
                                }
                                return t
                            }
                            var Zr = Tn ? function (t, e) {
                                    return Tn.set(t, e), t
                                } : nl,
                                ti = te ? function (t, e) {
                                    return te(t, "toString", {
                                        configurable: !0,
                                        enumerable: !1,
                                        value: Zs(e),
                                        writable: !0
                                    })
                                } : nl;

                            function ei(t) {
                                return Po(Fs(t))
                            }

                            function ni(t, e, n) {
                                var i = -1,
                                    o = t.length;
                                e < 0 && (e = -e > o ? 0 : o + e), (n = n > o ? o : n) < 0 && (n += o), o = e > n ? 0 : n - e >>> 0, e >>>= 0;
                                for (var a = r(o); ++i < o;) a[i] = t[i + e];
                                return a
                            }

                            function ri(t, e) {
                                var n;
                                return hr(t, (function (t, r, i) {
                                    return !(n = e(t, r, i))
                                })), !!n
                            }

                            function ii(t, e, n) {
                                var r = 0,
                                    i = null == t ? r : t.length;
                                if ("number" == typeof e && e == e && i <= 2147483647) {
                                    for (; r < i;) {
                                        var o = r + i >>> 1,
                                            a = t[o];
                                        null !== a && !ss(a) && (n ? a <= e : a < e) ? r = o + 1 : i = o
                                    }
                                    return i
                                }
                                return oi(t, e, nl, n)
                            }

                            function oi(t, e, n, r) {
                                var o = 0,
                                    a = null == t ? 0 : t.length;
                                if (0 === a) return 0;
                                for (var s = (e = n(e)) != e, l = null === e, c = ss(e), u = e === i; o < a;) {
                                    var h = fe((o + a) / 2),
                                        d = n(t[h]),
                                        p = d !== i,
                                        f = null === d,
                                        m = d == d,
                                        g = ss(d);
                                    if (s) var A = r || m;
                                    else A = u ? m && (r || p) : l ? m && p && (r || !f) : c ? m && p && !f && (r || !g) : !f && !g && (r ? d <= e : d < e);
                                    A ? o = h + 1 : a = h
                                }
                                return vn(a, 4294967294)
                            }

                            function ai(t, e) {
                                for (var n = -1, r = t.length, i = 0, o = []; ++n < r;) {
                                    var a = t[n],
                                        s = e ? e(a) : a;
                                    if (!n || !Fa(s, l)) {
                                        var l = s;
                                        o[i++] = 0 === a ? 0 : a
                                    }
                                }
                                return o
                            }

                            function si(t) {
                                return "number" == typeof t ? t : ss(t) ? p : +t
                            }

                            function li(t) {
                                if ("string" == typeof t) return t;
                                if (Ha(t)) return De(t, li) + "";
                                if (ss(t)) return Nn ? Nn.call(t) : "";
                                var e = t + "";
                                return "0" == e && 1 / t == -1 / 0 ? "-0" : e
                            }

                            function ci(t, e, n) {
                                var r = -1,
                                    i = Re,
                                    o = t.length,
                                    a = !0,
                                    s = [],
                                    l = s;
                                if (n) a = !1, i = Le;
                                else if (o >= 200) {
                                    var c = e ? null : Xi(t);
                                    if (c) return un(c);
                                    a = !1, i = Ze, l = new jn
                                } else l = e ? [] : s;
                                t: for (; ++r < o;) {
                                    var u = t[r],
                                        h = e ? e(u) : u;
                                    if (u = n || 0 !== u ? u : 0, a && h == h) {
                                        for (var d = l.length; d--;)
                                            if (l[d] === h) continue t;
                                        e && l.push(h), s.push(u)
                                    } else i(l, h, n) || (l !== s && l.push(h), s.push(u))
                                }
                                return s
                            }

                            function ui(t, e) {
                                return null == (t = Io(t, e = vi(e, t))) || delete t[ko(qo(e))]
                            }

                            function hi(t, e, n, r) {
                                return Jr(t, e, n(xr(t, e)), r)
                            }

                            function di(t, e, n, r) {
                                for (var i = t.length, o = r ? i : -1;
                                    (r ? o-- : ++o < i) && e(t[o], o, t););
                                return n ? ni(t, r ? 0 : o, r ? o + 1 : i) : ni(t, r ? o + 1 : 0, r ? i : o)
                            }

                            function pi(t, e) {
                                var n = t;
                                return n instanceof Hn && (n = n.value()), Oe(e, (function (t, e) {
                                    return e.func.apply(e.thisArg, Pe([t], e.args))
                                }), n)
                            }

                            function fi(t, e, n) {
                                var i = t.length;
                                if (i < 2) return i ? ci(t[0]) : [];
                                for (var o = -1, a = r(i); ++o < i;)
                                    for (var s = t[o], l = -1; ++l < i;) l != o && (a[o] = ur(a[o] || s, t[l], e, n));
                                return ci(gr(a, 1), e, n)
                            }

                            function mi(t, e, n) {
                                for (var r = -1, o = t.length, a = e.length, s = {}; ++r < o;) {
                                    var l = r < a ? e[r] : i;
                                    n(s, t[r], l)
                                }
                                return s
                            }

                            function gi(t) {
                                return Wa(t) ? t : []
                            }

                            function Ai(t) {
                                return "function" == typeof t ? t : nl
                            }

                            function vi(t, e) {
                                return Ha(t) ? t : yo(t, e) ? [t] : Oo(As(t))
                            }
                            var _i = qr;

                            function yi(t, e, n) {
                                var r = t.length;
                                return n = n === i ? r : n, !e && n >= r ? t : ni(t, e, n)
                            }
                            var Ei = ne || function (t) {
                                return pe.clearTimeout(t)
                            };

                            function xi(t, e) {
                                if (e) return t.slice();
                                var n = t.length,
                                    r = zt ? zt(n) : new t.constructor(n);
                                return t.copy(r), r
                            }

                            function bi(t) {
                                var e = new t.constructor(t.byteLength);
                                return new Ht(e).set(new Ht(t)), e
                            }

                            function wi(t, e) {
                                var n = e ? bi(t.buffer) : t.buffer;
                                return new t.constructor(n, t.byteOffset, t.length)
                            }

                            function Ci(t, e) {
                                if (t !== e) {
                                    var n = t !== i,
                                        r = null === t,
                                        o = t == t,
                                        a = ss(t),
                                        s = e !== i,
                                        l = null === e,
                                        c = e == e,
                                        u = ss(e);
                                    if (!l && !u && !a && t > e || a && s && c && !l && !u || r && s && c || !n && c || !o) return 1;
                                    if (!r && !a && !u && t < e || u && n && o && !r && !a || l && n && o || !s && o || !c) return -1
                                }
                                return 0
                            }

                            function Si(t, e, n, i) {
                                for (var o = -1, a = t.length, s = n.length, l = -1, c = e.length, u = An(a - s, 0), h = r(c + u), d = !i; ++l < c;) h[l] = e[l];
                                for (; ++o < s;)(d || o < a) && (h[n[o]] = t[o]);
                                for (; u--;) h[l++] = t[o++];
                                return h
                            }

                            function Ii(t, e, n, i) {
                                for (var o = -1, a = t.length, s = -1, l = n.length, c = -1, u = e.length, h = An(a - l, 0), d = r(h + u), p = !i; ++o < h;) d[o] = t[o];
                                for (var f = o; ++c < u;) d[f + c] = e[c];
                                for (; ++s < l;)(p || o < a) && (d[f + n[s]] = t[o++]);
                                return d
                            }

                            function Mi(t, e) {
                                var n = -1,
                                    i = t.length;
                                for (e || (e = r(i)); ++n < i;) e[n] = t[n];
                                return e
                            }

                            function Ti(t, e, n, r) {
                                var o = !n;
                                n || (n = {});
                                for (var a = -1, s = e.length; ++a < s;) {
                                    var l = e[a],
                                        c = r ? r(n[l], t[l], l, n, t) : i;
                                    c === i && (c = t[l]), o ? ir(n, l, c) : tr(n, l, c)
                                }
                                return n
                            }

                            function Bi(t, e) {
                                return function (n, r) {
                                    var i = Ha(n) ? Se : nr,
                                        o = e ? e() : {};
                                    return i(n, t, so(r, 2), o)
                                }
                            }

                            function Ri(t) {
                                return qr((function (e, n) {
                                    var r = -1,
                                        o = n.length,
                                        a = o > 1 ? n[o - 1] : i,
                                        s = o > 2 ? n[2] : i;
                                    for (a = t.length > 3 && "function" == typeof a ? (o--, a) : i, s && _o(n[0], n[1], s) && (a = o < 3 ? i : a, o = 1), e = Ct(e); ++r < o;) {
                                        var l = n[r];
                                        l && t(e, l, r, a)
                                    }
                                    return e
                                }))
                            }

                            function Li(t, e) {
                                return function (n, r) {
                                    if (null == n) return n;
                                    if (!Va(n)) return t(n, r);
                                    for (var i = n.length, o = e ? i : -1, a = Ct(n);
                                        (e ? o-- : ++o < i) && !1 !== r(a[o], o, a););
                                    return n
                                }
                            }

                            function Di(t) {
                                return function (e, n, r) {
                                    for (var i = -1, o = Ct(e), a = r(e), s = a.length; s--;) {
                                        var l = a[t ? s : ++i];
                                        if (!1 === n(o[l], l, o)) break
                                    }
                                    return e
                                }
                            }

                            function Pi(t) {
                                return function (e) {
                                    var n = an(e = As(e)) ? pn(e) : i,
                                        r = n ? n[0] : e.charAt(0),
                                        o = n ? yi(n, 1).join("") : e.slice(1);
                                    return r[t]() + o
                                }
                            }

                            function Oi(t) {
                                return function (e) {
                                    return Oe(Ys(Gs(e).replace(Jt, "")), t, "")
                                }
                            }

                            function ki(t) {
                                return function () {
                                    var e = arguments;
                                    switch (e.length) {
                                        case 0:
                                            return new t;
                                        case 1:
                                            return new t(e[0]);
                                        case 2:
                                            return new t(e[0], e[1]);
                                        case 3:
                                            return new t(e[0], e[1], e[2]);
                                        case 4:
                                            return new t(e[0], e[1], e[2], e[3]);
                                        case 5:
                                            return new t(e[0], e[1], e[2], e[3], e[4]);
                                        case 6:
                                            return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
                                        case 7:
                                            return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6])
                                    }
                                    var n = Qn(t.prototype),
                                        r = t.apply(n, e);
                                    return Za(r) ? r : n
                                }
                            }

                            function Ui(t) {
                                return function (e, n, r) {
                                    var o = Ct(e);
                                    if (!Va(e)) {
                                        var a = so(n, 3);
                                        e = Bs(e), n = function (t) {
                                            return a(o[t], t, o)
                                        }
                                    }
                                    var s = t(e, n, r);
                                    return s > -1 ? o[a ? e[s] : s] : i
                                }
                            }

                            function Ni(t) {
                                return eo((function (e) {
                                    var n = e.length,
                                        r = n,
                                        a = Gn.prototype.thru;
                                    for (t && e.reverse(); r--;) {
                                        var s = e[r];
                                        if ("function" != typeof s) throw new Mt(o);
                                        if (a && !l && "wrapper" == oo(s)) var l = new Gn([], !0)
                                    }
                                    for (r = l ? r : n; ++r < n;) {
                                        var c = oo(s = e[r]),
                                            u = "wrapper" == c ? io(s) : i;
                                        l = u && Eo(u[0]) && 424 == u[1] && !u[4].length && 1 == u[9] ? l[oo(u[0])].apply(l, u[3]) : 1 == s.length && Eo(s) ? l[c]() : l.thru(s)
                                    }
                                    return function () {
                                        var t = arguments,
                                            r = t[0];
                                        if (l && 1 == t.length && Ha(r)) return l.plant(r).value();
                                        for (var i = 0, o = n ? e[i].apply(this, t) : r; ++i < n;) o = e[i].call(this, o);
                                        return o
                                    }
                                }))
                            }

                            function Fi(t, e, n, o, a, s, l, u, h, d) {
                                var p = e & c,
                                    f = 1 & e,
                                    m = 2 & e,
                                    g = 24 & e,
                                    A = 512 & e,
                                    v = m ? i : ki(t);
                                return function c() {
                                    for (var _ = arguments.length, y = r(_), E = _; E--;) y[E] = arguments[E];
                                    if (g) var x = ao(c),
                                        b = function (t, e) {
                                            for (var n = t.length, r = 0; n--;) t[n] === e && ++r;
                                            return r
                                        }(y, x);
                                    if (o && (y = Si(y, o, a, g)), s && (y = Ii(y, s, l, g)), _ -= b, g && _ < d) {
                                        var w = cn(y, x);
                                        return Wi(t, e, Fi, c.placeholder, n, y, w, u, h, d - _)
                                    }
                                    var C = f ? n : this,
                                        S = m ? C[t] : t;
                                    return _ = y.length, u ? y = function (t, e) {
                                        var n = t.length,
                                            r = vn(e.length, n),
                                            o = Mi(t);
                                        for (; r--;) {
                                            var a = e[r];
                                            t[r] = vo(a, n) ? o[a] : i
                                        }
                                        return t
                                    }(y, u) : A && _ > 1 && y.reverse(), p && h < _ && (y.length = h), this && this !== pe && this instanceof c && (S = v || ki(S)), S.apply(C, y)
                                }
                            }

                            function Qi(t, e) {
                                return function (n, r) {
                                    return function (t, e, n, r) {
                                        return _r(t, (function (t, i, o) {
                                            e(r, n(t), i, o)
                                        })), r
                                    }(n, t, e(r), {})
                                }
                            }

                            function $i(t, e) {
                                return function (n, r) {
                                    var o;
                                    if (n === i && r === i) return e;
                                    if (n !== i && (o = n), r !== i) {
                                        if (o === i) return r;
                                        "string" == typeof n || "string" == typeof r ? (n = li(n), r = li(r)) : (n = si(n), r = si(r)), o = t(n, r)
                                    }
                                    return o
                                }
                            }

                            function Gi(t) {
                                return eo((function (e) {
                                    return e = De(e, Ke(so())), qr((function (n) {
                                        var r = this;
                                        return t(e, (function (t) {
                                            return Ce(t, r, n)
                                        }))
                                    }))
                                }))
                            }

                            function Hi(t, e) {
                                var n = (e = e === i ? " " : li(e)).length;
                                if (n < 2) return n ? Xr(e, t) : e;
                                var r = Xr(e, de(t / dn(e)));
                                return an(e) ? yi(pn(r), 0, t).join("") : r.slice(0, t)
                            }

                            function zi(t) {
                                return function (e, n, o) {
                                    return o && "number" != typeof o && _o(e, n, o) && (n = o = i), e = ds(e), n === i ? (n = e, e = 0) : n = ds(n),
                                        function (t, e, n, i) {
                                            for (var o = -1, a = An(de((e - t) / (n || 1)), 0), s = r(a); a--;) s[i ? a : ++o] = t, t += n;
                                            return s
                                        }(e, n, o = o === i ? e < n ? 1 : -1 : ds(o), t)
                                }
                            }

                            function Vi(t) {
                                return function (e, n) {
                                    return "string" == typeof e && "string" == typeof n || (e = ms(e), n = ms(n)), t(e, n)
                                }
                            }

                            function Wi(t, e, n, r, o, a, s, c, u, h) {
                                var d = 8 & e;
                                e |= d ? l : 64, 4 & (e &= ~(d ? 64 : l)) || (e &= -4);
                                var p = [t, e, o, d ? a : i, d ? s : i, d ? i : a, d ? i : s, c, u, h],
                                    f = n.apply(i, p);
                                return Eo(t) && To(f, p), f.placeholder = r, Lo(f, t, e)
                            }

                            function ji(t) {
                                var e = wt[t];
                                return function (t, n) {
                                    if (t = ms(t), (n = null == n ? 0 : vn(ps(n), 292)) && ve(t)) {
                                        var r = (As(t) + "e").split("e");
                                        return +((r = (As(e(r[0] + "e" + (+r[1] + n))) + "e").split("e"))[0] + "e" + (+r[1] - n))
                                    }
                                    return e(t)
                                }
                            }
                            var Xi = Sn && 1 / un(new Sn([, -0]))[1] == h ? function (t) {
                                return new Sn(t)
                            } : sl;

                            function qi(t) {
                                return function (e) {
                                    var n = fo(e);
                                    return n == b ? sn(e) : n == M ? hn(e) : function (t, e) {
                                        return De(e, (function (e) {
                                            return [e, t[e]]
                                        }))
                                    }(e, t(e))
                                }
                            }

                            function Yi(t, e, n, a, h, d, p, f) {
                                var m = 2 & e;
                                if (!m && "function" != typeof t) throw new Mt(o);
                                var g = a ? a.length : 0;
                                if (g || (e &= -97, a = h = i), p = p === i ? p : An(ps(p), 0), f = f === i ? f : ps(f), g -= h ? h.length : 0, 64 & e) {
                                    var A = a,
                                        v = h;
                                    a = h = i
                                }
                                var _ = m ? i : io(t),
                                    y = [t, e, n, a, h, A, v, d, p, f];
                                if (_ && function (t, e) {
                                        var n = t[1],
                                            r = e[1],
                                            i = n | r,
                                            o = i < 131,
                                            a = r == c && 8 == n || r == c && n == u && t[7].length <= e[8] || 384 == r && e[7].length <= e[8] && 8 == n;
                                        if (!o && !a) return t;
                                        1 & r && (t[2] = e[2], i |= 1 & n ? 0 : 4);
                                        var l = e[3];
                                        if (l) {
                                            var h = t[3];
                                            t[3] = h ? Si(h, l, e[4]) : l, t[4] = h ? cn(t[3], s) : e[4]
                                        }(l = e[5]) && (h = t[5], t[5] = h ? Ii(h, l, e[6]) : l, t[6] = h ? cn(t[5], s) : e[6]);
                                        (l = e[7]) && (t[7] = l);
                                        r & c && (t[8] = null == t[8] ? e[8] : vn(t[8], e[8]));
                                        null == t[9] && (t[9] = e[9]);
                                        t[0] = e[0], t[1] = i
                                    }(y, _), t = y[0], e = y[1], n = y[2], a = y[3], h = y[4], !(f = y[9] = y[9] === i ? m ? 0 : t.length : An(y[9] - g, 0)) && 24 & e && (e &= -25), e && 1 != e) E = 8 == e || 16 == e ? function (t, e, n) {
                                    var o = ki(t);
                                    return function a() {
                                        for (var s = arguments.length, l = r(s), c = s, u = ao(a); c--;) l[c] = arguments[c];
                                        var h = s < 3 && l[0] !== u && l[s - 1] !== u ? [] : cn(l, u);
                                        return (s -= h.length) < n ? Wi(t, e, Fi, a.placeholder, i, l, h, i, i, n - s) : Ce(this && this !== pe && this instanceof a ? o : t, this, l)
                                    }
                                }(t, e, f) : e != l && 33 != e || h.length ? Fi.apply(i, y) : function (t, e, n, i) {
                                    var o = 1 & e,
                                        a = ki(t);
                                    return function e() {
                                        for (var s = -1, l = arguments.length, c = -1, u = i.length, h = r(u + l), d = this && this !== pe && this instanceof e ? a : t; ++c < u;) h[c] = i[c];
                                        for (; l--;) h[c++] = arguments[++s];
                                        return Ce(d, o ? n : this, h)
                                    }
                                }(t, e, n, a);
                                else var E = function (t, e, n) {
                                    var r = 1 & e,
                                        i = ki(t);
                                    return function e() {
                                        return (this && this !== pe && this instanceof e ? i : t).apply(r ? n : this, arguments)
                                    }
                                }(t, e, n);
                                return Lo((_ ? Zr : To)(E, y), t, e)
                            }

                            function Ki(t, e, n, r) {
                                return t === i || Fa(t, Rt[n]) && !Pt.call(r, n) ? e : t
                            }

                            function Ji(t, e, n, r, o, a) {
                                return Za(t) && Za(e) && (a.set(e, t), $r(t, e, i, Ji, a), a.delete(e)), t
                            }

                            function Zi(t) {
                                return rs(t) ? i : t
                            }

                            function to(t, e, n, r, o, a) {
                                var s = 1 & n,
                                    l = t.length,
                                    c = e.length;
                                if (l != c && !(s && c > l)) return !1;
                                var u = a.get(t),
                                    h = a.get(e);
                                if (u && h) return u == e && h == t;
                                var d = -1,
                                    p = !0,
                                    f = 2 & n ? new jn : i;
                                for (a.set(t, e), a.set(e, t); ++d < l;) {
                                    var m = t[d],
                                        g = e[d];
                                    if (r) var A = s ? r(g, m, d, e, t, a) : r(m, g, d, t, e, a);
                                    if (A !== i) {
                                        if (A) continue;
                                        p = !1;
                                        break
                                    }
                                    if (f) {
                                        if (!Ue(e, (function (t, e) {
                                                if (!Ze(f, e) && (m === t || o(m, t, n, r, a))) return f.push(e)
                                            }))) {
                                            p = !1;
                                            break
                                        }
                                    } else if (m !== g && !o(m, g, n, r, a)) {
                                        p = !1;
                                        break
                                    }
                                }
                                return a.delete(t), a.delete(e), p
                            }

                            function eo(t) {
                                return Ro(So(t, i, zo), t + "")
                            }

                            function no(t) {
                                return br(t, Bs, ho)
                            }

                            function ro(t) {
                                return br(t, Rs, po)
                            }
                            var io = Tn ? function (t) {
                                return Tn.get(t)
                            } : sl;

                            function oo(t) {
                                for (var e = t.name + "", n = Bn[e], r = Pt.call(Bn, e) ? n.length : 0; r--;) {
                                    var i = n[r],
                                        o = i.func;
                                    if (null == o || o == t) return i.name
                                }
                                return e
                            }

                            function ao(t) {
                                return (Pt.call(Fn, "placeholder") ? Fn : t).placeholder
                            }

                            function so() {
                                var t = Fn.iteratee || rl;
                                return t = t === rl ? Pr : t, arguments.length ? t(arguments[0], arguments[1]) : t
                            }

                            function lo(t, e) {
                                var n, r, i = t.__data__;
                                return ("string" == (r = typeof (n = e)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map
                            }

                            function co(t) {
                                for (var e = Bs(t), n = e.length; n--;) {
                                    var r = e[n],
                                        i = t[r];
                                    e[n] = [r, i, wo(i)]
                                }
                                return e
                            }

                            function uo(t, e) {
                                var n = function (t, e) {
                                    return null == t ? i : t[e]
                                }(t, e);
                                return Dr(n) ? n : i
                            }
                            var ho = me ? function (t) {
                                    return null == t ? [] : (t = Ct(t), Be(me(t), (function (e) {
                                        return jt.call(t, e)
                                    })))
                                } : fl,
                                po = me ? function (t) {
                                    for (var e = []; t;) Pe(e, ho(t)), t = Vt(t);
                                    return e
                                } : fl,
                                fo = wr;

                            function mo(t, e, n) {
                                for (var r = -1, i = (e = vi(e, t)).length, o = !1; ++r < i;) {
                                    var a = ko(e[r]);
                                    if (!(o = null != t && n(t, a))) break;
                                    t = t[a]
                                }
                                return o || ++r != i ? o : !!(i = null == t ? 0 : t.length) && Ja(i) && vo(a, i) && (Ha(t) || Ga(t))
                            }

                            function go(t) {
                                return "function" != typeof t.constructor || bo(t) ? {} : Qn(Vt(t))
                            }

                            function Ao(t) {
                                return Ha(t) || Ga(t) || !!(qt && t && t[qt])
                            }

                            function vo(t, e) {
                                var n = typeof t;
                                return !!(e = null == e ? d : e) && ("number" == n || "symbol" != n && vt.test(t)) && t > -1 && t % 1 == 0 && t < e
                            }

                            function _o(t, e, n) {
                                if (!Za(n)) return !1;
                                var r = typeof e;
                                return !!("number" == r ? Va(n) && vo(e, n.length) : "string" == r && e in n) && Fa(n[e], t)
                            }

                            function yo(t, e) {
                                if (Ha(t)) return !1;
                                var n = typeof t;
                                return !("number" != n && "symbol" != n && "boolean" != n && null != t && !ss(t)) || (tt.test(t) || !Z.test(t) || null != e && t in Ct(e))
                            }

                            function Eo(t) {
                                var e = oo(t),
                                    n = Fn[e];
                                if ("function" != typeof n || !(e in Hn.prototype)) return !1;
                                if (t === n) return !0;
                                var r = io(n);
                                return !!r && t === r[0]
                            }(bn && fo(new bn(new ArrayBuffer(1))) != D || wn && fo(new wn) != b || Cn && fo(Cn.resolve()) != S || Sn && fo(new Sn) != M || In && fo(new In) != R) && (fo = function (t) {
                                var e = wr(t),
                                    n = e == C ? t.constructor : i,
                                    r = n ? Uo(n) : "";
                                if (r) switch (r) {
                                    case Rn:
                                        return D;
                                    case Ln:
                                        return b;
                                    case Dn:
                                        return S;
                                    case Pn:
                                        return M;
                                    case On:
                                        return R
                                }
                                return e
                            });
                            var xo = Lt ? Ya : ml;

                            function bo(t) {
                                var e = t && t.constructor;
                                return t === ("function" == typeof e && e.prototype || Rt)
                            }

                            function wo(t) {
                                return t == t && !Za(t)
                            }

                            function Co(t, e) {
                                return function (n) {
                                    return null != n && (n[t] === e && (e !== i || t in Ct(n)))
                                }
                            }

                            function So(t, e, n) {
                                return e = An(e === i ? t.length - 1 : e, 0),
                                    function () {
                                        for (var i = arguments, o = -1, a = An(i.length - e, 0), s = r(a); ++o < a;) s[o] = i[e + o];
                                        o = -1;
                                        for (var l = r(e + 1); ++o < e;) l[o] = i[o];
                                        return l[e] = n(s), Ce(t, this, l)
                                    }
                            }

                            function Io(t, e) {
                                return e.length < 2 ? t : xr(t, ni(e, 0, -1))
                            }

                            function Mo(t, e) {
                                if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e]
                            }
                            var To = Do(Zr),
                                Bo = he || function (t, e) {
                                    return pe.setTimeout(t, e)
                                },
                                Ro = Do(ti);

                            function Lo(t, e, n) {
                                var r = e + "";
                                return Ro(t, function (t, e) {
                                    var n = e.length;
                                    if (!n) return t;
                                    var r = n - 1;
                                    return e[r] = (n > 1 ? "& " : "") + e[r], e = e.join(n > 2 ? ", " : " "), t.replace(at, "{\n/* [wrapped with " + e + "] */\n")
                                }(r, function (t, e) {
                                    return Ie(m, (function (n) {
                                        var r = "_." + n[0];
                                        e & n[1] && !Re(t, r) && t.push(r)
                                    })), t.sort()
                                }(function (t) {
                                    var e = t.match(st);
                                    return e ? e[1].split(lt) : []
                                }(r), n)))
                            }

                            function Do(t) {
                                var e = 0,
                                    n = 0;
                                return function () {
                                    var r = _n(),
                                        o = 16 - (r - n);
                                    if (n = r, o > 0) {
                                        if (++e >= 800) return arguments[0]
                                    } else e = 0;
                                    return t.apply(i, arguments)
                                }
                            }

                            function Po(t, e) {
                                var n = -1,
                                    r = t.length,
                                    o = r - 1;
                                for (e = e === i ? r : e; ++n < e;) {
                                    var a = jr(n, o),
                                        s = t[a];
                                    t[a] = t[n], t[n] = s
                                }
                                return t.length = e, t
                            }
                            var Oo = function (t) {
                                var e = Da(t, (function (t) {
                                        return 500 === n.size && n.clear(), t
                                    })),
                                    n = e.cache;
                                return e
                            }((function (t) {
                                var e = [];
                                return 46 === t.charCodeAt(0) && e.push(""), t.replace(et, (function (t, n, r, i) {
                                    e.push(r ? i.replace(ht, "$1") : n || t)
                                })), e
                            }));

                            function ko(t) {
                                if ("string" == typeof t || ss(t)) return t;
                                var e = t + "";
                                return "0" == e && 1 / t == -1 / 0 ? "-0" : e
                            }

                            function Uo(t) {
                                if (null != t) {
                                    try {
                                        return Dt.call(t)
                                    } catch (t) {}
                                    try {
                                        return t + ""
                                    } catch (t) {}
                                }
                                return ""
                            }

                            function No(t) {
                                if (t instanceof Hn) return t.clone();
                                var e = new Gn(t.__wrapped__, t.__chain__);
                                return e.__actions__ = Mi(t.__actions__), e.__index__ = t.__index__, e.__values__ = t.__values__, e
                            }
                            var Fo = qr((function (t, e) {
                                    return Wa(t) ? ur(t, gr(e, 1, Wa, !0)) : []
                                })),
                                Qo = qr((function (t, e) {
                                    var n = qo(e);
                                    return Wa(n) && (n = i), Wa(t) ? ur(t, gr(e, 1, Wa, !0), so(n, 2)) : []
                                })),
                                $o = qr((function (t, e) {
                                    var n = qo(e);
                                    return Wa(n) && (n = i), Wa(t) ? ur(t, gr(e, 1, Wa, !0), i, n) : []
                                }));

                            function Go(t, e, n) {
                                var r = null == t ? 0 : t.length;
                                if (!r) return -1;
                                var i = null == n ? 0 : ps(n);
                                return i < 0 && (i = An(r + i, 0)), Qe(t, so(e, 3), i)
                            }

                            function Ho(t, e, n) {
                                var r = null == t ? 0 : t.length;
                                if (!r) return -1;
                                var o = r - 1;
                                return n !== i && (o = ps(n), o = n < 0 ? An(r + o, 0) : vn(o, r - 1)), Qe(t, so(e, 3), o, !0)
                            }

                            function zo(t) {
                                return (null == t ? 0 : t.length) ? gr(t, 1) : []
                            }

                            function Vo(t) {
                                return t && t.length ? t[0] : i
                            }
                            var Wo = qr((function (t) {
                                    var e = De(t, gi);
                                    return e.length && e[0] === t[0] ? Mr(e) : []
                                })),
                                jo = qr((function (t) {
                                    var e = qo(t),
                                        n = De(t, gi);
                                    return e === qo(n) ? e = i : n.pop(), n.length && n[0] === t[0] ? Mr(n, so(e, 2)) : []
                                })),
                                Xo = qr((function (t) {
                                    var e = qo(t),
                                        n = De(t, gi);
                                    return (e = "function" == typeof e ? e : i) && n.pop(), n.length && n[0] === t[0] ? Mr(n, i, e) : []
                                }));

                            function qo(t) {
                                var e = null == t ? 0 : t.length;
                                return e ? t[e - 1] : i
                            }
                            var Yo = qr(Ko);

                            function Ko(t, e) {
                                return t && t.length && e && e.length ? Vr(t, e) : t
                            }
                            var Jo = eo((function (t, e) {
                                var n = null == t ? 0 : t.length,
                                    r = or(t, e);
                                return Wr(t, De(e, (function (t) {
                                    return vo(t, n) ? +t : t
                                })).sort(Ci)), r
                            }));

                            function Zo(t) {
                                return null == t ? t : xn.call(t)
                            }
                            var ta = qr((function (t) {
                                    return ci(gr(t, 1, Wa, !0))
                                })),
                                ea = qr((function (t) {
                                    var e = qo(t);
                                    return Wa(e) && (e = i), ci(gr(t, 1, Wa, !0), so(e, 2))
                                })),
                                na = qr((function (t) {
                                    var e = qo(t);
                                    return e = "function" == typeof e ? e : i, ci(gr(t, 1, Wa, !0), i, e)
                                }));

                            function ra(t) {
                                if (!t || !t.length) return [];
                                var e = 0;
                                return t = Be(t, (function (t) {
                                    if (Wa(t)) return e = An(t.length, e), !0
                                })), qe(e, (function (e) {
                                    return De(t, Ve(e))
                                }))
                            }

                            function ia(t, e) {
                                if (!t || !t.length) return [];
                                var n = ra(t);
                                return null == e ? n : De(n, (function (t) {
                                    return Ce(e, i, t)
                                }))
                            }
                            var oa = qr((function (t, e) {
                                    return Wa(t) ? ur(t, e) : []
                                })),
                                aa = qr((function (t) {
                                    return fi(Be(t, Wa))
                                })),
                                sa = qr((function (t) {
                                    var e = qo(t);
                                    return Wa(e) && (e = i), fi(Be(t, Wa), so(e, 2))
                                })),
                                la = qr((function (t) {
                                    var e = qo(t);
                                    return e = "function" == typeof e ? e : i, fi(Be(t, Wa), i, e)
                                })),
                                ca = qr(ra);
                            var ua = qr((function (t) {
                                var e = t.length,
                                    n = e > 1 ? t[e - 1] : i;
                                return n = "function" == typeof n ? (t.pop(), n) : i, ia(t, n)
                            }));

                            function ha(t) {
                                var e = Fn(t);
                                return e.__chain__ = !0, e
                            }

                            function da(t, e) {
                                return e(t)
                            }
                            var pa = eo((function (t) {
                                var e = t.length,
                                    n = e ? t[0] : 0,
                                    r = this.__wrapped__,
                                    o = function (e) {
                                        return or(e, t)
                                    };
                                return !(e > 1 || this.__actions__.length) && r instanceof Hn && vo(n) ? ((r = r.slice(n, +n + (e ? 1 : 0))).__actions__.push({
                                    func: da,
                                    args: [o],
                                    thisArg: i
                                }), new Gn(r, this.__chain__).thru((function (t) {
                                    return e && !t.length && t.push(i), t
                                }))) : this.thru(o)
                            }));
                            var fa = Bi((function (t, e, n) {
                                Pt.call(t, n) ? ++t[n] : ir(t, n, 1)
                            }));
                            var ma = Ui(Go),
                                ga = Ui(Ho);

                            function Aa(t, e) {
                                return (Ha(t) ? Ie : hr)(t, so(e, 3))
                            }

                            function va(t, e) {
                                return (Ha(t) ? Me : dr)(t, so(e, 3))
                            }
                            var _a = Bi((function (t, e, n) {
                                Pt.call(t, n) ? t[n].push(e) : ir(t, n, [e])
                            }));
                            var ya = qr((function (t, e, n) {
                                    var i = -1,
                                        o = "function" == typeof e,
                                        a = Va(t) ? r(t.length) : [];
                                    return hr(t, (function (t) {
                                        a[++i] = o ? Ce(e, t, n) : Tr(t, e, n)
                                    })), a
                                })),
                                Ea = Bi((function (t, e, n) {
                                    ir(t, n, e)
                                }));

                            function xa(t, e) {
                                return (Ha(t) ? De : Nr)(t, so(e, 3))
                            }
                            var ba = Bi((function (t, e, n) {
                                t[n ? 0 : 1].push(e)
                            }), (function () {
                                return [
                                    [],
                                    []
                                ]
                            }));
                            var wa = qr((function (t, e) {
                                    if (null == t) return [];
                                    var n = e.length;
                                    return n > 1 && _o(t, e[0], e[1]) ? e = [] : n > 2 && _o(e[0], e[1], e[2]) && (e = [e[0]]), Hr(t, gr(e, 1), [])
                                })),
                                Ca = le || function () {
                                    return pe.Date.now()
                                };

                            function Sa(t, e, n) {
                                return e = n ? i : e, e = t && null == e ? t.length : e, Yi(t, c, i, i, i, i, e)
                            }

                            function Ia(t, e) {
                                var n;
                                if ("function" != typeof e) throw new Mt(o);
                                return t = ps(t),
                                    function () {
                                        return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = i), n
                                    }
                            }
                            var Ma = qr((function (t, e, n) {
                                    var r = 1;
                                    if (n.length) {
                                        var i = cn(n, ao(Ma));
                                        r |= l
                                    }
                                    return Yi(t, r, e, n, i)
                                })),
                                Ta = qr((function (t, e, n) {
                                    var r = 3;
                                    if (n.length) {
                                        var i = cn(n, ao(Ta));
                                        r |= l
                                    }
                                    return Yi(e, r, t, n, i)
                                }));

                            function Ba(t, e, n) {
                                var r, a, s, l, c, u, h = 0,
                                    d = !1,
                                    p = !1,
                                    f = !0;
                                if ("function" != typeof t) throw new Mt(o);

                                function m(e) {
                                    var n = r,
                                        o = a;
                                    return r = a = i, h = e, l = t.apply(o, n)
                                }

                                function g(t) {
                                    var n = t - u;
                                    return u === i || n >= e || n < 0 || p && t - h >= s
                                }

                                function A() {
                                    var t = Ca();
                                    if (g(t)) return v(t);
                                    c = Bo(A, function (t) {
                                        var n = e - (t - u);
                                        return p ? vn(n, s - (t - h)) : n
                                    }(t))
                                }

                                function v(t) {
                                    return c = i, f && r ? m(t) : (r = a = i, l)
                                }

                                function _() {
                                    var t = Ca(),
                                        n = g(t);
                                    if (r = arguments, a = this, u = t, n) {
                                        if (c === i) return function (t) {
                                            return h = t, c = Bo(A, e), d ? m(t) : l
                                        }(u);
                                        if (p) return Ei(c), c = Bo(A, e), m(u)
                                    }
                                    return c === i && (c = Bo(A, e)), l
                                }
                                return e = ms(e) || 0, Za(n) && (d = !!n.leading, s = (p = "maxWait" in n) ? An(ms(n.maxWait) || 0, e) : s, f = "trailing" in n ? !!n.trailing : f), _.cancel = function () {
                                    c !== i && Ei(c), h = 0, r = u = a = c = i
                                }, _.flush = function () {
                                    return c === i ? l : v(Ca())
                                }, _
                            }
                            var Ra = qr((function (t, e) {
                                    return cr(t, 1, e)
                                })),
                                La = qr((function (t, e, n) {
                                    return cr(t, ms(e) || 0, n)
                                }));

                            function Da(t, e) {
                                if ("function" != typeof t || null != e && "function" != typeof e) throw new Mt(o);
                                var n = function () {
                                    var r = arguments,
                                        i = e ? e.apply(this, r) : r[0],
                                        o = n.cache;
                                    if (o.has(i)) return o.get(i);
                                    var a = t.apply(this, r);
                                    return n.cache = o.set(i, a) || o, a
                                };
                                return n.cache = new(Da.Cache || Wn), n
                            }

                            function Pa(t) {
                                if ("function" != typeof t) throw new Mt(o);
                                return function () {
                                    var e = arguments;
                                    switch (e.length) {
                                        case 0:
                                            return !t.call(this);
                                        case 1:
                                            return !t.call(this, e[0]);
                                        case 2:
                                            return !t.call(this, e[0], e[1]);
                                        case 3:
                                            return !t.call(this, e[0], e[1], e[2])
                                    }
                                    return !t.apply(this, e)
                                }
                            }
                            Da.Cache = Wn;
                            var Oa = _i((function (t, e) {
                                    var n = (e = 1 == e.length && Ha(e[0]) ? De(e[0], Ke(so())) : De(gr(e, 1), Ke(so()))).length;
                                    return qr((function (r) {
                                        for (var i = -1, o = vn(r.length, n); ++i < o;) r[i] = e[i].call(this, r[i]);
                                        return Ce(t, this, r)
                                    }))
                                })),
                                ka = qr((function (t, e) {
                                    var n = cn(e, ao(ka));
                                    return Yi(t, l, i, e, n)
                                })),
                                Ua = qr((function (t, e) {
                                    var n = cn(e, ao(Ua));
                                    return Yi(t, 64, i, e, n)
                                })),
                                Na = eo((function (t, e) {
                                    return Yi(t, u, i, i, i, e)
                                }));

                            function Fa(t, e) {
                                return t === e || t != t && e != e
                            }
                            var Qa = Vi(Cr),
                                $a = Vi((function (t, e) {
                                    return t >= e
                                })),
                                Ga = Br(function () {
                                    return arguments
                                }()) ? Br : function (t) {
                                    return ts(t) && Pt.call(t, "callee") && !jt.call(t, "callee")
                                },
                                Ha = r.isArray,
                                za = _e ? Ke(_e) : function (t) {
                                    return ts(t) && wr(t) == L
                                };

                            function Va(t) {
                                return null != t && Ja(t.length) && !Ya(t)
                            }

                            function Wa(t) {
                                return ts(t) && Va(t)
                            }
                            var ja = Ae || ml,
                                Xa = ye ? Ke(ye) : function (t) {
                                    return ts(t) && wr(t) == _
                                };

                            function qa(t) {
                                if (!ts(t)) return !1;
                                var e = wr(t);
                                return e == y || "[object DOMException]" == e || "string" == typeof t.message && "string" == typeof t.name && !rs(t)
                            }

                            function Ya(t) {
                                if (!Za(t)) return !1;
                                var e = wr(t);
                                return e == E || e == x || "[object AsyncFunction]" == e || "[object Proxy]" == e
                            }

                            function Ka(t) {
                                return "number" == typeof t && t == ps(t)
                            }

                            function Ja(t) {
                                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= d
                            }

                            function Za(t) {
                                var e = typeof t;
                                return null != t && ("object" == e || "function" == e)
                            }

                            function ts(t) {
                                return null != t && "object" == typeof t
                            }
                            var es = Ee ? Ke(Ee) : function (t) {
                                return ts(t) && fo(t) == b
                            };

                            function ns(t) {
                                return "number" == typeof t || ts(t) && wr(t) == w
                            }

                            function rs(t) {
                                if (!ts(t) || wr(t) != C) return !1;
                                var e = Vt(t);
                                if (null === e) return !0;
                                var n = Pt.call(e, "constructor") && e.constructor;
                                return "function" == typeof n && n instanceof n && Dt.call(n) == Nt
                            }
                            var is = xe ? Ke(xe) : function (t) {
                                return ts(t) && wr(t) == I
                            };
                            var os = be ? Ke(be) : function (t) {
                                return ts(t) && fo(t) == M
                            };

                            function as(t) {
                                return "string" == typeof t || !Ha(t) && ts(t) && wr(t) == T
                            }

                            function ss(t) {
                                return "symbol" == typeof t || ts(t) && wr(t) == B
                            }
                            var ls = we ? Ke(we) : function (t) {
                                return ts(t) && Ja(t.length) && !!ae[wr(t)]
                            };
                            var cs = Vi(Ur),
                                us = Vi((function (t, e) {
                                    return t <= e
                                }));

                            function hs(t) {
                                if (!t) return [];
                                if (Va(t)) return as(t) ? pn(t) : Mi(t);
                                if (Yt && t[Yt]) return function (t) {
                                    for (var e, n = []; !(e = t.next()).done;) n.push(e.value);
                                    return n
                                }(t[Yt]());
                                var e = fo(t);
                                return (e == b ? sn : e == M ? un : Fs)(t)
                            }

                            function ds(t) {
                                return t ? (t = ms(t)) === h || t === -1 / 0 ? 17976931348623157e292 * (t < 0 ? -1 : 1) : t == t ? t : 0 : 0 === t ? t : 0
                            }

                            function ps(t) {
                                var e = ds(t),
                                    n = e % 1;
                                return e == e ? n ? e - n : e : 0
                            }

                            function fs(t) {
                                return t ? ar(ps(t), 0, f) : 0
                            }

                            function ms(t) {
                                if ("number" == typeof t) return t;
                                if (ss(t)) return p;
                                if (Za(t)) {
                                    var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                                    t = Za(e) ? e + "" : e
                                }
                                if ("string" != typeof t) return 0 === t ? t : +t;
                                t = Ye(t);
                                var n = mt.test(t);
                                return n || At.test(t) ? ue(t.slice(2), n ? 2 : 8) : ft.test(t) ? p : +t
                            }

                            function gs(t) {
                                return Ti(t, Rs(t))
                            }

                            function As(t) {
                                return null == t ? "" : li(t)
                            }
                            var vs = Ri((function (t, e) {
                                    if (bo(e) || Va(e)) Ti(e, Bs(e), t);
                                    else
                                        for (var n in e) Pt.call(e, n) && tr(t, n, e[n])
                                })),
                                _s = Ri((function (t, e) {
                                    Ti(e, Rs(e), t)
                                })),
                                ys = Ri((function (t, e, n, r) {
                                    Ti(e, Rs(e), t, r)
                                })),
                                Es = Ri((function (t, e, n, r) {
                                    Ti(e, Bs(e), t, r)
                                })),
                                xs = eo(or);
                            var bs = qr((function (t, e) {
                                    t = Ct(t);
                                    var n = -1,
                                        r = e.length,
                                        o = r > 2 ? e[2] : i;
                                    for (o && _o(e[0], e[1], o) && (r = 1); ++n < r;)
                                        for (var a = e[n], s = Rs(a), l = -1, c = s.length; ++l < c;) {
                                            var u = s[l],
                                                h = t[u];
                                            (h === i || Fa(h, Rt[u]) && !Pt.call(t, u)) && (t[u] = a[u])
                                        }
                                    return t
                                })),
                                ws = qr((function (t) {
                                    return t.push(i, Ji), Ce(Ds, i, t)
                                }));

                            function Cs(t, e, n) {
                                var r = null == t ? i : xr(t, e);
                                return r === i ? n : r
                            }

                            function Ss(t, e) {
                                return null != t && mo(t, e, Ir)
                            }
                            var Is = Qi((function (t, e, n) {
                                    null != e && "function" != typeof e.toString && (e = Ut.call(e)), t[e] = n
                                }), Zs(nl)),
                                Ms = Qi((function (t, e, n) {
                                    null != e && "function" != typeof e.toString && (e = Ut.call(e)), Pt.call(t, e) ? t[e].push(n) : t[e] = [n]
                                }), so),
                                Ts = qr(Tr);

                            function Bs(t) {
                                return Va(t) ? qn(t) : Or(t)
                            }

                            function Rs(t) {
                                return Va(t) ? qn(t, !0) : kr(t)
                            }
                            var Ls = Ri((function (t, e, n) {
                                    $r(t, e, n)
                                })),
                                Ds = Ri((function (t, e, n, r) {
                                    $r(t, e, n, r)
                                })),
                                Ps = eo((function (t, e) {
                                    var n = {};
                                    if (null == t) return n;
                                    var r = !1;
                                    e = De(e, (function (e) {
                                        return e = vi(e, t), r || (r = e.length > 1), e
                                    })), Ti(t, ro(t), n), r && (n = sr(n, 7, Zi));
                                    for (var i = e.length; i--;) ui(n, e[i]);
                                    return n
                                }));
                            var Os = eo((function (t, e) {
                                return null == t ? {} : function (t, e) {
                                    return zr(t, e, (function (e, n) {
                                        return Ss(t, n)
                                    }))
                                }(t, e)
                            }));

                            function ks(t, e) {
                                if (null == t) return {};
                                var n = De(ro(t), (function (t) {
                                    return [t]
                                }));
                                return e = so(e), zr(t, n, (function (t, n) {
                                    return e(t, n[0])
                                }))
                            }
                            var Us = qi(Bs),
                                Ns = qi(Rs);

                            function Fs(t) {
                                return null == t ? [] : Je(t, Bs(t))
                            }
                            var Qs = Oi((function (t, e, n) {
                                return e = e.toLowerCase(), t + (n ? $s(e) : e)
                            }));

                            function $s(t) {
                                return qs(As(t).toLowerCase())
                            }

                            function Gs(t) {
                                return (t = As(t)) && t.replace(_t, nn).replace(Zt, "")
                            }
                            var Hs = Oi((function (t, e, n) {
                                    return t + (n ? "-" : "") + e.toLowerCase()
                                })),
                                zs = Oi((function (t, e, n) {
                                    return t + (n ? " " : "") + e.toLowerCase()
                                })),
                                Vs = Pi("toLowerCase");
                            var Ws = Oi((function (t, e, n) {
                                return t + (n ? "_" : "") + e.toLowerCase()
                            }));
                            var js = Oi((function (t, e, n) {
                                return t + (n ? " " : "") + qs(e)
                            }));
                            var Xs = Oi((function (t, e, n) {
                                    return t + (n ? " " : "") + e.toUpperCase()
                                })),
                                qs = Pi("toUpperCase");

                            function Ys(t, e, n) {
                                return t = As(t), (e = n ? i : e) === i ? function (t) {
                                    return re.test(t)
                                }(t) ? function (t) {
                                    return t.match(ee) || []
                                }(t) : function (t) {
                                    return t.match(ct) || []
                                }(t) : t.match(e) || []
                            }
                            var Ks = qr((function (t, e) {
                                    try {
                                        return Ce(t, i, e)
                                    } catch (t) {
                                        return qa(t) ? t : new xt(t)
                                    }
                                })),
                                Js = eo((function (t, e) {
                                    return Ie(e, (function (e) {
                                        e = ko(e), ir(t, e, Ma(t[e], t))
                                    })), t
                                }));

                            function Zs(t) {
                                return function () {
                                    return t
                                }
                            }
                            var tl = Ni(),
                                el = Ni(!0);

                            function nl(t) {
                                return t
                            }

                            function rl(t) {
                                return Pr("function" == typeof t ? t : sr(t, 1))
                            }
                            var il = qr((function (t, e) {
                                    return function (n) {
                                        return Tr(n, t, e)
                                    }
                                })),
                                ol = qr((function (t, e) {
                                    return function (n) {
                                        return Tr(t, n, e)
                                    }
                                }));

                            function al(t, e, n) {
                                var r = Bs(e),
                                    i = Er(e, r);
                                null != n || Za(e) && (i.length || !r.length) || (n = e, e = t, t = this, i = Er(e, Bs(e)));
                                var o = !(Za(n) && "chain" in n && !n.chain),
                                    a = Ya(t);
                                return Ie(i, (function (n) {
                                    var r = e[n];
                                    t[n] = r, a && (t.prototype[n] = function () {
                                        var e = this.__chain__;
                                        if (o || e) {
                                            var n = t(this.__wrapped__);
                                            return (n.__actions__ = Mi(this.__actions__)).push({
                                                func: r,
                                                args: arguments,
                                                thisArg: t
                                            }), n.__chain__ = e, n
                                        }
                                        return r.apply(t, Pe([this.value()], arguments))
                                    })
                                })), t
                            }

                            function sl() {}
                            var ll = Gi(De),
                                cl = Gi(Te),
                                ul = Gi(Ue);

                            function hl(t) {
                                return yo(t) ? Ve(ko(t)) : function (t) {
                                    return function (e) {
                                        return xr(e, t)
                                    }
                                }(t)
                            }
                            var dl = zi(),
                                pl = zi(!0);

                            function fl() {
                                return []
                            }

                            function ml() {
                                return !1
                            }
                            var gl = $i((function (t, e) {
                                    return t + e
                                }), 0),
                                Al = ji("ceil"),
                                vl = $i((function (t, e) {
                                    return t / e
                                }), 1),
                                _l = ji("floor");
                            var yl, El = $i((function (t, e) {
                                    return t * e
                                }), 1),
                                xl = ji("round"),
                                bl = $i((function (t, e) {
                                    return t - e
                                }), 0);
                            return Fn.after = function (t, e) {
                                if ("function" != typeof e) throw new Mt(o);
                                return t = ps(t),
                                    function () {
                                        if (--t < 1) return e.apply(this, arguments)
                                    }
                            }, Fn.ary = Sa, Fn.assign = vs, Fn.assignIn = _s, Fn.assignInWith = ys, Fn.assignWith = Es, Fn.at = xs, Fn.before = Ia, Fn.bind = Ma, Fn.bindAll = Js, Fn.bindKey = Ta, Fn.castArray = function () {
                                if (!arguments.length) return [];
                                var t = arguments[0];
                                return Ha(t) ? t : [t]
                            }, Fn.chain = ha, Fn.chunk = function (t, e, n) {
                                e = (n ? _o(t, e, n) : e === i) ? 1 : An(ps(e), 0);
                                var o = null == t ? 0 : t.length;
                                if (!o || e < 1) return [];
                                for (var a = 0, s = 0, l = r(de(o / e)); a < o;) l[s++] = ni(t, a, a += e);
                                return l
                            }, Fn.compact = function (t) {
                                for (var e = -1, n = null == t ? 0 : t.length, r = 0, i = []; ++e < n;) {
                                    var o = t[e];
                                    o && (i[r++] = o)
                                }
                                return i
                            }, Fn.concat = function () {
                                var t = arguments.length;
                                if (!t) return [];
                                for (var e = r(t - 1), n = arguments[0], i = t; i--;) e[i - 1] = arguments[i];
                                return Pe(Ha(n) ? Mi(n) : [n], gr(e, 1))
                            }, Fn.cond = function (t) {
                                var e = null == t ? 0 : t.length,
                                    n = so();
                                return t = e ? De(t, (function (t) {
                                    if ("function" != typeof t[1]) throw new Mt(o);
                                    return [n(t[0]), t[1]]
                                })) : [], qr((function (n) {
                                    for (var r = -1; ++r < e;) {
                                        var i = t[r];
                                        if (Ce(i[0], this, n)) return Ce(i[1], this, n)
                                    }
                                }))
                            }, Fn.conforms = function (t) {
                                return function (t) {
                                    var e = Bs(t);
                                    return function (n) {
                                        return lr(n, t, e)
                                    }
                                }(sr(t, 1))
                            }, Fn.constant = Zs, Fn.countBy = fa, Fn.create = function (t, e) {
                                var n = Qn(t);
                                return null == e ? n : rr(n, e)
                            }, Fn.curry = function t(e, n, r) {
                                var o = Yi(e, 8, i, i, i, i, i, n = r ? i : n);
                                return o.placeholder = t.placeholder, o
                            }, Fn.curryRight = function t(e, n, r) {
                                var o = Yi(e, 16, i, i, i, i, i, n = r ? i : n);
                                return o.placeholder = t.placeholder, o
                            }, Fn.debounce = Ba, Fn.defaults = bs, Fn.defaultsDeep = ws, Fn.defer = Ra, Fn.delay = La, Fn.difference = Fo, Fn.differenceBy = Qo, Fn.differenceWith = $o, Fn.drop = function (t, e, n) {
                                var r = null == t ? 0 : t.length;
                                return r ? ni(t, (e = n || e === i ? 1 : ps(e)) < 0 ? 0 : e, r) : []
                            }, Fn.dropRight = function (t, e, n) {
                                var r = null == t ? 0 : t.length;
                                return r ? ni(t, 0, (e = r - (e = n || e === i ? 1 : ps(e))) < 0 ? 0 : e) : []
                            }, Fn.dropRightWhile = function (t, e) {
                                return t && t.length ? di(t, so(e, 3), !0, !0) : []
                            }, Fn.dropWhile = function (t, e) {
                                return t && t.length ? di(t, so(e, 3), !0) : []
                            }, Fn.fill = function (t, e, n, r) {
                                var o = null == t ? 0 : t.length;
                                return o ? (n && "number" != typeof n && _o(t, e, n) && (n = 0, r = o), function (t, e, n, r) {
                                    var o = t.length;
                                    for ((n = ps(n)) < 0 && (n = -n > o ? 0 : o + n), (r = r === i || r > o ? o : ps(r)) < 0 && (r += o), r = n > r ? 0 : fs(r); n < r;) t[n++] = e;
                                    return t
                                }(t, e, n, r)) : []
                            }, Fn.filter = function (t, e) {
                                return (Ha(t) ? Be : mr)(t, so(e, 3))
                            }, Fn.flatMap = function (t, e) {
                                return gr(xa(t, e), 1)
                            }, Fn.flatMapDeep = function (t, e) {
                                return gr(xa(t, e), h)
                            }, Fn.flatMapDepth = function (t, e, n) {
                                return n = n === i ? 1 : ps(n), gr(xa(t, e), n)
                            }, Fn.flatten = zo, Fn.flattenDeep = function (t) {
                                return (null == t ? 0 : t.length) ? gr(t, h) : []
                            }, Fn.flattenDepth = function (t, e) {
                                return (null == t ? 0 : t.length) ? gr(t, e = e === i ? 1 : ps(e)) : []
                            }, Fn.flip = function (t) {
                                return Yi(t, 512)
                            }, Fn.flow = tl, Fn.flowRight = el, Fn.fromPairs = function (t) {
                                for (var e = -1, n = null == t ? 0 : t.length, r = {}; ++e < n;) {
                                    var i = t[e];
                                    r[i[0]] = i[1]
                                }
                                return r
                            }, Fn.functions = function (t) {
                                return null == t ? [] : Er(t, Bs(t))
                            }, Fn.functionsIn = function (t) {
                                return null == t ? [] : Er(t, Rs(t))
                            }, Fn.groupBy = _a, Fn.initial = function (t) {
                                return (null == t ? 0 : t.length) ? ni(t, 0, -1) : []
                            }, Fn.intersection = Wo, Fn.intersectionBy = jo, Fn.intersectionWith = Xo, Fn.invert = Is, Fn.invertBy = Ms, Fn.invokeMap = ya, Fn.iteratee = rl, Fn.keyBy = Ea, Fn.keys = Bs, Fn.keysIn = Rs, Fn.map = xa, Fn.mapKeys = function (t, e) {
                                var n = {};
                                return e = so(e, 3), _r(t, (function (t, r, i) {
                                    ir(n, e(t, r, i), t)
                                })), n
                            }, Fn.mapValues = function (t, e) {
                                var n = {};
                                return e = so(e, 3), _r(t, (function (t, r, i) {
                                    ir(n, r, e(t, r, i))
                                })), n
                            }, Fn.matches = function (t) {
                                return Fr(sr(t, 1))
                            }, Fn.matchesProperty = function (t, e) {
                                return Qr(t, sr(e, 1))
                            }, Fn.memoize = Da, Fn.merge = Ls, Fn.mergeWith = Ds, Fn.method = il, Fn.methodOf = ol, Fn.mixin = al, Fn.negate = Pa, Fn.nthArg = function (t) {
                                return t = ps(t), qr((function (e) {
                                    return Gr(e, t)
                                }))
                            }, Fn.omit = Ps, Fn.omitBy = function (t, e) {
                                return ks(t, Pa(so(e)))
                            }, Fn.once = function (t) {
                                return Ia(2, t)
                            }, Fn.orderBy = function (t, e, n, r) {
                                return null == t ? [] : (Ha(e) || (e = null == e ? [] : [e]), Ha(n = r ? i : n) || (n = null == n ? [] : [n]), Hr(t, e, n))
                            }, Fn.over = ll, Fn.overArgs = Oa, Fn.overEvery = cl, Fn.overSome = ul, Fn.partial = ka, Fn.partialRight = Ua, Fn.partition = ba, Fn.pick = Os, Fn.pickBy = ks, Fn.property = hl, Fn.propertyOf = function (t) {
                                return function (e) {
                                    return null == t ? i : xr(t, e)
                                }
                            }, Fn.pull = Yo, Fn.pullAll = Ko, Fn.pullAllBy = function (t, e, n) {
                                return t && t.length && e && e.length ? Vr(t, e, so(n, 2)) : t
                            }, Fn.pullAllWith = function (t, e, n) {
                                return t && t.length && e && e.length ? Vr(t, e, i, n) : t
                            }, Fn.pullAt = Jo, Fn.range = dl, Fn.rangeRight = pl, Fn.rearg = Na, Fn.reject = function (t, e) {
                                return (Ha(t) ? Be : mr)(t, Pa(so(e, 3)))
                            }, Fn.remove = function (t, e) {
                                var n = [];
                                if (!t || !t.length) return n;
                                var r = -1,
                                    i = [],
                                    o = t.length;
                                for (e = so(e, 3); ++r < o;) {
                                    var a = t[r];
                                    e(a, r, t) && (n.push(a), i.push(r))
                                }
                                return Wr(t, i), n
                            }, Fn.rest = function (t, e) {
                                if ("function" != typeof t) throw new Mt(o);
                                return qr(t, e = e === i ? e : ps(e))
                            }, Fn.reverse = Zo, Fn.sampleSize = function (t, e, n) {
                                return e = (n ? _o(t, e, n) : e === i) ? 1 : ps(e), (Ha(t) ? Kn : Kr)(t, e)
                            }, Fn.set = function (t, e, n) {
                                return null == t ? t : Jr(t, e, n)
                            }, Fn.setWith = function (t, e, n, r) {
                                return r = "function" == typeof r ? r : i, null == t ? t : Jr(t, e, n, r)
                            }, Fn.shuffle = function (t) {
                                return (Ha(t) ? Jn : ei)(t)
                            }, Fn.slice = function (t, e, n) {
                                var r = null == t ? 0 : t.length;
                                return r ? (n && "number" != typeof n && _o(t, e, n) ? (e = 0, n = r) : (e = null == e ? 0 : ps(e), n = n === i ? r : ps(n)), ni(t, e, n)) : []
                            }, Fn.sortBy = wa, Fn.sortedUniq = function (t) {
                                return t && t.length ? ai(t) : []
                            }, Fn.sortedUniqBy = function (t, e) {
                                return t && t.length ? ai(t, so(e, 2)) : []
                            }, Fn.split = function (t, e, n) {
                                return n && "number" != typeof n && _o(t, e, n) && (e = n = i), (n = n === i ? f : n >>> 0) ? (t = As(t)) && ("string" == typeof e || null != e && !is(e)) && !(e = li(e)) && an(t) ? yi(pn(t), 0, n) : t.split(e, n) : []
                            }, Fn.spread = function (t, e) {
                                if ("function" != typeof t) throw new Mt(o);
                                return e = null == e ? 0 : An(ps(e), 0), qr((function (n) {
                                    var r = n[e],
                                        i = yi(n, 0, e);
                                    return r && Pe(i, r), Ce(t, this, i)
                                }))
                            }, Fn.tail = function (t) {
                                var e = null == t ? 0 : t.length;
                                return e ? ni(t, 1, e) : []
                            }, Fn.take = function (t, e, n) {
                                return t && t.length ? ni(t, 0, (e = n || e === i ? 1 : ps(e)) < 0 ? 0 : e) : []
                            }, Fn.takeRight = function (t, e, n) {
                                var r = null == t ? 0 : t.length;
                                return r ? ni(t, (e = r - (e = n || e === i ? 1 : ps(e))) < 0 ? 0 : e, r) : []
                            }, Fn.takeRightWhile = function (t, e) {
                                return t && t.length ? di(t, so(e, 3), !1, !0) : []
                            }, Fn.takeWhile = function (t, e) {
                                return t && t.length ? di(t, so(e, 3)) : []
                            }, Fn.tap = function (t, e) {
                                return e(t), t
                            }, Fn.throttle = function (t, e, n) {
                                var r = !0,
                                    i = !0;
                                if ("function" != typeof t) throw new Mt(o);
                                return Za(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), Ba(t, e, {
                                    leading: r,
                                    maxWait: e,
                                    trailing: i
                                })
                            }, Fn.thru = da, Fn.toArray = hs, Fn.toPairs = Us, Fn.toPairsIn = Ns, Fn.toPath = function (t) {
                                return Ha(t) ? De(t, ko) : ss(t) ? [t] : Mi(Oo(As(t)))
                            }, Fn.toPlainObject = gs, Fn.transform = function (t, e, n) {
                                var r = Ha(t),
                                    i = r || ja(t) || ls(t);
                                if (e = so(e, 4), null == n) {
                                    var o = t && t.constructor;
                                    n = i ? r ? new o : [] : Za(t) && Ya(o) ? Qn(Vt(t)) : {}
                                }
                                return (i ? Ie : _r)(t, (function (t, r, i) {
                                    return e(n, t, r, i)
                                })), n
                            }, Fn.unary = function (t) {
                                return Sa(t, 1)
                            }, Fn.union = ta, Fn.unionBy = ea, Fn.unionWith = na, Fn.uniq = function (t) {
                                return t && t.length ? ci(t) : []
                            }, Fn.uniqBy = function (t, e) {
                                return t && t.length ? ci(t, so(e, 2)) : []
                            }, Fn.uniqWith = function (t, e) {
                                return e = "function" == typeof e ? e : i, t && t.length ? ci(t, i, e) : []
                            }, Fn.unset = function (t, e) {
                                return null == t || ui(t, e)
                            }, Fn.unzip = ra, Fn.unzipWith = ia, Fn.update = function (t, e, n) {
                                return null == t ? t : hi(t, e, Ai(n))
                            }, Fn.updateWith = function (t, e, n, r) {
                                return r = "function" == typeof r ? r : i, null == t ? t : hi(t, e, Ai(n), r)
                            }, Fn.values = Fs, Fn.valuesIn = function (t) {
                                return null == t ? [] : Je(t, Rs(t))
                            }, Fn.without = oa, Fn.words = Ys, Fn.wrap = function (t, e) {
                                return ka(Ai(e), t)
                            }, Fn.xor = aa, Fn.xorBy = sa, Fn.xorWith = la, Fn.zip = ca, Fn.zipObject = function (t, e) {
                                return mi(t || [], e || [], tr)
                            }, Fn.zipObjectDeep = function (t, e) {
                                return mi(t || [], e || [], Jr)
                            }, Fn.zipWith = ua, Fn.entries = Us, Fn.entriesIn = Ns, Fn.extend = _s, Fn.extendWith = ys, al(Fn, Fn), Fn.add = gl, Fn.attempt = Ks, Fn.camelCase = Qs, Fn.capitalize = $s, Fn.ceil = Al, Fn.clamp = function (t, e, n) {
                                return n === i && (n = e, e = i), n !== i && (n = (n = ms(n)) == n ? n : 0), e !== i && (e = (e = ms(e)) == e ? e : 0), ar(ms(t), e, n)
                            }, Fn.clone = function (t) {
                                return sr(t, 4)
                            }, Fn.cloneDeep = function (t) {
                                return sr(t, 5)
                            }, Fn.cloneDeepWith = function (t, e) {
                                return sr(t, 5, e = "function" == typeof e ? e : i)
                            }, Fn.cloneWith = function (t, e) {
                                return sr(t, 4, e = "function" == typeof e ? e : i)
                            }, Fn.conformsTo = function (t, e) {
                                return null == e || lr(t, e, Bs(e))
                            }, Fn.deburr = Gs, Fn.defaultTo = function (t, e) {
                                return null == t || t != t ? e : t
                            }, Fn.divide = vl, Fn.endsWith = function (t, e, n) {
                                t = As(t), e = li(e);
                                var r = t.length,
                                    o = n = n === i ? r : ar(ps(n), 0, r);
                                return (n -= e.length) >= 0 && t.slice(n, o) == e
                            }, Fn.eq = Fa, Fn.escape = function (t) {
                                return (t = As(t)) && q.test(t) ? t.replace(j, rn) : t
                            }, Fn.escapeRegExp = function (t) {
                                return (t = As(t)) && rt.test(t) ? t.replace(nt, "\\$&") : t
                            }, Fn.every = function (t, e, n) {
                                var r = Ha(t) ? Te : pr;
                                return n && _o(t, e, n) && (e = i), r(t, so(e, 3))
                            }, Fn.find = ma, Fn.findIndex = Go, Fn.findKey = function (t, e) {
                                return Fe(t, so(e, 3), _r)
                            }, Fn.findLast = ga, Fn.findLastIndex = Ho, Fn.findLastKey = function (t, e) {
                                return Fe(t, so(e, 3), yr)
                            }, Fn.floor = _l, Fn.forEach = Aa, Fn.forEachRight = va, Fn.forIn = function (t, e) {
                                return null == t ? t : Ar(t, so(e, 3), Rs)
                            }, Fn.forInRight = function (t, e) {
                                return null == t ? t : vr(t, so(e, 3), Rs)
                            }, Fn.forOwn = function (t, e) {
                                return t && _r(t, so(e, 3))
                            }, Fn.forOwnRight = function (t, e) {
                                return t && yr(t, so(e, 3))
                            }, Fn.get = Cs, Fn.gt = Qa, Fn.gte = $a, Fn.has = function (t, e) {
                                return null != t && mo(t, e, Sr)
                            }, Fn.hasIn = Ss, Fn.head = Vo, Fn.identity = nl, Fn.includes = function (t, e, n, r) {
                                t = Va(t) ? t : Fs(t), n = n && !r ? ps(n) : 0;
                                var i = t.length;
                                return n < 0 && (n = An(i + n, 0)), as(t) ? n <= i && t.indexOf(e, n) > -1 : !!i && $e(t, e, n) > -1
                            }, Fn.indexOf = function (t, e, n) {
                                var r = null == t ? 0 : t.length;
                                if (!r) return -1;
                                var i = null == n ? 0 : ps(n);
                                return i < 0 && (i = An(r + i, 0)), $e(t, e, i)
                            }, Fn.inRange = function (t, e, n) {
                                return e = ds(e), n === i ? (n = e, e = 0) : n = ds(n),
                                    function (t, e, n) {
                                        return t >= vn(e, n) && t < An(e, n)
                                    }(t = ms(t), e, n)
                            }, Fn.invoke = Ts, Fn.isArguments = Ga, Fn.isArray = Ha, Fn.isArrayBuffer = za, Fn.isArrayLike = Va, Fn.isArrayLikeObject = Wa, Fn.isBoolean = function (t) {
                                return !0 === t || !1 === t || ts(t) && wr(t) == v
                            }, Fn.isBuffer = ja, Fn.isDate = Xa, Fn.isElement = function (t) {
                                return ts(t) && 1 === t.nodeType && !rs(t)
                            }, Fn.isEmpty = function (t) {
                                if (null == t) return !0;
                                if (Va(t) && (Ha(t) || "string" == typeof t || "function" == typeof t.splice || ja(t) || ls(t) || Ga(t))) return !t.length;
                                var e = fo(t);
                                if (e == b || e == M) return !t.size;
                                if (bo(t)) return !Or(t).length;
                                for (var n in t)
                                    if (Pt.call(t, n)) return !1;
                                return !0
                            }, Fn.isEqual = function (t, e) {
                                return Rr(t, e)
                            }, Fn.isEqualWith = function (t, e, n) {
                                var r = (n = "function" == typeof n ? n : i) ? n(t, e) : i;
                                return r === i ? Rr(t, e, i, n) : !!r
                            }, Fn.isError = qa, Fn.isFinite = function (t) {
                                return "number" == typeof t && ve(t)
                            }, Fn.isFunction = Ya, Fn.isInteger = Ka, Fn.isLength = Ja, Fn.isMap = es, Fn.isMatch = function (t, e) {
                                return t === e || Lr(t, e, co(e))
                            }, Fn.isMatchWith = function (t, e, n) {
                                return n = "function" == typeof n ? n : i, Lr(t, e, co(e), n)
                            }, Fn.isNaN = function (t) {
                                return ns(t) && t != +t
                            }, Fn.isNative = function (t) {
                                if (xo(t)) throw new xt("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
                                return Dr(t)
                            }, Fn.isNil = function (t) {
                                return null == t
                            }, Fn.isNull = function (t) {
                                return null === t
                            }, Fn.isNumber = ns, Fn.isObject = Za, Fn.isObjectLike = ts, Fn.isPlainObject = rs, Fn.isRegExp = is, Fn.isSafeInteger = function (t) {
                                return Ka(t) && t >= -9007199254740991 && t <= d
                            }, Fn.isSet = os, Fn.isString = as, Fn.isSymbol = ss, Fn.isTypedArray = ls, Fn.isUndefined = function (t) {
                                return t === i
                            }, Fn.isWeakMap = function (t) {
                                return ts(t) && fo(t) == R
                            }, Fn.isWeakSet = function (t) {
                                return ts(t) && "[object WeakSet]" == wr(t)
                            }, Fn.join = function (t, e) {
                                return null == t ? "" : Ne.call(t, e)
                            }, Fn.kebabCase = Hs, Fn.last = qo, Fn.lastIndexOf = function (t, e, n) {
                                var r = null == t ? 0 : t.length;
                                if (!r) return -1;
                                var o = r;
                                return n !== i && (o = (o = ps(n)) < 0 ? An(r + o, 0) : vn(o, r - 1)), e == e ? function (t, e, n) {
                                    for (var r = n + 1; r--;)
                                        if (t[r] === e) return r;
                                    return r
                                }(t, e, o) : Qe(t, He, o, !0)
                            }, Fn.lowerCase = zs, Fn.lowerFirst = Vs, Fn.lt = cs, Fn.lte = us, Fn.max = function (t) {
                                return t && t.length ? fr(t, nl, Cr) : i
                            }, Fn.maxBy = function (t, e) {
                                return t && t.length ? fr(t, so(e, 2), Cr) : i
                            }, Fn.mean = function (t) {
                                return ze(t, nl)
                            }, Fn.meanBy = function (t, e) {
                                return ze(t, so(e, 2))
                            }, Fn.min = function (t) {
                                return t && t.length ? fr(t, nl, Ur) : i
                            }, Fn.minBy = function (t, e) {
                                return t && t.length ? fr(t, so(e, 2), Ur) : i
                            }, Fn.stubArray = fl, Fn.stubFalse = ml, Fn.stubObject = function () {
                                return {}
                            }, Fn.stubString = function () {
                                return ""
                            }, Fn.stubTrue = function () {
                                return !0
                            }, Fn.multiply = El, Fn.nth = function (t, e) {
                                return t && t.length ? Gr(t, ps(e)) : i
                            }, Fn.noConflict = function () {
                                return pe._ === this && (pe._ = Ft), this
                            }, Fn.noop = sl, Fn.now = Ca, Fn.pad = function (t, e, n) {
                                t = As(t);
                                var r = (e = ps(e)) ? dn(t) : 0;
                                if (!e || r >= e) return t;
                                var i = (e - r) / 2;
                                return Hi(fe(i), n) + t + Hi(de(i), n)
                            }, Fn.padEnd = function (t, e, n) {
                                t = As(t);
                                var r = (e = ps(e)) ? dn(t) : 0;
                                return e && r < e ? t + Hi(e - r, n) : t
                            }, Fn.padStart = function (t, e, n) {
                                t = As(t);
                                var r = (e = ps(e)) ? dn(t) : 0;
                                return e && r < e ? Hi(e - r, n) + t : t
                            }, Fn.parseInt = function (t, e, n) {
                                return n || null == e ? e = 0 : e && (e = +e), yn(As(t).replace(it, ""), e || 0)
                            }, Fn.random = function (t, e, n) {
                                if (n && "boolean" != typeof n && _o(t, e, n) && (e = n = i), n === i && ("boolean" == typeof e ? (n = e, e = i) : "boolean" == typeof t && (n = t, t = i)), t === i && e === i ? (t = 0, e = 1) : (t = ds(t), e === i ? (e = t, t = 0) : e = ds(e)), t > e) {
                                    var r = t;
                                    t = e, e = r
                                }
                                if (n || t % 1 || e % 1) {
                                    var o = En();
                                    return vn(t + o * (e - t + ce("1e-" + ((o + "").length - 1))), e)
                                }
                                return jr(t, e)
                            }, Fn.reduce = function (t, e, n) {
                                var r = Ha(t) ? Oe : je,
                                    i = arguments.length < 3;
                                return r(t, so(e, 4), n, i, hr)
                            }, Fn.reduceRight = function (t, e, n) {
                                var r = Ha(t) ? ke : je,
                                    i = arguments.length < 3;
                                return r(t, so(e, 4), n, i, dr)
                            }, Fn.repeat = function (t, e, n) {
                                return e = (n ? _o(t, e, n) : e === i) ? 1 : ps(e), Xr(As(t), e)
                            }, Fn.replace = function () {
                                var t = arguments,
                                    e = As(t[0]);
                                return t.length < 3 ? e : e.replace(t[1], t[2])
                            }, Fn.result = function (t, e, n) {
                                var r = -1,
                                    o = (e = vi(e, t)).length;
                                for (o || (o = 1, t = i); ++r < o;) {
                                    var a = null == t ? i : t[ko(e[r])];
                                    a === i && (r = o, a = n), t = Ya(a) ? a.call(t) : a
                                }
                                return t
                            }, Fn.round = xl, Fn.runInContext = t, Fn.sample = function (t) {
                                return (Ha(t) ? Yn : Yr)(t)
                            }, Fn.size = function (t) {
                                if (null == t) return 0;
                                if (Va(t)) return as(t) ? dn(t) : t.length;
                                var e = fo(t);
                                return e == b || e == M ? t.size : Or(t).length
                            }, Fn.snakeCase = Ws, Fn.some = function (t, e, n) {
                                var r = Ha(t) ? Ue : ri;
                                return n && _o(t, e, n) && (e = i), r(t, so(e, 3))
                            }, Fn.sortedIndex = function (t, e) {
                                return ii(t, e)
                            }, Fn.sortedIndexBy = function (t, e, n) {
                                return oi(t, e, so(n, 2))
                            }, Fn.sortedIndexOf = function (t, e) {
                                var n = null == t ? 0 : t.length;
                                if (n) {
                                    var r = ii(t, e);
                                    if (r < n && Fa(t[r], e)) return r
                                }
                                return -1
                            }, Fn.sortedLastIndex = function (t, e) {
                                return ii(t, e, !0)
                            }, Fn.sortedLastIndexBy = function (t, e, n) {
                                return oi(t, e, so(n, 2), !0)
                            }, Fn.sortedLastIndexOf = function (t, e) {
                                if (null == t ? 0 : t.length) {
                                    var n = ii(t, e, !0) - 1;
                                    if (Fa(t[n], e)) return n
                                }
                                return -1
                            }, Fn.startCase = js, Fn.startsWith = function (t, e, n) {
                                return t = As(t), n = null == n ? 0 : ar(ps(n), 0, t.length), e = li(e), t.slice(n, n + e.length) == e
                            }, Fn.subtract = bl, Fn.sum = function (t) {
                                return t && t.length ? Xe(t, nl) : 0
                            }, Fn.sumBy = function (t, e) {
                                return t && t.length ? Xe(t, so(e, 2)) : 0
                            }, Fn.template = function (t, e, n) {
                                var r = Fn.templateSettings;
                                n && _o(t, e, n) && (e = i), t = As(t), e = ys({}, e, r, Ki);
                                var o, a, s = ys({}, e.imports, r.imports, Ki),
                                    l = Bs(s),
                                    c = Je(s, l),
                                    u = 0,
                                    h = e.interpolate || yt,
                                    d = "__p += '",
                                    p = St((e.escape || yt).source + "|" + h.source + "|" + (h === J ? dt : yt).source + "|" + (e.evaluate || yt).source + "|$", "g"),
                                    f = "//# sourceURL=" + (Pt.call(e, "sourceURL") ? (e.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++oe + "]") + "\n";
                                t.replace(p, (function (e, n, r, i, s, l) {
                                    return r || (r = i), d += t.slice(u, l).replace(Et, on), n && (o = !0, d += "' +\n__e(" + n + ") +\n'"), s && (a = !0, d += "';\n" + s + ";\n__p += '"), r && (d += "' +\n((__t = (" + r + ")) == null ? '' : __t) +\n'"), u = l + e.length, e
                                })), d += "';\n";
                                var m = Pt.call(e, "variable") && e.variable;
                                if (m) {
                                    if (ut.test(m)) throw new xt("Invalid `variable` option passed into `_.template`")
                                } else d = "with (obj) {\n" + d + "\n}\n";
                                d = (a ? d.replace(H, "") : d).replace(z, "$1").replace(V, "$1;"), d = "function(" + (m || "obj") + ") {\n" + (m ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (o ? ", __e = _.escape" : "") + (a ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + d + "return __p\n}";
                                var g = Ks((function () {
                                    return bt(l, f + "return " + d).apply(i, c)
                                }));
                                if (g.source = d, qa(g)) throw g;
                                return g
                            }, Fn.times = function (t, e) {
                                if ((t = ps(t)) < 1 || t > d) return [];
                                var n = f,
                                    r = vn(t, f);
                                e = so(e), t -= f;
                                for (var i = qe(r, e); ++n < t;) e(n);
                                return i
                            }, Fn.toFinite = ds, Fn.toInteger = ps, Fn.toLength = fs, Fn.toLower = function (t) {
                                return As(t).toLowerCase()
                            }, Fn.toNumber = ms, Fn.toSafeInteger = function (t) {
                                return t ? ar(ps(t), -9007199254740991, d) : 0 === t ? t : 0
                            }, Fn.toString = As, Fn.toUpper = function (t) {
                                return As(t).toUpperCase()
                            }, Fn.trim = function (t, e, n) {
                                if ((t = As(t)) && (n || e === i)) return Ye(t);
                                if (!t || !(e = li(e))) return t;
                                var r = pn(t),
                                    o = pn(e);
                                return yi(r, tn(r, o), en(r, o) + 1).join("")
                            }, Fn.trimEnd = function (t, e, n) {
                                if ((t = As(t)) && (n || e === i)) return t.slice(0, fn(t) + 1);
                                if (!t || !(e = li(e))) return t;
                                var r = pn(t);
                                return yi(r, 0, en(r, pn(e)) + 1).join("")
                            }, Fn.trimStart = function (t, e, n) {
                                if ((t = As(t)) && (n || e === i)) return t.replace(it, "");
                                if (!t || !(e = li(e))) return t;
                                var r = pn(t);
                                return yi(r, tn(r, pn(e))).join("")
                            }, Fn.truncate = function (t, e) {
                                var n = 30,
                                    r = "...";
                                if (Za(e)) {
                                    var o = "separator" in e ? e.separator : o;
                                    n = "length" in e ? ps(e.length) : n, r = "omission" in e ? li(e.omission) : r
                                }
                                var a = (t = As(t)).length;
                                if (an(t)) {
                                    var s = pn(t);
                                    a = s.length
                                }
                                if (n >= a) return t;
                                var l = n - dn(r);
                                if (l < 1) return r;
                                var c = s ? yi(s, 0, l).join("") : t.slice(0, l);
                                if (o === i) return c + r;
                                if (s && (l += c.length - l), is(o)) {
                                    if (t.slice(l).search(o)) {
                                        var u, h = c;
                                        for (o.global || (o = St(o.source, As(pt.exec(o)) + "g")), o.lastIndex = 0; u = o.exec(h);) var d = u.index;
                                        c = c.slice(0, d === i ? l : d)
                                    }
                                } else if (t.indexOf(li(o), l) != l) {
                                    var p = c.lastIndexOf(o);
                                    p > -1 && (c = c.slice(0, p))
                                }
                                return c + r
                            }, Fn.unescape = function (t) {
                                return (t = As(t)) && X.test(t) ? t.replace(W, mn) : t
                            }, Fn.uniqueId = function (t) {
                                var e = ++Ot;
                                return As(t) + e
                            }, Fn.upperCase = Xs, Fn.upperFirst = qs, Fn.each = Aa, Fn.eachRight = va, Fn.first = Vo, al(Fn, (yl = {}, _r(Fn, (function (t, e) {
                                Pt.call(Fn.prototype, e) || (yl[e] = t)
                            })), yl), {
                                chain: !1
                            }), Fn.VERSION = "4.17.21", Ie(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], (function (t) {
                                Fn[t].placeholder = Fn
                            })), Ie(["drop", "take"], (function (t, e) {
                                Hn.prototype[t] = function (n) {
                                    n = n === i ? 1 : An(ps(n), 0);
                                    var r = this.__filtered__ && !e ? new Hn(this) : this.clone();
                                    return r.__filtered__ ? r.__takeCount__ = vn(n, r.__takeCount__) : r.__views__.push({
                                        size: vn(n, f),
                                        type: t + (r.__dir__ < 0 ? "Right" : "")
                                    }), r
                                }, Hn.prototype[t + "Right"] = function (e) {
                                    return this.reverse()[t](e).reverse()
                                }
                            })), Ie(["filter", "map", "takeWhile"], (function (t, e) {
                                var n = e + 1,
                                    r = 1 == n || 3 == n;
                                Hn.prototype[t] = function (t) {
                                    var e = this.clone();
                                    return e.__iteratees__.push({
                                        iteratee: so(t, 3),
                                        type: n
                                    }), e.__filtered__ = e.__filtered__ || r, e
                                }
                            })), Ie(["head", "last"], (function (t, e) {
                                var n = "take" + (e ? "Right" : "");
                                Hn.prototype[t] = function () {
                                    return this[n](1).value()[0]
                                }
                            })), Ie(["initial", "tail"], (function (t, e) {
                                var n = "drop" + (e ? "" : "Right");
                                Hn.prototype[t] = function () {
                                    return this.__filtered__ ? new Hn(this) : this[n](1)
                                }
                            })), Hn.prototype.compact = function () {
                                return this.filter(nl)
                            }, Hn.prototype.find = function (t) {
                                return this.filter(t).head()
                            }, Hn.prototype.findLast = function (t) {
                                return this.reverse().find(t)
                            }, Hn.prototype.invokeMap = qr((function (t, e) {
                                return "function" == typeof t ? new Hn(this) : this.map((function (n) {
                                    return Tr(n, t, e)
                                }))
                            })), Hn.prototype.reject = function (t) {
                                return this.filter(Pa(so(t)))
                            }, Hn.prototype.slice = function (t, e) {
                                t = ps(t);
                                var n = this;
                                return n.__filtered__ && (t > 0 || e < 0) ? new Hn(n) : (t < 0 ? n = n.takeRight(-t) : t && (n = n.drop(t)), e !== i && (n = (e = ps(e)) < 0 ? n.dropRight(-e) : n.take(e - t)), n)
                            }, Hn.prototype.takeRightWhile = function (t) {
                                return this.reverse().takeWhile(t).reverse()
                            }, Hn.prototype.toArray = function () {
                                return this.take(f)
                            }, _r(Hn.prototype, (function (t, e) {
                                var n = /^(?:filter|find|map|reject)|While$/.test(e),
                                    r = /^(?:head|last)$/.test(e),
                                    o = Fn[r ? "take" + ("last" == e ? "Right" : "") : e],
                                    a = r || /^find/.test(e);
                                o && (Fn.prototype[e] = function () {
                                    var e = this.__wrapped__,
                                        s = r ? [1] : arguments,
                                        l = e instanceof Hn,
                                        c = s[0],
                                        u = l || Ha(e),
                                        h = function (t) {
                                            var e = o.apply(Fn, Pe([t], s));
                                            return r && d ? e[0] : e
                                        };
                                    u && n && "function" == typeof c && 1 != c.length && (l = u = !1);
                                    var d = this.__chain__,
                                        p = !!this.__actions__.length,
                                        f = a && !d,
                                        m = l && !p;
                                    if (!a && u) {
                                        e = m ? e : new Hn(this);
                                        var g = t.apply(e, s);
                                        return g.__actions__.push({
                                            func: da,
                                            args: [h],
                                            thisArg: i
                                        }), new Gn(g, d)
                                    }
                                    return f && m ? t.apply(this, s) : (g = this.thru(h), f ? r ? g.value()[0] : g.value() : g)
                                })
                            })), Ie(["pop", "push", "shift", "sort", "splice", "unshift"], (function (t) {
                                var e = Tt[t],
                                    n = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
                                    r = /^(?:pop|shift)$/.test(t);
                                Fn.prototype[t] = function () {
                                    var t = arguments;
                                    if (r && !this.__chain__) {
                                        var i = this.value();
                                        return e.apply(Ha(i) ? i : [], t)
                                    }
                                    return this[n]((function (n) {
                                        return e.apply(Ha(n) ? n : [], t)
                                    }))
                                }
                            })), _r(Hn.prototype, (function (t, e) {
                                var n = Fn[e];
                                if (n) {
                                    var r = n.name + "";
                                    Pt.call(Bn, r) || (Bn[r] = []), Bn[r].push({
                                        name: e,
                                        func: n
                                    })
                                }
                            })), Bn[Fi(i, 2).name] = [{
                                name: "wrapper",
                                func: i
                            }], Hn.prototype.clone = function () {
                                var t = new Hn(this.__wrapped__);
                                return t.__actions__ = Mi(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__, t.__iteratees__ = Mi(this.__iteratees__), t.__takeCount__ = this.__takeCount__, t.__views__ = Mi(this.__views__), t
                            }, Hn.prototype.reverse = function () {
                                if (this.__filtered__) {
                                    var t = new Hn(this);
                                    t.__dir__ = -1, t.__filtered__ = !0
                                } else(t = this.clone()).__dir__ *= -1;
                                return t
                            }, Hn.prototype.value = function () {
                                var t = this.__wrapped__.value(),
                                    e = this.__dir__,
                                    n = Ha(t),
                                    r = e < 0,
                                    i = n ? t.length : 0,
                                    o = function (t, e, n) {
                                        var r = -1,
                                            i = n.length;
                                        for (; ++r < i;) {
                                            var o = n[r],
                                                a = o.size;
                                            switch (o.type) {
                                                case "drop":
                                                    t += a;
                                                    break;
                                                case "dropRight":
                                                    e -= a;
                                                    break;
                                                case "take":
                                                    e = vn(e, t + a);
                                                    break;
                                                case "takeRight":
                                                    t = An(t, e - a)
                                            }
                                        }
                                        return {
                                            start: t,
                                            end: e
                                        }
                                    }(0, i, this.__views__),
                                    a = o.start,
                                    s = o.end,
                                    l = s - a,
                                    c = r ? s : a - 1,
                                    u = this.__iteratees__,
                                    h = u.length,
                                    d = 0,
                                    p = vn(l, this.__takeCount__);
                                if (!n || !r && i == l && p == l) return pi(t, this.__actions__);
                                var f = [];
                                t: for (; l-- && d < p;) {
                                    for (var m = -1, g = t[c += e]; ++m < h;) {
                                        var A = u[m],
                                            v = A.iteratee,
                                            _ = A.type,
                                            y = v(g);
                                        if (2 == _) g = y;
                                        else if (!y) {
                                            if (1 == _) continue t;
                                            break t
                                        }
                                    }
                                    f[d++] = g
                                }
                                return f
                            }, Fn.prototype.at = pa, Fn.prototype.chain = function () {
                                return ha(this)
                            }, Fn.prototype.commit = function () {
                                return new Gn(this.value(), this.__chain__)
                            }, Fn.prototype.next = function () {
                                this.__values__ === i && (this.__values__ = hs(this.value()));
                                var t = this.__index__ >= this.__values__.length;
                                return {
                                    done: t,
                                    value: t ? i : this.__values__[this.__index__++]
                                }
                            }, Fn.prototype.plant = function (t) {
                                for (var e, n = this; n instanceof $n;) {
                                    var r = No(n);
                                    r.__index__ = 0, r.__values__ = i, e ? o.__wrapped__ = r : e = r;
                                    var o = r;
                                    n = n.__wrapped__
                                }
                                return o.__wrapped__ = t, e
                            }, Fn.prototype.reverse = function () {
                                var t = this.__wrapped__;
                                if (t instanceof Hn) {
                                    var e = t;
                                    return this.__actions__.length && (e = new Hn(this)), (e = e.reverse()).__actions__.push({
                                        func: da,
                                        args: [Zo],
                                        thisArg: i
                                    }), new Gn(e, this.__chain__)
                                }
                                return this.thru(Zo)
                            }, Fn.prototype.toJSON = Fn.prototype.valueOf = Fn.prototype.value = function () {
                                return pi(this.__wrapped__, this.__actions__)
                            }, Fn.prototype.first = Fn.prototype.head, Yt && (Fn.prototype[Yt] = function () {
                                return this
                            }), Fn
                        }();
                        pe._ = gn, (r = function () {
                            return gn
                        }.call(e, n, e, t)) === i || (t.exports = r)
                    }.call(this)
            }
        },
        e = {};

    function n(r) {
        var i = e[r];
        if (void 0 !== i) return i.exports;
        var o = e[r] = {
            id: r,
            loaded: !1,
            exports: {}
        };
        return t[r].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports
    }
    n.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, {
            a: e
        }), e
    }, n.d = (t, e) => {
        for (var r in e) n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, {
            enumerable: !0,
            get: e[r]
        })
    }, n.g = function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.nmd = t => (t.paths = [], t.children || (t.children = []), t), (() => {
        function t(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function e(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        /*!
         * GSAP 3.12.5
         * https://gsap.com
         *
         * @license Copyright 2008-2024, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var r, i, o, a, s, l, c, u, h, d, p, f = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            m = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            g = 1e8,
            A = 1e-8,
            v = 2 * Math.PI,
            _ = v / 4,
            y = 0,
            E = Math.sqrt,
            x = Math.cos,
            b = Math.sin,
            w = function (t) {
                return "string" == typeof t
            },
            C = function (t) {
                return "function" == typeof t
            },
            S = function (t) {
                return "number" == typeof t
            },
            I = function (t) {
                return void 0 === t
            },
            M = function (t) {
                return "object" == typeof t
            },
            T = function (t) {
                return !1 !== t
            },
            B = function () {
                return "undefined" != typeof window
            },
            R = function (t) {
                return C(t) || w(t)
            },
            L = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {},
            D = Array.isArray,
            P = /(?:-?\.?\d|\.)+/gi,
            O = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            k = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            U = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
            N = /[+-]=-?[.\d]+/,
            F = /[^,'"\[\]\s]+/gi,
            Q = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
            $ = {},
            G = {},
            H = function (t) {
                return (G = vt(t, $)) && yn
            },
            z = function (t, e) {
                return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
            },
            V = function (t, e) {
                return !e && console.warn(t)
            },
            W = function (t, e) {
                return t && ($[t] = e) && G && (G[t] = e) || $
            },
            j = function () {
                return 0
            },
            X = {
                suppressEvents: !0,
                isStart: !0,
                kill: !1
            },
            q = {
                suppressEvents: !0,
                kill: !1
            },
            Y = {
                suppressEvents: !0
            },
            K = {},
            J = [],
            Z = {},
            tt = {},
            et = {},
            nt = 30,
            rt = [],
            it = "",
            ot = function (t) {
                var e, n, r = t[0];
                if (M(r) || C(r) || (t = [t]), !(e = (r._gsap || {}).harness)) {
                    for (n = rt.length; n-- && !rt[n].targetTest(r););
                    e = rt[n]
                }
                for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new De(t[n], e))) || t.splice(n, 1);
                return t
            },
            at = function (t) {
                return t._gsap || ot(Yt(t))[0]._gsap
            },
            st = function (t, e, n) {
                return (n = t[e]) && C(n) ? t[e]() : I(n) && t.getAttribute && t.getAttribute(e) || n
            },
            lt = function (t, e) {
                return (t = t.split(",")).forEach(e) || t
            },
            ct = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            ut = function (t) {
                return Math.round(1e7 * t) / 1e7 || 0
            },
            ht = function (t, e) {
                var n = e.charAt(0),
                    r = parseFloat(e.substr(2));
                return t = parseFloat(t), "+" === n ? t + r : "-" === n ? t - r : "*" === n ? t * r : t / r
            },
            dt = function (t, e) {
                for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n;);
                return r < n
            },
            pt = function () {
                var t, e, n = J.length,
                    r = J.slice(0);
                for (Z = {}, J.length = 0, t = 0; t < n; t++)(e = r[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            },
            ft = function (t, e, n, r) {
                J.length && !i && pt(), t.render(e, n, i && e < 0 && (t._initted || t._startAt)), J.length && !i && pt()
            },
            mt = function (t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(F).length < 2 ? e : w(t) ? t.trim() : t
            },
            gt = function (t) {
                return t
            },
            At = function (t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            vt = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            _t = function t(e, n) {
                for (var r in n) "__proto__" !== r && "constructor" !== r && "prototype" !== r && (e[r] = M(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r]);
                return e
            },
            yt = function (t, e) {
                var n, r = {};
                for (n in t) n in e || (r[n] = t[n]);
                return r
            },
            Et = function (t) {
                var e, n = t.parent || a,
                    r = t.keyframes ? (e = D(t.keyframes), function (t, n) {
                        for (var r in n) r in t || "duration" === r && e || "ease" === r || (t[r] = n[r])
                    }) : At;
                if (T(t.inherit))
                    for (; n;) r(t, n.vars.defaults), n = n.parent || n._dp;
                return t
            },
            xt = function (t, e, n, r, i) {
                var o, a = t[r];
                if (i)
                    for (o = e[i]; a && a[i] > o;) a = a._prev;
                return a ? (e._next = a._next, a._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = a, e.parent = e._dp = t, e
            },
            bt = function (t, e, n, r) {
                void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                var i = e._prev,
                    o = e._next;
                i ? i._next = o : t[n] === e && (t[n] = o), o ? o._prev = i : t[r] === e && (t[r] = i), e._next = e._prev = e.parent = null
            },
            wt = function (t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0
            },
            Ct = function (t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var n = t; n;) n._dirty = 1, n = n.parent;
                return t
            },
            St = function (t, e, n, r) {
                return t._startAt && (i ? t._startAt.revert(q) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, r))
            },
            It = function t(e) {
                return !e || e._ts && t(e.parent)
            },
            Mt = function (t) {
                return t._repeat ? Tt(t._tTime, t = t.duration() + t._rDelay) * t : 0
            },
            Tt = function (t, e) {
                var n = Math.floor(t /= e);
                return t && n === t ? n - 1 : n
            },
            Bt = function (t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            },
            Rt = function (t) {
                return t._end = ut(t._start + (t._tDur / Math.abs(t._ts || t._rts || A) || 0))
            },
            Lt = function (t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = ut(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Rt(t), n._dirty || Ct(n, t)), t
            },
            Dt = function (t, e) {
                var n;
                if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (n = Bt(t.rawTime(), e), (!e._dur || Vt(0, e.totalDuration(), n) - e._tTime > A) && e.render(n, !0)), Ct(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            },
            Pt = function (t, e, n, r) {
                return e.parent && wt(e), e._start = ut((S(n) ? n : n || t !== a ? Gt(t, n, e) : t._time) + e._delay), e._end = ut(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), xt(t, e, "_first", "_last", t._sort ? "_start" : 0), Nt(e) || (t._recent = e), r || Dt(t, e), t._ts < 0 && Lt(t, t._tTime), t
            },
            Ot = function (t, e) {
                return ($.ScrollTrigger || z("scrollTrigger", e)) && $.ScrollTrigger.create(e, t)
            },
            kt = function (t, e, n, r, o) {
                return $e(t, e, o), t._initted ? !n && t._pt && !i && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && h !== ye.frame ? (J.push(t), t._lazy = [o, r], 1) : void 0 : 1
            },
            Ut = function t(e) {
                var n = e.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
            },
            Nt = function (t) {
                var e = t.data;
                return "isFromStart" === e || "isStart" === e
            },
            Ft = function (t, e, n, r) {
                var i = t._repeat,
                    o = ut(e) || 0,
                    a = t._tTime / t._tDur;
                return a && !r && (t._time *= o / t._dur), t._dur = o, t._tDur = i ? i < 0 ? 1e10 : ut(o * (i + 1) + t._rDelay * i) : o, a > 0 && !r && Lt(t, t._tTime = t._tDur * a), t.parent && Rt(t), n || Ct(t.parent, t), t
            },
            Qt = function (t) {
                return t instanceof Oe ? Ct(t) : Ft(t, t._dur)
            },
            $t = {
                _start: 0,
                endTime: j,
                totalDuration: j
            },
            Gt = function t(e, n, r) {
                var i, o, a, s = e.labels,
                    l = e._recent || $t,
                    c = e.duration() >= g ? l.endTime(!1) : e._dur;
                return w(n) && (isNaN(n) || n in s) ? (o = n.charAt(0), a = "%" === n.substr(-1), i = n.indexOf("="), "<" === o || ">" === o ? (i >= 0 && (n = n.replace(/=/, "")), ("<" === o ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (a ? (i < 0 ? l : r).totalDuration() / 100 : 1)) : i < 0 ? (n in s || (s[n] = c), s[n]) : (o = parseFloat(n.charAt(i - 1) + n.substr(i + 1)), a && r && (o = o / 100 * (D(r) ? r[0] : r).totalDuration()), i > 1 ? t(e, n.substr(0, i - 1), r) + o : c + o)) : null == n ? c : +n
            },
            Ht = function (t, e, n) {
                var r, i, o = S(e[1]),
                    a = (o ? 2 : 1) + (t < 2 ? 0 : 1),
                    s = e[a];
                if (o && (s.duration = e[1]), s.parent = n, t) {
                    for (r = s, i = n; i && !("immediateRender" in r);) r = i.vars.defaults || {}, i = T(i.vars.inherit) && i.parent;
                    s.immediateRender = T(r.immediateRender), t < 2 ? s.runBackwards = 1 : s.startAt = e[a - 1]
                }
                return new We(e[0], s, e[a + 1])
            },
            zt = function (t, e) {
                return t || 0 === t ? e(t) : e
            },
            Vt = function (t, e, n) {
                return n < t ? t : n > e ? e : n
            },
            Wt = function (t, e) {
                return w(t) && (e = Q.exec(t)) ? e[1] : ""
            },
            jt = [].slice,
            Xt = function (t, e) {
                return t && M(t) && "length" in t && (!e && !t.length || t.length - 1 in t && M(t[0])) && !t.nodeType && t !== s
            },
            qt = function (t, e, n) {
                return void 0 === n && (n = []), t.forEach((function (t) {
                    var r;
                    return w(t) && !e || Xt(t, 1) ? (r = n).push.apply(r, Yt(t)) : n.push(t)
                })) || n
            },
            Yt = function (t, e, n) {
                return o && !e && o.selector ? o.selector(t) : !w(t) || n || !l && Ee() ? D(t) ? qt(t, n) : Xt(t) ? jt.call(t, 0) : t ? [t] : [] : jt.call((e || c).querySelectorAll(t), 0)
            },
            Kt = function (t) {
                return t = Yt(t)[0] || V("Invalid scope") || {},
                    function (e) {
                        var n = t.current || t.nativeElement || t;
                        return Yt(e, n.querySelectorAll ? n : n === t ? V("Invalid scope") || c.createElement("div") : t)
                    }
            },
            Jt = function (t) {
                return t.sort((function () {
                    return .5 - Math.random()
                }))
            },
            Zt = function (t) {
                if (C(t)) return t;
                var e = M(t) ? t : {
                        each: t
                    },
                    n = Me(e.ease),
                    r = e.from || 0,
                    i = parseFloat(e.base) || 0,
                    o = {},
                    a = r > 0 && r < 1,
                    s = isNaN(r) || a,
                    l = e.axis,
                    c = r,
                    u = r;
                return w(r) ? c = u = {
                        center: .5,
                        edges: .5,
                        end: 1
                    } [r] || 0 : !a && s && (c = r[0], u = r[1]),
                    function (t, a, h) {
                        var d, p, f, m, A, v, _, y, x, b = (h || e).length,
                            w = o[b];
                        if (!w) {
                            if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, g])[1])) {
                                for (_ = -g; _ < (_ = h[x++].getBoundingClientRect().left) && x < b;);
                                x < b && x--
                            }
                            for (w = o[b] = [], d = s ? Math.min(x, b) * c - .5 : r % x, p = x === g ? 0 : s ? b * u / x - .5 : r / x | 0, _ = 0, y = g, v = 0; v < b; v++) f = v % x - d, m = p - (v / x | 0), w[v] = A = l ? Math.abs("y" === l ? m : f) : E(f * f + m * m), A > _ && (_ = A), A < y && (y = A);
                            "random" === r && Jt(w), w.max = _ - y, w.min = y, w.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === r ? -1 : 1), w.b = b < 0 ? i - b : i, w.u = Wt(e.amount || e.each) || 0, n = n && b < 0 ? Se(n) : n
                        }
                        return b = (w[t] - w.min) / w.max || 0, ut(w.b + (n ? n(b) : b) * w.v) + w.u
                    }
            },
            te = function (t) {
                var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
                return function (n) {
                    var r = ut(Math.round(parseFloat(n) / t) * t * e);
                    return (r - r % 1) / e + (S(n) ? 0 : Wt(n))
                }
            },
            ee = function (t, e) {
                var n, r, i = D(t);
                return !i && M(t) && (n = i = t.radius || g, t.values ? (t = Yt(t.values), (r = !S(t[0])) && (n *= n)) : t = te(t.increment)), zt(e, i ? C(t) ? function (e) {
                    return r = t(e), Math.abs(r - e) <= n ? r : e
                } : function (e) {
                    for (var i, o, a = parseFloat(r ? e.x : e), s = parseFloat(r ? e.y : 0), l = g, c = 0, u = t.length; u--;)(i = r ? (i = t[u].x - a) * i + (o = t[u].y - s) * o : Math.abs(t[u] - a)) < l && (l = i, c = u);
                    return c = !n || l <= n ? t[c] : e, r || c === e || S(e) ? c : c + Wt(e)
                } : te(t))
            },
            ne = function (t, e, n, r) {
                return zt(D(t) ? !e : !0 === n ? !!(n = 0) : !r, (function () {
                    return D(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * r) / r
                }))
            },
            re = function (t, e, n) {
                return zt(n, (function (n) {
                    return t[~~e(n)]
                }))
            },
            ie = function (t) {
                for (var e, n, r, i, o = 0, a = ""; ~(e = t.indexOf("random(", o));) r = t.indexOf(")", e), i = "[" === t.charAt(e + 7), n = t.substr(e + 7, r - e - 7).match(i ? F : P), a += t.substr(o, e - o) + ne(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5), o = r + 1;
                return a + t.substr(o, t.length - o)
            },
            oe = function (t, e, n, r, i) {
                var o = e - t,
                    a = r - n;
                return zt(i, (function (e) {
                    return n + ((e - t) / o * a || 0)
                }))
            },
            ae = function (t, e, n) {
                var r, i, o, a = t.labels,
                    s = g;
                for (r in a)(i = a[r] - e) < 0 == !!n && i && s > (i = Math.abs(i)) && (o = r, s = i);
                return o
            },
            se = function (t, e, n) {
                var r, i, a, s = t.vars,
                    l = s[e],
                    c = o,
                    u = t._ctx;
                if (l) return r = s[e + "Params"], i = s.callbackScope || t, n && J.length && pt(), u && (o = u), a = r ? l.apply(i, r) : l.call(i), o = c, a
            },
            le = function (t) {
                return wt(t), t.scrollTrigger && t.scrollTrigger.kill(!!i), t.progress() < 1 && se(t, "onInterrupt"), t
            },
            ce = [],
            ue = function (t) {
                if (t)
                    if (t = !t.name && t.default || t, B() || t.headless) {
                        var e = t.name,
                            n = C(t),
                            r = e && !n && t.init ? function () {
                                this._props = []
                            } : t,
                            i = {
                                init: j,
                                render: en,
                                add: Fe,
                                kill: rn,
                                modifier: nn,
                                rawVars: 0
                            },
                            o = {
                                targetTest: 0,
                                get: 0,
                                getSetter: Ke,
                                aliases: {},
                                register: 0
                            };
                        if (Ee(), t !== r) {
                            if (tt[e]) return;
                            At(r, At(yt(t, i), o)), vt(r.prototype, vt(i, yt(t, o))), tt[r.prop = e] = r, t.targetTest && (rt.push(r), K[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                        }
                        W(e, r), t.register && t.register(yn, r, sn)
                    } else ce.push(t)
            },
            he = 255,
            de = {
                aqua: [0, he, he],
                lime: [0, he, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, he],
                navy: [0, 0, 128],
                white: [he, he, he],
                olive: [128, 128, 0],
                yellow: [he, he, 0],
                orange: [he, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [he, 0, 0],
                pink: [he, 192, 203],
                cyan: [0, he, he],
                transparent: [he, he, he, 0]
            },
            pe = function (t, e, n) {
                return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * he + .5 | 0
            },
            fe = function (t, e, n) {
                var r, i, o, a, s, l, c, u, h, d, p = t ? S(t) ? [t >> 16, t >> 8 & he, t & he] : 0 : de.black;
                if (!p) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), de[t]) p = de[t];
                    else if ("#" === t.charAt(0)) {
                        if (t.length < 6 && (r = t.charAt(1), i = t.charAt(2), o = t.charAt(3), t = "#" + r + r + i + i + o + o + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & he, p & he, parseInt(t.substr(7), 16) / 255];
                        p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & he, t & he]
                    } else if ("hsl" === t.substr(0, 3))
                        if (p = d = t.match(P), e) {
                            if (~t.indexOf("=")) return p = t.match(O), n && p.length < 4 && (p[3] = 1), p
                        } else a = +p[0] % 360 / 360, s = +p[1] / 100, r = 2 * (l = +p[2] / 100) - (i = l <= .5 ? l * (s + 1) : l + s - l * s), p.length > 3 && (p[3] *= 1), p[0] = pe(a + 1 / 3, r, i), p[1] = pe(a, r, i), p[2] = pe(a - 1 / 3, r, i);
                    else p = t.match(P) || de.transparent;
                    p = p.map(Number)
                }
                return e && !d && (r = p[0] / he, i = p[1] / he, o = p[2] / he, l = ((c = Math.max(r, i, o)) + (u = Math.min(r, i, o))) / 2, c === u ? a = s = 0 : (h = c - u, s = l > .5 ? h / (2 - c - u) : h / (c + u), a = c === r ? (i - o) / h + (i < o ? 6 : 0) : c === i ? (o - r) / h + 2 : (r - i) / h + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * s + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
            },
            me = function (t) {
                var e = [],
                    n = [],
                    r = -1;
                return t.split(Ae).forEach((function (t) {
                    var i = t.match(k) || [];
                    e.push.apply(e, i), n.push(r += i.length + 1)
                })), e.c = n, e
            },
            ge = function (t, e, n) {
                var r, i, o, a, s = "",
                    l = (t + s).match(Ae),
                    c = e ? "hsla(" : "rgba(",
                    u = 0;
                if (!l) return t;
                if (l = l.map((function (t) {
                        return (t = fe(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                    })), n && (o = me(t), (r = n.c).join(s) !== o.c.join(s)))
                    for (a = (i = t.replace(Ae, "1").split(k)).length - 1; u < a; u++) s += i[u] + (~r.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (o.length ? o : l.length ? l : n).shift());
                if (!i)
                    for (a = (i = t.split(Ae)).length - 1; u < a; u++) s += i[u] + l[u];
                return s + i[a]
            },
            Ae = function () {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (t in de) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(),
            ve = /hsl[a]?\(/,
            _e = function (t) {
                var e, n = t.join(" ");
                if (Ae.lastIndex = 0, Ae.test(n)) return e = ve.test(n), t[1] = ge(t[1], e), t[0] = ge(t[0], e, me(t[1])), !0
            },
            ye = function () {
                var t, e, n, r, i, o, a = Date.now,
                    h = 500,
                    d = 33,
                    f = a(),
                    m = f,
                    g = 1e3 / 240,
                    A = g,
                    v = [],
                    _ = function n(s) {
                        var l, c, u, p, _ = a() - m,
                            y = !0 === s;
                        if ((_ > h || _ < 0) && (f += _ - d), ((l = (u = (m += _) - f) - A) > 0 || y) && (p = ++r.frame, i = u - 1e3 * r.time, r.time = u /= 1e3, A += l + (l >= g ? 4 : g - l), c = 1), y || (t = e(n)), c)
                            for (o = 0; o < v.length; o++) v[o](u, i, p, s)
                    };
                return r = {
                    time: 0,
                    frame: 0,
                    tick: function () {
                        _(!0)
                    },
                    deltaRatio: function (t) {
                        return i / (1e3 / (t || 60))
                    },
                    wake: function () {
                        u && (!l && B() && (s = l = window, c = s.document || {}, $.gsap = yn, (s.gsapVersions || (s.gsapVersions = [])).push(yn.version), H(G || s.GreenSockGlobals || !s.gsap && s || {}), ce.forEach(ue)), n = "undefined" != typeof requestAnimationFrame && requestAnimationFrame, t && r.sleep(), e = n || function (t) {
                            return setTimeout(t, A - 1e3 * r.time + 1 | 0)
                        }, p = 1, _(2))
                    },
                    sleep: function () {
                        (n ? cancelAnimationFrame : clearTimeout)(t), p = 0, e = j
                    },
                    lagSmoothing: function (t, e) {
                        h = t || 1 / 0, d = Math.min(e || 33, h)
                    },
                    fps: function (t) {
                        g = 1e3 / (t || 240), A = 1e3 * r.time + g
                    },
                    add: function (t, e, n) {
                        var i = e ? function (e, n, o, a) {
                            t(e, n, o, a), r.remove(i)
                        } : t;
                        return r.remove(t), v[n ? "unshift" : "push"](i), Ee(), i
                    },
                    remove: function (t, e) {
                        ~(e = v.indexOf(t)) && v.splice(e, 1) && o >= e && o--
                    },
                    _listeners: v
                }, r
            }(),
            Ee = function () {
                return !p && ye.wake()
            },
            xe = {},
            be = /^[\d.\-M][\d.\-,\s]/,
            we = /["']/g,
            Ce = function (t) {
                for (var e, n, r, i = {}, o = t.substr(1, t.length - 3).split(":"), a = o[0], s = 1, l = o.length; s < l; s++) n = o[s], e = s !== l - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), i[a] = isNaN(r) ? r.replace(we, "").trim() : +r, a = n.substr(e + 1).trim();
                return i
            },
            Se = function (t) {
                return function (e) {
                    return 1 - t(1 - e)
                }
            },
            Ie = function t(e, n) {
                for (var r, i = e._first; i;) i instanceof Oe ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = n)), i = i._next
            },
            Me = function (t, e) {
                return t && (C(t) ? t : xe[t] || function (t) {
                    var e, n, r, i, o = (t + "").split("("),
                        a = xe[o[0]];
                    return a && o.length > 1 && a.config ? a.config.apply(null, ~t.indexOf("{") ? [Ce(o[1])] : (e = t, n = e.indexOf("(") + 1, r = e.indexOf(")"), i = e.indexOf("(", n), e.substring(n, ~i && i < r ? e.indexOf(")", r + 1) : r)).split(",").map(mt)) : xe._CE && be.test(t) ? xe._CE("", t) : a
                }(t)) || e
            },
            Te = function (t, e, n, r) {
                void 0 === n && (n = function (t) {
                    return 1 - e(1 - t)
                }), void 0 === r && (r = function (t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var i, o = {
                    easeIn: e,
                    easeOut: n,
                    easeInOut: r
                };
                return lt(t, (function (t) {
                    for (var e in xe[t] = $[t] = o, xe[i = t.toLowerCase()] = n, o) xe[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = xe[t + "." + e] = o[e]
                })), o
            },
            Be = function (t) {
                return function (e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            },
            Re = function t(e, n, r) {
                var i = n >= 1 ? n : 1,
                    o = (r || (e ? .3 : .45)) / (n < 1 ? n : 1),
                    a = o / v * (Math.asin(1 / i) || 0),
                    s = function (t) {
                        return 1 === t ? 1 : i * Math.pow(2, -10 * t) * b((t - a) * o) + 1
                    },
                    l = "out" === e ? s : "in" === e ? function (t) {
                        return 1 - s(1 - t)
                    } : Be(s);
                return o = v / o, l.config = function (n, r) {
                    return t(e, n, r)
                }, l
            },
            Le = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var r = function (t) {
                        return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                    },
                    i = "out" === e ? r : "in" === e ? function (t) {
                        return 1 - r(1 - t)
                    } : Be(r);
                return i.config = function (n) {
                    return t(e, n)
                }, i
            };
        lt("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
                var n = e < 5 ? e + 1 : e;
                Te(t + ",Power" + (n - 1), e ? function (t) {
                    return Math.pow(t, n)
                } : function (t) {
                    return t
                }, (function (t) {
                    return 1 - Math.pow(1 - t, n)
                }), (function (t) {
                    return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
                }))
            })), xe.Linear.easeNone = xe.none = xe.Linear.easeIn, Te("Elastic", Re("in"), Re("out"), Re()),
            function (t, e) {
                var n = 1 / e,
                    r = function (r) {
                        return r < n ? t * r * r : r < .7272727272727273 ? t * Math.pow(r - 1.5 / e, 2) + .75 : r < .9090909090909092 ? t * (r -= 2.25 / e) * r + .9375 : t * Math.pow(r - 2.625 / e, 2) + .984375
                    };
                Te("Bounce", (function (t) {
                    return 1 - r(1 - t)
                }), r)
            }(7.5625, 2.75), Te("Expo", (function (t) {
                return t ? Math.pow(2, 10 * (t - 1)) : 0
            })), Te("Circ", (function (t) {
                return -(E(1 - t * t) - 1)
            })), Te("Sine", (function (t) {
                return 1 === t ? 1 : 1 - x(t * _)
            })), Te("Back", Le("in"), Le("out"), Le()), xe.SteppedEase = xe.steps = $.SteppedEase = {
                config: function (t, e) {
                    void 0 === t && (t = 1);
                    var n = 1 / t,
                        r = t + (e ? 0 : 1),
                        i = e ? 1 : 0;
                    return function (t) {
                        return ((r * Vt(0, .99999999, t) | 0) + i) * n
                    }
                }
            }, m.ease = xe["quad.out"], lt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
                return it += t + "," + t + "Params,"
            }));
        var De = function (t, e) {
                this.id = y++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : st, this.set = e ? e.getSetter : Ke
            },
            Pe = function () {
                function t(t) {
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ft(this, +t.duration, 1, 1), this.data = t.data, o && (this._ctx = o, o.data.push(this)), p || ye.wake()
                }
                var e = t.prototype;
                return e.delay = function (t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, e.duration = function (t) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, e.totalDuration = function (t) {
                    return arguments.length ? (this._dirty = 0, Ft(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function (t, e) {
                    if (Ee(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (Lt(this, t), !n._dp || n.parent || Dt(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Pt(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === A || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), ft(this, t, e)), this
                }, e.time = function (t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Mt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
                }, e.totalProgress = function (t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
                }, e.progress = function (t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Mt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                }, e.iteration = function (t, e) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Tt(this._tTime, n) + 1 : 1
                }, e.timeScale = function (t, e) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var n = this.parent && this._ts ? Bt(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, this.totalTime(Vt(-Math.abs(this._delay), this._tDur, n), !1 !== e), Rt(this),
                        function (t) {
                            for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                            return t
                        }(this)
                }, e.paused = function (t) {
                    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ee(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== A && (this._tTime -= A)))), this) : this._ps
                }, e.startTime = function (t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return e && (e._sort || !this.parent) && Pt(e, this, t - this._delay), this
                    }
                    return this._start
                }, e.endTime = function (t) {
                    return this._start + (T(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                }, e.rawTime = function (t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Bt(e.rawTime(t), this) : this._tTime : this._tTime
                }, e.revert = function (t) {
                    void 0 === t && (t = Y);
                    var e = i;
                    return i = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), i = e, this
                }, e.globalTime = function (t) {
                    for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (Math.abs(e._ts) || 1), e = e._dp;
                    return !this.parent && this._sat ? this._sat.globalTime(t) : n
                }, e.repeat = function (t) {
                    return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Qt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                }, e.repeatDelay = function (t) {
                    if (arguments.length) {
                        var e = this._time;
                        return this._rDelay = t, Qt(this), e ? this.time(e) : this
                    }
                    return this._rDelay
                }, e.yoyo = function (t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, e.seek = function (t, e) {
                    return this.totalTime(Gt(this, t), T(e))
                }, e.restart = function (t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, T(e))
                }, e.play = function (t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, e.reverse = function (t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, e.pause = function (t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, e.resume = function () {
                    return this.paused(!1)
                }, e.reversed = function (t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                }, e.invalidate = function () {
                    return this._initted = this._act = 0, this._zTime = -1e-8, this
                }, e.isActive = function () {
                    var t, e = this.parent || this._dp,
                        n = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - A))
                }, e.eventCallback = function (t, e, n) {
                    var r = this.vars;
                    return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t]
                }, e.then = function (t) {
                    var e = this;
                    return new Promise((function (n) {
                        var r = C(t) ? t : gt,
                            i = function () {
                                var t = e.then;
                                e.then = null, C(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t
                            };
                        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i
                    }))
                }, e.kill = function () {
                    le(this)
                }, t
            }();
        At(Pe.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Oe = function (n) {
            function r(e, r) {
                var i;
                return void 0 === e && (e = {}), (i = n.call(this, e) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = T(e.sortChildren), a && Pt(e.parent || a, t(i), r), e.reversed && i.reverse(), e.paused && i.paused(!0), e.scrollTrigger && Ot(t(i), e.scrollTrigger), i
            }
            e(r, n);
            var o = r.prototype;
            return o.to = function (t, e, n) {
                return Ht(0, arguments, this), this
            }, o.from = function (t, e, n) {
                return Ht(1, arguments, this), this
            }, o.fromTo = function (t, e, n, r) {
                return Ht(2, arguments, this), this
            }, o.set = function (t, e, n) {
                return e.duration = 0, e.parent = this, Et(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new We(t, e, Gt(this, n), 1), this
            }, o.call = function (t, e, n) {
                return Pt(this, We.delayedCall(0, t, e), n)
            }, o.staggerTo = function (t, e, n, r, i, o, a) {
                return n.duration = e, n.stagger = n.stagger || r, n.onComplete = o, n.onCompleteParams = a, n.parent = this, new We(t, n, Gt(this, i)), this
            }, o.staggerFrom = function (t, e, n, r, i, o, a) {
                return n.runBackwards = 1, Et(n).immediateRender = T(n.immediateRender), this.staggerTo(t, e, n, r, i, o, a)
            }, o.staggerFromTo = function (t, e, n, r, i, o, a, s) {
                return r.startAt = n, Et(r).immediateRender = T(r.immediateRender), this.staggerTo(t, e, r, i, o, a, s)
            }, o.render = function (t, e, n) {
                var r, o, s, l, c, u, h, d, p, f, m, g, v = this._time,
                    _ = this._dirty ? this.totalDuration() : this._tDur,
                    y = this._dur,
                    E = t <= 0 ? 0 : ut(t),
                    x = this._zTime < 0 != t < 0 && (this._initted || !y);
                if (this !== a && E > _ && t >= 0 && (E = _), E !== this._tTime || n || x) {
                    if (v !== this._time && y && (E += this._time - v, t += this._time - v), r = E, p = this._start, u = !(d = this._ts), x && (y || (v = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (m = this._yoyo, c = y + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * c + t, e, n);
                        if (r = ut(E % c), E === _ ? (l = this._repeat, r = y) : ((l = ~~(E / c)) && l === E / c && (r = y, l--), r > y && (r = y)), f = Tt(this._tTime, c), !v && this._tTime && f !== l && this._tTime - f * c - this._dur <= 0 && (f = l), m && 1 & l && (r = y - r, g = 1), l !== f && !this._lock) {
                            var b = m && 1 & f,
                                w = b === (m && 1 & l);
                            if (l < f && (b = !b), v = b ? 0 : E % y ? y : E, this._lock = 1, this.render(v || (g ? 0 : ut(l * c)), e, !y)._lock = 0, this._tTime = E, !e && this.parent && se(this, "onRepeat"), this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1), v && v !== this._time || u !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (y = this._dur, _ = this._tDur, w && (this._lock = 2, v = b ? y : -1e-4, this.render(v, !0), this.vars.repeatRefresh && !g && this.invalidate()), this._lock = 0, !this._ts && !u) return this;
                            Ie(this, g)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (t, e, n) {
                            var r;
                            if (n > e)
                                for (r = t._first; r && r._start <= n;) {
                                    if ("isPause" === r.data && r._start > e) return r;
                                    r = r._next
                                } else
                                    for (r = t._last; r && r._start >= n;) {
                                        if ("isPause" === r.data && r._start < e) return r;
                                        r = r._prev
                                    }
                        }(this, ut(v), ut(r)), h && (E -= r - (r = h._start))), this._tTime = E, this._time = r, this._act = !d, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, v = 0), !v && r && !e && !l && (se(this, "onStart"), this._tTime !== E)) return this;
                    if (r >= v && t >= 0)
                        for (o = this._first; o;) {
                            if (s = o._next, (o._act || r >= o._start) && o._ts && h !== o) {
                                if (o.parent !== this) return this.render(t, e, n);
                                if (o.render(o._ts > 0 ? (r - o._start) * o._ts : (o._dirty ? o.totalDuration() : o._tDur) + (r - o._start) * o._ts, e, n), r !== this._time || !this._ts && !u) {
                                    h = 0, s && (E += this._zTime = -1e-8);
                                    break
                                }
                            }
                            o = s
                        } else {
                            o = this._last;
                            for (var C = t < 0 ? t : r; o;) {
                                if (s = o._prev, (o._act || C <= o._end) && o._ts && h !== o) {
                                    if (o.parent !== this) return this.render(t, e, n);
                                    if (o.render(o._ts > 0 ? (C - o._start) * o._ts : (o._dirty ? o.totalDuration() : o._tDur) + (C - o._start) * o._ts, e, n || i && (o._initted || o._startAt)), r !== this._time || !this._ts && !u) {
                                        h = 0, s && (E += this._zTime = C ? -1e-8 : A);
                                        break
                                    }
                                }
                                o = s
                            }
                        }
                    if (h && !e && (this.pause(), h.render(r >= v ? 0 : -1e-8)._zTime = r >= v ? 1 : -1, this._ts)) return this._start = p, Rt(this), this.render(t, e, n);
                    this._onUpdate && !e && se(this, "onUpdate", !0), (E === _ && this._tTime >= this.totalDuration() || !E && v) && (p !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((t || !y) && (E === _ && this._ts > 0 || !E && this._ts < 0) && wt(this, 1), e || t < 0 && !v || !E && !v && _ || (se(this, E === _ && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(E < _ && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, o.add = function (t, e) {
                var n = this;
                if (S(e) || (e = Gt(this, e, t)), !(t instanceof Pe)) {
                    if (D(t)) return t.forEach((function (t) {
                        return n.add(t, e)
                    })), this;
                    if (w(t)) return this.addLabel(t, e);
                    if (!C(t)) return this;
                    t = We.delayedCall(0, t)
                }
                return this !== t ? Pt(this, t, e) : this
            }, o.getChildren = function (t, e, n, r) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -g);
                for (var i = [], o = this._first; o;) o._start >= r && (o instanceof We ? e && i.push(o) : (n && i.push(o), t && i.push.apply(i, o.getChildren(!0, e, n)))), o = o._next;
                return i
            }, o.getById = function (t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                    if (e[n].vars.id === t) return e[n]
            }, o.remove = function (t) {
                return w(t) ? this.removeLabel(t) : C(t) ? this.killTweensOf(t) : (bt(this, t), t === this._recent && (this._recent = this._last), Ct(this))
            }, o.totalTime = function (t, e) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ut(ye.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), n.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime
            }, o.addLabel = function (t, e) {
                return this.labels[t] = Gt(this, e), this
            }, o.removeLabel = function (t) {
                return delete this.labels[t], this
            }, o.addPause = function (t, e, n) {
                var r = We.delayedCall(0, e || j, n);
                return r.data = "isPause", this._hasPause = 1, Pt(this, r, Gt(this, t))
            }, o.removePause = function (t) {
                var e = this._first;
                for (t = Gt(this, t); e;) e._start === t && "isPause" === e.data && wt(e), e = e._next
            }, o.killTweensOf = function (t, e, n) {
                for (var r = this.getTweensOf(t, n), i = r.length; i--;) ke !== r[i] && r[i].kill(t, e);
                return this
            }, o.getTweensOf = function (t, e) {
                for (var n, r = [], i = Yt(t), o = this._first, a = S(e); o;) o instanceof We ? dt(o._targets, i) && (a ? (!ke || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && r.push(o) : (n = o.getTweensOf(i, e)).length && r.push.apply(r, n), o = o._next;
                return r
            }, o.tweenTo = function (t, e) {
                e = e || {};
                var n, r = this,
                    i = Gt(r, t),
                    o = e,
                    a = o.startAt,
                    s = o.onStart,
                    l = o.onStartParams,
                    c = o.immediateRender,
                    u = We.to(r, At({
                        ease: e.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: i,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((i - (a && "time" in a ? a.time : r._time)) / r.timeScale()) || A,
                        onStart: function () {
                            if (r.pause(), !n) {
                                var t = e.duration || Math.abs((i - (a && "time" in a ? a.time : r._time)) / r.timeScale());
                                u._dur !== t && Ft(u, t, 0, 1).render(u._time, !0, !0), n = 1
                            }
                            s && s.apply(u, l || [])
                        }
                    }, e));
                return c ? u.render(0) : u
            }, o.tweenFromTo = function (t, e, n) {
                return this.tweenTo(e, At({
                    startAt: {
                        time: Gt(this, t)
                    }
                }, n))
            }, o.recent = function () {
                return this._recent
            }, o.nextLabel = function (t) {
                return void 0 === t && (t = this._time), ae(this, Gt(this, t))
            }, o.previousLabel = function (t) {
                return void 0 === t && (t = this._time), ae(this, Gt(this, t), 1)
            }, o.currentLabel = function (t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + A)
            }, o.shiftChildren = function (t, e, n) {
                void 0 === n && (n = 0);
                for (var r, i = this._first, o = this.labels; i;) i._start >= n && (i._start += t, i._end += t), i = i._next;
                if (e)
                    for (r in o) o[r] >= n && (o[r] += t);
                return Ct(this)
            }, o.invalidate = function (t) {
                var e = this._first;
                for (this._lock = 0; e;) e.invalidate(t), e = e._next;
                return n.prototype.invalidate.call(this, t)
            }, o.clear = function (t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Ct(this)
            }, o.totalDuration = function (t) {
                var e, n, r, i = 0,
                    o = this,
                    s = o._last,
                    l = g;
                if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
                if (o._dirty) {
                    for (r = o.parent; s;) e = s._prev, s._dirty && s.totalDuration(), (n = s._start) > l && o._sort && s._ts && !o._lock ? (o._lock = 1, Pt(o, s, n - s._delay, 1)._lock = 0) : l = n, n < 0 && s._ts && (i -= n, (!r && !o._dp || r && r.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -1 / 0), l = 0), s._end > i && s._ts && (i = s._end), s = e;
                    Ft(o, o === a && o._time > i ? o._time : i, 1, 1), o._dirty = 0
                }
                return o._tDur
            }, r.updateRoot = function (t) {
                if (a._ts && (ft(a, Bt(t, a)), h = ye.frame), ye.frame >= nt) {
                    nt += f.autoSleep || 120;
                    var e = a._first;
                    if ((!e || !e._ts) && f.autoSleep && ye._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || ye.sleep()
                    }
                }
            }, r
        }(Pe);
        At(Oe.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var ke, Ue, Ne = function (t, e, n, r, i, o, a) {
                var s, l, c, u, h, d, p, f, m = new sn(this._pt, t, e, 0, 1, tn, null, i),
                    g = 0,
                    A = 0;
                for (m.b = n, m.e = r, n += "", (p = ~(r += "").indexOf("random(")) && (r = ie(r)), o && (o(f = [n, r], t, e), n = f[0], r = f[1]), l = n.match(U) || []; s = U.exec(r);) u = s[0], h = r.substring(g, s.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[A++] && (d = parseFloat(l[A - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: h || 1 === A ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? ht(d, u) - d : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0
                }, g = U.lastIndex);
                return m.c = g < r.length ? r.substring(g, r.length) : "", m.fp = a, (N.test(r) || p) && (m.e = 0), this._pt = m, m
            },
            Fe = function (t, e, n, r, i, o, a, s, l, c) {
                C(r) && (r = r(i || 0, t, o));
                var u, h = t[e],
                    d = "get" !== n ? n : C(h) ? l ? t[e.indexOf("set") || !C(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h,
                    p = C(h) ? l ? qe : Xe : je;
                if (w(r) && (~r.indexOf("random(") && (r = ie(r)), "=" === r.charAt(1) && ((u = ht(d, r) + (Wt(d) || 0)) || 0 === u) && (r = u)), !c || d !== r || Ue) return isNaN(d * r) || "" === r ? (!h && !(e in t) && z(e, r), Ne.call(this, t, e, d, r, p, s || f.stringFilter, l)) : (u = new sn(this._pt, t, e, +d || 0, r - (d || 0), "boolean" == typeof h ? Ze : Je, 0, p), l && (u.fp = l), a && u.modifier(a, this, t), this._pt = u)
            },
            Qe = function (t, e, n, r, i, o) {
                var a, s, l, c;
                if (tt[t] && !1 !== (a = new tt[t]).init(i, a.rawVars ? e[t] : function (t, e, n, r, i) {
                        if (C(t) && (t = He(t, i, e, n, r)), !M(t) || t.style && t.nodeType || D(t) || L(t)) return w(t) ? He(t, i, e, n, r) : t;
                        var o, a = {};
                        for (o in t) a[o] = He(t[o], i, e, n, r);
                        return a
                    }(e[t], r, i, o, n), n, r, o) && (n._pt = s = new sn(n._pt, i, t, 0, 1, a.render, a, 0, a.priority), n !== d))
                    for (l = n._ptLookup[n._targets.indexOf(i)], c = a._props.length; c--;) l[a._props[c]] = s;
                return a
            },
            $e = function t(e, n, o) {
                var s, l, c, u, h, d, p, f, v, _, y, E, x, b = e.vars,
                    w = b.ease,
                    C = b.startAt,
                    S = b.immediateRender,
                    I = b.lazy,
                    M = b.onUpdate,
                    B = b.runBackwards,
                    R = b.yoyoEase,
                    L = b.keyframes,
                    D = b.autoRevert,
                    P = e._dur,
                    O = e._startAt,
                    k = e._targets,
                    U = e.parent,
                    N = U && "nested" === U.data ? U.vars.targets : k,
                    F = "auto" === e._overwrite && !r,
                    Q = e.timeline;
                if (Q && (!L || !w) && (w = "none"), e._ease = Me(w, m.ease), e._yEase = R ? Se(Me(!0 === R ? w : R, m.ease)) : 0, R && e._yoyo && !e._repeat && (R = e._yEase, e._yEase = e._ease, e._ease = R), e._from = !Q && !!b.runBackwards, !Q || L && !b.stagger) {
                    if (E = (f = k[0] ? at(k[0]).harness : 0) && b[f.prop], s = yt(b, K), O && (O._zTime < 0 && O.progress(1), n < 0 && B && S && !D ? O.render(-1, !0) : O.revert(B && P ? q : X), O._lazy = 0), C) {
                        if (wt(e._startAt = We.set(k, At({
                                data: "isStart",
                                overwrite: !1,
                                parent: U,
                                immediateRender: !0,
                                lazy: !O && T(I),
                                startAt: null,
                                delay: 0,
                                onUpdate: M && function () {
                                    return se(e, "onUpdate")
                                },
                                stagger: 0
                            }, C))), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (i || !S && !D) && e._startAt.revert(q), S && P && n <= 0 && o <= 0) return void(n && (e._zTime = n))
                    } else if (B && P && !O)
                        if (n && (S = !1), c = At({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: S && !O && T(I),
                                immediateRender: S,
                                stagger: 0,
                                parent: U
                            }, s), E && (c[f.prop] = E), wt(e._startAt = We.set(k, c)), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (i ? e._startAt.revert(q) : e._startAt.render(-1, !0)), e._zTime = n, S) {
                            if (!n) return
                        } else t(e._startAt, A, A);
                    for (e._pt = e._ptCache = 0, I = P && T(I) || I && !P, l = 0; l < k.length; l++) {
                        if (p = (h = k[l])._gsap || ot(k)[l]._gsap, e._ptLookup[l] = _ = {}, Z[p.id] && J.length && pt(), y = N === k ? l : N.indexOf(h), f && !1 !== (v = new f).init(h, E || s, e, y, N) && (e._pt = u = new sn(e._pt, h, v.name, 0, 1, v.render, v, 0, v.priority), v._props.forEach((function (t) {
                                _[t] = u
                            })), v.priority && (d = 1)), !f || E)
                            for (c in s) tt[c] && (v = Qe(c, s, e, y, h, N)) ? v.priority && (d = 1) : _[c] = u = Fe.call(e, h, c, "get", s[c], y, N, 0, b.stringFilter);
                        e._op && e._op[l] && e.kill(h, e._op[l]), F && e._pt && (ke = e, a.killTweensOf(h, _, e.globalTime(n)), x = !e.parent, ke = 0), e._pt && I && (Z[p.id] = 1)
                    }
                    d && an(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = M, e._initted = (!e._op || e._pt) && !x, L && n <= 0 && Q.render(g, !0, !0)
            },
            Ge = function (t, e, n, r) {
                var i, o, a = e.ease || r || "power1.inOut";
                if (D(e)) o = n[t] || (n[t] = []), e.forEach((function (t, n) {
                    return o.push({
                        t: n / (e.length - 1) * 100,
                        v: t,
                        e: a
                    })
                }));
                else
                    for (i in e) o = n[i] || (n[i] = []), "ease" === i || o.push({
                        t: parseFloat(t),
                        v: e[i],
                        e: a
                    })
            },
            He = function (t, e, n, r, i) {
                return C(t) ? t.call(e, n, r, i) : w(t) && ~t.indexOf("random(") ? ie(t) : t
            },
            ze = it + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
            Ve = {};
        lt(ze + ",id,stagger,delay,duration,paused,scrollTrigger", (function (t) {
            return Ve[t] = 1
        }));
        var We = function (n) {
            function o(e, i, o, s) {
                var l;
                "number" == typeof i && (o.duration = i, i = o, o = null);
                var c, u, h, d, p, m, g, A, v = (l = n.call(this, s ? i : Et(i)) || this).vars,
                    _ = v.duration,
                    y = v.delay,
                    E = v.immediateRender,
                    x = v.stagger,
                    b = v.overwrite,
                    w = v.keyframes,
                    C = v.defaults,
                    I = v.scrollTrigger,
                    B = v.yoyoEase,
                    P = i.parent || a,
                    O = (D(e) || L(e) ? S(e[0]) : "length" in i) ? [e] : Yt(e);
                if (l._targets = O.length ? ot(O) : V("GSAP target " + e + " not found. https://gsap.com", !f.nullTargetWarn) || [], l._ptLookup = [], l._overwrite = b, w || x || R(_) || R(y)) {
                    if (i = l.vars, (c = l.timeline = new Oe({
                            data: "nested",
                            defaults: C || {},
                            targets: P && "nested" === P.data ? P.vars.targets : O
                        })).kill(), c.parent = c._dp = t(l), c._start = 0, x || R(_) || R(y)) {
                        if (d = O.length, g = x && Zt(x), M(x))
                            for (p in x) ~ze.indexOf(p) && (A || (A = {}), A[p] = x[p]);
                        for (u = 0; u < d; u++)(h = yt(i, Ve)).stagger = 0, B && (h.yoyoEase = B), A && vt(h, A), m = O[u], h.duration = +He(_, t(l), u, m, O), h.delay = (+He(y, t(l), u, m, O) || 0) - l._delay, !x && 1 === d && h.delay && (l._delay = y = h.delay, l._start += y, h.delay = 0), c.to(m, h, g ? g(u, m, O) : 0), c._ease = xe.none;
                        c.duration() ? _ = y = 0 : l.timeline = 0
                    } else if (w) {
                        Et(At(c.vars.defaults, {
                            ease: "none"
                        })), c._ease = Me(w.ease || i.ease || "none");
                        var k, U, N, F = 0;
                        if (D(w)) w.forEach((function (t) {
                            return c.to(O, t, ">")
                        })), c.duration();
                        else {
                            for (p in h = {}, w) "ease" === p || "easeEach" === p || Ge(p, w[p], h, w.easeEach);
                            for (p in h)
                                for (k = h[p].sort((function (t, e) {
                                        return t.t - e.t
                                    })), F = 0, u = 0; u < k.length; u++)(N = {
                                    ease: (U = k[u]).e,
                                    duration: (U.t - (u ? k[u - 1].t : 0)) / 100 * _
                                })[p] = U.v, c.to(O, N, F), F += N.duration;
                            c.duration() < _ && c.to({}, {
                                duration: _ - c.duration()
                            })
                        }
                    }
                    _ || l.duration(_ = c.duration())
                } else l.timeline = 0;
                return !0 !== b || r || (ke = t(l), a.killTweensOf(O), ke = 0), Pt(P, t(l), o), i.reversed && l.reverse(), i.paused && l.paused(!0), (E || !_ && !w && l._start === ut(P._time) && T(E) && It(t(l)) && "nested" !== P.data) && (l._tTime = -1e-8, l.render(Math.max(0, -y) || 0)), I && Ot(t(l), I), l
            }
            e(o, n);
            var s = o.prototype;
            return s.render = function (t, e, n) {
                var r, o, a, s, l, c, u, h, d, p = this._time,
                    f = this._tDur,
                    m = this._dur,
                    g = t < 0,
                    v = t > f - A && !g ? f : t < A ? 0 : t;
                if (m) {
                    if (v !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                        if (r = v, h = this.timeline, this._repeat) {
                            if (s = m + this._rDelay, this._repeat < -1 && g) return this.totalTime(100 * s + t, e, n);
                            if (r = ut(v % s), v === f ? (a = this._repeat, r = m) : ((a = ~~(v / s)) && a === ut(v / s) && (r = m, a--), r > m && (r = m)), (c = this._yoyo && 1 & a) && (d = this._yEase, r = m - r), l = Tt(this._tTime, s), r === p && !n && this._initted && a === l) return this._tTime = v, this;
                            a !== l && (h && this._yEase && Ie(h, c), this.vars.repeatRefresh && !c && !this._lock && this._time !== s && this._initted && (this._lock = n = 1, this.render(ut(s * a), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (kt(this, g ? t : r, n, e, v)) return this._tTime = 0, this;
                            if (!(p === this._time || n && this.vars.repeatRefresh && a !== l)) return this;
                            if (m !== this._dur) return this.render(t, e, n)
                        }
                        if (this._tTime = v, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = u = (d || this._ease)(r / m), this._from && (this.ratio = u = 1 - u), r && !p && !e && !a && (se(this, "onStart"), this._tTime !== v)) return this;
                        for (o = this._pt; o;) o.r(u, o.d), o = o._next;
                        h && h.render(t < 0 ? t : h._dur * h._ease(r / this._dur), e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (g && St(this, t, 0, n), se(this, "onUpdate")), this._repeat && a !== l && this.vars.onRepeat && !e && this.parent && se(this, "onRepeat"), v !== this._tDur && v || this._tTime !== v || (g && !this._onUpdate && St(this, t, 0, !0), (t || !m) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && wt(this, 1), e || g && !p || !(v || p || c) || (se(this, v === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < f && this.timeScale() > 0) && this._prom()))
                    }
                } else ! function (t, e, n, r) {
                    var o, a, s, l = t.ratio,
                        c = e < 0 || !e && (!t._start && Ut(t) && (t._initted || !Nt(t)) || (t._ts < 0 || t._dp._ts < 0) && !Nt(t)) ? 0 : 1,
                        u = t._rDelay,
                        h = 0;
                    if (u && t._repeat && (h = Vt(0, t._tDur, e), a = Tt(h, u), t._yoyo && 1 & a && (c = 1 - c), a !== Tt(t._tTime, u) && (l = 1 - c, t.vars.repeatRefresh && t._initted && t.invalidate())), c !== l || i || r || t._zTime === A || !e && t._zTime) {
                        if (!t._initted && kt(t, e, r, n, h)) return;
                        for (s = t._zTime, t._zTime = e || (n ? A : 0), n || (n = e && !s), t.ratio = c, t._from && (c = 1 - c), t._time = 0, t._tTime = h, o = t._pt; o;) o.r(c, o.d), o = o._next;
                        e < 0 && St(t, e, 0, !0), t._onUpdate && !n && se(t, "onUpdate"), h && t._repeat && !n && t.parent && se(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === c && (c && wt(t, 1), n || i || (se(t, c ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    } else t._zTime || (t._zTime = e)
                }(this, t, e, n);
                return this
            }, s.targets = function () {
                return this._targets
            }, s.invalidate = function (t) {
                return (!t || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), n.prototype.invalidate.call(this, t)
            }, s.resetTo = function (t, e, n, r, i) {
                p || ye.wake(), this._ts || this.play();
                var o = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                return this._initted || $e(this, o),
                    function (t, e, n, r, i, o, a, s) {
                        var l, c, u, h, d = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                        if (!d)
                            for (d = t._ptCache[e] = [], u = t._ptLookup, h = t._targets.length; h--;) {
                                if ((l = u[h][e]) && l.d && l.d._pt)
                                    for (l = l.d._pt; l && l.p !== e && l.fp !== e;) l = l._next;
                                if (!l) return Ue = 1, t.vars[e] = "+=0", $e(t, a), Ue = 0, s ? V(e + " not eligible for reset") : 1;
                                d.push(l)
                            }
                        for (h = d.length; h--;)(l = (c = d[h])._pt || c).s = !r && 0 !== r || i ? l.s + (r || 0) + o * l.c : r, l.c = n - l.s, c.e && (c.e = ct(n) + Wt(c.e)), c.b && (c.b = l.s + Wt(c.b))
                    }(this, t, e, n, r, this._ease(o / this._dur), o, i) ? this.resetTo(t, e, n, r, 1) : (Lt(this, 0), this.parent || xt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
            }, s.kill = function (t, e) {
                if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? le(this) : this;
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, ke && !0 !== ke.vars.overwrite)._first || le(this), this.parent && n !== this.timeline.totalDuration() && Ft(this, this._dur * this.timeline._tDur / n, 0, 1), this
                }
                var r, i, o, a, s, l, c, u = this._targets,
                    h = t ? Yt(t) : u,
                    d = this._ptLookup,
                    p = this._pt;
                if ((!e || "all" === e) && function (t, e) {
                        for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n];);
                        return n < 0
                    }(u, h)) return "all" === e && (this._pt = 0), le(this);
                for (r = this._op = this._op || [], "all" !== e && (w(e) && (s = {}, lt(e, (function (t) {
                        return s[t] = 1
                    })), e = s), e = function (t, e) {
                        var n, r, i, o, a = t[0] ? at(t[0]).harness : 0,
                            s = a && a.aliases;
                        if (!s) return e;
                        for (r in n = vt({}, e), s)
                            if (r in n)
                                for (i = (o = s[r].split(",")).length; i--;) n[o[i]] = n[r];
                        return n
                    }(u, e)), c = u.length; c--;)
                    if (~h.indexOf(u[c]))
                        for (s in i = d[c], "all" === e ? (r[c] = e, a = i, o = {}) : (o = r[c] = r[c] || {}, a = e), a)(l = i && i[s]) && ("kill" in l.d && !0 !== l.d.kill(s) || bt(this, l, "_pt"), delete i[s]), "all" !== o && (o[s] = 1);
                return this._initted && !this._pt && p && le(this), this
            }, o.to = function (t, e) {
                return new o(t, e, arguments[2])
            }, o.from = function (t, e) {
                return Ht(1, arguments)
            }, o.delayedCall = function (t, e, n, r) {
                return new o(e, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: e,
                    onReverseComplete: e,
                    onCompleteParams: n,
                    onReverseCompleteParams: n,
                    callbackScope: r
                })
            }, o.fromTo = function (t, e, n) {
                return Ht(2, arguments)
            }, o.set = function (t, e) {
                return e.duration = 0, e.repeatDelay || (e.repeat = 0), new o(t, e)
            }, o.killTweensOf = function (t, e, n) {
                return a.killTweensOf(t, e, n)
            }, o
        }(Pe);
        At(We.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), lt("staggerTo,staggerFrom,staggerFromTo", (function (t) {
            We[t] = function () {
                var e = new Oe,
                    n = jt.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var je = function (t, e, n) {
                return t[e] = n
            },
            Xe = function (t, e, n) {
                return t[e](n)
            },
            qe = function (t, e, n, r) {
                return t[e](r.fp, n)
            },
            Ye = function (t, e, n) {
                return t.setAttribute(e, n)
            },
            Ke = function (t, e) {
                return C(t[e]) ? Xe : I(t[e]) && t.setAttribute ? Ye : je
            },
            Je = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
            },
            Ze = function (t, e) {
                return e.set(e.t, e.p, !!(e.s + e.c * t), e)
            },
            tn = function (t, e) {
                var n = e._pt,
                    r = "";
                if (!t && e.b) r = e.b;
                else if (1 === t && e.e) r = e.e;
                else {
                    for (; n;) r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r, n = n._next;
                    r += e.c
                }
                e.set(e.t, e.p, r, e)
            },
            en = function (t, e) {
                for (var n = e._pt; n;) n.r(t, n.d), n = n._next
            },
            nn = function (t, e, n, r) {
                for (var i, o = this._pt; o;) i = o._next, o.p === r && o.modifier(t, e, n), o = i
            },
            rn = function (t) {
                for (var e, n, r = this._pt; r;) n = r._next, r.p === t && !r.op || r.op === t ? bt(this, r, "_pt") : r.dep || (e = 1), r = n;
                return !e
            },
            on = function (t, e, n, r) {
                r.mSet(t, e, r.m.call(r.tween, n, r.mt), r)
            },
            an = function (t) {
                for (var e, n, r, i, o = t._pt; o;) {
                    for (e = o._next, n = r; n && n.pr > o.pr;) n = n._next;
                    (o._prev = n ? n._prev : i) ? o._prev._next = o: r = o, (o._next = n) ? n._prev = o : i = o, o = e
                }
                t._pt = r
            },
            sn = function () {
                function t(t, e, n, r, i, o, a, s, l) {
                    this.t = e, this.s = r, this.c = i, this.p = n, this.r = o || Je, this.d = a || this, this.set = s || je, this.pr = l || 0, this._next = t, t && (t._prev = this)
                }
                return t.prototype.modifier = function (t, e, n) {
                    this.mSet = this.mSet || this.set, this.set = on, this.m = t, this.mt = n, this.tween = e
                }, t
            }();
        lt(it + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
            return K[t] = 1
        })), $.TweenMax = $.TweenLite = We, $.TimelineLite = $.TimelineMax = Oe, a = new Oe({
            sortChildren: !1,
            defaults: m,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), f.stringFilter = _e;
        var ln = [],
            cn = {},
            un = [],
            hn = 0,
            dn = 0,
            pn = function (t) {
                return (cn[t] || un).map((function (t) {
                    return t()
                }))
            },
            fn = function () {
                var t = Date.now(),
                    e = [];
                t - hn > 2 && (pn("matchMediaInit"), ln.forEach((function (t) {
                    var n, r, i, o, a = t.queries,
                        l = t.conditions;
                    for (r in a)(n = s.matchMedia(a[r]).matches) && (i = 1), n !== l[r] && (l[r] = n, o = 1);
                    o && (t.revert(), i && e.push(t))
                })), pn("matchMediaRevert"), e.forEach((function (t) {
                    return t.onMatch(t, (function (e) {
                        return t.add(null, e)
                    }))
                })), hn = t, pn("matchMedia"))
            },
            mn = function () {
                function t(t, e) {
                    this.selector = e && Kt(e), this.data = [], this._r = [], this.isReverted = !1, this.id = dn++, t && this.add(t)
                }
                var e = t.prototype;
                return e.add = function (t, e, n) {
                    C(t) && (n = e, e = t, t = C);
                    var r = this,
                        i = function () {
                            var t, i = o,
                                a = r.selector;
                            return i && i !== r && i.data.push(r), n && (r.selector = Kt(n)), o = r, t = e.apply(r, arguments), C(t) && r._r.push(t), o = i, r.selector = a, r.isReverted = !1, t
                        };
                    return r.last = i, t === C ? i(r, (function (t) {
                        return r.add(null, t)
                    })) : t ? r[t] = i : i
                }, e.ignore = function (t) {
                    var e = o;
                    o = null, t(this), o = e
                }, e.getTweens = function () {
                    var e = [];
                    return this.data.forEach((function (n) {
                        return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof We && !(n.parent && "nested" === n.parent.data) && e.push(n)
                    })), e
                }, e.clear = function () {
                    this._r.length = this.data.length = 0
                }, e.kill = function (t, e) {
                    var n = this;
                    if (t ? function () {
                            for (var e, r = n.getTweens(), i = n.data.length; i--;) "isFlip" === (e = n.data[i]).data && (e.revert(), e.getChildren(!0, !0, !1).forEach((function (t) {
                                return r.splice(r.indexOf(t), 1)
                            })));
                            for (r.map((function (t) {
                                    return {
                                        g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -1 / 0,
                                        t: t
                                    }
                                })).sort((function (t, e) {
                                    return e.g - t.g || -1 / 0
                                })).forEach((function (e) {
                                    return e.t.revert(t)
                                })), i = n.data.length; i--;)(e = n.data[i]) instanceof Oe ? "nested" !== e.data && (e.scrollTrigger && e.scrollTrigger.revert(), e.kill()) : !(e instanceof We) && e.revert && e.revert(t);
                            n._r.forEach((function (e) {
                                return e(t, n)
                            })), n.isReverted = !0
                        }() : this.data.forEach((function (t) {
                            return t.kill && t.kill()
                        })), this.clear(), e)
                        for (var r = ln.length; r--;) ln[r].id === this.id && ln.splice(r, 1)
                }, e.revert = function (t) {
                    this.kill(t || {})
                }, t
            }(),
            gn = function () {
                function t(t) {
                    this.contexts = [], this.scope = t, o && o.data.push(this)
                }
                var e = t.prototype;
                return e.add = function (t, e, n) {
                    M(t) || (t = {
                        matches: t
                    });
                    var r, i, a, l = new mn(0, n || this.scope),
                        c = l.conditions = {};
                    for (i in o && !l.selector && (l.selector = o.selector), this.contexts.push(l), e = l.add("onMatch", e), l.queries = t, t) "all" === i ? a = 1 : (r = s.matchMedia(t[i])) && (ln.indexOf(l) < 0 && ln.push(l), (c[i] = r.matches) && (a = 1), r.addListener ? r.addListener(fn) : r.addEventListener("change", fn));
                    return a && e(l, (function (t) {
                        return l.add(null, t)
                    })), this
                }, e.revert = function (t) {
                    this.kill(t || {})
                }, e.kill = function (t) {
                    this.contexts.forEach((function (e) {
                        return e.kill(t, !0)
                    }))
                }, t
            }(),
            An = {
                registerPlugin: function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    e.forEach((function (t) {
                        return ue(t)
                    }))
                },
                timeline: function (t) {
                    return new Oe(t)
                },
                getTweensOf: function (t, e) {
                    return a.getTweensOf(t, e)
                },
                getProperty: function (t, e, n, r) {
                    w(t) && (t = Yt(t)[0]);
                    var i = at(t || {}).get,
                        o = n ? gt : mt;
                    return "native" === n && (n = ""), t ? e ? o((tt[e] && tt[e].get || i)(t, e, n, r)) : function (e, n, r) {
                        return o((tt[e] && tt[e].get || i)(t, e, n, r))
                    } : t
                },
                quickSetter: function (t, e, n) {
                    if ((t = Yt(t)).length > 1) {
                        var r = t.map((function (t) {
                                return yn.quickSetter(t, e, n)
                            })),
                            i = r.length;
                        return function (t) {
                            for (var e = i; e--;) r[e](t)
                        }
                    }
                    t = t[0] || {};
                    var o = tt[e],
                        a = at(t),
                        s = a.harness && (a.harness.aliases || {})[e] || e,
                        l = o ? function (e) {
                            var r = new o;
                            d._pt = 0, r.init(t, n ? e + n : e, d, 0, [t]), r.render(1, r), d._pt && en(1, d)
                        } : a.set(t, s);
                    return o ? l : function (e) {
                        return l(t, s, n ? e + n : e, a, 1)
                    }
                },
                quickTo: function (t, e, n) {
                    var r, i = yn.to(t, vt(((r = {})[e] = "+=0.1", r.paused = !0, r), n || {})),
                        o = function (t, n, r) {
                            return i.resetTo(e, t, n, r)
                        };
                    return o.tween = i, o
                },
                isTweening: function (t) {
                    return a.getTweensOf(t, !0).length > 0
                },
                defaults: function (t) {
                    return t && t.ease && (t.ease = Me(t.ease, m.ease)), _t(m, t || {})
                },
                config: function (t) {
                    return _t(f, t || {})
                },
                registerEffect: function (t) {
                    var e = t.name,
                        n = t.effect,
                        r = t.plugins,
                        i = t.defaults,
                        o = t.extendTimeline;
                    (r || "").split(",").forEach((function (t) {
                        return t && !tt[t] && !$[t] && V(e + " effect requires " + t + " plugin.")
                    })), et[e] = function (t, e, r) {
                        return n(Yt(t), At(e || {}, i), r)
                    }, o && (Oe.prototype[e] = function (t, n, r) {
                        return this.add(et[e](t, M(n) ? n : (r = n) && {}, this), r)
                    })
                },
                registerEase: function (t, e) {
                    xe[t] = Me(e)
                },
                parseEase: function (t, e) {
                    return arguments.length ? Me(t, e) : xe
                },
                getById: function (t) {
                    return a.getById(t)
                },
                exportRoot: function (t, e) {
                    void 0 === t && (t = {});
                    var n, r, i = new Oe(t);
                    for (i.smoothChildTiming = T(t.smoothChildTiming), a.remove(i), i._dp = 0, i._time = i._tTime = a._time, n = a._first; n;) r = n._next, !e && !n._dur && n instanceof We && n.vars.onComplete === n._targets[0] || Pt(i, n, n._start - n._delay), n = r;
                    return Pt(a, i, 0), i
                },
                context: function (t, e) {
                    return t ? new mn(t, e) : o
                },
                matchMedia: function (t) {
                    return new gn(t)
                },
                matchMediaRefresh: function () {
                    return ln.forEach((function (t) {
                        var e, n, r = t.conditions;
                        for (n in r) r[n] && (r[n] = !1, e = 1);
                        e && t.revert()
                    })) || fn()
                },
                addEventListener: function (t, e) {
                    var n = cn[t] || (cn[t] = []);
                    ~n.indexOf(e) || n.push(e)
                },
                removeEventListener: function (t, e) {
                    var n = cn[t],
                        r = n && n.indexOf(e);
                    r >= 0 && n.splice(r, 1)
                },
                utils: {
                    wrap: function t(e, n, r) {
                        var i = n - e;
                        return D(e) ? re(e, t(0, e.length), n) : zt(r, (function (t) {
                            return (i + (t - e) % i) % i + e
                        }))
                    },
                    wrapYoyo: function t(e, n, r) {
                        var i = n - e,
                            o = 2 * i;
                        return D(e) ? re(e, t(0, e.length - 1), n) : zt(r, (function (t) {
                            return e + ((t = (o + (t - e) % o) % o || 0) > i ? o - t : t)
                        }))
                    },
                    distribute: Zt,
                    random: ne,
                    snap: ee,
                    normalize: function (t, e, n) {
                        return oe(t, e, 0, 1, n)
                    },
                    getUnit: Wt,
                    clamp: function (t, e, n) {
                        return zt(n, (function (n) {
                            return Vt(t, e, n)
                        }))
                    },
                    splitColor: fe,
                    toArray: Yt,
                    selector: Kt,
                    mapRange: oe,
                    pipe: function () {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        return function (t) {
                            return e.reduce((function (t, e) {
                                return e(t)
                            }), t)
                        }
                    },
                    unitize: function (t, e) {
                        return function (n) {
                            return t(parseFloat(n)) + (e || Wt(n))
                        }
                    },
                    interpolate: function t(e, n, r, i) {
                        var o = isNaN(e + n) ? 0 : function (t) {
                            return (1 - t) * e + t * n
                        };
                        if (!o) {
                            var a, s, l, c, u, h = w(e),
                                d = {};
                            if (!0 === r && (i = 1) && (r = null), h) e = {
                                p: e
                            }, n = {
                                p: n
                            };
                            else if (D(e) && !D(n)) {
                                for (l = [], c = e.length, u = c - 2, s = 1; s < c; s++) l.push(t(e[s - 1], e[s]));
                                c--, o = function (t) {
                                    t *= c;
                                    var e = Math.min(u, ~~t);
                                    return l[e](t - e)
                                }, r = n
                            } else i || (e = vt(D(e) ? [] : {}, e));
                            if (!l) {
                                for (a in n) Fe.call(d, e, a, "get", n[a]);
                                o = function (t) {
                                    return en(t, d) || (h ? e.p : e)
                                }
                            }
                        }
                        return zt(r, o)
                    },
                    shuffle: Jt
                },
                install: H,
                effects: et,
                ticker: ye,
                updateRoot: Oe.updateRoot,
                plugins: tt,
                globalTimeline: a,
                core: {
                    PropTween: sn,
                    globals: W,
                    Tween: We,
                    Timeline: Oe,
                    Animation: Pe,
                    getCache: at,
                    _removeLinkedListItem: bt,
                    reverting: function () {
                        return i
                    },
                    context: function (t) {
                        return t && o && (o.data.push(t), t._ctx = o), o
                    },
                    suppressOverwrites: function (t) {
                        return r = t
                    }
                }
            };
        lt("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
            return An[t] = We[t]
        })), ye.add(Oe.updateRoot), d = An.to({}, {
            duration: 0
        });
        var vn = function (t, e) {
                for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                return n
            },
            _n = function (t, e) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function (t, n, r) {
                        r._onInit = function (t) {
                            var r, i;
                            if (w(n) && (r = {}, lt(n, (function (t) {
                                    return r[t] = 1
                                })), n = r), e) {
                                for (i in r = {}, n) r[i] = e(n[i]);
                                n = r
                            }! function (t, e) {
                                var n, r, i, o = t._targets;
                                for (n in e)
                                    for (r = o.length; r--;)(i = t._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = vn(i, n)), i && i.modifier && i.modifier(e[n], t, o[r], n))
                            }(t, n)
                        }
                    }
                }
            },
            yn = An.registerPlugin({
                name: "attr",
                init: function (t, e, n, r, i) {
                    var o, a, s;
                    for (o in this.tween = n, e) s = t.getAttribute(o) || "", (a = this.add(t, "setAttribute", (s || 0) + "", e[o], r, i, 0, 0, o)).op = o, a.b = s, this._props.push(o)
                },
                render: function (t, e) {
                    for (var n = e._pt; n;) i ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), n = n._next
                }
            }, {
                name: "endArray",
                init: function (t, e) {
                    for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
                }
            }, _n("roundProps", te), _n("modifiers"), _n("snap", ee)) || An;
        We.version = Oe.version = yn.version = "3.12.5", u = 1, B() && Ee(), xe.Power0, xe.Power1;
        var En = xe.Power2;
        xe.Power3, xe.Power4, xe.Linear, xe.Quad, xe.Cubic, xe.Quart, xe.Quint, xe.Strong, xe.Elastic, xe.Back, xe.SteppedEase, xe.Bounce, xe.Sine, xe.Expo, xe.Circ;
        /*!
         * CSSPlugin 3.12.5
         * https://gsap.com
         *
         * Copyright 2008-2024, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var xn, bn, wn, Cn, Sn, In, Mn, Tn, Bn = {},
            Rn = 180 / Math.PI,
            Ln = Math.PI / 180,
            Dn = Math.atan2,
            Pn = /([A-Z])/g,
            On = /(left|right|width|margin|padding|x)/i,
            kn = /[\s,\(]\S/,
            Un = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            Nn = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            Fn = function (t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            Qn = function (t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            },
            $n = function (t, e) {
                var n = e.s + e.c * t;
                e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
            },
            Gn = function (t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            },
            Hn = function (t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            },
            zn = function (t, e, n) {
                return t.style[e] = n
            },
            Vn = function (t, e, n) {
                return t.style.setProperty(e, n)
            },
            Wn = function (t, e, n) {
                return t._gsap[e] = n
            },
            jn = function (t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            },
            Xn = function (t, e, n, r, i) {
                var o = t._gsap;
                o.scaleX = o.scaleY = n, o.renderTransform(i, o)
            },
            qn = function (t, e, n, r, i) {
                var o = t._gsap;
                o[e] = n, o.renderTransform(i, o)
            },
            Yn = "transform",
            Kn = Yn + "Origin",
            Jn = function t(e, n) {
                var r = this,
                    i = this.target,
                    o = i.style,
                    a = i._gsap;
                if (e in Bn && o) {
                    if (this.tfm = this.tfm || {}, "transform" === e) return Un.transform.split(",").forEach((function (e) {
                        return t.call(r, e, n)
                    }));
                    if (~(e = Un[e] || e).indexOf(",") ? e.split(",").forEach((function (t) {
                            return r.tfm[t] = gr(i, t)
                        })) : this.tfm[e] = a.x ? a[e] : gr(i, e), e === Kn && (this.tfm.zOrigin = a.zOrigin), this.props.indexOf(Yn) >= 0) return;
                    a.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(Kn, n, "")), e = Yn
                }(o || n) && this.props.push(e, n, o[e])
            },
            Zn = function (t) {
                t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
            },
            tr = function () {
                var t, e, n = this.props,
                    r = this.target,
                    i = r.style,
                    o = r._gsap;
                for (t = 0; t < n.length; t += 3) n[t + 1] ? r[n[t]] = n[t + 2] : n[t + 2] ? i[n[t]] = n[t + 2] : i.removeProperty("--" === n[t].substr(0, 2) ? n[t] : n[t].replace(Pn, "-$1").toLowerCase());
                if (this.tfm) {
                    for (e in this.tfm) o[e] = this.tfm[e];
                    o.svg && (o.renderTransform(), r.setAttribute("data-svg-origin", this.svgo || "")), (t = Mn()) && t.isStart || i[Yn] || (Zn(i), o.zOrigin && i[Kn] && (i[Kn] += " " + o.zOrigin + "px", o.zOrigin = 0, o.renderTransform()), o.uncache = 1)
                }
            },
            er = function (t, e) {
                var n = {
                    target: t,
                    props: [],
                    revert: tr,
                    save: Jn
                };
                return t._gsap || yn.core.getCache(t), e && e.split(",").forEach((function (t) {
                    return n.save(t)
                })), n
            },
            nr = function (t, e) {
                var n = bn.createElementNS ? bn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : bn.createElement(t);
                return n && n.style ? n : bn.createElement(t)
            },
            rr = function t(e, n, r) {
                var i = getComputedStyle(e);
                return i[n] || i.getPropertyValue(n.replace(Pn, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && t(e, or(n) || n, 1) || ""
            },
            ir = "O,Moz,ms,Ms,Webkit".split(","),
            or = function (t, e, n) {
                var r = (e || Sn).style,
                    i = 5;
                if (t in r && !n) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(ir[i] + t in r););
                return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? ir[i] : "") + t
            },
            ar = function () {
                "undefined" != typeof window && window.document && (xn = window, bn = xn.document, wn = bn.documentElement, Sn = nr("div") || {
                    style: {}
                }, nr("div"), Yn = or(Yn), Kn = Yn + "Origin", Sn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Tn = !!or("perspective"), Mn = yn.core.reverting, Cn = 1)
            },
            sr = function t(e) {
                var n, r = nr("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    i = this.parentNode,
                    o = this.nextSibling,
                    a = this.style.cssText;
                if (wn.appendChild(r), r.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                return i && (o ? i.insertBefore(this, o) : i.appendChild(this)), wn.removeChild(r), this.style.cssText = a, n
            },
            lr = function (t, e) {
                for (var n = e.length; n--;)
                    if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            },
            cr = function (t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = sr.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === sr || (e = sr.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +lr(t, ["x", "cx", "x1"]) || 0,
                    y: +lr(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            ur = function (t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !cr(t))
            },
            hr = function (t, e) {
                if (e) {
                    var n, r = t.style;
                    e in Bn && e !== Kn && (e = Yn), r.removeProperty ? ("ms" !== (n = e.substr(0, 2)) && "webkit" !== e.substr(0, 6) || (e = "-" + e), r.removeProperty("--" === n ? e : e.replace(Pn, "-$1").toLowerCase())) : r.removeAttribute(e)
                }
            },
            dr = function (t, e, n, r, i, o) {
                var a = new sn(t._pt, e, n, 0, 1, o ? Hn : Gn);
                return t._pt = a, a.b = r, a.e = i, t._props.push(n), a
            },
            pr = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            fr = {
                grid: 1,
                flex: 1
            },
            mr = function t(e, n, r, i) {
                var o, a, s, l, c = parseFloat(r) || 0,
                    u = (r + "").trim().substr((c + "").length) || "px",
                    h = Sn.style,
                    d = On.test(n),
                    p = "svg" === e.tagName.toLowerCase(),
                    f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                    m = 100,
                    g = "px" === i,
                    A = "%" === i;
                if (i === u || !c || pr[i] || pr[u]) return c;
                if ("px" !== u && !g && (c = t(e, n, r, "px")), l = e.getCTM && ur(e), (A || "%" === u) && (Bn[n] || ~n.indexOf("adius"))) return o = l ? e.getBBox()[d ? "width" : "height"] : e[f], ct(A ? c / o * m : c / 100 * o);
                if (h[d ? "width" : "height"] = m + (g ? u : i), a = ~n.indexOf("adius") || "em" === i && e.appendChild && !p ? e : e.parentNode, l && (a = (e.ownerSVGElement || {}).parentNode), a && a !== bn && a.appendChild || (a = bn.body), (s = a._gsap) && A && s.width && d && s.time === ye.time && !s.uncache) return ct(c / s.width * m);
                if (!A || "height" !== n && "width" !== n)(A || "%" === u) && !fr[rr(a, "display")] && (h.position = rr(e, "position")), a === e && (h.position = "static"), a.appendChild(Sn), o = Sn[f], a.removeChild(Sn), h.position = "absolute";
                else {
                    var v = e.style[n];
                    e.style[n] = m + i, o = e[f], v ? e.style[n] = v : hr(e, n)
                }
                return d && A && ((s = at(a)).time = ye.time, s.width = a[f]), ct(g ? o * c / m : o && c ? m / o * c : 0)
            },
            gr = function (t, e, n, r) {
                var i;
                return Cn || ar(), e in Un && "transform" !== e && ~(e = Un[e]).indexOf(",") && (e = e.split(",")[0]), Bn[e] && "transform" !== e ? (i = Mr(t, r), i = "transformOrigin" !== e ? i[e] : i.svg ? i.origin : Tr(rr(t, Kn)) + " " + i.zOrigin + "px") : (!(i = t.style[e]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = Er[e] && Er[e](t, e, n) || rr(t, e) || st(t, e) || ("opacity" === e ? 1 : 0)), n && !~(i + "").trim().indexOf(" ") ? mr(t, e, i, n) + n : i
            },
            Ar = function (t, e, n, r) {
                if (!n || "none" === n) {
                    var i = or(e, t, 1),
                        o = i && rr(t, i, 1);
                    o && o !== n ? (e = i, n = o) : "borderColor" === e && (n = rr(t, "borderTopColor"))
                }
                var a, s, l, c, u, h, d, p, m, g, A, v = new sn(this._pt, t.style, e, 0, 1, tn),
                    _ = 0,
                    y = 0;
                if (v.b = n, v.e = r, n += "", "auto" === (r += "") && (h = t.style[e], t.style[e] = r, r = rr(t, e) || r, h ? t.style[e] = h : hr(t, e)), _e(a = [n, r]), r = a[1], l = (n = a[0]).match(k) || [], (r.match(k) || []).length) {
                    for (; s = k.exec(r);) d = s[0], m = r.substring(_, s.index), u ? u = (u + 1) % 5 : "rgba(" !== m.substr(-5) && "hsla(" !== m.substr(-5) || (u = 1), d !== (h = l[y++] || "") && (c = parseFloat(h) || 0, A = h.substr((c + "").length), "=" === d.charAt(1) && (d = ht(c, d) + A), p = parseFloat(d), g = d.substr((p + "").length), _ = k.lastIndex - g.length, g || (g = g || f.units[e] || A, _ === r.length && (r += g, v.e += g)), A !== g && (c = mr(t, e, h, g) || 0), v._pt = {
                        _next: v._pt,
                        p: m || 1 === y ? m : ",",
                        s: c,
                        c: p - c,
                        m: u && u < 4 || "zIndex" === e ? Math.round : 0
                    });
                    v.c = _ < r.length ? r.substring(_, r.length) : ""
                } else v.r = "display" === e && "none" === r ? Hn : Gn;
                return N.test(r) && (v.e = 0), this._pt = v, v
            },
            vr = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            _r = function (t) {
                var e = t.split(" "),
                    n = e[0],
                    r = e[1] || "50%";
                return "top" !== n && "bottom" !== n && "left" !== r && "right" !== r || (t = n, n = r, r = t), e[0] = vr[n] || n, e[1] = vr[r] || r, e.join(" ")
            },
            yr = function (t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var n, r, i, o = e.t,
                        a = o.style,
                        s = e.u,
                        l = o._gsap;
                    if ("all" === s || !0 === s) a.cssText = "", r = 1;
                    else
                        for (i = (s = s.split(",")).length; --i > -1;) n = s[i], Bn[n] && (r = 1, n = "transformOrigin" === n ? Kn : Yn), hr(o, n);
                    r && (hr(o, Yn), l && (l.svg && o.removeAttribute("transform"), Mr(o, 1), l.uncache = 1, Zn(a)))
                }
            },
            Er = {
                clearProps: function (t, e, n, r, i) {
                    if ("isFromStart" !== i.data) {
                        var o = t._pt = new sn(t._pt, e, n, 0, 0, yr);
                        return o.u = r, o.pr = -10, o.tween = i, t._props.push(n), 1
                    }
                }
            },
            xr = [1, 0, 0, 1, 0, 0],
            br = {},
            wr = function (t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            },
            Cr = function (t) {
                var e = rr(t, Yn);
                return wr(e) ? xr : e.substr(7).match(O).map(ct)
            },
            Sr = function (t, e) {
                var n, r, i, o, a = t._gsap || at(t),
                    s = t.style,
                    l = Cr(t);
                return a.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? xr : l : (l !== xr || t.offsetParent || t === wn || a.svg || (i = s.display, s.display = "block", (n = t.parentNode) && t.offsetParent || (o = 1, r = t.nextElementSibling, wn.appendChild(t)), l = Cr(t), i ? s.display = i : hr(t, "display"), o && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : wn.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            },
            Ir = function (t, e, n, r, i, o) {
                var a, s, l, c = t._gsap,
                    u = i || Sr(t, !0),
                    h = c.xOrigin || 0,
                    d = c.yOrigin || 0,
                    p = c.xOffset || 0,
                    f = c.yOffset || 0,
                    m = u[0],
                    g = u[1],
                    A = u[2],
                    v = u[3],
                    _ = u[4],
                    y = u[5],
                    E = e.split(" "),
                    x = parseFloat(E[0]) || 0,
                    b = parseFloat(E[1]) || 0;
                n ? u !== xr && (s = m * v - g * A) && (l = x * (-g / s) + b * (m / s) - (m * y - g * _) / s, x = x * (v / s) + b * (-A / s) + (A * y - v * _) / s, b = l) : (x = (a = cr(t)).x + (~E[0].indexOf("%") ? x / 100 * a.width : x), b = a.y + (~(E[1] || E[0]).indexOf("%") ? b / 100 * a.height : b)), r || !1 !== r && c.smooth ? (_ = x - h, y = b - d, c.xOffset = p + (_ * m + y * A) - _, c.yOffset = f + (_ * g + y * v) - y) : c.xOffset = c.yOffset = 0, c.xOrigin = x, c.yOrigin = b, c.smooth = !!r, c.origin = e, c.originIsAbsolute = !!n, t.style[Kn] = "0px 0px", o && (dr(o, c, "xOrigin", h, x), dr(o, c, "yOrigin", d, b), dr(o, c, "xOffset", p, c.xOffset), dr(o, c, "yOffset", f, c.yOffset)), t.setAttribute("data-svg-origin", x + " " + b)
            },
            Mr = function (t, e) {
                var n = t._gsap || new De(t);
                if ("x" in n && !e && !n.uncache) return n;
                var r, i, o, a, s, l, c, u, h, d, p, m, g, A, v, _, y, E, x, b, w, C, S, I, M, T, B, R, L, D, P, O, k = t.style,
                    U = n.scaleX < 0,
                    N = "px",
                    F = "deg",
                    Q = getComputedStyle(t),
                    $ = rr(t, Kn) || "0";
                return r = i = o = l = c = u = h = d = p = 0, a = s = 1, n.svg = !(!t.getCTM || !ur(t)), Q.translate && ("none" === Q.translate && "none" === Q.scale && "none" === Q.rotate || (k[Yn] = ("none" !== Q.translate ? "translate3d(" + (Q.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== Q.rotate ? "rotate(" + Q.rotate + ") " : "") + ("none" !== Q.scale ? "scale(" + Q.scale.split(" ").join(",") + ") " : "") + ("none" !== Q[Yn] ? Q[Yn] : "")), k.scale = k.rotate = k.translate = "none"), A = Sr(t, n.svg), n.svg && (n.uncache ? (M = t.getBBox(), $ = n.xOrigin - M.x + "px " + (n.yOrigin - M.y) + "px", I = "") : I = !e && t.getAttribute("data-svg-origin"), Ir(t, I || $, !!I || n.originIsAbsolute, !1 !== n.smooth, A)), m = n.xOrigin || 0, g = n.yOrigin || 0, A !== xr && (E = A[0], x = A[1], b = A[2], w = A[3], r = C = A[4], i = S = A[5], 6 === A.length ? (a = Math.sqrt(E * E + x * x), s = Math.sqrt(w * w + b * b), l = E || x ? Dn(x, E) * Rn : 0, (h = b || w ? Dn(b, w) * Rn + l : 0) && (s *= Math.abs(Math.cos(h * Ln))), n.svg && (r -= m - (m * E + g * b), i -= g - (m * x + g * w))) : (O = A[6], D = A[7], B = A[8], R = A[9], L = A[10], P = A[11], r = A[12], i = A[13], o = A[14], c = (v = Dn(O, L)) * Rn, v && (I = C * (_ = Math.cos(-v)) + B * (y = Math.sin(-v)), M = S * _ + R * y, T = O * _ + L * y, B = C * -y + B * _, R = S * -y + R * _, L = O * -y + L * _, P = D * -y + P * _, C = I, S = M, O = T), u = (v = Dn(-b, L)) * Rn, v && (_ = Math.cos(-v), P = w * (y = Math.sin(-v)) + P * _, E = I = E * _ - B * y, x = M = x * _ - R * y, b = T = b * _ - L * y), l = (v = Dn(x, E)) * Rn, v && (I = E * (_ = Math.cos(v)) + x * (y = Math.sin(v)), M = C * _ + S * y, x = x * _ - E * y, S = S * _ - C * y, E = I, C = M), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), a = ct(Math.sqrt(E * E + x * x + b * b)), s = ct(Math.sqrt(S * S + O * O)), v = Dn(C, S), h = Math.abs(v) > 2e-4 ? v * Rn : 0, p = P ? 1 / (P < 0 ? -P : P) : 0), n.svg && (I = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !wr(rr(t, Yn)), I && t.setAttribute("transform", I))), Math.abs(h) > 90 && Math.abs(h) < 270 && (U ? (a *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (s *= -1, h += h <= 0 ? 180 : -180)), e = e || n.uncache, n.x = r - ((n.xPercent = r && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + N, n.y = i - ((n.yPercent = i && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + N, n.z = o + N, n.scaleX = ct(a), n.scaleY = ct(s), n.rotation = ct(l) + F, n.rotationX = ct(c) + F, n.rotationY = ct(u) + F, n.skewX = h + F, n.skewY = d + F, n.transformPerspective = p + N, (n.zOrigin = parseFloat($.split(" ")[2]) || !e && n.zOrigin || 0) && (k[Kn] = Tr($)), n.xOffset = n.yOffset = 0, n.force3D = f.force3D, n.renderTransform = n.svg ? kr : Tn ? Or : Rr, n.uncache = 0, n
            },
            Tr = function (t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            Br = function (t, e, n) {
                var r = Wt(e);
                return ct(parseFloat(e) + parseFloat(mr(t, "x", n + "px", r))) + r
            },
            Rr = function (t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Or(t, e)
            },
            Lr = "0deg",
            Dr = "0px",
            Pr = ") ",
            Or = function (t, e) {
                var n = e || this,
                    r = n.xPercent,
                    i = n.yPercent,
                    o = n.x,
                    a = n.y,
                    s = n.z,
                    l = n.rotation,
                    c = n.rotationY,
                    u = n.rotationX,
                    h = n.skewX,
                    d = n.skewY,
                    p = n.scaleX,
                    f = n.scaleY,
                    m = n.transformPerspective,
                    g = n.force3D,
                    A = n.target,
                    v = n.zOrigin,
                    _ = "",
                    y = "auto" === g && t && 1 !== t || !0 === g;
                if (v && (u !== Lr || c !== Lr)) {
                    var E, x = parseFloat(c) * Ln,
                        b = Math.sin(x),
                        w = Math.cos(x);
                    x = parseFloat(u) * Ln, E = Math.cos(x), o = Br(A, o, b * E * -v), a = Br(A, a, -Math.sin(x) * -v), s = Br(A, s, w * E * -v + v)
                }
                m !== Dr && (_ += "perspective(" + m + Pr), (r || i) && (_ += "translate(" + r + "%, " + i + "%) "), (y || o !== Dr || a !== Dr || s !== Dr) && (_ += s !== Dr || y ? "translate3d(" + o + ", " + a + ", " + s + ") " : "translate(" + o + ", " + a + Pr), l !== Lr && (_ += "rotate(" + l + Pr), c !== Lr && (_ += "rotateY(" + c + Pr), u !== Lr && (_ += "rotateX(" + u + Pr), h === Lr && d === Lr || (_ += "skew(" + h + ", " + d + Pr), 1 === p && 1 === f || (_ += "scale(" + p + ", " + f + Pr), A.style[Yn] = _ || "translate(0, 0)"
            },
            kr = function (t, e) {
                var n, r, i, o, a, s = e || this,
                    l = s.xPercent,
                    c = s.yPercent,
                    u = s.x,
                    h = s.y,
                    d = s.rotation,
                    p = s.skewX,
                    f = s.skewY,
                    m = s.scaleX,
                    g = s.scaleY,
                    A = s.target,
                    v = s.xOrigin,
                    _ = s.yOrigin,
                    y = s.xOffset,
                    E = s.yOffset,
                    x = s.forceCSS,
                    b = parseFloat(u),
                    w = parseFloat(h);
                d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= Ln, p *= Ln, n = Math.cos(d) * m, r = Math.sin(d) * m, i = Math.sin(d - p) * -g, o = Math.cos(d - p) * g, p && (f *= Ln, a = Math.tan(p - f), i *= a = Math.sqrt(1 + a * a), o *= a, f && (a = Math.tan(f), n *= a = Math.sqrt(1 + a * a), r *= a)), n = ct(n), r = ct(r), i = ct(i), o = ct(o)) : (n = m, o = g, r = i = 0), (b && !~(u + "").indexOf("px") || w && !~(h + "").indexOf("px")) && (b = mr(A, "x", u, "px"), w = mr(A, "y", h, "px")), (v || _ || y || E) && (b = ct(b + v - (v * n + _ * i) + y), w = ct(w + _ - (v * r + _ * o) + E)), (l || c) && (a = A.getBBox(), b = ct(b + l / 100 * a.width), w = ct(w + c / 100 * a.height)), a = "matrix(" + n + "," + r + "," + i + "," + o + "," + b + "," + w + ")", A.setAttribute("transform", a), x && (A.style[Yn] = a)
            },
            Ur = function (t, e, n, r, i) {
                var o, a, s = 360,
                    l = w(i),
                    c = parseFloat(i) * (l && ~i.indexOf("rad") ? Rn : 1) - r,
                    u = r + c + "deg";
                return l && ("short" === (o = i.split("_")[1]) && (c %= s) !== c % 180 && (c += c < 0 ? s : -360), "cw" === o && c < 0 ? c = (c + 36e9) % s - ~~(c / s) * s : "ccw" === o && c > 0 && (c = (c - 36e9) % s - ~~(c / s) * s)), t._pt = a = new sn(t._pt, e, n, r, c, Fn), a.e = u, a.u = "deg", t._props.push(n), a
            },
            Nr = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            Fr = function (t, e, n) {
                var r, i, o, a, s, l, c, u = Nr({}, n._gsap),
                    h = n.style;
                for (i in u.svg ? (o = n.getAttribute("transform"), n.setAttribute("transform", ""), h[Yn] = e, r = Mr(n, 1), hr(n, Yn), n.setAttribute("transform", o)) : (o = getComputedStyle(n)[Yn], h[Yn] = e, r = Mr(n, 1), h[Yn] = o), Bn)(o = u[i]) !== (a = r[i]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) < 0 && (s = Wt(o) !== (c = Wt(a)) ? mr(n, i, o, c) : parseFloat(o), l = parseFloat(a), t._pt = new sn(t._pt, r, i, s, l - s, Nn), t._pt.u = c || 0, t._props.push(i));
                Nr(r, u)
            };
        lt("padding,margin,Width,Radius", (function (t, e) {
            var n = "Top",
                r = "Right",
                i = "Bottom",
                o = "Left",
                a = (e < 3 ? [n, r, i, o] : [n + o, n + r, i + r, i + o]).map((function (n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            Er[e > 1 ? "border" + t : t] = function (t, e, n, r, i) {
                var o, s;
                if (arguments.length < 4) return o = a.map((function (e) {
                    return gr(t, e, n)
                })), 5 === (s = o.join(" ")).split(o[0]).length ? o[0] : s;
                o = (r + "").split(" "), s = {}, a.forEach((function (t, e) {
                    return s[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
                })), t.init(e, s, i)
            }
        }));
        var Qr, $r, Gr, Hr = {
            name: "css",
            register: ar,
            targetTest: function (t) {
                return t.style && t.nodeType
            },
            init: function (t, e, n, r, i) {
                var o, a, s, l, c, u, h, d, p, m, g, A, v, _, y, E, x = this._props,
                    b = t.style,
                    C = n.vars.startAt;
                for (h in Cn || ar(), this.styles = this.styles || er(t), E = this.styles.props, this.tween = n, e)
                    if ("autoRound" !== h && (a = e[h], !tt[h] || !Qe(h, e, n, r, t, i)))
                        if (c = typeof a, u = Er[h], "function" === c && (c = typeof (a = a.call(n, r, t, i))), "string" === c && ~a.indexOf("random(") && (a = ie(a)), u) u(this, t, h, a, n) && (y = 1);
                        else if ("--" === h.substr(0, 2)) o = (getComputedStyle(t).getPropertyValue(h) + "").trim(), a += "", Ae.lastIndex = 0, Ae.test(o) || (d = Wt(o), p = Wt(a)), p ? d !== p && (o = mr(t, h, o, p) + p) : d && (a += d), this.add(b, "setProperty", o, a, r, i, 0, 0, h), x.push(h), E.push(h, 0, b[h]);
                else if ("undefined" !== c) {
                    if (C && h in C ? (o = "function" == typeof C[h] ? C[h].call(n, r, t, i) : C[h], w(o) && ~o.indexOf("random(") && (o = ie(o)), Wt(o + "") || "auto" === o || (o += f.units[h] || Wt(gr(t, h)) || ""), "=" === (o + "").charAt(1) && (o = gr(t, h))) : o = gr(t, h), l = parseFloat(o), (m = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)), s = parseFloat(a), h in Un && ("autoAlpha" === h && (1 === l && "hidden" === gr(t, "visibility") && s && (l = 0), E.push("visibility", 0, b.visibility), dr(this, b, "visibility", l ? "inherit" : "hidden", s ? "inherit" : "hidden", !s)), "scale" !== h && "transform" !== h && ~(h = Un[h]).indexOf(",") && (h = h.split(",")[0])), g = h in Bn)
                        if (this.styles.save(h), A || ((v = t._gsap).renderTransform && !e.parseTransform || Mr(t, e.parseTransform), _ = !1 !== e.smoothOrigin && v.smooth, (A = this._pt = new sn(this._pt, b, Yn, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new sn(this._pt, v, "scaleY", v.scaleY, (m ? ht(v.scaleY, m + s) : s) - v.scaleY || 0, Nn), this._pt.u = 0, x.push("scaleY", h), h += "X";
                        else {
                            if ("transformOrigin" === h) {
                                E.push(Kn, 0, b[Kn]), a = _r(a), v.svg ? Ir(t, a, 0, _, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== v.zOrigin && dr(this, v, "zOrigin", v.zOrigin, p), dr(this, b, h, Tr(o), Tr(a)));
                                continue
                            }
                            if ("svgOrigin" === h) {
                                Ir(t, a, 1, _, 0, this);
                                continue
                            }
                            if (h in br) {
                                Ur(this, v, h, l, m ? ht(l, m + a) : a);
                                continue
                            }
                            if ("smoothOrigin" === h) {
                                dr(this, v, "smooth", v.smooth, a);
                                continue
                            }
                            if ("force3D" === h) {
                                v[h] = a;
                                continue
                            }
                            if ("transform" === h) {
                                Fr(this, a, t);
                                continue
                            }
                        }
                    else h in b || (h = or(h) || h);
                    if (g || (s || 0 === s) && (l || 0 === l) && !kn.test(a) && h in b) s || (s = 0), (d = (o + "").substr((l + "").length)) !== (p = Wt(a) || (h in f.units ? f.units[h] : d)) && (l = mr(t, h, o, p)), this._pt = new sn(this._pt, g ? v : b, h, l, (m ? ht(l, m + s) : s) - l, g || "px" !== p && "zIndex" !== h || !1 === e.autoRound ? Nn : $n), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = o, this._pt.r = Qn);
                    else if (h in b) Ar.call(this, t, h, o, m ? m + a : a);
                    else if (h in t) this.add(t, h, o || t[h], m ? m + a : a, r, i);
                    else if ("parseTransform" !== h) {
                        z(h, a);
                        continue
                    }
                    g || (h in b ? E.push(h, 0, b[h]) : E.push(h, 1, o || t[h])), x.push(h)
                }
                y && an(this)
            },
            render: function (t, e) {
                if (e.tween._time || !Mn())
                    for (var n = e._pt; n;) n.r(t, n.d), n = n._next;
                else e.styles.revert()
            },
            get: gr,
            aliases: Un,
            getSetter: function (t, e, n) {
                var r = Un[e];
                return r && r.indexOf(",") < 0 && (e = r), e in Bn && e !== Kn && (t._gsap.x || gr(t, "x")) ? n && In === n ? "scale" === e ? jn : Wn : (In = n || {}) && ("scale" === e ? Xn : qn) : t.style && !I(t.style[e]) ? zn : ~e.indexOf("-") ? Vn : Ke(t, e)
            },
            core: {
                _removeProperty: hr,
                _getMatrix: Sr
            }
        };
        yn.utils.checkPrefix = or, yn.core.getStyleSaver = er, Gr = lt((Qr = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + ($r = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
            Bn[t] = 1
        })), lt($r, (function (t) {
            f.units[t] = "deg", br[t] = 1
        })), Un[Gr[13]] = Qr + "," + $r, lt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
            var e = t.split(":");
            Un[e[1]] = Gr[e[0]]
        })), lt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
            f.units[t] = "px"
        })), yn.registerPlugin(Hr);
        var zr = yn.registerPlugin(Hr) || yn;
        zr.core.Tween;
        /**
         * @license
         * Copyright 2010-2023 Three.js Authors
         * SPDX-License-Identifier: MIT
         */
        const Vr = "162",
            Wr = 1,
            jr = 2,
            Xr = 3,
            qr = 0,
            Yr = 1,
            Kr = 100,
            Jr = 0,
            Zr = 1,
            ti = 2,
            ei = 0,
            ni = 1,
            ri = 2,
            ii = 3,
            oi = 4,
            ai = 5,
            si = 6,
            li = 7,
            ci = "attached",
            ui = 301,
            hi = 302,
            di = 306,
            pi = 1e3,
            fi = 1001,
            mi = 1002,
            gi = 1003,
            Ai = 1004,
            vi = 1005,
            _i = 1006,
            yi = 1007,
            Ei = 1008,
            xi = 1009,
            bi = 1012,
            wi = 1013,
            Ci = 1014,
            Si = 1015,
            Ii = 1016,
            Mi = 1020,
            Ti = 1023,
            Bi = 1026,
            Ri = 1027,
            Li = 1028,
            Di = 1030,
            Pi = 33776,
            Oi = 33777,
            ki = 33778,
            Ui = 33779,
            Ni = 35840,
            Fi = 35842,
            Qi = 36196,
            $i = 37492,
            Gi = 37496,
            Hi = 37808,
            zi = 37812,
            Vi = 36492,
            Wi = 2300,
            ji = 2301,
            Xi = 2302,
            qi = "",
            Yi = "srgb",
            Ki = "srgb-linear",
            Ji = "display-p3",
            Zi = "display-p3-linear",
            to = "linear",
            eo = "srgb",
            no = "rec709",
            ro = "p3",
            io = 7680,
            oo = 35044,
            ao = "300 es",
            so = 1035,
            lo = 2e3,
            co = 2001;
        class uo {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const ho = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let po = 1234567;
        const fo = Math.PI / 180,
            mo = 180 / Math.PI;

        function go() {
            const t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                r = 4294967295 * Math.random() | 0;
            return (ho[255 & t] + ho[t >> 8 & 255] + ho[t >> 16 & 255] + ho[t >> 24 & 255] + "-" + ho[255 & e] + ho[e >> 8 & 255] + "-" + ho[e >> 16 & 15 | 64] + ho[e >> 24 & 255] + "-" + ho[63 & n | 128] + ho[n >> 8 & 255] + "-" + ho[n >> 16 & 255] + ho[n >> 24 & 255] + ho[255 & r] + ho[r >> 8 & 255] + ho[r >> 16 & 255] + ho[r >> 24 & 255]).toLowerCase()
        }

        function Ao(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function vo(t, e) {
            return (t % e + e) % e
        }

        function _o(t, e, n) {
            return (1 - n) * t + n * e
        }

        function yo(t) {
            return 0 == (t & t - 1) && 0 !== t
        }

        function Eo(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }

        function xo(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint32Array:
                    return t / 4294967295;
                case Uint16Array:
                    return t / 65535;
                case Uint8Array:
                    return t / 255;
                case Int32Array:
                    return Math.max(t / 2147483647, -1);
                case Int16Array:
                    return Math.max(t / 32767, -1);
                case Int8Array:
                    return Math.max(t / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        function bo(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint32Array:
                    return Math.round(4294967295 * t);
                case Uint16Array:
                    return Math.round(65535 * t);
                case Uint8Array:
                    return Math.round(255 * t);
                case Int32Array:
                    return Math.round(2147483647 * t);
                case Int16Array:
                    return Math.round(32767 * t);
                case Int8Array:
                    return Math.round(127 * t);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        const wo = {
            DEG2RAD: fo,
            RAD2DEG: mo,
            generateUUID: go,
            clamp: Ao,
            euclideanModulo: vo,
            mapLinear: function (t, e, n, r, i) {
                return r + (t - e) * (i - r) / (n - e)
            },
            inverseLerp: function (t, e, n) {
                return t !== e ? (n - t) / (e - t) : 0
            },
            lerp: _o,
            damp: function (t, e, n, r) {
                return _o(t, e, 1 - Math.exp(-n * r))
            },
            pingpong: function (t, e = 1) {
                return e - Math.abs(vo(t, 2 * e) - e)
            },
            smoothstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function (t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function (t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function (t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function (t) {
                void 0 !== t && (po = t);
                let e = po += 1831565813;
                return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
            },
            degToRad: function (t) {
                return t * fo
            },
            radToDeg: function (t) {
                return t * mo
            },
            isPowerOfTwo: yo,
            ceilPowerOfTwo: function (t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: Eo,
            setQuaternionFromProperEuler: function (t, e, n, r, i) {
                const o = Math.cos,
                    a = Math.sin,
                    s = o(n / 2),
                    l = a(n / 2),
                    c = o((e + r) / 2),
                    u = a((e + r) / 2),
                    h = o((e - r) / 2),
                    d = a((e - r) / 2),
                    p = o((r - e) / 2),
                    f = a((r - e) / 2);
                switch (i) {
                    case "XYX":
                        t.set(s * u, l * h, l * d, s * c);
                        break;
                    case "YZY":
                        t.set(l * d, s * u, l * h, s * c);
                        break;
                    case "ZXZ":
                        t.set(l * h, l * d, s * u, s * c);
                        break;
                    case "XZX":
                        t.set(s * u, l * f, l * p, s * c);
                        break;
                    case "YXY":
                        t.set(l * p, s * u, l * f, s * c);
                        break;
                    case "ZYZ":
                        t.set(l * f, l * p, s * u, s * c);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                }
            },
            normalize: bo,
            denormalize: xo
        };
        class Co {
            constructor(t = 0, e = 0) {
                Co.prototype.isVector2 = !0, this.x = t, this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(Ao(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this
            }
            rotateAround(t, e) {
                const n = Math.cos(e),
                    r = Math.sin(e),
                    i = this.x - t.x,
                    o = this.y - t.y;
                return this.x = i * n - o * r + t.x, this.y = i * r + o * n + t.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        class So {
            constructor(t, e, n, r, i, o, a, s, l) {
                So.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, r, i, o, a, s, l)
            }
            set(t, e, n, r, i, o, a, s, l) {
                const c = this.elements;
                return c[0] = t, c[1] = r, c[2] = a, c[3] = e, c[4] = i, c[5] = s, c[6] = n, c[7] = o, c[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    r = e.elements,
                    i = this.elements,
                    o = n[0],
                    a = n[3],
                    s = n[6],
                    l = n[1],
                    c = n[4],
                    u = n[7],
                    h = n[2],
                    d = n[5],
                    p = n[8],
                    f = r[0],
                    m = r[3],
                    g = r[6],
                    A = r[1],
                    v = r[4],
                    _ = r[7],
                    y = r[2],
                    E = r[5],
                    x = r[8];
                return i[0] = o * f + a * A + s * y, i[3] = o * m + a * v + s * E, i[6] = o * g + a * _ + s * x, i[1] = l * f + c * A + u * y, i[4] = l * m + c * v + u * E, i[7] = l * g + c * _ + u * x, i[2] = h * f + d * A + p * y, i[5] = h * m + d * v + p * E, i[8] = h * g + d * _ + p * x, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    i = t[3],
                    o = t[4],
                    a = t[5],
                    s = t[6],
                    l = t[7],
                    c = t[8];
                return e * o * c - e * a * l - n * i * c + n * a * s + r * i * l - r * o * s
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    i = t[3],
                    o = t[4],
                    a = t[5],
                    s = t[6],
                    l = t[7],
                    c = t[8],
                    u = c * o - a * l,
                    h = a * s - c * i,
                    d = l * i - o * s,
                    p = e * u + n * h + r * d;
                if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = u * f, t[1] = (r * l - c * n) * f, t[2] = (a * n - r * o) * f, t[3] = h * f, t[4] = (c * e - r * s) * f, t[5] = (r * i - a * e) * f, t[6] = d * f, t[7] = (n * s - l * e) * f, t[8] = (o * e - n * i) * f, this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }
            setUvTransform(t, e, n, r, i, o, a) {
                const s = Math.cos(i),
                    l = Math.sin(i);
                return this.set(n * s, n * l, -n * (s * o + l * a) + o + t, -r * l, r * s, -r * (-l * o + s * a) + a + e, 0, 0, 1), this
            }
            scale(t, e) {
                return this.premultiply(Io.makeScale(t, e)), this
            }
            rotate(t) {
                return this.premultiply(Io.makeRotation(-t)), this
            }
            translate(t, e) {
                return this.premultiply(Io.makeTranslation(t, e)), this
            }
            makeTranslation(t, e) {
                return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
            }
            makeRotation(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
            }
            makeScale(t, e) {
                return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Io = new So;

        function Mo(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] >= 65535) return !0;
            return !1
        }

        function To(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }

        function Bo() {
            const t = To("canvas");
            return t.style.display = "block", t
        }
        const Ro = {};

        function Lo(t) {
            t in Ro || (Ro[t] = !0, console.warn(t))
        }
        const Do = (new So).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
            Po = (new So).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
            Oo = {
                [Ki]: {
                    transfer: to,
                    primaries: no,
                    toReference: t => t,
                    fromReference: t => t
                },
                [Yi]: {
                    transfer: eo,
                    primaries: no,
                    toReference: t => t.convertSRGBToLinear(),
                    fromReference: t => t.convertLinearToSRGB()
                },
                [Zi]: {
                    transfer: to,
                    primaries: ro,
                    toReference: t => t.applyMatrix3(Po),
                    fromReference: t => t.applyMatrix3(Do)
                },
                [Ji]: {
                    transfer: eo,
                    primaries: ro,
                    toReference: t => t.convertSRGBToLinear().applyMatrix3(Po),
                    fromReference: t => t.applyMatrix3(Do).convertLinearToSRGB()
                }
            },
            ko = new Set([Ki, Zi]),
            Uo = {
                enabled: !0,
                _workingColorSpace: Ki,
                get workingColorSpace() {
                    return this._workingColorSpace
                },
                set workingColorSpace(t) {
                    if (!ko.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
                    this._workingColorSpace = t
                },
                convert: function (t, e, n) {
                    if (!1 === this.enabled || e === n || !e || !n) return t;
                    const r = Oo[e].toReference;
                    return (0, Oo[n].fromReference)(r(t))
                },
                fromWorkingColorSpace: function (t, e) {
                    return this.convert(t, this._workingColorSpace, e)
                },
                toWorkingColorSpace: function (t, e) {
                    return this.convert(t, e, this._workingColorSpace)
                },
                getPrimaries: function (t) {
                    return Oo[t].primaries
                },
                getTransfer: function (t) {
                    return t === qi ? to : Oo[t].transfer
                }
            };

        function No(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function Fo(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        let Qo;
        class $o {
            static getDataURL(t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                let e;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === Qo && (Qo = To("canvas")), Qo.width = t.width, Qo.height = t.height;
                    const n = Qo.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Qo
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = To("canvas");
                    e.width = t.width, e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const r = n.getImageData(0, 0, t.width, t.height),
                        i = r.data;
                    for (let t = 0; t < i.length; t++) i[t] = 255 * No(i[t] / 255);
                    return n.putImageData(r, 0, 0), e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * No(e[t] / 255)) : e[t] = No(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
            }
        }
        let Go = 0;
        class Ho {
            constructor(t = null) {
                this.isSource = !0, Object.defineProperty(this, "id", {
                    value: Go++
                }), this.uuid = go(), this.data = t, this.dataReady = !0, this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ""
                    },
                    r = this.data;
                if (null !== r) {
                    let t;
                    if (Array.isArray(r)) {
                        t = [];
                        for (let e = 0, n = r.length; e < n; e++) r[e].isDataTexture ? t.push(zo(r[e].image)) : t.push(zo(r[e]))
                    } else t = zo(r);
                    n.url = t
                }
                return e || (t.images[this.uuid] = n), n
            }
        }

        function zo(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? $o.getDataURL(t) : t.data ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        let Vo = 0;
        class Wo extends uo {
            constructor(t = Wo.DEFAULT_IMAGE, e = Wo.DEFAULT_MAPPING, n = 1001, r = 1001, i = 1006, o = 1008, a = 1023, s = 1009, l = Wo.DEFAULT_ANISOTROPY, c = qi) {
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                    value: Vo++
                }), this.uuid = go(), this.name = "", this.source = new Ho(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = o, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = s, this.offset = new Co(0, 0), this.repeat = new Co(1, 1), this.center = new Co(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new So, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(t = null) {
                this.source.data = t
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(t).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case pi:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case fi:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case mi:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case pi:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case fi:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case mi:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
            set needsUpdate(t) {
                !0 === t && (this.version++, this.source.needsUpdate = !0)
            }
        }
        Wo.DEFAULT_IMAGE = null, Wo.DEFAULT_MAPPING = 300, Wo.DEFAULT_ANISOTROPY = 1;
        class jo {
            constructor(t = 0, e = 0, n = 0, r = 1) {
                jo.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = r
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, r) {
                return this.x = t, this.y = e, this.z = n, this.w = r, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setW(t) {
                return this.w = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = this.w,
                    o = t.elements;
                return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, r, i;
                const o = .01,
                    a = .1,
                    s = t.elements,
                    l = s[0],
                    c = s[4],
                    u = s[8],
                    h = s[1],
                    d = s[5],
                    p = s[9],
                    f = s[2],
                    m = s[6],
                    g = s[10];
                if (Math.abs(c - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                    if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (l + 1) / 2,
                        s = (d + 1) / 2,
                        A = (g + 1) / 2,
                        v = (c + h) / 4,
                        _ = (u + f) / 4,
                        y = (p + m) / 4;
                    return t > s && t > A ? t < o ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = v / n, i = _ / n) : s > A ? s < o ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(s), n = v / r, i = y / r) : A < o ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(A), n = _ / i, r = y / i), this.set(n, r, i, e), this
                }
                let A = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                return Math.abs(A) < .001 && (A = 1), this.x = (m - p) / A, this.y = (u - f) / A, this.z = (h - c) / A, this.w = Math.acos((l + d + g - 1) / 2), this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        class Xo extends uo {
            constructor(t = 1, e = 1, n = {}) {
                super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new jo(0, 0, t, e), this.scissorTest = !1, this.viewport = new jo(0, 0, t, e);
                const r = {
                    width: t,
                    height: e,
                    depth: 1
                };
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: _i,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0,
                    count: 1
                }, n);
                const i = new Wo(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
                i.flipY = !1, i.generateMipmaps = n.generateMipmaps, i.internalFormat = n.internalFormat, this.textures = [];
                const o = n.count;
                for (let t = 0; t < o; t++) this.textures[t] = i.clone(), this.textures[t].isRenderTargetTexture = !0;
                this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
            }
            get texture() {
                return this.textures[0]
            }
            set texture(t) {
                this.textures[0] = t
            }
            setSize(t, e, n = 1) {
                if (this.width !== t || this.height !== e || this.depth !== n) {
                    this.width = t, this.height = e, this.depth = n;
                    for (let r = 0, i = this.textures.length; r < i; r++) this.textures[r].image.width = t, this.textures[r].image.height = e, this.textures[r].image.depth = n;
                    this.dispose()
                }
                this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
                for (let e = 0, n = t.textures.length; e < n; e++) this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0;
                const e = Object.assign({}, t.texture.image);
                return this.texture.source = new Ho(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class qo extends Xo {
            constructor(t = 1, e = 1, n = {}) {
                super(t, e, n), this.isWebGLRenderTarget = !0
            }
        }
        class Yo extends Wo {
            constructor(t = null, e = 1, n = 1, r = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: r
                }, this.magFilter = gi, this.minFilter = gi, this.wrapR = fi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class Ko extends Wo {
            constructor(t = null, e = 1, n = 1, r = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: r
                }, this.magFilter = gi, this.minFilter = gi, this.wrapR = fi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class Jo {
            constructor(t = 0, e = 0, n = 0, r = 1) {
                this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = r
            }
            static slerpFlat(t, e, n, r, i, o, a) {
                let s = n[r + 0],
                    l = n[r + 1],
                    c = n[r + 2],
                    u = n[r + 3];
                const h = i[o + 0],
                    d = i[o + 1],
                    p = i[o + 2],
                    f = i[o + 3];
                if (0 === a) return t[e + 0] = s, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = u);
                if (1 === a) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = f);
                if (u !== f || s !== h || l !== d || c !== p) {
                    let t = 1 - a;
                    const e = s * h + l * d + c * p + u * f,
                        n = e >= 0 ? 1 : -1,
                        r = 1 - e * e;
                    if (r > Number.EPSILON) {
                        const i = Math.sqrt(r),
                            o = Math.atan2(i, e * n);
                        t = Math.sin(t * o) / i, a = Math.sin(a * o) / i
                    }
                    const i = a * n;
                    if (s = s * t + h * i, l = l * t + d * i, c = c * t + p * i, u = u * t + f * i, t === 1 - a) {
                        const t = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                        s *= t, l *= t, c *= t, u *= t
                    }
                }
                t[e] = s, t[e + 1] = l, t[e + 2] = c, t[e + 3] = u
            }
            static multiplyQuaternionsFlat(t, e, n, r, i, o) {
                const a = n[r],
                    s = n[r + 1],
                    l = n[r + 2],
                    c = n[r + 3],
                    u = i[o],
                    h = i[o + 1],
                    d = i[o + 2],
                    p = i[o + 3];
                return t[e] = a * p + c * u + s * d - l * h, t[e + 1] = s * p + c * h + l * u - a * d, t[e + 2] = l * p + c * d + a * h - s * u, t[e + 3] = c * p - a * u - s * h - l * d, t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t, this._onChangeCallback()
            }
            set(t, e, n, r) {
                return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }
            setFromEuler(t, e = !0) {
                const n = t._x,
                    r = t._y,
                    i = t._z,
                    o = t._order,
                    a = Math.cos,
                    s = Math.sin,
                    l = a(n / 2),
                    c = a(r / 2),
                    u = a(i / 2),
                    h = s(n / 2),
                    d = s(r / 2),
                    p = s(i / 2);
                switch (o) {
                    case "XYZ":
                        this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case "YXZ":
                        this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    case "ZXY":
                        this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case "ZYX":
                        this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    case "YZX":
                        this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case "XZY":
                        this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                }
                return !0 === e && this._onChangeCallback(), this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2,
                    r = Math.sin(n);
                return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(t) {
                const e = t.elements,
                    n = e[0],
                    r = e[4],
                    i = e[8],
                    o = e[1],
                    a = e[5],
                    s = e[9],
                    l = e[2],
                    c = e[6],
                    u = e[10],
                    h = n + a + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t, this._x = (c - s) * t, this._y = (i - l) * t, this._z = (o - r) * t
                } else if (n > a && n > u) {
                    const t = 2 * Math.sqrt(1 + n - a - u);
                    this._w = (c - s) / t, this._x = .25 * t, this._y = (r + o) / t, this._z = (i + l) / t
                } else if (a > u) {
                    const t = 2 * Math.sqrt(1 + a - n - u);
                    this._w = (i - l) / t, this._x = (r + o) / t, this._y = .25 * t, this._z = (s + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - a);
                    this._w = (o - r) / t, this._x = (i + l) / t, this._y = (s + c) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(Ao(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n) return this;
                const r = Math.min(1, e / n);
                return this.slerp(t, r), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }
            multiply(t) {
                return this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x,
                    r = t._y,
                    i = t._z,
                    o = t._w,
                    a = e._x,
                    s = e._y,
                    l = e._z,
                    c = e._w;
                return this._x = n * c + o * a + r * l - i * s, this._y = r * c + o * s + i * a - n * l, this._z = i * c + o * l + n * s - r * a, this._w = o * c - n * a - r * s - i * l, this._onChangeCallback(), this
            }
            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x,
                    r = this._y,
                    i = this._z,
                    o = this._w;
                let a = o * t._w + n * t._x + r * t._y + i * t._z;
                if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                const s = 1 - a * a;
                if (s <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this
                }
                const l = Math.sqrt(s),
                    c = Math.atan2(l, a),
                    u = Math.sin((1 - e) * c) / l,
                    h = Math.sin(e * c) / l;
                return this._w = o * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = 2 * Math.PI * Math.random(),
                    e = 2 * Math.PI * Math.random(),
                    n = Math.random(),
                    r = Math.sqrt(1 - n),
                    i = Math.sqrt(n);
                return this.set(r * Math.sin(t), r * Math.cos(t), i * Math.sin(e), i * Math.cos(e))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }
        class Zo {
            constructor(t = 0, e = 0, n = 0) {
                Zo.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }
            applyEuler(t) {
                return this.applyQuaternion(ea.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(ea.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements,
                    o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o, this
            }
            applyQuaternion(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.x,
                    o = t.y,
                    a = t.z,
                    s = t.w,
                    l = 2 * (o * r - a * n),
                    c = 2 * (a * e - i * r),
                    u = 2 * (i * n - o * e);
                return this.x = e + s * l + o * u - a * c, this.y = n + s * c + a * l - i * u, this.z = r + s * u + i * c - o * l, this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements;
                return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }
            cross(t) {
                return this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x,
                    r = t.y,
                    i = t.z,
                    o = e.x,
                    a = e.y,
                    s = e.z;
                return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return ta.copy(this).projectOnVector(t), this.sub(ta)
            }
            reflect(t) {
                return this.sub(ta.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(Ao(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y,
                    r = this.z - t.z;
                return e * e + n * n + r * r
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const r = Math.sin(e) * t;
                return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    r = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = r, this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            setFromEuler(t) {
                return this.x = t._x, this.y = t._y, this.z = t._z, this
            }
            setFromColor(t) {
                return this.x = t.r, this.y = t.g, this.z = t.b, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const t = Math.random() * Math.PI * 2,
                    e = 2 * Math.random() - 1,
                    n = Math.sqrt(1 - e * e);
                return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        const ta = new Zo,
            ea = new Jo;
        class na {
            constructor(t = new Zo(1 / 0, 1 / 0, 1 / 0), e = new Zo(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromArray(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(ia.fromArray(t, e));
                return this
            }
            setFromBufferAttribute(t) {
                this.makeEmpty();
                for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(ia.fromBufferAttribute(t, e));
                return this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = ia.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            setFromObject(t, e = !1) {
                return this.makeEmpty(), this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            expandByObject(t, e = !1) {
                t.updateWorldMatrix(!1, !1);
                const n = t.geometry;
                if (void 0 !== n) {
                    const r = n.getAttribute("position");
                    if (!0 === e && void 0 !== r && !0 !== t.isInstancedMesh)
                        for (let e = 0, n = r.count; e < n; e++) !0 === t.isMesh ? t.getVertexPosition(e, ia) : ia.fromBufferAttribute(r, e), ia.applyMatrix4(t.matrixWorld), this.expandByPoint(ia);
                    else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), oa.copy(t.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), oa.copy(n.boundingBox)), oa.applyMatrix4(t.matrixWorld), this.union(oa)
                }
                const r = t.children;
                for (let t = 0, n = r.length; t < n; t++) this.expandByObject(r[t], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, ia), ia.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(da), pa.subVectors(this.max, da), aa.subVectors(t.a, da), sa.subVectors(t.b, da), la.subVectors(t.c, da), ca.subVectors(sa, aa), ua.subVectors(la, sa), ha.subVectors(aa, la);
                let e = [0, -ca.z, ca.y, 0, -ua.z, ua.y, 0, -ha.z, ha.y, ca.z, 0, -ca.x, ua.z, 0, -ua.x, ha.z, 0, -ha.x, -ca.y, ca.x, 0, -ua.y, ua.x, 0, -ha.y, ha.x, 0];
                return !!ga(e, aa, sa, la, pa) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!ga(e, aa, sa, la, pa) && (fa.crossVectors(ca, ua), e = [fa.x, fa.y, fa.z], ga(e, aa, sa, la, pa)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return this.clampPoint(t, ia).distanceTo(t)
            }
            getBoundingSphere(t) {
                return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(ia).length()), t
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (ra[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), ra[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), ra[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), ra[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), ra[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), ra[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), ra[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), ra[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(ra)), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        const ra = [new Zo, new Zo, new Zo, new Zo, new Zo, new Zo, new Zo, new Zo],
            ia = new Zo,
            oa = new na,
            aa = new Zo,
            sa = new Zo,
            la = new Zo,
            ca = new Zo,
            ua = new Zo,
            ha = new Zo,
            da = new Zo,
            pa = new Zo,
            fa = new Zo,
            ma = new Zo;

        function ga(t, e, n, r, i) {
            for (let o = 0, a = t.length - 3; o <= a; o += 3) {
                ma.fromArray(t, o);
                const a = i.x * Math.abs(ma.x) + i.y * Math.abs(ma.y) + i.z * Math.abs(ma.z),
                    s = e.dot(ma),
                    l = n.dot(ma),
                    c = r.dot(ma);
                if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > a) return !1
            }
            return !0
        }
        const Aa = new na,
            va = new Zo,
            _a = new Zo;
        class ya {
            constructor(t = new Zo, e = -1) {
                this.isSphere = !0, this.center = t, this.radius = e
            }
            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : Aa.setFromPoints(t).getCenter(n);
                let r = 0;
                for (let e = 0, i = t.length; e < i; e++) r = Math.max(r, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(r), this
            }
            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }
            translate(t) {
                return this.center.add(t), this
            }
            expandByPoint(t) {
                if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                va.subVectors(t, this.center);
                const e = va.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e),
                        n = .5 * (t - this.radius);
                    this.center.addScaledVector(va, n / t), this.radius += n
                }
                return this
            }
            union(t) {
                return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (_a.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(va.copy(t.center).add(_a)), this.expandByPoint(va.copy(t.center).sub(_a))), this)
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Ea = new Zo,
            xa = new Zo,
            ba = new Zo,
            wa = new Zo,
            Ca = new Zo,
            Sa = new Zo,
            Ia = new Zo;
        class Ma {
            constructor(t = new Zo, e = new Zo(0, 0, -1)) {
                this.origin = t, this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }
            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }
            at(t, e) {
                return e.copy(this.origin).addScaledVector(this.direction, t)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }
            recast(t) {
                return this.origin.copy(this.at(t, Ea)), this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = Ea.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Ea.copy(this.origin).addScaledVector(this.direction, e), Ea.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, r) {
                xa.copy(t).add(e).multiplyScalar(.5), ba.copy(e).sub(t).normalize(), wa.copy(this.origin).sub(xa);
                const i = .5 * t.distanceTo(e),
                    o = -this.direction.dot(ba),
                    a = wa.dot(this.direction),
                    s = -wa.dot(ba),
                    l = wa.lengthSq(),
                    c = Math.abs(1 - o * o);
                let u, h, d, p;
                if (c > 0)
                    if (u = o * s - a, h = o * a - s, p = i * c, u >= 0)
                        if (h >= -p)
                            if (h <= p) {
                                const t = 1 / c;
                                u *= t, h *= t, d = u * (u + o * h + 2 * a) + h * (o * u + h + 2 * s) + l
                            } else h = i, u = Math.max(0, -(o * h + a)), d = -u * u + h * (h + 2 * s) + l;
                else h = -i, u = Math.max(0, -(o * h + a)), d = -u * u + h * (h + 2 * s) + l;
                else h <= -p ? (u = Math.max(0, -(-o * i + a)), h = u > 0 ? -i : Math.min(Math.max(-i, -s), i), d = -u * u + h * (h + 2 * s) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-i, -s), i), d = h * (h + 2 * s) + l) : (u = Math.max(0, -(o * i + a)), h = u > 0 ? i : Math.min(Math.max(-i, -s), i), d = -u * u + h * (h + 2 * s) + l);
                else h = o > 0 ? -i : i, u = Math.max(0, -(o * h + a)), d = -u * u + h * (h + 2 * s) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, u), r && r.copy(xa).addScaledVector(ba, h), d
            }
            intersectSphere(t, e) {
                Ea.subVectors(t.center, this.origin);
                const n = Ea.dot(this.direction),
                    r = Ea.dot(Ea) - n * n,
                    i = t.radius * t.radius;
                if (r > i) return null;
                const o = Math.sqrt(i - r),
                    a = n - o,
                    s = n + o;
                return s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e) return !0;
                return t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, r, i, o, a, s;
                const l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    u = 1 / this.direction.z,
                    h = this.origin;
                return l >= 0 ? (n = (t.min.x - h.x) * l, r = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l, r = (t.min.x - h.x) * l), c >= 0 ? (i = (t.min.y - h.y) * c, o = (t.max.y - h.y) * c) : (i = (t.max.y - h.y) * c, o = (t.min.y - h.y) * c), n > o || i > r ? null : ((i > n || isNaN(n)) && (n = i), (o < r || isNaN(r)) && (r = o), u >= 0 ? (a = (t.min.z - h.z) * u, s = (t.max.z - h.z) * u) : (a = (t.max.z - h.z) * u, s = (t.min.z - h.z) * u), n > s || a > r ? null : ((a > n || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, Ea)
            }
            intersectTriangle(t, e, n, r, i) {
                Ca.subVectors(e, t), Sa.subVectors(n, t), Ia.crossVectors(Ca, Sa);
                let o, a = this.direction.dot(Ia);
                if (a > 0) {
                    if (r) return null;
                    o = 1
                } else {
                    if (!(a < 0)) return null;
                    o = -1, a = -a
                }
                wa.subVectors(this.origin, t);
                const s = o * this.direction.dot(Sa.crossVectors(wa, Sa));
                if (s < 0) return null;
                const l = o * this.direction.dot(Ca.cross(wa));
                if (l < 0) return null;
                if (s + l > a) return null;
                const c = -o * wa.dot(Ia);
                return c < 0 ? null : this.at(c / a, i)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Ta {
            constructor(t, e, n, r, i, o, a, s, l, c, u, h, d, p, f, m) {
                Ta.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, r, i, o, a, s, l, c, u, h, d, p, f, m)
            }
            set(t, e, n, r, i, o, a, s, l, c, u, h, d, p, f, m) {
                const g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new Ta).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }
            copyPosition(t) {
                const e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(t) {
                const e = this.elements,
                    n = t.elements,
                    r = 1 / Ba.setFromMatrixColumn(t, 0).length(),
                    i = 1 / Ba.setFromMatrixColumn(t, 1).length(),
                    o = 1 / Ba.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromEuler(t) {
                const e = this.elements,
                    n = t.x,
                    r = t.y,
                    i = t.z,
                    o = Math.cos(n),
                    a = Math.sin(n),
                    s = Math.cos(r),
                    l = Math.sin(r),
                    c = Math.cos(i),
                    u = Math.sin(i);
                if ("XYZ" === t.order) {
                    const t = o * c,
                        n = o * u,
                        r = a * c,
                        i = a * u;
                    e[0] = s * c, e[4] = -s * u, e[8] = l, e[1] = n + r * l, e[5] = t - i * l, e[9] = -a * s, e[2] = i - t * l, e[6] = r + n * l, e[10] = o * s
                } else if ("YXZ" === t.order) {
                    const t = s * c,
                        n = s * u,
                        r = l * c,
                        i = l * u;
                    e[0] = t + i * a, e[4] = r * a - n, e[8] = o * l, e[1] = o * u, e[5] = o * c, e[9] = -a, e[2] = n * a - r, e[6] = i + t * a, e[10] = o * s
                } else if ("ZXY" === t.order) {
                    const t = s * c,
                        n = s * u,
                        r = l * c,
                        i = l * u;
                    e[0] = t - i * a, e[4] = -o * u, e[8] = r + n * a, e[1] = n + r * a, e[5] = o * c, e[9] = i - t * a, e[2] = -o * l, e[6] = a, e[10] = o * s
                } else if ("ZYX" === t.order) {
                    const t = o * c,
                        n = o * u,
                        r = a * c,
                        i = a * u;
                    e[0] = s * c, e[4] = r * l - n, e[8] = t * l + i, e[1] = s * u, e[5] = i * l + t, e[9] = n * l - r, e[2] = -l, e[6] = a * s, e[10] = o * s
                } else if ("YZX" === t.order) {
                    const t = o * s,
                        n = o * l,
                        r = a * s,
                        i = a * l;
                    e[0] = s * c, e[4] = i - t * u, e[8] = r * u + n, e[1] = u, e[5] = o * c, e[9] = -a * c, e[2] = -l * c, e[6] = n * u + r, e[10] = t - i * u
                } else if ("XZY" === t.order) {
                    const t = o * s,
                        n = o * l,
                        r = a * s,
                        i = a * l;
                    e[0] = s * c, e[4] = -u, e[8] = l * c, e[1] = t * u + i, e[5] = o * c, e[9] = n * u - r, e[2] = r * u - n, e[6] = a * c, e[10] = i * u + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(La, t, Da)
            }
            lookAt(t, e, n) {
                const r = this.elements;
                return ka.subVectors(t, e), 0 === ka.lengthSq() && (ka.z = 1), ka.normalize(), Pa.crossVectors(n, ka), 0 === Pa.lengthSq() && (1 === Math.abs(n.z) ? ka.x += 1e-4 : ka.z += 1e-4, ka.normalize(), Pa.crossVectors(n, ka)), Pa.normalize(), Oa.crossVectors(ka, Pa), r[0] = Pa.x, r[4] = Oa.x, r[8] = ka.x, r[1] = Pa.y, r[5] = Oa.y, r[9] = ka.y, r[2] = Pa.z, r[6] = Oa.z, r[10] = ka.z, this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    r = e.elements,
                    i = this.elements,
                    o = n[0],
                    a = n[4],
                    s = n[8],
                    l = n[12],
                    c = n[1],
                    u = n[5],
                    h = n[9],
                    d = n[13],
                    p = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    A = n[3],
                    v = n[7],
                    _ = n[11],
                    y = n[15],
                    E = r[0],
                    x = r[4],
                    b = r[8],
                    w = r[12],
                    C = r[1],
                    S = r[5],
                    I = r[9],
                    M = r[13],
                    T = r[2],
                    B = r[6],
                    R = r[10],
                    L = r[14],
                    D = r[3],
                    P = r[7],
                    O = r[11],
                    k = r[15];
                return i[0] = o * E + a * C + s * T + l * D, i[4] = o * x + a * S + s * B + l * P, i[8] = o * b + a * I + s * R + l * O, i[12] = o * w + a * M + s * L + l * k, i[1] = c * E + u * C + h * T + d * D, i[5] = c * x + u * S + h * B + d * P, i[9] = c * b + u * I + h * R + d * O, i[13] = c * w + u * M + h * L + d * k, i[2] = p * E + f * C + m * T + g * D, i[6] = p * x + f * S + m * B + g * P, i[10] = p * b + f * I + m * R + g * O, i[14] = p * w + f * M + m * L + g * k, i[3] = A * E + v * C + _ * T + y * D, i[7] = A * x + v * S + _ * B + y * P, i[11] = A * b + v * I + _ * R + y * O, i[15] = A * w + v * M + _ * L + y * k, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[4],
                    r = t[8],
                    i = t[12],
                    o = t[1],
                    a = t[5],
                    s = t[9],
                    l = t[13],
                    c = t[2],
                    u = t[6],
                    h = t[10],
                    d = t[14];
                return t[3] * (+i * s * u - r * l * u - i * a * h + n * l * h + r * a * d - n * s * d) + t[7] * (+e * s * d - e * l * h + i * o * h - r * o * d + r * l * c - i * s * c) + t[11] * (+e * l * u - e * a * d - i * o * u + n * o * d + i * a * c - n * l * c) + t[15] * (-r * a * c - e * s * u + e * a * h + r * o * u - n * o * h + n * s * c)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }
            setPosition(t, e, n) {
                const r = this.elements;
                return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    i = t[3],
                    o = t[4],
                    a = t[5],
                    s = t[6],
                    l = t[7],
                    c = t[8],
                    u = t[9],
                    h = t[10],
                    d = t[11],
                    p = t[12],
                    f = t[13],
                    m = t[14],
                    g = t[15],
                    A = u * m * l - f * h * l + f * s * d - a * m * d - u * s * g + a * h * g,
                    v = p * h * l - c * m * l - p * s * d + o * m * d + c * s * g - o * h * g,
                    _ = c * f * l - p * u * l + p * a * d - o * f * d - c * a * g + o * u * g,
                    y = p * u * s - c * f * s - p * a * h + o * f * h + c * a * m - o * u * m,
                    E = e * A + n * v + r * _ + i * y;
                if (0 === E) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const x = 1 / E;
                return t[0] = A * x, t[1] = (f * h * i - u * m * i - f * r * d + n * m * d + u * r * g - n * h * g) * x, t[2] = (a * m * i - f * s * i + f * r * l - n * m * l - a * r * g + n * s * g) * x, t[3] = (u * s * i - a * h * i - u * r * l + n * h * l + a * r * d - n * s * d) * x, t[4] = v * x, t[5] = (c * m * i - p * h * i + p * r * d - e * m * d - c * r * g + e * h * g) * x, t[6] = (p * s * i - o * m * i - p * r * l + e * m * l + o * r * g - e * s * g) * x, t[7] = (o * h * i - c * s * i + c * r * l - e * h * l - o * r * d + e * s * d) * x, t[8] = _ * x, t[9] = (p * u * i - c * f * i - p * n * d + e * f * d + c * n * g - e * u * g) * x, t[10] = (o * f * i - p * a * i + p * n * l - e * f * l - o * n * g + e * a * g) * x, t[11] = (c * a * i - o * u * i - c * n * l + e * u * l + o * n * d - e * a * d) * x, t[12] = y * x, t[13] = (c * f * r - p * u * r + p * n * h - e * f * h - c * n * m + e * u * m) * x, t[14] = (p * a * r - o * f * r - p * n * s + e * f * s + o * n * m - e * a * m) * x, t[15] = (o * u * r - c * a * r + c * n * s - e * u * s - o * n * h + e * a * h) * x, this
            }
            scale(t) {
                const e = this.elements,
                    n = t.x,
                    r = t.y,
                    i = t.z;
                return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
            }
            getMaxScaleOnAxis() {
                const t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, r))
            }
            makeTranslation(t, e, n) {
                return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            }
            makeRotationY(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e),
                    r = Math.sin(e),
                    i = 1 - n,
                    o = t.x,
                    a = t.y,
                    s = t.z,
                    l = i * o,
                    c = i * a;
                return this.set(l * o + n, l * a - r * s, l * s + r * a, 0, l * a + r * s, c * a + n, c * s - r * o, 0, l * s - r * a, c * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(t, e, n, r, i, o) {
                return this.set(1, n, i, 0, t, 1, o, 0, e, r, 1, 0, 0, 0, 0, 1), this
            }
            compose(t, e, n) {
                const r = this.elements,
                    i = e._x,
                    o = e._y,
                    a = e._z,
                    s = e._w,
                    l = i + i,
                    c = o + o,
                    u = a + a,
                    h = i * l,
                    d = i * c,
                    p = i * u,
                    f = o * c,
                    m = o * u,
                    g = a * u,
                    A = s * l,
                    v = s * c,
                    _ = s * u,
                    y = n.x,
                    E = n.y,
                    x = n.z;
                return r[0] = (1 - (f + g)) * y, r[1] = (d + _) * y, r[2] = (p - v) * y, r[3] = 0, r[4] = (d - _) * E, r[5] = (1 - (h + g)) * E, r[6] = (m + A) * E, r[7] = 0, r[8] = (p + v) * x, r[9] = (m - A) * x, r[10] = (1 - (h + f)) * x, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
            }
            decompose(t, e, n) {
                const r = this.elements;
                let i = Ba.set(r[0], r[1], r[2]).length();
                const o = Ba.set(r[4], r[5], r[6]).length(),
                    a = Ba.set(r[8], r[9], r[10]).length();
                this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], Ra.copy(this);
                const s = 1 / i,
                    l = 1 / o,
                    c = 1 / a;
                return Ra.elements[0] *= s, Ra.elements[1] *= s, Ra.elements[2] *= s, Ra.elements[4] *= l, Ra.elements[5] *= l, Ra.elements[6] *= l, Ra.elements[8] *= c, Ra.elements[9] *= c, Ra.elements[10] *= c, e.setFromRotationMatrix(Ra), n.x = i, n.y = o, n.z = a, this
            }
            makePerspective(t, e, n, r, i, o, a = 2e3) {
                const s = this.elements,
                    l = 2 * i / (e - t),
                    c = 2 * i / (n - r),
                    u = (e + t) / (e - t),
                    h = (n + r) / (n - r);
                let d, p;
                if (a === lo) d = -(o + i) / (o - i), p = -2 * o * i / (o - i);
                else {
                    if (a !== co) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                    d = -o / (o - i), p = -o * i / (o - i)
                }
                return s[0] = l, s[4] = 0, s[8] = u, s[12] = 0, s[1] = 0, s[5] = c, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = d, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            }
            makeOrthographic(t, e, n, r, i, o, a = 2e3) {
                const s = this.elements,
                    l = 1 / (e - t),
                    c = 1 / (n - r),
                    u = 1 / (o - i),
                    h = (e + t) * l,
                    d = (n + r) * c;
                let p, f;
                if (a === lo) p = (o + i) * u, f = -2 * u;
                else {
                    if (a !== co) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                    p = i * u, f = -1 * u
                }
                return s[0] = 2 * l, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -d, s[2] = 0, s[6] = 0, s[10] = f, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }
        const Ba = new Zo,
            Ra = new Ta,
            La = new Zo(0, 0, 0),
            Da = new Zo(1, 1, 1),
            Pa = new Zo,
            Oa = new Zo,
            ka = new Zo,
            Ua = new Ta,
            Na = new Jo;
        class Fa {
            constructor(t = 0, e = 0, n = 0, r = Fa.DEFAULT_ORDER) {
                this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = r
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t, this._onChangeCallback()
            }
            set(t, e, n, r = this._order) {
                return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(t, e = this._order, n = !0) {
                const r = t.elements,
                    i = r[0],
                    o = r[4],
                    a = r[8],
                    s = r[1],
                    l = r[5],
                    c = r[9],
                    u = r[2],
                    h = r[6],
                    d = r[10];
                switch (e) {
                    case "XYZ":
                        this._y = Math.asin(Ao(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(h, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-Ao(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, i), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(Ao(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(s, i));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-Ao(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-o, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(Ao(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(a, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-Ao(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-c, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(t, e, n) {
                return Ua.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ua, e, n)
            }
            setFromVector3(t, e = this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return Na.setFromEuler(this), this.setFromQuaternion(Na, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
        }
        Fa.DEFAULT_ORDER = "XYZ";
        class Qa {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = (1 << t | 0) >>> 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
            isEnabled(t) {
                return 0 != (this.mask & (1 << t | 0))
            }
        }
        let $a = 0;
        const Ga = new Zo,
            Ha = new Jo,
            za = new Ta,
            Va = new Zo,
            Wa = new Zo,
            ja = new Zo,
            Xa = new Jo,
            qa = new Zo(1, 0, 0),
            Ya = new Zo(0, 1, 0),
            Ka = new Zo(0, 0, 1),
            Ja = {
                type: "added"
            },
            Za = {
                type: "removed"
            },
            ts = {
                type: "childadded",
                child: null
            },
            es = {
                type: "childremoved",
                child: null
            };
        class ns extends uo {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                    value: $a++
                }), this.uuid = go(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ns.DEFAULT_UP.clone();
                const t = new Zo,
                    e = new Fa,
                    n = new Jo,
                    r = new Zo(1, 1, 1);
                e._onChange((function () {
                    n.setFromEuler(e, !1)
                })), n._onChange((function () {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new Ta
                    },
                    normalMatrix: {
                        value: new So
                    }
                }), this.matrix = new Ta, this.matrixWorld = new Ta, this.matrixAutoUpdate = ns.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = ns.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Qa, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t), this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return Ha.setFromAxisAngle(t, e), this.quaternion.multiply(Ha), this
            }
            rotateOnWorldAxis(t, e) {
                return Ha.setFromAxisAngle(t, e), this.quaternion.premultiply(Ha), this
            }
            rotateX(t) {
                return this.rotateOnAxis(qa, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(Ya, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(Ka, t)
            }
            translateOnAxis(t, e) {
                return Ga.copy(t).applyQuaternion(this.quaternion), this.position.add(Ga.multiplyScalar(e)), this
            }
            translateX(t) {
                return this.translateOnAxis(qa, t)
            }
            translateY(t) {
                return this.translateOnAxis(Ya, t)
            }
            translateZ(t) {
                return this.translateOnAxis(Ka, t)
            }
            localToWorld(t) {
                return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return this.updateWorldMatrix(!0, !1), t.applyMatrix4(za.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? Va.copy(t) : Va.set(t, e, n);
                const r = this.parent;
                this.updateWorldMatrix(!0, !1), Wa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? za.lookAt(Wa, Va, this.up) : za.lookAt(Va, Wa, this.up), this.quaternion.setFromRotationMatrix(za), r && (za.extractRotation(r.matrixWorld), Ha.setFromRotationMatrix(za), this.quaternion.premultiply(Ha.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Ja), ts.child = t, this.dispatchEvent(ts), ts.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Za), es.child = t, this.dispatchEvent(es), es.child = null), this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this), this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1), za.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), za.multiply(t.parent.matrixWorld)), t.applyMatrix4(za), this.add(t), t.updateWorldMatrix(!1, !0), this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e) return this;
                for (let n = 0, r = this.children.length; n < r; n++) {
                    const r = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            }
            getObjectsByProperty(t, e, n = []) {
                this[t] === e && n.push(this);
                const r = this.children;
                for (let i = 0, o = r.length; i < o; i++) r[i].getObjectsByProperty(t, e, n);
                return n
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wa, t, ja), t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wa, Xa, t), t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n];
                    !0 !== r.matrixWorldAutoUpdate && !0 !== t || r.updateMatrixWorld(t)
                }
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t,
                    n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const r = {};

                function i(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((t => ({
                        boxInitialized: t.boxInitialized,
                        boxMin: t.box.min.toArray(),
                        boxMax: t.box.max.toArray(),
                        sphereInitialized: t.sphereInitialized,
                        sphereRadius: t.sphere.radius,
                        sphereCenter: t.sphere.center.toArray()
                    }))), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(t), null !== this.boundingSphere && (r.boundingSphere = {
                        center: r.boundingSphere.center.toArray(),
                        radius: r.boundingSphere.radius
                    }), null !== this.boundingBox && (r.boundingBox = {
                        min: r.boundingBox.min.toArray(),
                        max: r.boundingBox.max.toArray()
                    })), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    r.geometry = i(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                i(t.shapes, r)
                            } else i(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, r = this.material.length; n < r; n++) e.push(i(t.materials, this.material[n]));
                        r.material = e
                    } else r.material = i(t.materials, this.material);
                if (this.children.length > 0) {
                    r.children = [];
                    for (let e = 0; e < this.children.length; e++) r.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    r.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        r.animations.push(i(t.animations, n))
                    }
                }
                if (e) {
                    const e = o(t.geometries),
                        r = o(t.materials),
                        i = o(t.textures),
                        a = o(t.images),
                        s = o(t.shapes),
                        l = o(t.skeletons),
                        c = o(t.animations),
                        u = o(t.nodes);
                    e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a), s.length > 0 && (n.shapes = s), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u)
                }
                return n.object = r, n;

                function o(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        delete r.metadata, e.push(r)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e = !0) {
                if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        ns.DEFAULT_UP = new Zo(0, 1, 0), ns.DEFAULT_MATRIX_AUTO_UPDATE = !0, ns.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const rs = new Zo,
            is = new Zo,
            os = new Zo,
            as = new Zo,
            ss = new Zo,
            ls = new Zo,
            cs = new Zo,
            us = new Zo,
            hs = new Zo,
            ds = new Zo;
        class ps {
            constructor(t = new Zo, e = new Zo, n = new Zo) {
                this.a = t, this.b = e, this.c = n
            }
            static getNormal(t, e, n, r) {
                r.subVectors(n, e), rs.subVectors(t, e), r.cross(rs);
                const i = r.lengthSq();
                return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, r, i) {
                rs.subVectors(r, e), is.subVectors(n, e), os.subVectors(t, e);
                const o = rs.dot(rs),
                    a = rs.dot(is),
                    s = rs.dot(os),
                    l = is.dot(is),
                    c = is.dot(os),
                    u = o * l - a * a;
                if (0 === u) return i.set(0, 0, 0), null;
                const h = 1 / u,
                    d = (l * s - a * c) * h,
                    p = (o * c - a * s) * h;
                return i.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, r) {
                return null !== this.getBarycoord(t, e, n, r, as) && (as.x >= 0 && as.y >= 0 && as.x + as.y <= 1)
            }
            static getInterpolation(t, e, n, r, i, o, a, s) {
                return null === this.getBarycoord(t, e, n, r, as) ? (s.x = 0, s.y = 0, "z" in s && (s.z = 0), "w" in s && (s.w = 0), null) : (s.setScalar(0), s.addScaledVector(i, as.x), s.addScaledVector(o, as.y), s.addScaledVector(a, as.z), s)
            }
            static isFrontFacing(t, e, n, r) {
                return rs.subVectors(n, e), is.subVectors(t, e), rs.cross(is).dot(r) < 0
            }
            set(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }
            setFromPointsAndIndices(t, e, n, r) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
            }
            setFromAttributeAndIndices(t, e, n, r) {
                return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }
            getArea() {
                return rs.subVectors(this.c, this.b), is.subVectors(this.a, this.b), .5 * rs.cross(is).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return ps.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return ps.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getInterpolation(t, e, n, r, i) {
                return ps.getInterpolation(t, this.a, this.b, this.c, e, n, r, i)
            }
            containsPoint(t) {
                return ps.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return ps.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a,
                    r = this.b,
                    i = this.c;
                let o, a;
                ss.subVectors(r, n), ls.subVectors(i, n), us.subVectors(t, n);
                const s = ss.dot(us),
                    l = ls.dot(us);
                if (s <= 0 && l <= 0) return e.copy(n);
                hs.subVectors(t, r);
                const c = ss.dot(hs),
                    u = ls.dot(hs);
                if (c >= 0 && u <= c) return e.copy(r);
                const h = s * u - c * l;
                if (h <= 0 && s >= 0 && c <= 0) return o = s / (s - c), e.copy(n).addScaledVector(ss, o);
                ds.subVectors(t, i);
                const d = ss.dot(ds),
                    p = ls.dot(ds);
                if (p >= 0 && d <= p) return e.copy(i);
                const f = d * l - s * p;
                if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(ls, a);
                const m = c * p - d * u;
                if (m <= 0 && u - c >= 0 && d - p >= 0) return cs.subVectors(i, r), a = (u - c) / (u - c + (d - p)), e.copy(r).addScaledVector(cs, a);
                const g = 1 / (m + f + h);
                return o = f * g, a = h * g, e.copy(n).addScaledVector(ss, o).addScaledVector(ls, a)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        const fs = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            ms = {
                h: 0,
                s: 0,
                l: 0
            },
            gs = {
                h: 0,
                s: 0,
                l: 0
            };

        function As(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        class vs {
            constructor(t, e, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
            }
            set(t, e, n) {
                if (void 0 === e && void 0 === n) {
                    const e = t;
                    e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                } else this.setRGB(t, e, n);
                return this
            }
            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }
            setHex(t, e = Yi) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, Uo.toWorkingColorSpace(this, e), this
            }
            setRGB(t, e, n, r = Uo.workingColorSpace) {
                return this.r = t, this.g = e, this.b = n, Uo.toWorkingColorSpace(this, r), this
            }
            setHSL(t, e, n, r = Uo.workingColorSpace) {
                if (t = vo(t, 1), e = Ao(e, 0, 1), n = Ao(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                else {
                    const r = n <= .5 ? n * (1 + e) : n + e - n * e,
                        i = 2 * n - r;
                    this.r = As(i, r, t + 1 / 3), this.g = As(i, r, t), this.b = As(i, r, t - 1 / 3)
                }
                return Uo.toWorkingColorSpace(this, r), this
            }
            setStyle(t, e = Yi) {
                function n(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let r;
                if (r = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                    let i;
                    const o = r[1],
                        a = r[2];
                    switch (o) {
                        case "rgb":
                        case "rgba":
                            if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(i[4]), this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, e);
                            if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(i[4]), this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, e);
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(i[4]), this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, e);
                            break;
                        default:
                            console.warn("THREE.Color: Unknown color model " + t)
                    }
                } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const n = r[1],
                        i = n.length;
                    if (3 === i) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, e);
                    if (6 === i) return this.setHex(parseInt(n, 16), e);
                    console.warn("THREE.Color: Invalid hex color " + t)
                } else if (t && t.length > 0) return this.setColorName(t, e);
                return this
            }
            setColorName(t, e = Yi) {
                const n = fs[t.toLowerCase()];
                return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }
            copySRGBToLinear(t) {
                return this.r = No(t.r), this.g = No(t.g), this.b = No(t.b), this
            }
            copyLinearToSRGB(t) {
                return this.r = Fo(t.r), this.g = Fo(t.g), this.b = Fo(t.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex(t = Yi) {
                return Uo.fromWorkingColorSpace(_s.copy(this), t), 65536 * Math.round(Ao(255 * _s.r, 0, 255)) + 256 * Math.round(Ao(255 * _s.g, 0, 255)) + Math.round(Ao(255 * _s.b, 0, 255))
            }
            getHexString(t = Yi) {
                return ("000000" + this.getHex(t).toString(16)).slice(-6)
            }
            getHSL(t, e = Uo.workingColorSpace) {
                Uo.fromWorkingColorSpace(_s.copy(this), e);
                const n = _s.r,
                    r = _s.g,
                    i = _s.b,
                    o = Math.max(n, r, i),
                    a = Math.min(n, r, i);
                let s, l;
                const c = (a + o) / 2;
                if (a === o) s = 0, l = 0;
                else {
                    const t = o - a;
                    switch (l = c <= .5 ? t / (o + a) : t / (2 - o - a), o) {
                        case n:
                            s = (r - i) / t + (r < i ? 6 : 0);
                            break;
                        case r:
                            s = (i - n) / t + 2;
                            break;
                        case i:
                            s = (n - r) / t + 4
                    }
                    s /= 6
                }
                return t.h = s, t.s = l, t.l = c, t
            }
            getRGB(t, e = Uo.workingColorSpace) {
                return Uo.fromWorkingColorSpace(_s.copy(this), e), t.r = _s.r, t.g = _s.g, t.b = _s.b, t
            }
            getStyle(t = Yi) {
                Uo.fromWorkingColorSpace(_s.copy(this), t);
                const e = _s.r,
                    n = _s.g,
                    r = _s.b;
                return t !== Yi ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*r)})`
            }
            offsetHSL(t, e, n) {
                return this.getHSL(ms), this.setHSL(ms.h + t, ms.s + e, ms.l + n)
            }
            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }
            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }
            addScalar(t) {
                return this.r += t, this.g += t, this.b += t, this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }
            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }
            multiplyScalar(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
            }
            lerpHSL(t, e) {
                this.getHSL(ms), t.getHSL(gs);
                const n = _o(ms.h, gs.h, e),
                    r = _o(ms.s, gs.s, e),
                    i = _o(ms.l, gs.l, e);
                return this.setHSL(n, r, i), this
            }
            setFromVector3(t) {
                return this.r = t.x, this.g = t.y, this.b = t.z, this
            }
            applyMatrix3(t) {
                const e = this.r,
                    n = this.g,
                    r = this.b,
                    i = t.elements;
                return this.r = i[0] * e + i[3] * n + i[6] * r, this.g = i[1] * e + i[4] * n + i[7] * r, this.b = i[2] * e + i[5] * n + i[8] * r, this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
            }
            toJSON() {
                return this.getHex()
            }*[Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }
        const _s = new vs;
        vs.NAMES = fs;
        let ys = 0;
        class Es extends uo {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                    value: ys++
                }), this.uuid = go(), this.name = "", this.type = "Material", this.blending = 1, this.side = qr, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Kr, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new vs(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = io, this.stencilZFail = io, this.stencilZPass = io, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                            continue
                        }
                        const r = this[e];
                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function r(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        delete r.metadata, e.push(r)
                    }
                    return e
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== qr && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), 204 !== this.blendSrc && (n.blendSrc = this.blendSrc), 205 !== this.blendDst && (n.blendDst = this.blendDst), this.blendEquation !== Kr && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== io && (n.stencilFail = this.stencilFail), this.stencilZFail !== io && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== io && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
                    const e = r(t.textures),
                        i = r(t.images);
                    e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let r = 0; r !== t; ++r) n[r] = e[r].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        class xs extends Es {
            constructor(t) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new vs(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Fa, this.combine = Jr, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
            }
        }
        const bs = ws();

        function ws() {
            const t = new ArrayBuffer(4),
                e = new Float32Array(t),
                n = new Uint32Array(t),
                r = new Uint32Array(512),
                i = new Uint32Array(512);
            for (let t = 0; t < 256; ++t) {
                const e = t - 127;
                e < -27 ? (r[t] = 0, r[256 | t] = 32768, i[t] = 24, i[256 | t] = 24) : e < -14 ? (r[t] = 1024 >> -e - 14, r[256 | t] = 1024 >> -e - 14 | 32768, i[t] = -e - 1, i[256 | t] = -e - 1) : e <= 15 ? (r[t] = e + 15 << 10, r[256 | t] = e + 15 << 10 | 32768, i[t] = 13, i[256 | t] = 13) : e < 128 ? (r[t] = 31744, r[256 | t] = 64512, i[t] = 24, i[256 | t] = 24) : (r[t] = 31744, r[256 | t] = 64512, i[t] = 13, i[256 | t] = 13)
            }
            const o = new Uint32Array(2048),
                a = new Uint32Array(64),
                s = new Uint32Array(64);
            for (let t = 1; t < 1024; ++t) {
                let e = t << 13,
                    n = 0;
                for (; 0 == (8388608 & e);) e <<= 1, n -= 8388608;
                e &= -8388609, n += 947912704, o[t] = e | n
            }
            for (let t = 1024; t < 2048; ++t) o[t] = 939524096 + (t - 1024 << 13);
            for (let t = 1; t < 31; ++t) a[t] = t << 23;
            a[31] = 1199570944, a[32] = 2147483648;
            for (let t = 33; t < 63; ++t) a[t] = 2147483648 + (t - 32 << 23);
            a[63] = 3347054592;
            for (let t = 1; t < 64; ++t) 32 !== t && (s[t] = 1024);
            return {
                floatView: e,
                uint32View: n,
                baseTable: r,
                shiftTable: i,
                mantissaTable: o,
                exponentTable: a,
                offsetTable: s
            }
        }
        const Cs = {
                toHalfFloat: function (t) {
                    Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = Ao(t, -65504, 65504), bs.floatView[0] = t;
                    const e = bs.uint32View[0],
                        n = e >> 23 & 511;
                    return bs.baseTable[n] + ((8388607 & e) >> bs.shiftTable[n])
                },
                fromHalfFloat: function (t) {
                    const e = t >> 10;
                    return bs.uint32View[0] = bs.mantissaTable[bs.offsetTable[e] + (1023 & t)] + bs.exponentTable[e], bs.floatView[0]
                }
            },
            Ss = new Zo,
            Is = new Co;
        class Ms {
            constructor(t, e, n = !1) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = oo, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.gpuType = Si, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            get updateRange() {
                return Lo("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
            }
            setUsage(t) {
                return this.usage = t, this
            }
            addUpdateRange(t, e) {
                this.updateRanges.push({
                    start: t,
                    count: e
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
            }
            copyAt(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
                return this
            }
            copyArray(t) {
                return this.array.set(t), this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) Is.fromBufferAttribute(this, e), Is.applyMatrix3(t), this.setXY(e, Is.x, Is.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) Ss.fromBufferAttribute(this, e), Ss.applyMatrix3(t), this.setXYZ(e, Ss.x, Ss.y, Ss.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++) Ss.fromBufferAttribute(this, e), Ss.applyMatrix4(t), this.setXYZ(e, Ss.x, Ss.y, Ss.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) Ss.fromBufferAttribute(this, e), Ss.applyNormalMatrix(t), this.setXYZ(e, Ss.x, Ss.y, Ss.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) Ss.fromBufferAttribute(this, e), Ss.transformDirection(t), this.setXYZ(e, Ss.x, Ss.y, Ss.z);
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            getComponent(t, e) {
                let n = this.array[t * this.itemSize + e];
                return this.normalized && (n = xo(n, this.array)), n
            }
            setComponent(t, e, n) {
                return this.normalized && (n = bo(n, this.array)), this.array[t * this.itemSize + e] = n, this
            }
            getX(t) {
                let e = this.array[t * this.itemSize];
                return this.normalized && (e = xo(e, this.array)), e
            }
            setX(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.array[t * this.itemSize] = e, this
            }
            getY(t) {
                let e = this.array[t * this.itemSize + 1];
                return this.normalized && (e = xo(e, this.array)), e
            }
            setY(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.array[t * this.itemSize + 1] = e, this
            }
            getZ(t) {
                let e = this.array[t * this.itemSize + 2];
                return this.normalized && (e = xo(e, this.array)), e
            }
            setZ(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.array[t * this.itemSize + 2] = e, this
            }
            getW(t) {
                let e = this.array[t * this.itemSize + 3];
                return this.normalized && (e = xo(e, this.array)), e
            }
            setW(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.array[t * this.itemSize + 3] = e, this
            }
            setXY(t, e, n) {
                return t *= this.itemSize, this.normalized && (e = bo(e, this.array), n = bo(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
            }
            setXYZ(t, e, n, r) {
                return t *= this.itemSize, this.normalized && (e = bo(e, this.array), n = bo(n, this.array), r = bo(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
            }
            setXYZW(t, e, n, r, i) {
                return t *= this.itemSize, this.normalized && (e = bo(e, this.array), n = bo(n, this.array), r = bo(r, this.array), i = bo(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name), this.usage !== oo && (t.usage = this.usage), t
            }
        }
        class Ts extends Ms {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class Bs extends Ms {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        class Rs extends Ms {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let Ls = 0;
        const Ds = new Ta,
            Ps = new ns,
            Os = new Zo,
            ks = new na,
            Us = new na,
            Ns = new Zo;
        class Fs extends uo {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                    value: Ls++
                }), this.uuid = go(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new(Mo(t) ? Bs : Ts)(t, 1) : this.index = t, this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e, this
            }
            deleteAttribute(t) {
                return delete this.attributes[t], this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n = 0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new So).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(t) {
                return Ds.makeRotationFromQuaternion(t), this.applyMatrix4(Ds), this
            }
            rotateX(t) {
                return Ds.makeRotationX(t), this.applyMatrix4(Ds), this
            }
            rotateY(t) {
                return Ds.makeRotationY(t), this.applyMatrix4(Ds), this
            }
            rotateZ(t) {
                return Ds.makeRotationZ(t), this.applyMatrix4(Ds), this
            }
            translate(t, e, n) {
                return Ds.makeTranslation(t, e, n), this.applyMatrix4(Ds), this
            }
            scale(t, e, n) {
                return Ds.makeScale(t, e, n), this.applyMatrix4(Ds), this
            }
            lookAt(t) {
                return Ps.lookAt(t), Ps.updateMatrix(), this.applyMatrix4(Ps.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Os).negate(), this.translate(Os.x, Os.y, Os.z), this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new Rs(e, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new na);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new Zo(-1 / 0, -1 / 0, -1 / 0), new Zo(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            ks.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ns.addVectors(this.boundingBox.min, ks.min), this.boundingBox.expandByPoint(Ns), Ns.addVectors(this.boundingBox.max, ks.max), this.boundingBox.expandByPoint(Ns)) : (this.boundingBox.expandByPoint(ks.min), this.boundingBox.expandByPoint(ks.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new ya);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new Zo, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (ks.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Us.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ns.addVectors(ks.min, Us.min), ks.expandByPoint(Ns), Ns.addVectors(ks.max, Us.max), ks.expandByPoint(Ns)) : (ks.expandByPoint(Us.min), ks.expandByPoint(Us.max))
                        }
                    ks.getCenter(n);
                    let r = 0;
                    for (let e = 0, i = t.count; e < i; e++) Ns.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(Ns));
                    if (e)
                        for (let i = 0, o = e.length; i < o; i++) {
                            const o = e[i],
                                a = this.morphTargetsRelative;
                            for (let e = 0, i = o.count; e < i; e++) Ns.fromBufferAttribute(o, e), a && (Os.fromBufferAttribute(t, e), Ns.add(Os)), r = Math.max(r, n.distanceToSquared(Ns))
                        }
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index,
                    e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = e.position,
                    r = e.normal,
                    i = e.uv;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ms(new Float32Array(4 * n.count), 4));
                const o = this.getAttribute("tangent"),
                    a = [],
                    s = [];
                for (let t = 0; t < n.count; t++) a[t] = new Zo, s[t] = new Zo;
                const l = new Zo,
                    c = new Zo,
                    u = new Zo,
                    h = new Co,
                    d = new Co,
                    p = new Co,
                    f = new Zo,
                    m = new Zo;

                function g(t, e, r) {
                    l.fromBufferAttribute(n, t), c.fromBufferAttribute(n, e), u.fromBufferAttribute(n, r), h.fromBufferAttribute(i, t), d.fromBufferAttribute(i, e), p.fromBufferAttribute(i, r), c.sub(l), u.sub(l), d.sub(h), p.sub(h);
                    const o = 1 / (d.x * p.y - p.x * d.y);
                    isFinite(o) && (f.copy(c).multiplyScalar(p.y).addScaledVector(u, -d.y).multiplyScalar(o), m.copy(u).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(o), a[t].add(f), a[e].add(f), a[r].add(f), s[t].add(m), s[e].add(m), s[r].add(m))
                }
                let A = this.groups;
                0 === A.length && (A = [{
                    start: 0,
                    count: t.count
                }]);
                for (let e = 0, n = A.length; e < n; ++e) {
                    const n = A[e],
                        r = n.start;
                    for (let e = r, i = r + n.count; e < i; e += 3) g(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2))
                }
                const v = new Zo,
                    _ = new Zo,
                    y = new Zo,
                    E = new Zo;

                function x(t) {
                    y.fromBufferAttribute(r, t), E.copy(y);
                    const e = a[t];
                    v.copy(e), v.sub(y.multiplyScalar(y.dot(e))).normalize(), _.crossVectors(E, e);
                    const n = _.dot(s[t]) < 0 ? -1 : 1;
                    o.setXYZW(t, v.x, v.y, v.z, n)
                }
                for (let e = 0, n = A.length; e < n; ++e) {
                    const n = A[e],
                        r = n.start;
                    for (let e = r, i = r + n.count; e < i; e += 3) x(t.getX(e + 0)), x(t.getX(e + 1)), x(t.getX(e + 2))
                }
            }
            computeVertexNormals() {
                const t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Ms(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                    const r = new Zo,
                        i = new Zo,
                        o = new Zo,
                        a = new Zo,
                        s = new Zo,
                        l = new Zo,
                        c = new Zo,
                        u = new Zo;
                    if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                            const d = t.getX(h + 0),
                                p = t.getX(h + 1),
                                f = t.getX(h + 2);
                            r.fromBufferAttribute(e, d), i.fromBufferAttribute(e, p), o.fromBufferAttribute(e, f), c.subVectors(o, i), u.subVectors(r, i), c.cross(u), a.fromBufferAttribute(n, d), s.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), s.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(f, l.x, l.y, l.z)
                        } else
                            for (let t = 0, a = e.count; t < a; t += 3) r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), c.subVectors(o, i), u.subVectors(r, i), c.cross(u), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++) Ns.fromBufferAttribute(t, e), Ns.normalize(), t.setXYZ(e, Ns.x, Ns.y, Ns.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array,
                        r = t.itemSize,
                        i = t.normalized,
                        o = new n.constructor(e.length * r);
                    let a = 0,
                        s = 0;
                    for (let i = 0, l = e.length; i < l; i++) {
                        a = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r;
                        for (let t = 0; t < r; t++) o[s++] = n[a++]
                    }
                    return new Ms(o, r, i)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new Fs,
                    n = this.index.array,
                    r = this.attributes;
                for (const i in r) {
                    const o = t(r[i], n);
                    e.setAttribute(i, o)
                }
                const i = this.morphAttributes;
                for (const r in i) {
                    const o = [],
                        a = i[r];
                    for (let e = 0, r = a.length; e < r; e++) {
                        const r = t(a[e], n);
                        o.push(r)
                    }
                    e.morphAttributes[r] = o
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const o = this.groups;
                for (let t = 0, n = o.length; t < n; t++) {
                    const n = o[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const r = n[e];
                    t.data.attributes[e] = r.toJSON(t.data)
                }
                const r = {};
                let i = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e],
                        o = [];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        o.push(r.toJSON(t.data))
                    }
                    o.length > 0 && (r[e] = o, i = !0)
                }
                i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
                const a = this.boundingSphere;
                return null !== a && (t.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }), t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const r = t.attributes;
                for (const t in r) {
                    const n = r[t];
                    this.setAttribute(t, n.clone(e))
                }
                const i = t.morphAttributes;
                for (const t in i) {
                    const n = [],
                        r = i[t];
                    for (let t = 0, i = r.length; t < i; t++) n.push(r[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const o = t.groups;
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = o[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const a = t.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const s = t.boundingSphere;
                return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Qs = new Ta,
            $s = new Ma,
            Gs = new ya,
            Hs = new Zo,
            zs = new Zo,
            Vs = new Zo,
            Ws = new Zo,
            js = new Zo,
            Xs = new Zo,
            qs = new Co,
            Ys = new Co,
            Ks = new Co,
            Js = new Zo,
            Zs = new Zo,
            tl = new Zo,
            el = new Zo,
            nl = new Zo;
        class rl extends ns {
            constructor(t = new Fs, e = new xs) {
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
            getVertexPosition(t, e) {
                const n = this.geometry,
                    r = n.attributes.position,
                    i = n.morphAttributes.position,
                    o = n.morphTargetsRelative;
                e.fromBufferAttribute(r, t);
                const a = this.morphTargetInfluences;
                if (i && a) {
                    Xs.set(0, 0, 0);
                    for (let n = 0, r = i.length; n < r; n++) {
                        const r = a[n],
                            s = i[n];
                        0 !== r && (js.fromBufferAttribute(s, t), o ? Xs.addScaledVector(js, r) : Xs.addScaledVector(js.sub(e), r))
                    }
                    e.add(Xs)
                }
                return e
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.material,
                    i = this.matrixWorld;
                if (void 0 !== r) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Gs.copy(n.boundingSphere), Gs.applyMatrix4(i), $s.copy(t.ray).recast(t.near), !1 === Gs.containsPoint($s.origin)) {
                        if (null === $s.intersectSphere(Gs, Hs)) return;
                        if ($s.origin.distanceToSquared(Hs) > (t.far - t.near) ** 2) return
                    }
                    Qs.copy(i).invert(), $s.copy(t.ray).applyMatrix4(Qs), null !== n.boundingBox && !1 === $s.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, $s)
                }
            }
            _computeIntersections(t, e, n) {
                let r;
                const i = this.geometry,
                    o = this.material,
                    a = i.index,
                    s = i.attributes.position,
                    l = i.attributes.uv,
                    c = i.attributes.uv1,
                    u = i.attributes.normal,
                    h = i.groups,
                    d = i.drawRange;
                if (null !== a)
                    if (Array.isArray(o))
                        for (let i = 0, s = h.length; i < s; i++) {
                            const s = h[i],
                                p = o[s.materialIndex];
                            for (let i = Math.max(s.start, d.start), o = Math.min(a.count, Math.min(s.start + s.count, d.start + d.count)); i < o; i += 3) {
                                r = il(this, p, t, n, l, c, u, a.getX(i), a.getX(i + 1), a.getX(i + 2)), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = s.materialIndex, e.push(r))
                            }
                        } else {
                            for (let i = Math.max(0, d.start), s = Math.min(a.count, d.start + d.count); i < s; i += 3) {
                                r = il(this, o, t, n, l, c, u, a.getX(i), a.getX(i + 1), a.getX(i + 2)), r && (r.faceIndex = Math.floor(i / 3), e.push(r))
                            }
                        } else if (void 0 !== s)
                            if (Array.isArray(o))
                                for (let i = 0, a = h.length; i < a; i++) {
                                    const a = h[i],
                                        p = o[a.materialIndex];
                                    for (let i = Math.max(a.start, d.start), o = Math.min(s.count, Math.min(a.start + a.count, d.start + d.count)); i < o; i += 3) {
                                        r = il(this, p, t, n, l, c, u, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = a.materialIndex, e.push(r))
                                    }
                                } else {
                                    for (let i = Math.max(0, d.start), a = Math.min(s.count, d.start + d.count); i < a; i += 3) {
                                        r = il(this, o, t, n, l, c, u, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), e.push(r))
                                    }
                                }
            }
        }

        function il(t, e, n, r, i, o, a, s, l, c) {
            t.getVertexPosition(s, zs), t.getVertexPosition(l, Vs), t.getVertexPosition(c, Ws);
            const u = function (t, e, n, r, i, o, a, s) {
                let l;
                if (l = e.side === Yr ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, e.side === qr, s), null === l) return null;
                nl.copy(s), nl.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(nl);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: nl.clone(),
                    object: t
                }
            }(t, e, n, r, zs, Vs, Ws, el);
            if (u) {
                i && (qs.fromBufferAttribute(i, s), Ys.fromBufferAttribute(i, l), Ks.fromBufferAttribute(i, c), u.uv = ps.getInterpolation(el, zs, Vs, Ws, qs, Ys, Ks, new Co)), o && (qs.fromBufferAttribute(o, s), Ys.fromBufferAttribute(o, l), Ks.fromBufferAttribute(o, c), u.uv1 = ps.getInterpolation(el, zs, Vs, Ws, qs, Ys, Ks, new Co)), a && (Js.fromBufferAttribute(a, s), Zs.fromBufferAttribute(a, l), tl.fromBufferAttribute(a, c), u.normal = ps.getInterpolation(el, zs, Vs, Ws, Js, Zs, tl, new Zo), u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
                const t = {
                    a: s,
                    b: l,
                    c: c,
                    normal: new Zo,
                    materialIndex: 0
                };
                ps.getNormal(zs, Vs, Ws, t.normal), u.face = t
            }
            return u
        }
        class ol extends Fs {
            constructor(t = 1, e = 1, n = 1, r = 1, i = 1, o = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                };
                const a = this;
                r = Math.floor(r), i = Math.floor(i), o = Math.floor(o);
                const s = [],
                    l = [],
                    c = [],
                    u = [];
                let h = 0,
                    d = 0;

                function p(t, e, n, r, i, o, p, f, m, g, A) {
                    const v = o / m,
                        _ = p / g,
                        y = o / 2,
                        E = p / 2,
                        x = f / 2,
                        b = m + 1,
                        w = g + 1;
                    let C = 0,
                        S = 0;
                    const I = new Zo;
                    for (let o = 0; o < w; o++) {
                        const a = o * _ - E;
                        for (let s = 0; s < b; s++) {
                            const h = s * v - y;
                            I[t] = h * r, I[e] = a * i, I[n] = x, l.push(I.x, I.y, I.z), I[t] = 0, I[e] = 0, I[n] = f > 0 ? 1 : -1, c.push(I.x, I.y, I.z), u.push(s / m), u.push(1 - o / g), C += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = h + e + b * t,
                                r = h + e + b * (t + 1),
                                i = h + (e + 1) + b * (t + 1),
                                o = h + (e + 1) + b * t;
                            s.push(n, r, o), s.push(r, i, o), S += 6
                        }
                    a.addGroup(d, S, A), d += S, h += C
                }
                p("z", "y", "x", -1, -1, n, e, t, o, i, 0), p("z", "y", "x", 1, -1, n, e, -t, o, i, 1), p("x", "z", "y", 1, 1, t, n, e, r, o, 2), p("x", "z", "y", 1, -1, t, n, -e, r, o, 3), p("x", "y", "z", 1, -1, t, e, n, r, i, 4), p("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(s), this.setAttribute("position", new Rs(l, 3)), this.setAttribute("normal", new Rs(c, 3)), this.setAttribute("uv", new Rs(u, 2))
            }
            copy(t) {
                return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
            }
            static fromJSON(t) {
                return new ol(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
            }
        }

        function al(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const r in t[n]) {
                    const i = t[n][r];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][r] = null) : e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                }
            }
            return e
        }

        function sl(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const r = al(t[n]);
                for (const t in r) e[t] = r[t]
            }
            return e
        }

        function ll(t) {
            return null === t.getRenderTarget() ? t.outputColorSpace : Uo.workingColorSpace
        }
        const cl = {
            clone: al,
            merge: sl
        };
        class ul extends Es {
            constructor(t) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1,
                    clipCullDistance: !1,
                    multiDraw: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = al(t.uniforms), this.uniformsGroups = function (t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                    return e
                }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const n in this.uniforms) {
                    const r = this.uniforms[n].value;
                    r && r.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r && r.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[n] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                const n = {};
                for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }
        }
        class hl extends ns {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ta, this.projectionMatrix = new Ta, this.projectionMatrixInverse = new Ta, this.coordinateSystem = lo
            }
            copy(t, e) {
                return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
            }
            getWorldDirection(t) {
                return super.getWorldDirection(t).negate()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const dl = new Zo,
            pl = new Co,
            fl = new Co;
        class ml extends hl {
            constructor(t = 50, e = 1, n = .1, r = 2e3) {
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * mo * Math.atan(e), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * fo * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * mo * Math.atan(Math.tan(.5 * fo * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            getViewBounds(t, e, n) {
                dl.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set(dl.x, dl.y).multiplyScalar(-t / dl.z), dl.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(dl.x, dl.y).multiplyScalar(-t / dl.z)
            }
            getViewSize(t, e) {
                return this.getViewBounds(t, pl, fl), e.subVectors(fl, pl)
            }
            setViewOffset(t, e, n, r, i, o) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * fo * this.fov) / this.zoom,
                    n = 2 * e,
                    r = this.aspect * n,
                    i = -.5 * r;
                const o = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = o.fullWidth,
                        a = o.fullHeight;
                    i += o.offsetX * r / t, e -= o.offsetY * n / a, r *= o.width / t, n *= o.height / a
                }
                const a = this.filmOffset;
                0 !== a && (i += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }
        const gl = -90;
        class Al extends ns {
            constructor(t, e, n) {
                super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                const r = new ml(gl, 1, t, e);
                r.layers = this.layers, this.add(r);
                const i = new ml(gl, 1, t, e);
                i.layers = this.layers, this.add(i);
                const o = new ml(gl, 1, t, e);
                o.layers = this.layers, this.add(o);
                const a = new ml(gl, 1, t, e);
                a.layers = this.layers, this.add(a);
                const s = new ml(gl, 1, t, e);
                s.layers = this.layers, this.add(s);
                const l = new ml(gl, 1, t, e);
                l.layers = this.layers, this.add(l)
            }
            updateCoordinateSystem() {
                const t = this.coordinateSystem,
                    e = this.children.concat(),
                    [n, r, i, o, a, s] = e;
                for (const t of e) this.remove(t);
                if (t === lo) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), i.up.set(0, 0, -1), i.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), s.up.set(0, 1, 0), s.lookAt(0, 0, -1);
                else {
                    if (t !== co) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                    n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), i.up.set(0, 0, 1), i.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), s.up.set(0, -1, 0), s.lookAt(0, 0, -1)
                }
                for (const t of e) this.add(t), t.updateMatrixWorld()
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const {
                    renderTarget: n,
                    activeMipmapLevel: r
                } = this;
                this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
                const [i, o, a, s, l, c] = this.children, u = t.getRenderTarget(), h = t.getActiveCubeFace(), d = t.getActiveMipmapLevel(), p = t.xr.enabled;
                t.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, r), t.render(e, i), t.setRenderTarget(n, 1, r), t.render(e, o), t.setRenderTarget(n, 2, r), t.render(e, a), t.setRenderTarget(n, 3, r), t.render(e, s), t.setRenderTarget(n, 4, r), t.render(e, l), n.texture.generateMipmaps = f, t.setRenderTarget(n, 5, r), t.render(e, c), t.setRenderTarget(u, h, d), t.xr.enabled = p, n.texture.needsPMREMUpdate = !0
            }
        }
        class vl extends Wo {
            constructor(t, e, n, r, i, o, a, s, l, c) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : ui, n, r, i, o, a, s, l, c), this.isCubeTexture = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        class _l extends qo {
            constructor(t = 1, e = {}) {
                super(t, t, e), this.isWebGLCubeRenderTarget = !0;
                const n = {
                        width: t,
                        height: t,
                        depth: 1
                    },
                    r = [n, n, n, n, n, n];
                this.texture = new vl(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : _i
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                    },
                    r = new ol(5, 5, 5),
                    i = new ul({
                        name: "CubemapFromEquirect",
                        uniforms: al(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: Yr,
                        blending: 0
                    });
                i.uniforms.tEquirect.value = e;
                const o = new rl(r, i),
                    a = e.minFilter;
                e.minFilter === Ei && (e.minFilter = _i);
                return new Al(1, 10, this).update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
            }
            clear(t, e, n, r) {
                const i = t.getRenderTarget();
                for (let i = 0; i < 6; i++) t.setRenderTarget(this, i), t.clear(e, n, r);
                t.setRenderTarget(i)
            }
        }
        const yl = new Zo,
            El = new Zo,
            xl = new So;
        class bl {
            constructor(t = new Zo(1, 0, 0), e = 0) {
                this.isPlane = !0, this.normal = t, this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }
            setComponents(t, e, n, r) {
                return this.normal.set(t, e, n), this.constant = r, this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }
            setFromCoplanarPoints(t, e, n) {
                const r = yl.subVectors(n, e).cross(El.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(r, t), this
            }
            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
            }
            intersectLine(t, e) {
                const n = t.delta(yl),
                    r = this.normal.dot(n);
                if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const i = -(t.start.dot(this.normal) + this.constant) / r;
                return i < 0 || i > 1 ? null : e.copy(t.start).addScaledVector(n, i)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || xl.getNormalMatrix(t),
                    r = this.coplanarPoint(yl).applyMatrix4(t),
                    i = this.normal.applyMatrix3(n).normalize();
                return this.constant = -r.dot(i), this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const wl = new ya,
            Cl = new Zo;
        class Sl {
            constructor(t = new bl, e = new bl, n = new bl, r = new bl, i = new bl, o = new bl) {
                this.planes = [t, e, n, r, i, o]
            }
            set(t, e, n, r, i, o) {
                const a = this.planes;
                return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t, e = 2e3) {
                const n = this.planes,
                    r = t.elements,
                    i = r[0],
                    o = r[1],
                    a = r[2],
                    s = r[3],
                    l = r[4],
                    c = r[5],
                    u = r[6],
                    h = r[7],
                    d = r[8],
                    p = r[9],
                    f = r[10],
                    m = r[11],
                    g = r[12],
                    A = r[13],
                    v = r[14],
                    _ = r[15];
                if (n[0].setComponents(s - i, h - l, m - d, _ - g).normalize(), n[1].setComponents(s + i, h + l, m + d, _ + g).normalize(), n[2].setComponents(s + o, h + c, m + p, _ + A).normalize(), n[3].setComponents(s - o, h - c, m - p, _ - A).normalize(), n[4].setComponents(s - a, h - u, m - f, _ - v).normalize(), e === lo) n[5].setComponents(s + a, h + u, m + f, _ + v).normalize();
                else {
                    if (e !== co) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                    n[5].setComponents(a, u, f, v).normalize()
                }
                return this
            }
            intersectsObject(t) {
                if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), wl.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                else {
                    const e = t.geometry;
                    null === e.boundingSphere && e.computeBoundingSphere(), wl.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                }
                return this.intersectsSphere(wl)
            }
            intersectsSprite(t) {
                return wl.center.set(0, 0, 0), wl.radius = .7071067811865476, wl.applyMatrix4(t.matrixWorld), this.intersectsSphere(wl)
            }
            intersectsSphere(t) {
                const e = this.planes,
                    n = t.center,
                    r = -t.radius;
                for (let t = 0; t < 6; t++) {
                    if (e[t].distanceToPoint(n) < r) return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const r = e[n];
                    if (Cl.x = r.normal.x > 0 ? t.max.x : t.min.x, Cl.y = r.normal.y > 0 ? t.max.y : t.min.y, Cl.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Cl) < 0) return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function Il() {
            let t = null,
                e = !1,
                n = null,
                r = null;

            function i(e, o) {
                n(e, o), r = t.requestAnimationFrame(i)
            }
            return {
                start: function () {
                    !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0)
                },
                stop: function () {
                    t.cancelAnimationFrame(r), e = !1
                },
                setAnimationLoop: function (t) {
                    n = t
                },
                setContext: function (e) {
                    t = e
                }
            }
        }

        function Ml(t, e) {
            const n = e.isWebGL2,
                r = new WeakMap;
            return {
                get: function (t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
                },
                remove: function (e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = r.get(e);
                    n && (t.deleteBuffer(n.buffer), r.delete(e))
                },
                update: function (e, i) {
                    if (e.isGLBufferAttribute) {
                        const t = r.get(e);
                        return void((!t || t.version < e.version) && r.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const o = r.get(e);
                    if (void 0 === o) r.set(e, function (e, r) {
                        const i = e.array,
                            o = e.usage,
                            a = i.byteLength,
                            s = t.createBuffer();
                        let l;
                        if (t.bindBuffer(r, s), t.bufferData(r, i, o), e.onUploadCallback(), i instanceof Float32Array) l = t.FLOAT;
                        else if (i instanceof Uint16Array)
                            if (e.isFloat16BufferAttribute) {
                                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                l = t.HALF_FLOAT
                            } else l = t.UNSIGNED_SHORT;
                        else if (i instanceof Int16Array) l = t.SHORT;
                        else if (i instanceof Uint32Array) l = t.UNSIGNED_INT;
                        else if (i instanceof Int32Array) l = t.INT;
                        else if (i instanceof Int8Array) l = t.BYTE;
                        else if (i instanceof Uint8Array) l = t.UNSIGNED_BYTE;
                        else {
                            if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                            l = t.UNSIGNED_BYTE
                        }
                        return {
                            buffer: s,
                            type: l,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: e.version,
                            size: a
                        }
                    }(e, i));
                    else if (o.version < e.version) {
                        if (o.size !== e.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        ! function (e, r, i) {
                            const o = r.array,
                                a = r._updateRange,
                                s = r.updateRanges;
                            if (t.bindBuffer(i, e), -1 === a.count && 0 === s.length && t.bufferSubData(i, 0, o), 0 !== s.length) {
                                for (let e = 0, r = s.length; e < r; e++) {
                                    const r = s[e];
                                    n ? t.bufferSubData(i, r.start * o.BYTES_PER_ELEMENT, o, r.start, r.count) : t.bufferSubData(i, r.start * o.BYTES_PER_ELEMENT, o.subarray(r.start, r.start + r.count))
                                }
                                r.clearUpdateRanges()
                            } - 1 !== a.count && (n ? t.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count) : t.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)), a.count = -1), r.onUploadCallback()
                        }(o.buffer, e, i), o.version = e.version
                    }
                }
            }
        }
        class Tl extends Fs {
            constructor(t = 1, e = 1, n = 1, r = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r
                };
                const i = t / 2,
                    o = e / 2,
                    a = Math.floor(n),
                    s = Math.floor(r),
                    l = a + 1,
                    c = s + 1,
                    u = t / a,
                    h = e / s,
                    d = [],
                    p = [],
                    f = [],
                    m = [];
                for (let t = 0; t < c; t++) {
                    const e = t * h - o;
                    for (let n = 0; n < l; n++) {
                        const r = n * u - i;
                        p.push(r, -e, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - t / s)
                    }
                }
                for (let t = 0; t < s; t++)
                    for (let e = 0; e < a; e++) {
                        const n = e + l * t,
                            r = e + l * (t + 1),
                            i = e + 1 + l * (t + 1),
                            o = e + 1 + l * t;
                        d.push(n, r, o), d.push(r, i, o)
                    }
                this.setIndex(d), this.setAttribute("position", new Rs(p, 3)), this.setAttribute("normal", new Rs(f, 3)), this.setAttribute("uv", new Rs(m, 2))
            }
            copy(t) {
                return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
            }
            static fromJSON(t) {
                return new Tl(t.width, t.height, t.widthSegments, t.heightSegments)
            }
        }
        const Bl = {
                alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tfloat startCompression = 0.8 - 0.04;\n\tfloat desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min(color.r, min(color.g, color.b));\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max(color.r, max(color.g, color.b));\n\tif (peak < startCompression) return color;\n\tfloat d = 1. - startCompression;\n\tfloat newPeak = 1. - d * d / (peak + d - startCompression);\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n\treturn mix(color, vec3(1, 1, 1), g);\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
            },
            Rl = {
                common: {
                    diffuse: {
                        value: new vs(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new So
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new So
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    },
                    specularMapTransform: {
                        value: new So
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    envMapRotation: {
                        value: new So
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    },
                    aoMapTransform: {
                        value: new So
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    },
                    lightMapTransform: {
                        value: new So
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpMapTransform: {
                        value: new So
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalMapTransform: {
                        value: new So
                    },
                    normalScale: {
                        value: new Co(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementMapTransform: {
                        value: new So
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    },
                    emissiveMapTransform: {
                        value: new So
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    },
                    metalnessMapTransform: {
                        value: new So
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    },
                    roughnessMapTransform: {
                        value: new So
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new vs(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new vs(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new So
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new So
                    }
                },
                sprite: {
                    diffuse: {
                        value: new vs(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Co(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new So
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new So
                    },
                    alphaTest: {
                        value: 0
                    }
                }
            },
            Ll = {
                basic: {
                    uniforms: sl([Rl.common, Rl.specularmap, Rl.envmap, Rl.aomap, Rl.lightmap, Rl.fog]),
                    vertexShader: Bl.meshbasic_vert,
                    fragmentShader: Bl.meshbasic_frag
                },
                lambert: {
                    uniforms: sl([Rl.common, Rl.specularmap, Rl.envmap, Rl.aomap, Rl.lightmap, Rl.emissivemap, Rl.bumpmap, Rl.normalmap, Rl.displacementmap, Rl.fog, Rl.lights, {
                        emissive: {
                            value: new vs(0)
                        }
                    }]),
                    vertexShader: Bl.meshlambert_vert,
                    fragmentShader: Bl.meshlambert_frag
                },
                phong: {
                    uniforms: sl([Rl.common, Rl.specularmap, Rl.envmap, Rl.aomap, Rl.lightmap, Rl.emissivemap, Rl.bumpmap, Rl.normalmap, Rl.displacementmap, Rl.fog, Rl.lights, {
                        emissive: {
                            value: new vs(0)
                        },
                        specular: {
                            value: new vs(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Bl.meshphong_vert,
                    fragmentShader: Bl.meshphong_frag
                },
                standard: {
                    uniforms: sl([Rl.common, Rl.envmap, Rl.aomap, Rl.lightmap, Rl.emissivemap, Rl.bumpmap, Rl.normalmap, Rl.displacementmap, Rl.roughnessmap, Rl.metalnessmap, Rl.fog, Rl.lights, {
                        emissive: {
                            value: new vs(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Bl.meshphysical_vert,
                    fragmentShader: Bl.meshphysical_frag
                },
                toon: {
                    uniforms: sl([Rl.common, Rl.aomap, Rl.lightmap, Rl.emissivemap, Rl.bumpmap, Rl.normalmap, Rl.displacementmap, Rl.gradientmap, Rl.fog, Rl.lights, {
                        emissive: {
                            value: new vs(0)
                        }
                    }]),
                    vertexShader: Bl.meshtoon_vert,
                    fragmentShader: Bl.meshtoon_frag
                },
                matcap: {
                    uniforms: sl([Rl.common, Rl.bumpmap, Rl.normalmap, Rl.displacementmap, Rl.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: Bl.meshmatcap_vert,
                    fragmentShader: Bl.meshmatcap_frag
                },
                points: {
                    uniforms: sl([Rl.points, Rl.fog]),
                    vertexShader: Bl.points_vert,
                    fragmentShader: Bl.points_frag
                },
                dashed: {
                    uniforms: sl([Rl.common, Rl.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Bl.linedashed_vert,
                    fragmentShader: Bl.linedashed_frag
                },
                depth: {
                    uniforms: sl([Rl.common, Rl.displacementmap]),
                    vertexShader: Bl.depth_vert,
                    fragmentShader: Bl.depth_frag
                },
                normal: {
                    uniforms: sl([Rl.common, Rl.bumpmap, Rl.normalmap, Rl.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Bl.meshnormal_vert,
                    fragmentShader: Bl.meshnormal_frag
                },
                sprite: {
                    uniforms: sl([Rl.sprite, Rl.fog]),
                    vertexShader: Bl.sprite_vert,
                    fragmentShader: Bl.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new So
                        },
                        t2D: {
                            value: null
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: Bl.background_vert,
                    fragmentShader: Bl.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        },
                        backgroundIntensity: {
                            value: 1
                        },
                        backgroundRotation: {
                            value: new So
                        }
                    },
                    vertexShader: Bl.backgroundCube_vert,
                    fragmentShader: Bl.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: Bl.cube_vert,
                    fragmentShader: Bl.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: Bl.equirect_vert,
                    fragmentShader: Bl.equirect_frag
                },
                distanceRGBA: {
                    uniforms: sl([Rl.common, Rl.displacementmap, {
                        referencePosition: {
                            value: new Zo
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: Bl.distanceRGBA_vert,
                    fragmentShader: Bl.distanceRGBA_frag
                },
                shadow: {
                    uniforms: sl([Rl.lights, Rl.fog, {
                        color: {
                            value: new vs(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Bl.shadow_vert,
                    fragmentShader: Bl.shadow_frag
                }
            };
        Ll.physical = {
            uniforms: sl([Ll.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new So
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new So
                },
                clearcoatNormalScale: {
                    value: new Co(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new So
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new So
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new So
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new vs(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new So
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new So
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new So
                },
                transmissionSamplerSize: {
                    value: new Co
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new So
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new vs(0)
                },
                specularColor: {
                    value: new vs(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new So
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new So
                },
                anisotropyVector: {
                    value: new Co
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new So
                }
            }]),
            vertexShader: Bl.meshphysical_vert,
            fragmentShader: Bl.meshphysical_frag
        };
        const Dl = {
                r: 0,
                b: 0,
                g: 0
            },
            Pl = new Fa,
            Ol = new Ta;

        function kl(t, e, n, r, i, o, a) {
            const s = new vs(0);
            let l, c, u = !0 === o ? 0 : 1,
                h = null,
                d = 0,
                p = null;

            function f(e, n) {
                e.getRGB(Dl, ll(t)), r.buffers.color.setClear(Dl.r, Dl.g, Dl.b, n, a)
            }
            return {
                getClearColor: function () {
                    return s
                },
                setClearColor: function (t, e = 1) {
                    s.set(t), u = e, f(s, u)
                },
                getClearAlpha: function () {
                    return u
                },
                setClearAlpha: function (t) {
                    u = t, f(s, u)
                },
                render: function (o, m) {
                    let g = !1,
                        A = !0 === m.isScene ? m.background : null;
                    if (A && A.isTexture) {
                        A = (m.backgroundBlurriness > 0 ? n : e).get(A)
                    }
                    null === A ? f(s, u) : A && A.isColor && (f(A, 1), g = !0);
                    const v = t.xr.getEnvironmentBlendMode();
                    "additive" === v ? r.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === v && r.buffers.color.setClear(0, 0, 0, 0, a), (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), A && (A.isCubeTexture || A.mapping === di) ? (void 0 === c && (c = new rl(new ol(1, 1, 1), new ul({
                        name: "BackgroundCubeMaterial",
                        uniforms: al(Ll.backgroundCube.uniforms),
                        vertexShader: Ll.backgroundCube.vertexShader,
                        fragmentShader: Ll.backgroundCube.fragmentShader,
                        side: Yr,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(c.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), i.update(c)), Pl.copy(m.backgroundRotation), Pl.x *= -1, Pl.y *= -1, Pl.z *= -1, A.isCubeTexture && !1 === A.isRenderTargetTexture && (Pl.y *= -1, Pl.z *= -1), c.material.uniforms.envMap.value = A, c.material.uniforms.flipEnvMap.value = A.isCubeTexture && !1 === A.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(Ol.makeRotationFromEuler(Pl)), c.material.toneMapped = Uo.getTransfer(A.colorSpace) !== eo, h === A && d === A.version && p === t.toneMapping || (c.material.needsUpdate = !0, h = A, d = A.version, p = t.toneMapping), c.layers.enableAll(), o.unshift(c, c.geometry, c.material, 0, 0, null)) : A && A.isTexture && (void 0 === l && (l = new rl(new Tl(2, 2), new ul({
                        name: "BackgroundMaterial",
                        uniforms: al(Ll.background.uniforms),
                        vertexShader: Ll.background.vertexShader,
                        fragmentShader: Ll.background.fragmentShader,
                        side: qr,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), i.update(l)), l.material.uniforms.t2D.value = A, l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, l.material.toneMapped = Uo.getTransfer(A.colorSpace) !== eo, !0 === A.matrixAutoUpdate && A.updateMatrix(), l.material.uniforms.uvTransform.value.copy(A.matrix), h === A && d === A.version && p === t.toneMapping || (l.material.needsUpdate = !0, h = A, d = A.version, p = t.toneMapping), l.layers.enableAll(), o.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }

        function Ul(t, e, n, r) {
            const i = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                a = r.isWebGL2 || null !== o,
                s = {},
                l = p(null);
            let c = l,
                u = !1;

            function h(e) {
                return r.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
            }

            function d(e) {
                return r.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
            }

            function p(t) {
                const e = [],
                    n = [],
                    r = [];
                for (let t = 0; t < i; t++) e[t] = 0, n[t] = 0, r[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: r,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function f() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++) t[e] = 0
            }

            function m(t) {
                g(t, 0)
            }

            function g(n, i) {
                const o = c.newAttributes,
                    a = c.enabledAttributes,
                    s = c.attributeDivisors;
                if (o[n] = 1, 0 === a[n] && (t.enableVertexAttribArray(n), a[n] = 1), s[n] !== i) {
                    (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i
                }
            }

            function A() {
                const e = c.newAttributes,
                    n = c.enabledAttributes;
                for (let r = 0, i = n.length; r < i; r++) n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0)
            }

            function v(e, n, r, i, o, a, s) {
                !0 === s ? t.vertexAttribIPointer(e, n, r, o, a) : t.vertexAttribPointer(e, n, r, i, o, a)
            }

            function _() {
                y(), u = !0, c !== l && (c = l, h(c.object))
            }

            function y() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: function (i, l, d, _, y) {
                    let E = !1;
                    if (a) {
                        const e = function (e, n, i) {
                            const a = !0 === i.wireframe;
                            let l = s[e.id];
                            void 0 === l && (l = {}, s[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {}, l[n.id] = c);
                            let u = c[a];
                            void 0 === u && (u = p(r.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), c[a] = u);
                            return u
                        }(_, d, l);
                        c !== e && (c = e, h(c.object)), E = function (t, e, n, r) {
                            const i = c.attributes,
                                o = e.attributes;
                            let a = 0;
                            const s = n.getAttributes();
                            for (const e in s) {
                                if (s[e].location >= 0) {
                                    const n = i[e];
                                    let r = o[e];
                                    if (void 0 === r && ("instanceMatrix" === e && t.instanceMatrix && (r = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (r = t.instanceColor)), void 0 === n) return !0;
                                    if (n.attribute !== r) return !0;
                                    if (r && n.data !== r.data) return !0;
                                    a++
                                }
                            }
                            return c.attributesNum !== a || c.index !== r
                        }(i, _, d, y), E && function (t, e, n, r) {
                            const i = {},
                                o = e.attributes;
                            let a = 0;
                            const s = n.getAttributes();
                            for (const e in s) {
                                if (s[e].location >= 0) {
                                    let n = o[e];
                                    void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                                    const r = {};
                                    r.attribute = n, n && n.data && (r.data = n.data), i[e] = r, a++
                                }
                            }
                            c.attributes = i, c.attributesNum = a, c.index = r
                        }(i, _, d, y)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === _.id && c.program === d.id && c.wireframe === t || (c.geometry = _.id, c.program = d.id, c.wireframe = t, E = !0)
                    }
                    null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER), (E || u) && (u = !1, function (i, o, a, s) {
                        if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        f();
                        const l = s.attributes,
                            c = a.getAttributes(),
                            u = o.defaultAttributeValues;
                        for (const e in c) {
                            const o = c[e];
                            if (o.location >= 0) {
                                let a = l[e];
                                if (void 0 === a && ("instanceMatrix" === e && i.instanceMatrix && (a = i.instanceMatrix), "instanceColor" === e && i.instanceColor && (a = i.instanceColor)), void 0 !== a) {
                                    const e = a.normalized,
                                        l = a.itemSize,
                                        c = n.get(a);
                                    if (void 0 === c) continue;
                                    const u = c.buffer,
                                        h = c.type,
                                        d = c.bytesPerElement,
                                        p = !0 === r.isWebGL2 && (h === t.INT || h === t.UNSIGNED_INT || a.gpuType === wi);
                                    if (a.isInterleavedBufferAttribute) {
                                        const n = a.data,
                                            r = n.stride,
                                            c = a.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < o.locationSize; t++) g(o.location + t, n.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < o.locationSize; t++) m(o.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, u);
                                        for (let t = 0; t < o.locationSize; t++) v(o.location + t, l / o.locationSize, h, e, r * d, (c + l / o.locationSize * t) * d, p)
                                    } else {
                                        if (a.isInstancedBufferAttribute) {
                                            for (let t = 0; t < o.locationSize; t++) g(o.location + t, a.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)
                                        } else
                                            for (let t = 0; t < o.locationSize; t++) m(o.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, u);
                                        for (let t = 0; t < o.locationSize; t++) v(o.location + t, l / o.locationSize, h, e, l * d, l / o.locationSize * t * d, p)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(o.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(o.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(o.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(o.location, n)
                                    }
                                }
                            }
                        }
                        A()
                    }(i, l, d, _), null !== y && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(y).buffer))
                },
                reset: _,
                resetDefaultState: y,
                dispose: function () {
                    _();
                    for (const t in s) {
                        const e = s[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) d(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete s[t]
                    }
                },
                releaseStatesOfGeometry: function (t) {
                    if (void 0 === s[t.id]) return;
                    const e = s[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) d(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete s[t.id]
                },
                releaseStatesOfProgram: function (t) {
                    for (const e in s) {
                        const n = s[e];
                        if (void 0 === n[t.id]) continue;
                        const r = n[t.id];
                        for (const t in r) d(r[t].object), delete r[t];
                        delete n[t.id]
                    }
                },
                initAttributes: f,
                enableAttribute: m,
                disableUnusedAttributes: A
            }
        }

        function Nl(t, e, n, r) {
            const i = r.isWebGL2;
            let o;
            this.setMode = function (t) {
                o = t
            }, this.render = function (e, r) {
                t.drawArrays(o, e, r), n.update(r, o, 1)
            }, this.renderInstances = function (r, a, s) {
                if (0 === s) return;
                let l, c;
                if (i) l = t, c = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](o, r, a, s), n.update(a, o, s)
            }, this.renderMultiDraw = function (t, r, i) {
                if (0 === i) return;
                const a = e.get("WEBGL_multi_draw");
                if (null === a)
                    for (let e = 0; e < i; e++) this.render(t[e], r[e]);
                else {
                    a.multiDrawArraysWEBGL(o, t, 0, r, 0, i);
                    let e = 0;
                    for (let t = 0; t < i; t++) e += r[t];
                    n.update(e, o, 1)
                }
            }
        }

        function Fl(t, e, n) {
            let r;

            function i(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const o = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === t.constructor.name;
            let a = void 0 !== n.precision ? n.precision : "highp";
            const s = i(a);
            s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
            const l = o || e.has("WEBGL_draw_buffers"),
                c = !0 === n.logarithmicDepthBuffer,
                u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                d = t.getParameter(t.MAX_TEXTURE_SIZE),
                p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                g = t.getParameter(t.MAX_VARYING_VECTORS),
                A = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                v = h > 0,
                _ = o || e.has("OES_texture_float");
            return {
                isWebGL2: o,
                drawBuffers: l,
                getMaxAnisotropy: function () {
                    if (void 0 !== r) return r;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else r = 0;
                    return r
                },
                getMaxPrecision: i,
                precision: a,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: A,
                vertexTextures: v,
                floatFragmentTextures: _,
                floatVertexTextures: v && _,
                maxSamples: o ? t.getParameter(t.MAX_SAMPLES) : 0
            }
        }

        function Ql(t) {
            const e = this;
            let n = null,
                r = 0,
                i = !1,
                o = !1;
            const a = new bl,
                s = new So,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function c(t, n, r, i) {
                const o = null !== t ? t.length : 0;
                let c = null;
                if (0 !== o) {
                    if (c = l.value, !0 !== i || null === c) {
                        const e = r + 4 * o,
                            i = n.matrixWorldInverse;
                        s.getNormalMatrix(i), (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = r; e !== o; ++e, n += 4) a.copy(t[e]).applyMatrix4(i, s), a.normal.toArray(c, n), c[n + 3] = a.constant
                    }
                    l.value = c, l.needsUpdate = !0
                }
                return e.numPlanes = o, e.numIntersection = 0, c
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e) {
                const n = 0 !== t.length || e || 0 !== r || i;
                return i = e, r = t.length, n
            }, this.beginShadows = function () {
                o = !0, c(null)
            }, this.endShadows = function () {
                o = !1
            }, this.setGlobalState = function (t, e) {
                n = c(t, e, 0)
            }, this.setState = function (a, s, u) {
                const h = a.clippingPlanes,
                    d = a.clipIntersection,
                    p = a.clipShadows,
                    f = t.get(a);
                if (!i || null === h || 0 === h.length || o && !p) o ? c(null) : function () {
                    l.value !== n && (l.value = n, l.needsUpdate = r > 0);
                    e.numPlanes = r, e.numIntersection = 0
                }();
                else {
                    const t = o ? 0 : r,
                        e = 4 * t;
                    let i = f.clippingState || null;
                    l.value = i, i = c(h, s, e, u);
                    for (let t = 0; t !== e; ++t) i[t] = n[t];
                    f.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function $l(t) {
            let e = new WeakMap;

            function n(t, e) {
                return 303 === e ? t.mapping = ui : 304 === e && (t.mapping = hi), t
            }

            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const i = e.get(n);
                void 0 !== i && (e.delete(n), i.dispose())
            }
            return {
                get: function (i) {
                    if (i && i.isTexture) {
                        const o = i.mapping;
                        if (303 === o || 304 === o) {
                            if (e.has(i)) {
                                return n(e.get(i).texture, i.mapping)
                            } {
                                const o = i.image;
                                if (o && o.height > 0) {
                                    const a = new _l(o.height);
                                    return a.fromEquirectangularTexture(t, i), e.set(i, a), i.addEventListener("dispose", r), n(a.texture, i.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }
        class Gl extends hl {
            constructor(t = -1, e = 1, n = 1, r = -1, i = .1, o = 2e3) {
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = o, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            }
            setViewOffset(t, e, n, r, i, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2;
                let i = n - t,
                    o = n + t,
                    a = r + e,
                    s = r - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    i += t * this.view.offsetX, o = i + t * this.view.width, a -= e * this.view.offsetY, s = a - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }
        const Hl = [.125, .215, .35, .446, .526, .582],
            zl = 20,
            Vl = new Gl,
            Wl = new vs;
        let jl = null,
            Xl = 0,
            ql = 0;
        const Yl = (1 + Math.sqrt(5)) / 2,
            Kl = 1 / Yl,
            Jl = [new Zo(1, 1, 1), new Zo(-1, 1, 1), new Zo(1, 1, -1), new Zo(-1, 1, -1), new Zo(0, Yl, Kl), new Zo(0, Yl, -Kl), new Zo(Kl, 0, Yl), new Zo(-Kl, 0, Yl), new Zo(Yl, Kl, 0), new Zo(-Yl, Kl, 0)];
        class Zl {
            constructor(t) {
                this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e = 0, n = .1, r = 100) {
                jl = this._renderer.getRenderTarget(), Xl = this._renderer.getActiveCubeFace(), ql = this._renderer.getActiveMipmapLevel(), this._setSize(256);
                const i = this._allocateTargets();
                return i.depthBuffer = !0, this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i
            }
            fromEquirectangular(t, e = null) {
                return this._fromTexture(t, e)
            }
            fromCubemap(t, e = null) {
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = rc(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = nc(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(t) {
                this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget(jl, Xl, ql), t.scissorTest = !1, ec(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                t.mapping === ui || t.mapping === hi ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), jl = this._renderer.getRenderTarget(), Xl = this._renderer.getActiveCubeFace(), ql = this._renderer.getActiveMipmapLevel();
                const n = e || this._allocateTargets();
                return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const t = 3 * Math.max(this._cubeSize, 112),
                    e = 4 * this._cubeSize,
                    n = {
                        magFilter: _i,
                        minFilter: _i,
                        generateMipmaps: !1,
                        type: Ii,
                        format: Ti,
                        colorSpace: Ki,
                        depthBuffer: !1
                    },
                    r = tc(t, e, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = tc(t, e, n);
                    const {
                        _lodMax: r
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function (t) {
                        const e = [],
                            n = [],
                            r = [];
                        let i = t;
                        const o = t - 4 + 1 + Hl.length;
                        for (let a = 0; a < o; a++) {
                            const o = Math.pow(2, i);
                            n.push(o);
                            let s = 1 / o;
                            a > t - 4 ? s = Hl[a - t + 4 - 1] : 0 === a && (s = 0), r.push(s);
                            const l = 1 / (o - 2),
                                c = -l,
                                u = 1 + l,
                                h = [c, c, u, c, u, u, c, c, u, u, c, u],
                                d = 6,
                                p = 6,
                                f = 3,
                                m = 2,
                                g = 1,
                                A = new Float32Array(f * p * d),
                                v = new Float32Array(m * p * d),
                                _ = new Float32Array(g * p * d);
                            for (let t = 0; t < d; t++) {
                                const e = t % 3 * 2 / 3 - 1,
                                    n = t > 2 ? 0 : -1,
                                    r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                A.set(r, f * p * t), v.set(h, m * p * t);
                                const i = [t, t, t, t, t, t];
                                _.set(i, g * p * t)
                            }
                            const y = new Fs;
                            y.setAttribute("position", new Ms(A, f)), y.setAttribute("uv", new Ms(v, m)), y.setAttribute("faceIndex", new Ms(_, g)), e.push(y), i > 4 && i--
                        }
                        return {
                            lodPlanes: e,
                            sizeLods: n,
                            sigmas: r
                        }
                    }(r)), this._blurMaterial = function (t, e, n) {
                        const r = new Float32Array(zl),
                            i = new Zo(0, 1, 0),
                            o = new ul({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: zl,
                                    CUBEUV_TEXEL_WIDTH: 1 / e,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${t}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: r
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: i
                                    }
                                },
                                vertexShader: ic(),
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            });
                        return o
                    }(r, t, e)
                }
                return r
            }
            _compileMaterial(t) {
                const e = new rl(this._lodPlanes[0], t);
                this._renderer.compile(e, Vl)
            }
            _sceneToCubeUV(t, e, n, r) {
                const i = new ml(90, 1, e, n),
                    o = [1, -1, 1, 1, 1, 1],
                    a = [1, 1, 1, -1, -1, -1],
                    s = this._renderer,
                    l = s.autoClear,
                    c = s.toneMapping;
                s.getClearColor(Wl), s.toneMapping = ei, s.autoClear = !1;
                const u = new xs({
                        name: "PMREM.Background",
                        side: Yr,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    h = new rl(new ol, u);
                let d = !1;
                const p = t.background;
                p ? p.isColor && (u.color.copy(p), t.background = null, d = !0) : (u.color.copy(Wl), d = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 === n ? (i.up.set(0, o[e], 0), i.lookAt(a[e], 0, 0)) : 1 === n ? (i.up.set(0, 0, o[e]), i.lookAt(0, a[e], 0)) : (i.up.set(0, o[e], 0), i.lookAt(0, 0, a[e]));
                    const l = this._cubeSize;
                    ec(r, n * l, e > 2 ? l : 0, l, l), s.setRenderTarget(r), d && s.render(h, i), s.render(t, i)
                }
                h.geometry.dispose(), h.material.dispose(), s.toneMapping = c, s.autoClear = l, t.background = p
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer,
                    r = t.mapping === ui || t.mapping === hi;
                r ? (null === this._cubemapMaterial && (this._cubemapMaterial = rc()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = nc());
                const i = r ? this._cubemapMaterial : this._equirectMaterial,
                    o = new rl(this._lodPlanes[0], i);
                i.uniforms.envMap.value = t;
                const a = this._cubeSize;
                ec(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(o, Vl)
            }
            _applyPMREM(t) {
                const e = this._renderer,
                    n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < this._lodPlanes.length; e++) {
                    const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                        r = Jl[(e - 1) % Jl.length];
                    this._blur(t, e - 1, e, n, r)
                }
                e.autoClear = n
            }
            _blur(t, e, n, r, i) {
                const o = this._pingPongRenderTarget;
                this._halfBlur(t, o, e, n, r, "latitudinal", i), this._halfBlur(o, t, n, n, r, "longitudinal", i)
            }
            _halfBlur(t, e, n, r, i, o, a) {
                const s = this._renderer,
                    l = this._blurMaterial;
                "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new rl(this._lodPlanes[r], l),
                    u = l.uniforms,
                    h = this._sizeLods[n] - 1,
                    d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                    p = i / d,
                    f = isFinite(i) ? 1 + Math.floor(3 * p) : zl;
                f > zl && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let t = 0; t < zl; ++t) {
                    const e = t / p,
                        n = Math.exp(-e * e / 2);
                    m.push(n), 0 === t ? g += n : t < f && (g += 2 * n)
                }
                for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                u.envMap.value = t.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === o, a && (u.poleAxis.value = a);
                const {
                    _lodMax: A
                } = this;
                u.dTheta.value = d, u.mipInt.value = A - n;
                const v = this._sizeLods[r];
                ec(e, 3 * v * (r > A - 4 ? r - A + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), s.setRenderTarget(e), s.render(c, Vl)
            }
        }

        function tc(t, e, n) {
            const r = new qo(t, e, n);
            return r.texture.mapping = di, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
        }

        function ec(t, e, n, r, i) {
            t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
        }

        function nc() {
            return new ul({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: ic(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function rc() {
            return new ul({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: ic(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function ic() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }

        function oc(t) {
            let e = new WeakMap,
                n = null;

            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const i = e.get(n);
                void 0 !== i && (e.delete(n), i.dispose())
            }
            return {
                get: function (i) {
                    if (i && i.isTexture) {
                        const o = i.mapping,
                            a = 303 === o || 304 === o,
                            s = o === ui || o === hi;
                        if (a || s) {
                            if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                i.needsPMREMUpdate = !1;
                                let r = e.get(i);
                                return null === n && (n = new Zl(t)), r = a ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r), e.set(i, r), r.texture
                            }
                            if (e.has(i)) return e.get(i).texture; {
                                const o = i.image;
                                if (a && o && o.height > 0 || s && o && function (t) {
                                        let e = 0;
                                        const n = 6;
                                        for (let r = 0; r < n; r++) void 0 !== t[r] && e++;
                                        return e === n
                                    }(o)) {
                                    null === n && (n = new Zl(t));
                                    const o = a ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                    return e.set(i, o), i.addEventListener("dispose", r), o.texture
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function () {
                    e = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function ac(t) {
            const e = {};

            function n(n) {
                if (void 0 !== e[n]) return e[n];
                let r;
                switch (n) {
                    case "WEBGL_depth_texture":
                        r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        r = t.getExtension(n)
                }
                return e[n] = r, r
            }
            return {
                has: function (t) {
                    return null !== n(t)
                },
                init: function (t) {
                    t.isWebGL2 ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                },
                get: function (t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                }
            }
        }

        function sc(t, e, n, r) {
            const i = {},
                o = new WeakMap;

            function a(t) {
                const s = t.target;
                null !== s.index && e.remove(s.index);
                for (const t in s.attributes) e.remove(s.attributes[t]);
                for (const t in s.morphAttributes) {
                    const n = s.morphAttributes[t];
                    for (let t = 0, r = n.length; t < r; t++) e.remove(n[t])
                }
                s.removeEventListener("dispose", a), delete i[s.id];
                const l = o.get(s);
                l && (e.remove(l), o.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries--
            }

            function s(t) {
                const n = [],
                    r = t.index,
                    i = t.attributes.position;
                let a = 0;
                if (null !== r) {
                    const t = r.array;
                    a = r.version;
                    for (let e = 0, r = t.length; e < r; e += 3) {
                        const r = t[e + 0],
                            i = t[e + 1],
                            o = t[e + 2];
                        n.push(r, i, i, o, o, r)
                    }
                } else {
                    if (void 0 === i) return; {
                        const t = i.array;
                        a = i.version;
                        for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                            const t = e + 0,
                                r = e + 1,
                                i = e + 2;
                            n.push(t, r, r, i, i, t)
                        }
                    }
                }
                const s = new(Mo(n) ? Bs : Ts)(n, 1);
                s.version = a;
                const l = o.get(t);
                l && e.remove(l), o.set(t, s)
            }
            return {
                get: function (t, e) {
                    return !0 === i[e.id] || (e.addEventListener("dispose", a), i[e.id] = !0, n.memory.geometries++), e
                },
                update: function (n) {
                    const r = n.attributes;
                    for (const n in r) e.update(r[n], t.ARRAY_BUFFER);
                    const i = n.morphAttributes;
                    for (const n in i) {
                        const r = i[n];
                        for (let n = 0, i = r.length; n < i; n++) e.update(r[n], t.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function (t) {
                    const e = o.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && s(t)
                    } else s(t);
                    return o.get(t)
                }
            }
        }

        function lc(t, e, n, r) {
            const i = r.isWebGL2;
            let o, a, s;
            this.setMode = function (t) {
                o = t
            }, this.setIndex = function (t) {
                a = t.type, s = t.bytesPerElement
            }, this.render = function (e, r) {
                t.drawElements(o, r, a, e * s), n.update(r, o, 1)
            }, this.renderInstances = function (r, l, c) {
                if (0 === c) return;
                let u, h;
                if (i) u = t, h = "drawElementsInstanced";
                else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[h](o, l, a, r * s, c), n.update(l, o, c)
            }, this.renderMultiDraw = function (t, r, i) {
                if (0 === i) return;
                const l = e.get("WEBGL_multi_draw");
                if (null === l)
                    for (let e = 0; e < i; e++) this.render(t[e] / s, r[e]);
                else {
                    l.multiDrawElementsWEBGL(o, r, 0, a, t, 0, i);
                    let e = 0;
                    for (let t = 0; t < i; t++) e += r[t];
                    n.update(e, o, 1)
                }
            }
        }

        function cc(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function () {
                    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function (n, r, i) {
                    switch (e.calls++, r) {
                        case t.TRIANGLES:
                            e.triangles += i * (n / 3);
                            break;
                        case t.LINES:
                            e.lines += i * (n / 2);
                            break;
                        case t.LINE_STRIP:
                            e.lines += i * (n - 1);
                            break;
                        case t.LINE_LOOP:
                            e.lines += i * n;
                            break;
                        case t.POINTS:
                            e.points += i * n;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                    }
                }
            }
        }

        function uc(t, e) {
            return t[0] - e[0]
        }

        function hc(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function dc(t, e, n) {
            const r = {},
                i = new Float32Array(8),
                o = new WeakMap,
                a = new jo,
                s = [];
            for (let t = 0; t < 8; t++) s[t] = [t, 0];
            return {
                update: function (l, c, u) {
                    const h = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const r = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                            i = void 0 !== r ? r.length : 0;
                        let s = o.get(c);
                        if (void 0 === s || s.count !== i) {
                            void 0 !== s && s.texture.dispose();
                            const t = void 0 !== c.morphAttributes.position,
                                n = void 0 !== c.morphAttributes.normal,
                                r = void 0 !== c.morphAttributes.color,
                                l = c.morphAttributes.position || [],
                                u = c.morphAttributes.normal || [],
                                h = c.morphAttributes.color || [];
                            let d = 0;
                            !0 === t && (d = 1), !0 === n && (d = 2), !0 === r && (d = 3);
                            let p = c.attributes.position.count * d,
                                f = 1;
                            p > e.maxTextureSize && (f = Math.ceil(p / e.maxTextureSize), p = e.maxTextureSize);
                            const m = new Float32Array(p * f * 4 * i),
                                g = new Yo(m, p, f, i);
                            g.type = Si, g.needsUpdate = !0;
                            const A = 4 * d;
                            for (let e = 0; e < i; e++) {
                                const i = l[e],
                                    o = u[e],
                                    s = h[e],
                                    c = p * f * 4 * e;
                                for (let e = 0; e < i.count; e++) {
                                    const l = e * A;
                                    !0 === t && (a.fromBufferAttribute(i, e), m[c + l + 0] = a.x, m[c + l + 1] = a.y, m[c + l + 2] = a.z, m[c + l + 3] = 0), !0 === n && (a.fromBufferAttribute(o, e), m[c + l + 4] = a.x, m[c + l + 5] = a.y, m[c + l + 6] = a.z, m[c + l + 7] = 0), !0 === r && (a.fromBufferAttribute(s, e), m[c + l + 8] = a.x, m[c + l + 9] = a.y, m[c + l + 10] = a.z, m[c + l + 11] = 4 === s.itemSize ? a.w : 1)
                                }
                            }
                            s = {
                                count: i,
                                texture: g,
                                size: new Co(p, f)
                            }, o.set(c, s), c.addEventListener("dispose", (function t() {
                                g.dispose(), o.delete(c), c.removeEventListener("dispose", t)
                            }))
                        }
                        if (!0 === l.isInstancedMesh && null !== l.morphTexture) u.getUniforms().setValue(t, "morphTexture", l.morphTexture, n);
                        else {
                            let e = 0;
                            for (let t = 0; t < h.length; t++) e += h[t];
                            const n = c.morphTargetsRelative ? 1 : 1 - e;
                            u.getUniforms().setValue(t, "morphTargetBaseInfluence", n), u.getUniforms().setValue(t, "morphTargetInfluences", h)
                        }
                        u.getUniforms().setValue(t, "morphTargetsTexture", s.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", s.size)
                    } else {
                        const e = void 0 === h ? 0 : h.length;
                        let n = r[c.id];
                        if (void 0 === n || n.length !== e) {
                            n = [];
                            for (let t = 0; t < e; t++) n[t] = [t, 0];
                            r[c.id] = n
                        }
                        for (let t = 0; t < e; t++) {
                            const e = n[t];
                            e[0] = t, e[1] = h[t]
                        }
                        n.sort(hc);
                        for (let t = 0; t < 8; t++) t < e && n[t][1] ? (s[t][0] = n[t][0], s[t][1] = n[t][1]) : (s[t][0] = Number.MAX_SAFE_INTEGER, s[t][1] = 0);
                        s.sort(uc);
                        const o = c.morphAttributes.position,
                            a = c.morphAttributes.normal;
                        let l = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = s[t],
                                n = e[0],
                                r = e[1];
                            n !== Number.MAX_SAFE_INTEGER && r ? (o && c.getAttribute("morphTarget" + t) !== o[n] && c.setAttribute("morphTarget" + t, o[n]), a && c.getAttribute("morphNormal" + t) !== a[n] && c.setAttribute("morphNormal" + t, a[n]), i[t] = r, l += r) : (o && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t), a && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t), i[t] = 0)
                        }
                        const d = c.morphTargetsRelative ? 1 : 1 - l;
                        u.getUniforms().setValue(t, "morphTargetBaseInfluence", d), u.getUniforms().setValue(t, "morphTargetInfluences", i)
                    }
                }
            }
        }

        function pc(t, e, n, r) {
            let i = new WeakMap;

            function o(t) {
                const e = t.target;
                e.removeEventListener("dispose", o), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function (a) {
                    const s = r.render.frame,
                        l = a.geometry,
                        c = e.get(a, l);
                    if (i.get(c) !== s && (e.update(c), i.set(c, s)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", o) && a.addEventListener("dispose", o), i.get(a) !== s && (n.update(a.instanceMatrix, t.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER), i.set(a, s))), a.isSkinnedMesh) {
                        const t = a.skeleton;
                        i.get(t) !== s && (t.update(), i.set(t, s))
                    }
                    return c
                },
                dispose: function () {
                    i = new WeakMap
                }
            }
        }
        class fc extends Wo {
            constructor(t, e, n, r, i, o, a, s, l, c) {
                if ((c = void 0 !== c ? c : Bi) !== Bi && c !== Ri) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === Bi && (n = Ci), void 0 === n && c === Ri && (n = Mi), super(null, r, i, o, a, s, c, n, l), this.isDepthTexture = !0, this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== a ? a : gi, this.minFilter = void 0 !== s ? s : gi, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
            }
            copy(t) {
                return super.copy(t), this.compareFunction = t.compareFunction, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
            }
        }
        const mc = new Wo,
            gc = new fc(1, 1);
        gc.compareFunction = 515;
        const Ac = new Yo,
            vc = new Ko,
            _c = new vl,
            yc = [],
            Ec = [],
            xc = new Float32Array(16),
            bc = new Float32Array(9),
            wc = new Float32Array(4);

        function Cc(t, e, n) {
            const r = t[0];
            if (r <= 0 || r > 0) return t;
            const i = e * n;
            let o = yc[i];
            if (void 0 === o && (o = new Float32Array(i), yc[i] = o), 0 !== e) {
                r.toArray(o, 0);
                for (let r = 1, i = 0; r !== e; ++r) i += n, t[r].toArray(o, i)
            }
            return o
        }

        function Sc(t, e) {
            if (t.length !== e.length) return !1;
            for (let n = 0, r = t.length; n < r; n++)
                if (t[n] !== e[n]) return !1;
            return !0
        }

        function Ic(t, e) {
            for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
        }

        function Mc(t, e) {
            let n = Ec[e];
            void 0 === n && (n = new Int32Array(e), Ec[e] = n);
            for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
            return n
        }

        function Tc(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function Bc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (Sc(n, e)) return;
                t.uniform2fv(this.addr, e), Ic(n, e)
            }
        }

        function Rc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (Sc(n, e)) return;
                t.uniform3fv(this.addr, e), Ic(n, e)
            }
        }

        function Lc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (Sc(n, e)) return;
                t.uniform4fv(this.addr, e), Ic(n, e)
            }
        }

        function Dc(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (Sc(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Ic(n, e)
            } else {
                if (Sc(n, r)) return;
                wc.set(r), t.uniformMatrix2fv(this.addr, !1, wc), Ic(n, r)
            }
        }

        function Pc(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (Sc(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Ic(n, e)
            } else {
                if (Sc(n, r)) return;
                bc.set(r), t.uniformMatrix3fv(this.addr, !1, bc), Ic(n, r)
            }
        }

        function Oc(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (Sc(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Ic(n, e)
            } else {
                if (Sc(n, r)) return;
                xc.set(r), t.uniformMatrix4fv(this.addr, !1, xc), Ic(n, r)
            }
        }

        function kc(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function Uc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (Sc(n, e)) return;
                t.uniform2iv(this.addr, e), Ic(n, e)
            }
        }

        function Nc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (Sc(n, e)) return;
                t.uniform3iv(this.addr, e), Ic(n, e)
            }
        }

        function Fc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (Sc(n, e)) return;
                t.uniform4iv(this.addr, e), Ic(n, e)
            }
        }

        function Qc(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function $c(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (Sc(n, e)) return;
                t.uniform2uiv(this.addr, e), Ic(n, e)
            }
        }

        function Gc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (Sc(n, e)) return;
                t.uniform3uiv(this.addr, e), Ic(n, e)
            }
        }

        function Hc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (Sc(n, e)) return;
                t.uniform4uiv(this.addr, e), Ic(n, e)
            }
        }

        function zc(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i);
            const o = this.type === t.SAMPLER_2D_SHADOW ? gc : mc;
            n.setTexture2D(e || o, i)
        }

        function Vc(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || vc, i)
        }

        function Wc(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || _c, i)
        }

        function jc(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || Ac, i)
        }

        function Xc(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function qc(t, e) {
            const n = Cc(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function Yc(t, e) {
            const n = Cc(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function Kc(t, e) {
            const n = Cc(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function Jc(t, e) {
            const n = Cc(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function Zc(t, e) {
            const n = Cc(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function tu(t, e) {
            const n = Cc(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function eu(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function nu(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function ru(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function iu(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function ou(t, e) {
            t.uniform1uiv(this.addr, e)
        }

        function au(t, e) {
            t.uniform2uiv(this.addr, e)
        }

        function su(t, e) {
            t.uniform3uiv(this.addr, e)
        }

        function lu(t, e) {
            t.uniform4uiv(this.addr, e)
        }

        function cu(t, e, n) {
            const r = this.cache,
                i = e.length,
                o = Mc(n, i);
            Sc(r, o) || (t.uniform1iv(this.addr, o), Ic(r, o));
            for (let t = 0; t !== i; ++t) n.setTexture2D(e[t] || mc, o[t])
        }

        function uu(t, e, n) {
            const r = this.cache,
                i = e.length,
                o = Mc(n, i);
            Sc(r, o) || (t.uniform1iv(this.addr, o), Ic(r, o));
            for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || vc, o[t])
        }

        function hu(t, e, n) {
            const r = this.cache,
                i = e.length,
                o = Mc(n, i);
            Sc(r, o) || (t.uniform1iv(this.addr, o), Ic(r, o));
            for (let t = 0; t !== i; ++t) n.setTextureCube(e[t] || _c, o[t])
        }

        function du(t, e, n) {
            const r = this.cache,
                i = e.length,
                o = Mc(n, i);
            Sc(r, o) || (t.uniform1iv(this.addr, o), Ic(r, o));
            for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || Ac, o[t])
        }
        class pu {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return Tc;
                        case 35664:
                            return Bc;
                        case 35665:
                            return Rc;
                        case 35666:
                            return Lc;
                        case 35674:
                            return Dc;
                        case 35675:
                            return Pc;
                        case 35676:
                            return Oc;
                        case 5124:
                        case 35670:
                            return kc;
                        case 35667:
                        case 35671:
                            return Uc;
                        case 35668:
                        case 35672:
                            return Nc;
                        case 35669:
                        case 35673:
                            return Fc;
                        case 5125:
                            return Qc;
                        case 36294:
                            return $c;
                        case 36295:
                            return Gc;
                        case 36296:
                            return Hc;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return zc;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Vc;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Wc;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return jc
                    }
                }(e.type)
            }
        }
        class fu {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return Xc;
                        case 35664:
                            return qc;
                        case 35665:
                            return Yc;
                        case 35666:
                            return Kc;
                        case 35674:
                            return Jc;
                        case 35675:
                            return Zc;
                        case 35676:
                            return tu;
                        case 5124:
                        case 35670:
                            return eu;
                        case 35667:
                        case 35671:
                            return nu;
                        case 35668:
                        case 35672:
                            return ru;
                        case 35669:
                        case 35673:
                            return iu;
                        case 5125:
                            return ou;
                        case 36294:
                            return au;
                        case 36295:
                            return su;
                        case 36296:
                            return lu;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return cu;
                        case 35679:
                        case 36299:
                        case 36307:
                            return uu;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return hu;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return du
                    }
                }(e.type)
            }
        }
        class mu {
            constructor(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            setValue(t, e, n) {
                const r = this.seq;
                for (let i = 0, o = r.length; i !== o; ++i) {
                    const o = r[i];
                    o.setValue(t, e[o.id], n)
                }
            }
        }
        const gu = /(\w+)(\])?(\[|\.)?/g;

        function Au(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function vu(t, e, n) {
            const r = t.name,
                i = r.length;
            for (gu.lastIndex = 0;;) {
                const o = gu.exec(r),
                    a = gu.lastIndex;
                let s = o[1];
                const l = "]" === o[2],
                    c = o[3];
                if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === i) {
                    Au(n, void 0 === c ? new pu(s, t, e) : new fu(s, t, e));
                    break
                } {
                    let t = n.map[s];
                    void 0 === t && (t = new mu(s), Au(n, t)), n = t
                }
            }
        }
        class _u {
            constructor(t, e) {
                this.seq = [], this.map = {};
                const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                for (let r = 0; r < n; ++r) {
                    const n = t.getActiveUniform(e, r);
                    vu(n, t.getUniformLocation(e, n.name), this)
                }
            }
            setValue(t, e, n, r) {
                const i = this.map[e];
                void 0 !== i && i.setValue(t, n, r)
            }
            setOptional(t, e, n) {
                const r = e[n];
                void 0 !== r && this.setValue(t, n, r)
            }
            static upload(t, e, n, r) {
                for (let i = 0, o = e.length; i !== o; ++i) {
                    const o = e[i],
                        a = n[o.id];
                    !1 !== a.needsUpdate && o.setValue(t, a.value, r)
                }
            }
            static seqWithValue(t, e) {
                const n = [];
                for (let r = 0, i = t.length; r !== i; ++r) {
                    const i = t[r];
                    i.id in e && n.push(i)
                }
                return n
            }
        }

        function yu(t, e, n) {
            const r = t.createShader(e);
            return t.shaderSource(r, n), t.compileShader(r), r
        }
        const Eu = 37297;
        let xu = 0;

        function bu(t, e, n) {
            const r = t.getShaderParameter(e, t.COMPILE_STATUS),
                i = t.getShaderInfoLog(e).trim();
            if (r && "" === i) return "";
            const o = /ERROR: 0:(\d+)/.exec(i);
            if (o) {
                const r = parseInt(o[1]);
                return n.toUpperCase() + "\n\n" + i + "\n\n" + function (t, e) {
                    const n = t.split("\n"),
                        r = [],
                        i = Math.max(e - 6, 0),
                        o = Math.min(e + 6, n.length);
                    for (let t = i; t < o; t++) {
                        const i = t + 1;
                        r.push(`${i===e?">":" "} ${i}: ${n[t]}`)
                    }
                    return r.join("\n")
                }(t.getShaderSource(e), r)
            }
            return i
        }

        function wu(t, e) {
            const n = function (t) {
                const e = Uo.getPrimaries(Uo.workingColorSpace),
                    n = Uo.getPrimaries(t);
                let r;
                switch (e === n ? r = "" : e === ro && n === no ? r = "LinearDisplayP3ToLinearSRGB" : e === no && n === ro && (r = "LinearSRGBToLinearDisplayP3"), t) {
                    case Ki:
                    case Zi:
                        return [r, "LinearTransferOETF"];
                    case Yi:
                    case Ji:
                        return [r, "sRGBTransferOETF"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space:", t), [r, "LinearTransferOETF"]
                }
            }(e);
            return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
        }

        function Cu(t, e) {
            let n;
            switch (e) {
                case ni:
                    n = "Linear";
                    break;
                case ri:
                    n = "Reinhard";
                    break;
                case ii:
                    n = "OptimizedCineon";
                    break;
                case oi:
                    n = "ACESFilmic";
                    break;
                case si:
                    n = "AgX";
                    break;
                case li:
                    n = "Neutral";
                    break;
                case ai:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Su(t) {
            return "" !== t
        }

        function Iu(t, e) {
            const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Mu(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Tu = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Bu(t) {
            return t.replace(Tu, Lu)
        }
        const Ru = new Map([
            ["encodings_fragment", "colorspace_fragment"],
            ["encodings_pars_fragment", "colorspace_pars_fragment"],
            ["output_fragment", "opaque_fragment"]
        ]);

        function Lu(t, e) {
            let n = Bl[e];
            if (void 0 === n) {
                const t = Ru.get(e);
                if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
                n = Bl[t], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
            }
            return Bu(n)
        }
        const Du = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Pu(t) {
            return t.replace(Du, Ou)
        }

        function Ou(t, e, n, r) {
            let i = "";
            for (let t = parseInt(e); t < parseInt(n); t++) i += r.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return i
        }

        function ku(t) {
            let e = `precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\t`;
            return t.isWebGL2 && (e += `precision ${t.precision} sampler3D;\n\t\tprecision ${t.precision} sampler2DArray;\n\t\tprecision ${t.precision} sampler2DShadow;\n\t\tprecision ${t.precision} samplerCubeShadow;\n\t\tprecision ${t.precision} sampler2DArrayShadow;\n\t\tprecision ${t.precision} isampler2D;\n\t\tprecision ${t.precision} isampler3D;\n\t\tprecision ${t.precision} isamplerCube;\n\t\tprecision ${t.precision} isampler2DArray;\n\t\tprecision ${t.precision} usampler2D;\n\t\tprecision ${t.precision} usampler3D;\n\t\tprecision ${t.precision} usamplerCube;\n\t\tprecision ${t.precision} usampler2DArray;\n\t\t`), "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function Uu(t, e, n, r) {
            const i = t.getContext(),
                o = n.defines;
            let a = n.vertexShader,
                s = n.fragmentShader;
            const l = function (t) {
                    let e = "SHADOWMAP_TYPE_BASIC";
                    return t.shadowMapType === Wr ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === jr ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Xr && (e = "SHADOWMAP_TYPE_VSM"), e
                }(n),
                c = function (t) {
                    let e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case ui:
                        case hi:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case di:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(n),
                u = function (t) {
                    let e = "ENVMAP_MODE_REFLECTION";
                    t.envMap && t.envMapMode === hi && (e = "ENVMAP_MODE_REFRACTION");
                    return e
                }(n),
                h = function (t) {
                    let e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case Jr:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case Zr:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case ti:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                d = function (t) {
                    const e = t.envMapCubeUVHeight;
                    if (null === e) return null;
                    const n = Math.log2(e) - 2,
                        r = 1 / e;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: r,
                        maxMip: n
                    }
                }(n),
                p = n.isWebGL2 ? "" : function (t) {
                    return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || t.alphaToCoverage || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Su).join("\n")
                }(n),
                f = function (t) {
                    return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Su).join("\n")
                }(n),
                m = function (t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        !1 !== r && e.push("#define " + n + " " + r)
                    }
                    return e.join("\n")
                }(o),
                g = i.createProgram();
            let A, v, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (A = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Su).join("\n"), A.length > 0 && (A += "\n"), v = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Su).join("\n"), v.length > 0 && (v += "\n")) : (A = [ku(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Su).join("\n"), v = [p, ku(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== ei ? "#define TONE_MAPPING" : "", n.toneMapping !== ei ? Bl.tonemapping_pars_fragment : "", n.toneMapping !== ei ? Cu("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Bl.colorspace_pars_fragment, wu("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Su).join("\n")), a = Bu(a), a = Iu(a, n), a = Mu(a, n), s = Bu(s), s = Iu(s, n), s = Mu(s, n), a = Pu(a), s = Pu(s), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", A = [f, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + A, v = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === ao ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === ao ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const y = _ + A + a,
                E = _ + v + s,
                x = yu(i, i.VERTEX_SHADER, y),
                b = yu(i, i.FRAGMENT_SHADER, E);

            function w(e) {
                if (t.debug.checkShaderErrors) {
                    const n = i.getProgramInfoLog(g).trim(),
                        r = i.getShaderInfoLog(x).trim(),
                        o = i.getShaderInfoLog(b).trim();
                    let a = !0,
                        s = !0;
                    if (!1 === i.getProgramParameter(g, i.LINK_STATUS))
                        if (a = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(i, g, x, b);
                        else {
                            const t = bu(i, x, "vertex"),
                                r = bu(i, b, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + "\n\nMaterial Name: " + e.name + "\nMaterial Type: " + e.type + "\n\nProgram Info Log: " + n + "\n" + t + "\n" + r)
                        }
                    else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== r && "" !== o || (s = !1);
                    s && (e.diagnostics = {
                        runnable: a,
                        programLog: n,
                        vertexShader: {
                            log: r,
                            prefix: A
                        },
                        fragmentShader: {
                            log: o,
                            prefix: v
                        }
                    })
                }
                i.deleteShader(x), i.deleteShader(b), C = new _u(i, g), S = function (t, e) {
                    const n = {},
                        r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let i = 0; i < r; i++) {
                        const r = t.getActiveAttrib(e, i),
                            o = r.name;
                        let a = 1;
                        r.type === t.FLOAT_MAT2 && (a = 2), r.type === t.FLOAT_MAT3 && (a = 3), r.type === t.FLOAT_MAT4 && (a = 4), n[o] = {
                            type: r.type,
                            location: t.getAttribLocation(e, o),
                            locationSize: a
                        }
                    }
                    return n
                }(i, g)
            }
            let C, S;
            i.attachShader(g, x), i.attachShader(g, b), void 0 !== n.index0AttributeName ? i.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(g, 0, "position"), i.linkProgram(g), this.getUniforms = function () {
                return void 0 === C && w(this), C
            }, this.getAttributes = function () {
                return void 0 === S && w(this), S
            };
            let I = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function () {
                return !1 === I && (I = i.getProgramParameter(g, Eu)), I
            }, this.destroy = function () {
                r.releaseStatesOfProgram(this), i.deleteProgram(g), this.program = void 0
            }, this.type = n.shaderType, this.name = n.shaderName, this.id = xu++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = x, this.fragmentShader = b, this
        }
        let Nu = 0;
        class Fu {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader,
                    n = t.fragmentShader,
                    r = this._getShaderStage(e),
                    i = this._getShaderStage(n),
                    o = this._getShaderCacheForMaterial(t);
                return !1 === o.has(r) && (o.add(r), r.usedTimes++), !1 === o.has(i) && (o.add(i), i.usedTimes++), this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                return this.materialCache.delete(t), this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                let n = e.get(t);
                return void 0 === n && (n = new Set, e.set(t, n)), n
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                let n = e.get(t);
                return void 0 === n && (n = new Qu(t), e.set(t, n)), n
            }
        }
        class Qu {
            constructor(t) {
                this.id = Nu++, this.code = t, this.usedTimes = 0
            }
        }

        function $u(t, e, n, r, i, o, a) {
            const s = new Qa,
                l = new Fu,
                c = new Set,
                u = [],
                h = i.isWebGL2,
                d = i.logarithmicDepthBuffer,
                p = i.vertexTextures;
            let f = i.precision;
            const m = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };

            function g(t) {
                return c.add(t), 0 === t ? "uv" : `uv${t}`
            }
            return {
                getParameters: function (o, s, u, A, v) {
                    const _ = A.fog,
                        y = v.geometry,
                        E = o.isMeshStandardMaterial ? A.environment : null,
                        x = (o.isMeshStandardMaterial ? n : e).get(o.envMap || E),
                        b = x && x.mapping === di ? x.image.height : null,
                        w = m[o.type];
                    null !== o.precision && (f = i.getMaxPrecision(o.precision), f !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", f, "instead."));
                    const C = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                        S = void 0 !== C ? C.length : 0;
                    let I, M, T, B, R = 0;
                    if (void 0 !== y.morphAttributes.position && (R = 1), void 0 !== y.morphAttributes.normal && (R = 2), void 0 !== y.morphAttributes.color && (R = 3), w) {
                        const t = Ll[w];
                        I = t.vertexShader, M = t.fragmentShader
                    } else I = o.vertexShader, M = o.fragmentShader, l.update(o), T = l.getVertexShaderID(o), B = l.getFragmentShaderID(o);
                    const L = t.getRenderTarget(),
                        D = !0 === v.isInstancedMesh,
                        P = !0 === v.isBatchedMesh,
                        O = !!o.map,
                        k = !!o.matcap,
                        U = !!x,
                        N = !!o.aoMap,
                        F = !!o.lightMap,
                        Q = !!o.bumpMap,
                        $ = !!o.normalMap,
                        G = !!o.displacementMap,
                        H = !!o.emissiveMap,
                        z = !!o.metalnessMap,
                        V = !!o.roughnessMap,
                        W = o.anisotropy > 0,
                        j = o.clearcoat > 0,
                        X = o.iridescence > 0,
                        q = o.sheen > 0,
                        Y = o.transmission > 0,
                        K = W && !!o.anisotropyMap,
                        J = j && !!o.clearcoatMap,
                        Z = j && !!o.clearcoatNormalMap,
                        tt = j && !!o.clearcoatRoughnessMap,
                        et = X && !!o.iridescenceMap,
                        nt = X && !!o.iridescenceThicknessMap,
                        rt = q && !!o.sheenColorMap,
                        it = q && !!o.sheenRoughnessMap,
                        ot = !!o.specularMap,
                        at = !!o.specularColorMap,
                        st = !!o.specularIntensityMap,
                        lt = Y && !!o.transmissionMap,
                        ct = Y && !!o.thicknessMap,
                        ut = !!o.gradientMap,
                        ht = !!o.alphaMap,
                        dt = o.alphaTest > 0,
                        pt = !!o.alphaHash,
                        ft = !!o.extensions;
                    let mt = ei;
                    o.toneMapped && (null !== L && !0 !== L.isXRRenderTarget || (mt = t.toneMapping));
                    const gt = {
                        isWebGL2: h,
                        shaderID: w,
                        shaderType: o.type,
                        shaderName: o.name,
                        vertexShader: I,
                        fragmentShader: M,
                        defines: o.defines,
                        customVertexShaderID: T,
                        customFragmentShaderID: B,
                        isRawShaderMaterial: !0 === o.isRawShaderMaterial,
                        glslVersion: o.glslVersion,
                        precision: f,
                        batching: P,
                        instancing: D,
                        instancingColor: D && null !== v.instanceColor,
                        instancingMorph: D && null !== v.morphTexture,
                        supportsVertexTextures: p,
                        outputColorSpace: null === L ? t.outputColorSpace : !0 === L.isXRRenderTarget ? L.texture.colorSpace : Ki,
                        alphaToCoverage: !!o.alphaToCoverage,
                        map: O,
                        matcap: k,
                        envMap: U,
                        envMapMode: U && x.mapping,
                        envMapCubeUVHeight: b,
                        aoMap: N,
                        lightMap: F,
                        bumpMap: Q,
                        normalMap: $,
                        displacementMap: p && G,
                        emissiveMap: H,
                        normalMapObjectSpace: $ && 1 === o.normalMapType,
                        normalMapTangentSpace: $ && 0 === o.normalMapType,
                        metalnessMap: z,
                        roughnessMap: V,
                        anisotropy: W,
                        anisotropyMap: K,
                        clearcoat: j,
                        clearcoatMap: J,
                        clearcoatNormalMap: Z,
                        clearcoatRoughnessMap: tt,
                        iridescence: X,
                        iridescenceMap: et,
                        iridescenceThicknessMap: nt,
                        sheen: q,
                        sheenColorMap: rt,
                        sheenRoughnessMap: it,
                        specularMap: ot,
                        specularColorMap: at,
                        specularIntensityMap: st,
                        transmission: Y,
                        transmissionMap: lt,
                        thicknessMap: ct,
                        gradientMap: ut,
                        opaque: !1 === o.transparent && 1 === o.blending && !1 === o.alphaToCoverage,
                        alphaMap: ht,
                        alphaTest: dt,
                        alphaHash: pt,
                        combine: o.combine,
                        mapUv: O && g(o.map.channel),
                        aoMapUv: N && g(o.aoMap.channel),
                        lightMapUv: F && g(o.lightMap.channel),
                        bumpMapUv: Q && g(o.bumpMap.channel),
                        normalMapUv: $ && g(o.normalMap.channel),
                        displacementMapUv: G && g(o.displacementMap.channel),
                        emissiveMapUv: H && g(o.emissiveMap.channel),
                        metalnessMapUv: z && g(o.metalnessMap.channel),
                        roughnessMapUv: V && g(o.roughnessMap.channel),
                        anisotropyMapUv: K && g(o.anisotropyMap.channel),
                        clearcoatMapUv: J && g(o.clearcoatMap.channel),
                        clearcoatNormalMapUv: Z && g(o.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: tt && g(o.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: et && g(o.iridescenceMap.channel),
                        iridescenceThicknessMapUv: nt && g(o.iridescenceThicknessMap.channel),
                        sheenColorMapUv: rt && g(o.sheenColorMap.channel),
                        sheenRoughnessMapUv: it && g(o.sheenRoughnessMap.channel),
                        specularMapUv: ot && g(o.specularMap.channel),
                        specularColorMapUv: at && g(o.specularColorMap.channel),
                        specularIntensityMapUv: st && g(o.specularIntensityMap.channel),
                        transmissionMapUv: lt && g(o.transmissionMap.channel),
                        thicknessMapUv: ct && g(o.thicknessMap.channel),
                        alphaMapUv: ht && g(o.alphaMap.channel),
                        vertexTangents: !!y.attributes.tangent && ($ || W),
                        vertexColors: o.vertexColors,
                        vertexAlphas: !0 === o.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                        pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (O || ht),
                        fog: !!_,
                        useFog: !0 === o.fog,
                        fogExp2: !!_ && _.isFogExp2,
                        flatShading: !0 === o.flatShading,
                        sizeAttenuation: !0 === o.sizeAttenuation,
                        logarithmicDepthBuffer: d,
                        skinning: !0 === v.isSkinnedMesh,
                        morphTargets: void 0 !== y.morphAttributes.position,
                        morphNormals: void 0 !== y.morphAttributes.normal,
                        morphColors: void 0 !== y.morphAttributes.color,
                        morphTargetsCount: S,
                        morphTextureStride: R,
                        numDirLights: s.directional.length,
                        numPointLights: s.point.length,
                        numSpotLights: s.spot.length,
                        numSpotLightMaps: s.spotLightMap.length,
                        numRectAreaLights: s.rectArea.length,
                        numHemiLights: s.hemi.length,
                        numDirLightShadows: s.directionalShadowMap.length,
                        numPointLightShadows: s.pointShadowMap.length,
                        numSpotLightShadows: s.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                        numLightProbes: s.numLightProbes,
                        numClippingPlanes: a.numPlanes,
                        numClipIntersection: a.numIntersection,
                        dithering: o.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: mt,
                        useLegacyLights: t._useLegacyLights,
                        decodeVideoTexture: O && !0 === o.map.isVideoTexture && Uo.getTransfer(o.map.colorSpace) === eo,
                        premultipliedAlpha: o.premultipliedAlpha,
                        doubleSided: 2 === o.side,
                        flipSided: o.side === Yr,
                        useDepthPacking: o.depthPacking >= 0,
                        depthPacking: o.depthPacking || 0,
                        index0AttributeName: o.index0AttributeName,
                        extensionDerivatives: ft && !0 === o.extensions.derivatives,
                        extensionFragDepth: ft && !0 === o.extensions.fragDepth,
                        extensionDrawBuffers: ft && !0 === o.extensions.drawBuffers,
                        extensionShaderTextureLOD: ft && !0 === o.extensions.shaderTextureLOD,
                        extensionClipCullDistance: ft && !0 === o.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"),
                        extensionMultiDraw: ft && !0 === o.extensions.multiDraw && r.has("WEBGL_multi_draw"),
                        rendererExtensionFragDepth: h || r.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: h || r.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: h || r.has("EXT_shader_texture_lod"),
                        rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: o.customProgramCacheKey()
                    };
                    return gt.vertexUv1s = c.has(1), gt.vertexUv2s = c.has(2), gt.vertexUv3s = c.has(3), c.clear(), gt
                },
                getProgramCacheKey: function (e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    return !1 === e.isRawShaderMaterial && (! function (t, e) {
                        t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.numLightProbes), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
                    }(n, e), function (t, e) {
                        s.disableAll(), e.isWebGL2 && s.enable(0);
                        e.supportsVertexTextures && s.enable(1);
                        e.instancing && s.enable(2);
                        e.instancingColor && s.enable(3);
                        e.instancingMorph && s.enable(4);
                        e.matcap && s.enable(5);
                        e.envMap && s.enable(6);
                        e.normalMapObjectSpace && s.enable(7);
                        e.normalMapTangentSpace && s.enable(8);
                        e.clearcoat && s.enable(9);
                        e.iridescence && s.enable(10);
                        e.alphaTest && s.enable(11);
                        e.vertexColors && s.enable(12);
                        e.vertexAlphas && s.enable(13);
                        e.vertexUv1s && s.enable(14);
                        e.vertexUv2s && s.enable(15);
                        e.vertexUv3s && s.enable(16);
                        e.vertexTangents && s.enable(17);
                        e.anisotropy && s.enable(18);
                        e.alphaHash && s.enable(19);
                        e.batching && s.enable(20);
                        t.push(s.mask), s.disableAll(), e.fog && s.enable(0);
                        e.useFog && s.enable(1);
                        e.flatShading && s.enable(2);
                        e.logarithmicDepthBuffer && s.enable(3);
                        e.skinning && s.enable(4);
                        e.morphTargets && s.enable(5);
                        e.morphNormals && s.enable(6);
                        e.morphColors && s.enable(7);
                        e.premultipliedAlpha && s.enable(8);
                        e.shadowMapEnabled && s.enable(9);
                        e.useLegacyLights && s.enable(10);
                        e.doubleSided && s.enable(11);
                        e.flipSided && s.enable(12);
                        e.useDepthPacking && s.enable(13);
                        e.dithering && s.enable(14);
                        e.transmission && s.enable(15);
                        e.sheen && s.enable(16);
                        e.opaque && s.enable(17);
                        e.pointsUvs && s.enable(18);
                        e.decodeVideoTexture && s.enable(19);
                        e.alphaToCoverage && s.enable(20);
                        t.push(s.mask)
                    }(n, e), n.push(t.outputColorSpace)), n.push(e.customProgramCacheKey), n.join()
                },
                getUniforms: function (t) {
                    const e = m[t.type];
                    let n;
                    if (e) {
                        const t = Ll[e];
                        n = cl.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                },
                acquireProgram: function (e, n) {
                    let r;
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        if (e.cacheKey === n) {
                            r = e, ++r.usedTimes;
                            break
                        }
                    }
                    return void 0 === r && (r = new Uu(t, n, e, o), u.push(r)), r
                },
                releaseProgram: function (t) {
                    if (0 == --t.usedTimes) {
                        const e = u.indexOf(t);
                        u[e] = u[u.length - 1], u.pop(), t.destroy()
                    }
                },
                releaseShaderCache: function (t) {
                    l.remove(t)
                },
                programs: u,
                dispose: function () {
                    l.dispose()
                }
            }
        }

        function Gu() {
            let t = new WeakMap;
            return {
                get: function (e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                },
                remove: function (e) {
                    t.delete(e)
                },
                update: function (e, n, r) {
                    t.get(e)[n] = r
                },
                dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function Hu(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function zu(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Vu() {
            const t = [];
            let e = 0;
            const n = [],
                r = [],
                i = [];

            function o(n, r, i, o, a, s) {
                let l = t[e];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: r,
                    material: i,
                    groupOrder: o,
                    renderOrder: n.renderOrder,
                    z: a,
                    group: s
                }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = o, l.renderOrder = n.renderOrder, l.z = a, l.group = s), e++, l
            }
            return {
                opaque: n,
                transmissive: r,
                transparent: i,
                init: function () {
                    e = 0, n.length = 0, r.length = 0, i.length = 0
                },
                push: function (t, e, a, s, l, c) {
                    const u = o(t, e, a, s, l, c);
                    a.transmission > 0 ? r.push(u) : !0 === a.transparent ? i.push(u) : n.push(u)
                },
                unshift: function (t, e, a, s, l, c) {
                    const u = o(t, e, a, s, l, c);
                    a.transmission > 0 ? r.unshift(u) : !0 === a.transparent ? i.unshift(u) : n.unshift(u)
                },
                finish: function () {
                    for (let n = e, r = t.length; n < r; n++) {
                        const e = t[n];
                        if (null === e.id) break;
                        e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                    }
                },
                sort: function (t, e) {
                    n.length > 1 && n.sort(t || Hu), r.length > 1 && r.sort(e || zu), i.length > 1 && i.sort(e || zu)
                }
            }
        }

        function Wu() {
            let t = new WeakMap;
            return {
                get: function (e, n) {
                    const r = t.get(e);
                    let i;
                    return void 0 === r ? (i = new Vu, t.set(e, [i])) : n >= r.length ? (i = new Vu, r.push(i)) : i = r[n], i
                },
                dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function ju() {
            const t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Zo,
                                color: new vs
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Zo,
                                direction: new Zo,
                                color: new vs,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Zo,
                                color: new vs,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Zo,
                                skyColor: new vs,
                                groundColor: new vs
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new vs,
                                position: new Zo,
                                halfWidth: new Zo,
                                halfHeight: new Zo
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        let Xu = 0;

        function qu(t, e) {
            return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
        }

        function Yu(t, e) {
            const n = new ju,
                r = function () {
                    const t = {};
                    return {
                        get: function (e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Co
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Co,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }(),
                i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1,
                        numLightProbes: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0,
                    numLightProbes: 0
                };
            for (let t = 0; t < 9; t++) i.probe.push(new Zo);
            const o = new Zo,
                a = new Ta,
                s = new Ta;
            return {
                setup: function (o, a) {
                    let s = 0,
                        l = 0,
                        c = 0;
                    for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
                    let u = 0,
                        h = 0,
                        d = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        A = 0,
                        v = 0,
                        _ = 0,
                        y = 0;
                    o.sort(qu);
                    const E = !0 === a ? Math.PI : 1;
                    for (let t = 0, e = o.length; t < e; t++) {
                        const e = o[t],
                            a = e.color,
                            x = e.intensity,
                            b = e.distance,
                            w = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) s += a.r * x * E, l += a.g * x * E, c += a.b * x * E;
                        else if (e.isLightProbe) {
                            for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(e.sh.coefficients[t], x);
                            y++
                        } else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * E), e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[u] = n, i.directionalShadowMap[u] = w, i.directionalShadowMatrix[u] = e.shadow.matrix, m++
                            }
                            i.directional[u] = t, u++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(a).multiplyScalar(x * E), t.distance = b, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, i.spot[d] = t;
                            const o = e.shadow;
                            if (e.map && (i.spotLightMap[v] = e.map, v++, o.updateMatrices(e), e.castShadow && _++), i.spotLightMatrix[d] = o.matrix, e.castShadow) {
                                const t = r.get(e);
                                t.shadowBias = o.bias, t.shadowNormalBias = o.normalBias, t.shadowRadius = o.radius, t.shadowMapSize = o.mapSize, i.spotShadow[d] = t, i.spotShadowMap[d] = w, A++
                            }
                            d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(a).multiplyScalar(x), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[p] = t, p++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * E), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[h] = n, i.pointShadowMap[h] = w, i.pointShadowMatrix[h] = e.shadow.matrix, g++
                            }
                            i.point[h] = t, h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(x * E), t.groundColor.copy(e.groundColor).multiplyScalar(x * E), i.hemi[f] = t, f++
                        }
                    }
                    p > 0 && (e.isWebGL2 ? !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Rl.LTC_FLOAT_1, i.rectAreaLTC2 = Rl.LTC_FLOAT_2) : (i.rectAreaLTC1 = Rl.LTC_HALF_1, i.rectAreaLTC2 = Rl.LTC_HALF_2) : !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Rl.LTC_FLOAT_1, i.rectAreaLTC2 = Rl.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Rl.LTC_HALF_1, i.rectAreaLTC2 = Rl.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = s, i.ambient[1] = l, i.ambient[2] = c;
                    const x = i.hash;
                    x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === A && x.numSpotMaps === v && x.numLightProbes === y || (i.directional.length = u, i.spot.length = d, i.rectArea.length = p, i.point.length = h, i.hemi.length = f, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = A, i.spotShadowMap.length = A, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = g, i.spotLightMatrix.length = A + v - _, i.spotLightMap.length = v, i.numSpotLightShadowsWithMaps = _, i.numLightProbes = y, x.directionalLength = u, x.pointLength = h, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = f, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = A, x.numSpotMaps = v, x.numLightProbes = y, i.version = Xu++)
                },
                setupView: function (t, e) {
                    let n = 0,
                        r = 0,
                        l = 0,
                        c = 0,
                        u = 0;
                    const h = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = i.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(h), n++
                        } else if (d.isSpotLight) {
                            const t = i.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(h), l++
                        } else if (d.isRectAreaLight) {
                            const t = i.rectArea[c];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), s.identity(), a.copy(d.matrixWorld), a.premultiply(h), s.extractRotation(a), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(s), t.halfHeight.applyMatrix4(s), c++
                        } else if (d.isPointLight) {
                            const t = i.point[r];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), r++
                        } else if (d.isHemisphereLight) {
                            const t = i.hemi[u];
                            t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), u++
                        }
                    }
                },
                state: i
            }
        }

        function Ku(t, e) {
            const n = new Yu(t, e),
                r = [],
                i = [];
            return {
                init: function () {
                    r.length = 0, i.length = 0
                },
                state: {
                    lightsArray: r,
                    shadowsArray: i,
                    lights: n
                },
                setupLights: function (t) {
                    n.setup(r, t)
                },
                setupLightsView: function (t) {
                    n.setupView(r, t)
                },
                pushLight: function (t) {
                    r.push(t)
                },
                pushShadow: function (t) {
                    i.push(t)
                }
            }
        }

        function Ju(t, e) {
            let n = new WeakMap;
            return {
                get: function (r, i = 0) {
                    const o = n.get(r);
                    let a;
                    return void 0 === o ? (a = new Ku(t, e), n.set(r, [a])) : i >= o.length ? (a = new Ku(t, e), o.push(a)) : a = o[i], a
                },
                dispose: function () {
                    n = new WeakMap
                }
            }
        }
        class Zu extends Es {
            constructor(t) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }
        }
        class th extends Es {
            constructor(t) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }
        }

        function eh(t, e, n) {
            let r = new Sl;
            const i = new Co,
                o = new Co,
                a = new jo,
                s = new Zu({
                    depthPacking: 3201
                }),
                l = new th,
                c = {},
                u = n.maxTextureSize,
                h = {
                    [qr]: Yr,
                    [Yr]: qr,
                    2: 2
                },
                d = new ul({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Co
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                p = d.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new Fs;
            f.setAttribute("position", new Ms(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const m = new rl(f, d),
                g = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Wr;
            let A = this.type;

            function v(n, r) {
                const o = e.update(m);
                d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new qo(i.x, i.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, o, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, o, p, m, null)
            }

            function _(e, n, r, i) {
                let o = null;
                const a = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (void 0 !== a) o = a;
                else if (o = !0 === r.isPointLight ? l : s, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const t = o.uuid,
                        e = n.uuid;
                    let r = c[t];
                    void 0 === r && (r = {}, c[t] = r);
                    let i = r[e];
                    void 0 === i && (i = o.clone(), r[e] = i, n.addEventListener("dispose", E)), o = i
                }
                if (o.visible = n.visible, o.wireframe = n.wireframe, o.side = i === Xr ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], o.alphaMap = n.alphaMap, o.alphaTest = n.alphaTest, o.map = n.map, o.clipShadows = n.clipShadows, o.clippingPlanes = n.clippingPlanes, o.clipIntersection = n.clipIntersection, o.displacementMap = n.displacementMap, o.displacementScale = n.displacementScale, o.displacementBias = n.displacementBias, o.wireframeLinewidth = n.wireframeLinewidth, o.linewidth = n.linewidth, !0 === r.isPointLight && !0 === o.isMeshDistanceMaterial) {
                    t.properties.get(o).light = r
                }
                return o
            }

            function y(n, i, o, a, s) {
                if (!1 === n.visible) return;
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === Xr) && (!n.frustumCulled || r.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    const r = e.update(n),
                        l = n.material;
                    if (Array.isArray(l)) {
                        const e = r.groups;
                        for (let c = 0, u = e.length; c < u; c++) {
                            const u = e[c],
                                h = l[u.materialIndex];
                            if (h && h.visible) {
                                const e = _(n, h, a, s);
                                n.onBeforeShadow(t, n, i, o, r, e, u), t.renderBufferDirect(o, null, r, e, n, u), n.onAfterShadow(t, n, i, o, r, e, u)
                            }
                        }
                    } else if (l.visible) {
                        const e = _(n, l, a, s);
                        n.onBeforeShadow(t, n, i, o, r, e, null), t.renderBufferDirect(o, null, r, e, n, null), n.onAfterShadow(t, n, i, o, r, e, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++) y(l[t], i, o, a, s)
            }

            function E(t) {
                t.target.removeEventListener("dispose", E);
                for (const e in c) {
                    const n = c[e],
                        r = t.target.uuid;
                    if (r in n) {
                        n[r].dispose(), delete n[r]
                    }
                }
            }
            this.render = function (e, n, s) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === e.length) return;
                const l = t.getRenderTarget(),
                    c = t.getActiveCubeFace(),
                    h = t.getActiveMipmapLevel(),
                    d = t.state;
                d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                const p = A !== Xr && this.type === Xr,
                    f = A === Xr && this.type !== Xr;
                for (let l = 0, c = e.length; l < c; l++) {
                    const c = e[l],
                        h = c.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                    i.copy(h.mapSize);
                    const m = h.getFrameExtents();
                    if (i.multiply(m), o.copy(h.mapSize), (i.x > u || i.y > u) && (i.x > u && (o.x = Math.floor(u / m.x), i.x = o.x * m.x, h.mapSize.x = o.x), i.y > u && (o.y = Math.floor(u / m.y), i.y = o.y * m.y, h.mapSize.y = o.y)), null === h.map || !0 === p || !0 === f) {
                        const t = this.type !== Xr ? {
                            minFilter: gi,
                            magFilter: gi
                        } : {};
                        null !== h.map && h.map.dispose(), h.map = new qo(i.x, i.y, t), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(h.map), t.clear();
                    const g = h.getViewportCount();
                    for (let t = 0; t < g; t++) {
                        const e = h.getViewport(t);
                        a.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), d.viewport(a), h.updateMatrices(c, t), r = h.getFrustum(), y(n, s, h.camera, c, this.type)
                    }!0 !== h.isPointLightShadow && this.type === Xr && v(h, s), h.needsUpdate = !1
                }
                A = this.type, g.needsUpdate = !1, t.setRenderTarget(l, c, h)
            }
        }

        function nh(t, e, n) {
            const r = n.isWebGL2;
            const i = new function () {
                    let e = !1;
                    const n = new jo;
                    let r = null;
                    const i = new jo(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            r === n || e || (t.colorMask(n, n, n, n), r = n)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e, r, o, a, s) {
                            !0 === s && (e *= a, r *= a, o *= a), n.set(e, r, o, a), !1 === i.equals(n) && (t.clearColor(e, r, o, a), i.copy(n))
                        },
                        reset: function () {
                            e = !1, r = null, i.set(-1, 0, 0, 0)
                        }
                    }
                },
                o = new function () {
                    let e = !1,
                        n = null,
                        r = null,
                        i = null;
                    return {
                        setTest: function (e) {
                            e ? G(t.DEPTH_TEST) : H(t.DEPTH_TEST)
                        },
                        setMask: function (r) {
                            n === r || e || (t.depthMask(r), n = r)
                        },
                        setFunc: function (e) {
                            if (r !== e) {
                                switch (e) {
                                    case 0:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case 1:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case 2:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case 3:
                                    default:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case 4:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case 5:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case 6:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case 7:
                                        t.depthFunc(t.NOTEQUAL)
                                }
                                r = e
                            }
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            i !== e && (t.clearDepth(e), i = e)
                        },
                        reset: function () {
                            e = !1, n = null, r = null, i = null
                        }
                    }
                },
                a = new function () {
                    let e = !1,
                        n = null,
                        r = null,
                        i = null,
                        o = null,
                        a = null,
                        s = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function (n) {
                            e || (n ? G(t.STENCIL_TEST) : H(t.STENCIL_TEST))
                        },
                        setMask: function (r) {
                            n === r || e || (t.stencilMask(r), n = r)
                        },
                        setFunc: function (e, n, a) {
                            r === e && i === n && o === a || (t.stencilFunc(e, n, a), r = e, i = n, o = a)
                        },
                        setOp: function (e, n, r) {
                            a === e && s === n && l === r || (t.stencilOp(e, n, r), a = e, s = n, l = r)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            c !== e && (t.clearStencil(e), c = e)
                        },
                        reset: function () {
                            e = !1, n = null, r = null, i = null, o = null, a = null, s = null, l = null, c = null
                        }
                    }
                },
                s = new WeakMap,
                l = new WeakMap;
            let c = {},
                u = {},
                h = new WeakMap,
                d = [],
                p = null,
                f = !1,
                m = null,
                g = null,
                A = null,
                v = null,
                _ = null,
                y = null,
                E = null,
                x = new vs(0, 0, 0),
                b = 0,
                w = !1,
                C = null,
                S = null,
                I = null,
                M = null,
                T = null;
            const B = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let R = !1,
                L = 0;
            const D = t.getParameter(t.VERSION); - 1 !== D.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(D)[1]), R = L >= 1) : -1 !== D.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]), R = L >= 2);
            let P = null,
                O = {};
            const k = t.getParameter(t.SCISSOR_BOX),
                U = t.getParameter(t.VIEWPORT),
                N = (new jo).fromArray(k),
                F = (new jo).fromArray(U);

            function Q(e, n, i, o) {
                const a = new Uint8Array(4),
                    s = t.createTexture();
                t.bindTexture(e, s), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (let s = 0; s < i; s++) !r || e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY ? t.texImage2D(n + s, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a) : t.texImage3D(n, 0, t.RGBA, 1, 1, o, 0, t.RGBA, t.UNSIGNED_BYTE, a);
                return s
            }
            const $ = {};

            function G(e) {
                !0 !== c[e] && (t.enable(e), c[e] = !0)
            }

            function H(e) {
                !1 !== c[e] && (t.disable(e), c[e] = !1)
            }
            $[t.TEXTURE_2D] = Q(t.TEXTURE_2D, t.TEXTURE_2D, 1), $[t.TEXTURE_CUBE_MAP] = Q(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && ($[t.TEXTURE_2D_ARRAY] = Q(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), $[t.TEXTURE_3D] = Q(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), i.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), G(t.DEPTH_TEST), o.setFunc(3), j(!1), X(1), G(t.CULL_FACE), W(0);
            const z = {
                [Kr]: t.FUNC_ADD,
                101: t.FUNC_SUBTRACT,
                102: t.FUNC_REVERSE_SUBTRACT
            };
            if (r) z[103] = t.MIN, z[104] = t.MAX;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (z[103] = t.MIN_EXT, z[104] = t.MAX_EXT)
            }
            const V = {
                200: t.ZERO,
                201: t.ONE,
                202: t.SRC_COLOR,
                204: t.SRC_ALPHA,
                210: t.SRC_ALPHA_SATURATE,
                208: t.DST_COLOR,
                206: t.DST_ALPHA,
                203: t.ONE_MINUS_SRC_COLOR,
                205: t.ONE_MINUS_SRC_ALPHA,
                209: t.ONE_MINUS_DST_COLOR,
                207: t.ONE_MINUS_DST_ALPHA,
                211: t.CONSTANT_COLOR,
                212: t.ONE_MINUS_CONSTANT_COLOR,
                213: t.CONSTANT_ALPHA,
                214: t.ONE_MINUS_CONSTANT_ALPHA
            };

            function W(e, n, r, i, o, a, s, l, c, u) {
                if (0 !== e) {
                    if (!1 === f && (G(t.BLEND), f = !0), 5 === e) o = o || n, a = a || r, s = s || i, n === g && o === _ || (t.blendEquationSeparate(z[n], z[o]), g = n, _ = o), r === A && i === v && a === y && s === E || (t.blendFuncSeparate(V[r], V[i], V[a], V[s]), A = r, v = i, y = a, E = s), !1 !== l.equals(x) && c === b || (t.blendColor(l.r, l.g, l.b, c), x.copy(l), b = c), m = e, w = !1;
                    else if (e !== m || u !== w) {
                        if (g === Kr && _ === Kr || (t.blendEquation(t.FUNC_ADD), g = Kr, _ = Kr), u) switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.ONE, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.SRC_ALPHA, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFunc(t.ZERO, t.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        A = null, v = null, y = null, E = null, x.set(0, 0, 0), b = 0, m = e, w = u
                    }
                } else !0 === f && (H(t.BLEND), f = !1)
            }

            function j(e) {
                C !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), C = e)
            }

            function X(e) {
                0 !== e ? (G(t.CULL_FACE), e !== S && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : H(t.CULL_FACE), S = e
            }

            function q(e, n, r) {
                e ? (G(t.POLYGON_OFFSET_FILL), M === n && T === r || (t.polygonOffset(n, r), M = n, T = r)) : H(t.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: i,
                    depth: o,
                    stencil: a
                },
                enable: G,
                disable: H,
                bindFramebuffer: function (e, n) {
                    return u[e] !== n && (t.bindFramebuffer(e, n), u[e] = n, r && (e === t.DRAW_FRAMEBUFFER && (u[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (u[t.DRAW_FRAMEBUFFER] = n)), !0)
                },
                drawBuffers: function (r, i) {
                    let o = d,
                        a = !1;
                    if (r) {
                        o = h.get(i), void 0 === o && (o = [], h.set(i, o));
                        const e = r.textures;
                        if (o.length !== e.length || o[0] !== t.COLOR_ATTACHMENT0) {
                            for (let n = 0, r = e.length; n < r; n++) o[n] = t.COLOR_ATTACHMENT0 + n;
                            o.length = e.length, a = !0
                        }
                    } else o[0] !== t.BACK && (o[0] = t.BACK, a = !0);
                    if (a)
                        if (n.isWebGL2) t.drawBuffers(o);
                        else {
                            if (!0 !== e.has("WEBGL_draw_buffers")) throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension");
                            e.get("WEBGL_draw_buffers").drawBuffersWEBGL(o)
                        }
                },
                useProgram: function (e) {
                    return p !== e && (t.useProgram(e), p = e, !0)
                },
                setBlending: W,
                setMaterial: function (e, n) {
                    2 === e.side ? H(t.CULL_FACE) : G(t.CULL_FACE);
                    let r = e.side === Yr;
                    n && (r = !r), j(r), 1 === e.blending && !1 === e.transparent ? W(0) : W(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.blendColor, e.blendAlpha, e.premultipliedAlpha), o.setFunc(e.depthFunc), o.setTest(e.depthTest), o.setMask(e.depthWrite), i.setMask(e.colorWrite);
                    const s = e.stencilWrite;
                    a.setTest(s), s && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? G(t.SAMPLE_ALPHA_TO_COVERAGE) : H(t.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: j,
                setCullFace: X,
                setLineWidth: function (e) {
                    e !== I && (R && t.lineWidth(e), I = e)
                },
                setPolygonOffset: q,
                setScissorTest: function (e) {
                    e ? G(t.SCISSOR_TEST) : H(t.SCISSOR_TEST)
                },
                activeTexture: function (e) {
                    void 0 === e && (e = t.TEXTURE0 + B - 1), P !== e && (t.activeTexture(e), P = e)
                },
                bindTexture: function (e, n, r) {
                    void 0 === r && (r = null === P ? t.TEXTURE0 + B - 1 : P);
                    let i = O[r];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, O[r] = i), i.type === e && i.texture === n || (P !== r && (t.activeTexture(r), P = r), t.bindTexture(e, n || $[e]), i.type = e, i.texture = n)
                },
                unbindTexture: function () {
                    const e = O[P];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function () {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexImage3D: function () {
                    try {
                        t.compressedTexImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function () {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function () {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                updateUBOMapping: function (e, n) {
                    let r = l.get(n);
                    void 0 === r && (r = new WeakMap, l.set(n, r));
                    let i = r.get(e);
                    void 0 === i && (i = t.getUniformBlockIndex(n, e.name), r.set(e, i))
                },
                uniformBlockBinding: function (e, n) {
                    const r = l.get(n).get(e);
                    s.get(n) !== r && (t.uniformBlockBinding(n, r, e.__bindingPointIndex), s.set(n, r))
                },
                texStorage2D: function () {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function () {
                    try {
                        t.texStorage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function () {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function () {
                    try {
                        t.texSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function () {
                    try {
                        t.compressedTexSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage3D: function () {
                    try {
                        t.compressedTexSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function (e) {
                    !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e))
                },
                viewport: function (e) {
                    !1 === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), F.copy(e))
                },
                reset: function () {
                    t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === r && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), c = {}, P = null, O = {}, u = {}, h = new WeakMap, d = [], p = null, f = !1, m = null, g = null, A = null, v = null, _ = null, y = null, E = null, x = new vs(0, 0, 0), b = 0, w = !1, C = null, S = null, I = null, M = null, T = null, N.set(0, 0, t.canvas.width, t.canvas.height), F.set(0, 0, t.canvas.width, t.canvas.height), i.reset(), o.reset(), a.reset()
                }
            }
        }

        function rh(t, e, n, r, i, o, a) {
            const s = i.isWebGL2,
                l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                u = new Co,
                h = new WeakMap;
            let d;
            const p = new WeakMap;
            let f = !1;
            try {
                f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function m(t, e) {
                return f ? new OffscreenCanvas(t, e) : To("canvas")
            }

            function g(t, e, n, r) {
                let i = 1;
                const o = Q(t);
                if ((o.width > r || o.height > r) && (i = r / Math.max(o.width, o.height)), i < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof VideoFrame && t instanceof VideoFrame) {
                        const r = e ? Eo : Math.floor,
                            a = r(i * o.width),
                            s = r(i * o.height);
                        void 0 === d && (d = m(a, s));
                        const l = n ? m(a, s) : d;
                        l.width = a, l.height = s;
                        return l.getContext("2d").drawImage(t, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + o.width + "x" + o.height + ") to (" + a + "x" + s + ")."), l
                    }
                    return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + o.width + "x" + o.height + ")."), t
                }
                return t
            }

            function A(t) {
                const e = Q(t);
                return yo(e.width) && yo(e.height)
            }

            function v(t, e) {
                return t.generateMipmaps && e && t.minFilter !== gi && t.minFilter !== _i
            }

            function _(e) {
                t.generateMipmap(e)
            }

            function y(n, r, i, o, a = !1) {
                if (!1 === s) return r;
                if (null !== n) {
                    if (void 0 !== t[n]) return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = r;
                if (r === t.RED && (i === t.FLOAT && (l = t.R32F), i === t.HALF_FLOAT && (l = t.R16F), i === t.UNSIGNED_BYTE && (l = t.R8)), r === t.RED_INTEGER && (i === t.UNSIGNED_BYTE && (l = t.R8UI), i === t.UNSIGNED_SHORT && (l = t.R16UI), i === t.UNSIGNED_INT && (l = t.R32UI), i === t.BYTE && (l = t.R8I), i === t.SHORT && (l = t.R16I), i === t.INT && (l = t.R32I)), r === t.RG && (i === t.FLOAT && (l = t.RG32F), i === t.HALF_FLOAT && (l = t.RG16F), i === t.UNSIGNED_BYTE && (l = t.RG8)), r === t.RG_INTEGER && (i === t.UNSIGNED_BYTE && (l = t.RG8UI), i === t.UNSIGNED_SHORT && (l = t.RG16UI), i === t.UNSIGNED_INT && (l = t.RG32UI), i === t.BYTE && (l = t.RG8I), i === t.SHORT && (l = t.RG16I), i === t.INT && (l = t.RG32I)), r === t.RGBA) {
                    const e = a ? to : Uo.getTransfer(o);
                    i === t.FLOAT && (l = t.RGBA32F), i === t.HALF_FLOAT && (l = t.RGBA16F), i === t.UNSIGNED_BYTE && (l = e === eo ? t.SRGB8_ALPHA8 : t.RGBA8), i === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), i === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)
                }
                return l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
            }

            function E(t, e, n) {
                return !0 === v(t, n) || t.isFramebufferTexture && t.minFilter !== gi && t.minFilter !== _i ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }

            function x(e) {
                return e === gi || e === Ai || e === vi ? t.NEAREST : t.LINEAR
            }

            function b(t) {
                const e = t.target;
                e.removeEventListener("dispose", b),
                    function (t) {
                        const e = r.get(t);
                        if (void 0 === e.__webglInit) return;
                        const n = t.source,
                            i = p.get(n);
                        if (i) {
                            const r = i[e.__cacheKey];
                            r.usedTimes--, 0 === r.usedTimes && C(t), 0 === Object.keys(i).length && p.delete(n)
                        }
                        r.remove(t)
                    }(e), e.isVideoTexture && h.delete(e)
            }

            function w(e) {
                const n = e.target;
                n.removeEventListener("dispose", w),
                    function (e) {
                        const n = r.get(e);
                        e.depthTexture && e.depthTexture.dispose();
                        if (e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++) {
                                if (Array.isArray(n.__webglFramebuffer[e]))
                                    for (let r = 0; r < n.__webglFramebuffer[e].length; r++) t.deleteFramebuffer(n.__webglFramebuffer[e][r]);
                                else t.deleteFramebuffer(n.__webglFramebuffer[e]);
                                n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e])
                            } else {
                                if (Array.isArray(n.__webglFramebuffer))
                                    for (let e = 0; e < n.__webglFramebuffer.length; e++) t.deleteFramebuffer(n.__webglFramebuffer[e]);
                                else t.deleteFramebuffer(n.__webglFramebuffer);
                                if (n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                                    for (let e = 0; e < n.__webglColorRenderbuffer.length; e++) n.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(n.__webglColorRenderbuffer[e]);
                                n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                            }
                        const i = e.textures;
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = r.get(i[e]);
                            n.__webglTexture && (t.deleteTexture(n.__webglTexture), a.memory.textures--), r.remove(i[e])
                        }
                        r.remove(e)
                    }(n)
            }

            function C(e) {
                const n = r.get(e);
                t.deleteTexture(n.__webglTexture);
                const i = e.source;
                delete p.get(i)[n.__cacheKey], a.memory.textures--
            }
            let S = 0;

            function I(e, i) {
                const o = r.get(e);
                if (e.isVideoTexture && function (t) {
                        const e = a.render.frame;
                        h.get(t) !== e && (h.set(t, e), t.update())
                    }(e), !1 === e.isRenderTargetTexture && e.version > 0 && o.__version !== e.version) {
                    const t = e.image;
                    if (null === t) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== t.complete) return void D(o, e, i);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(t.TEXTURE_2D, o.__webglTexture, t.TEXTURE0 + i)
            }
            const M = {
                    [pi]: t.REPEAT,
                    [fi]: t.CLAMP_TO_EDGE,
                    [mi]: t.MIRRORED_REPEAT
                },
                T = {
                    [gi]: t.NEAREST,
                    [Ai]: t.NEAREST_MIPMAP_NEAREST,
                    [vi]: t.NEAREST_MIPMAP_LINEAR,
                    [_i]: t.LINEAR,
                    [yi]: t.LINEAR_MIPMAP_NEAREST,
                    [Ei]: t.LINEAR_MIPMAP_LINEAR
                },
                B = {
                    512: t.NEVER,
                    519: t.ALWAYS,
                    513: t.LESS,
                    515: t.LEQUAL,
                    514: t.EQUAL,
                    518: t.GEQUAL,
                    516: t.GREATER,
                    517: t.NOTEQUAL
                };

            function R(n, o, a) {
                if (o.type !== Si || !1 !== e.has("OES_texture_float_linear") || o.magFilter !== _i && o.magFilter !== yi && o.magFilter !== vi && o.magFilter !== Ei && o.minFilter !== _i && o.minFilter !== yi && o.minFilter !== vi && o.minFilter !== Ei || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), a ? (t.texParameteri(n, t.TEXTURE_WRAP_S, M[o.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, M[o.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, M[o.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, T[o.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, T[o.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), o.wrapS === fi && o.wrapT === fi || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, x(o.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, x(o.minFilter)), o.minFilter !== gi && o.minFilter !== _i && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), o.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, B[o.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    if (o.magFilter === gi) return;
                    if (o.minFilter !== vi && o.minFilter !== Ei) return;
                    if (o.type === Si && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === s && o.type === Ii && !1 === e.has("OES_texture_half_float_linear")) return;
                    if (o.anisotropy > 1 || r.get(o).__currentAnisotropy) {
                        const a = e.get("EXT_texture_filter_anisotropic");
                        t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())), r.get(o).__currentAnisotropy = o.anisotropy
                    }
                }
            }

            function L(e, n) {
                let r = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", b));
                const i = n.source;
                let o = p.get(i);
                void 0 === o && (o = {}, p.set(i, o));
                const s = function (t) {
                    const e = [];
                    return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join()
                }(n);
                if (s !== e.__cacheKey) {
                    void 0 === o[s] && (o[s] = {
                        texture: t.createTexture(),
                        usedTimes: 0
                    }, a.memory.textures++, r = !0), o[s].usedTimes++;
                    const i = o[e.__cacheKey];
                    void 0 !== i && (o[e.__cacheKey].usedTimes--, 0 === i.usedTimes && C(n)), e.__cacheKey = s, e.__webglTexture = o[s].texture
                }
                return r
            }

            function D(e, a, l) {
                let c = t.TEXTURE_2D;
                (a.isDataArrayTexture || a.isCompressedArrayTexture) && (c = t.TEXTURE_2D_ARRAY), a.isData3DTexture && (c = t.TEXTURE_3D);
                const u = L(e, a),
                    h = a.source;
                n.bindTexture(c, e.__webglTexture, t.TEXTURE0 + l);
                const d = r.get(h);
                if (h.version !== d.__version || !0 === u) {
                    n.activeTexture(t.TEXTURE0 + l);
                    const e = Uo.getPrimaries(Uo.workingColorSpace),
                        r = a.colorSpace === qi ? null : Uo.getPrimaries(a.colorSpace),
                        p = a.colorSpace === qi || e === r ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
                    const f = function (t) {
                        return !s && (t.wrapS !== fi || t.wrapT !== fi || t.minFilter !== gi && t.minFilter !== _i)
                    }(a) && !1 === A(a.image);
                    let m = g(a.image, f, !1, i.maxTextureSize);
                    m = F(a, m);
                    const x = A(m) || s,
                        b = o.convert(a.format, a.colorSpace);
                    let w, C = o.convert(a.type),
                        S = y(a.internalFormat, b, C, a.colorSpace, a.isVideoTexture);
                    R(c, a, x);
                    const I = a.mipmaps,
                        M = s && !0 !== a.isVideoTexture && S !== Qi,
                        T = void 0 === d.__version || !0 === u,
                        B = h.dataReady,
                        L = E(a, m, x);
                    if (a.isDepthTexture) S = t.DEPTH_COMPONENT, s ? S = a.type === Si ? t.DEPTH_COMPONENT32F : a.type === Ci ? t.DEPTH_COMPONENT24 : a.type === Mi ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : a.type === Si && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), a.format === Bi && S === t.DEPTH_COMPONENT && a.type !== bi && a.type !== Ci && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), a.type = Ci, C = o.convert(a.type)), a.format === Ri && S === t.DEPTH_COMPONENT && (S = t.DEPTH_STENCIL, a.type !== Mi && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), a.type = Mi, C = o.convert(a.type))), T && (M ? n.texStorage2D(t.TEXTURE_2D, 1, S, m.width, m.height) : n.texImage2D(t.TEXTURE_2D, 0, S, m.width, m.height, 0, b, C, null));
                    else if (a.isDataTexture)
                        if (I.length > 0 && x) {
                            M && T && n.texStorage2D(t.TEXTURE_2D, L, S, I[0].width, I[0].height);
                            for (let e = 0, r = I.length; e < r; e++) w = I[e], M ? B && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, w.width, w.height, b, C, w.data) : n.texImage2D(t.TEXTURE_2D, e, S, w.width, w.height, 0, b, C, w.data);
                            a.generateMipmaps = !1
                        } else M ? (T && n.texStorage2D(t.TEXTURE_2D, L, S, m.width, m.height), B && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, m.width, m.height, b, C, m.data)) : n.texImage2D(t.TEXTURE_2D, 0, S, m.width, m.height, 0, b, C, m.data);
                    else if (a.isCompressedTexture)
                        if (a.isCompressedArrayTexture) {
                            M && T && n.texStorage3D(t.TEXTURE_2D_ARRAY, L, S, I[0].width, I[0].height, m.depth);
                            for (let e = 0, r = I.length; e < r; e++) w = I[e], a.format !== Ti ? null !== b ? M ? B && n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, w.width, w.height, m.depth, b, w.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, S, w.width, w.height, m.depth, 0, w.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? B && n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, w.width, w.height, m.depth, b, C, w.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, S, w.width, w.height, m.depth, 0, b, C, w.data)
                        } else {
                            M && T && n.texStorage2D(t.TEXTURE_2D, L, S, I[0].width, I[0].height);
                            for (let e = 0, r = I.length; e < r; e++) w = I[e], a.format !== Ti ? null !== b ? M ? B && n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, w.width, w.height, b, w.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, S, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? B && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, w.width, w.height, b, C, w.data) : n.texImage2D(t.TEXTURE_2D, e, S, w.width, w.height, 0, b, C, w.data)
                        }
                    else if (a.isDataArrayTexture) M ? (T && n.texStorage3D(t.TEXTURE_2D_ARRAY, L, S, m.width, m.height, m.depth), B && n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, m.width, m.height, m.depth, b, C, m.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, S, m.width, m.height, m.depth, 0, b, C, m.data);
                    else if (a.isData3DTexture) M ? (T && n.texStorage3D(t.TEXTURE_3D, L, S, m.width, m.height, m.depth), B && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, m.width, m.height, m.depth, b, C, m.data)) : n.texImage3D(t.TEXTURE_3D, 0, S, m.width, m.height, m.depth, 0, b, C, m.data);
                    else if (a.isFramebufferTexture) {
                        if (T)
                            if (M) n.texStorage2D(t.TEXTURE_2D, L, S, m.width, m.height);
                            else {
                                let e = m.width,
                                    r = m.height;
                                for (let i = 0; i < L; i++) n.texImage2D(t.TEXTURE_2D, i, S, e, r, 0, b, C, null), e >>= 1, r >>= 1
                            }
                    } else if (I.length > 0 && x) {
                        if (M && T) {
                            const e = Q(I[0]);
                            n.texStorage2D(t.TEXTURE_2D, L, S, e.width, e.height)
                        }
                        for (let e = 0, r = I.length; e < r; e++) w = I[e], M ? B && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, b, C, w) : n.texImage2D(t.TEXTURE_2D, e, S, b, C, w);
                        a.generateMipmaps = !1
                    } else if (M) {
                        if (T) {
                            const e = Q(m);
                            n.texStorage2D(t.TEXTURE_2D, L, S, e.width, e.height)
                        }
                        B && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, b, C, m)
                    } else n.texImage2D(t.TEXTURE_2D, 0, S, b, C, m);
                    v(a, x) && _(c), d.__version = h.version, a.onUpdate && a.onUpdate(a)
                }
                e.__version = a.version
            }

            function P(e, i, a, s, c, u) {
                const h = o.convert(a.format, a.colorSpace),
                    d = o.convert(a.type),
                    p = y(a.internalFormat, h, d, a.colorSpace);
                if (!r.get(i).__hasExternalTextures) {
                    const e = Math.max(1, i.width >> u),
                        r = Math.max(1, i.height >> u);
                    c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, p, e, r, i.depth, 0, h, d, null) : n.texImage2D(c, u, p, e, r, 0, h, d, null)
                }
                n.bindFramebuffer(t.FRAMEBUFFER, e), N(i) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, s, c, r.get(a).__webglTexture, 0, U(i)) : (c === t.TEXTURE_2D || c >= t.TEXTURE_CUBE_MAP_POSITIVE_X && c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, s, c, r.get(a).__webglTexture, u), n.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function O(e, n, r) {
                if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                    let i = !0 === s ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
                    if (r || N(n)) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === Si ? i = t.DEPTH_COMPONENT32F : e.type === Ci && (i = t.DEPTH_COMPONENT24));
                        const r = U(n);
                        N(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, i, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, r, i, n.width, n.height)
                    } else t.renderbufferStorage(t.RENDERBUFFER, i, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const i = U(n);
                    r && !1 === N(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, i, t.DEPTH24_STENCIL8, n.width, n.height) : N(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                } else {
                    const e = n.textures;
                    for (let i = 0; i < e.length; i++) {
                        const a = e[i],
                            s = o.convert(a.format, a.colorSpace),
                            c = o.convert(a.type),
                            u = y(a.internalFormat, s, c, a.colorSpace),
                            h = U(n);
                        r && !1 === N(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, h, u, n.width, n.height) : N(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, h, u, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, u, n.width, n.height)
                    }
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null)
            }

            function k(e) {
                const i = r.get(e),
                    o = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !i.__autoAllocateDepthBuffer) {
                    if (o) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function (e, i) {
                        if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(t.FRAMEBUFFER, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), I(i.depthTexture, 0);
                        const o = r.get(i.depthTexture).__webglTexture,
                            a = U(i);
                        if (i.depthTexture.format === Bi) N(i) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, o, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, o, 0);
                        else {
                            if (i.depthTexture.format !== Ri) throw new Error("Unknown depthTexture format");
                            N(i) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, o, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, o, 0)
                        }
                    }(i.__webglFramebuffer, e)
                } else if (o) {
                    i.__webglDepthbuffer = [];
                    for (let r = 0; r < 6; r++) n.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), O(i.__webglDepthbuffer[r], e, !1)
                } else n.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), O(i.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function U(t) {
                return Math.min(i.maxSamples, t.samples)
            }

            function N(t) {
                const n = r.get(t);
                return s && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function F(t, n) {
                const r = t.colorSpace,
                    i = t.format,
                    o = t.type;
                return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === so || r !== Ki && r !== qi && (Uo.getTransfer(r) === eo ? !1 === s ? !0 === e.has("EXT_sRGB") && i === Ti ? (t.format = so, t.minFilter = _i, t.generateMipmaps = !1) : n = $o.sRGBToLinear(n) : i === Ti && o === xi || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", r)), n
            }

            function Q(t) {
                return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement ? (u.width = t.naturalWidth || t.width, u.height = t.naturalHeight || t.height) : "undefined" != typeof VideoFrame && t instanceof VideoFrame ? (u.width = t.displayWidth, u.height = t.displayHeight) : (u.width = t.width, u.height = t.height), u
            }
            this.allocateTextureUnit = function () {
                const t = S;
                return t >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + i.maxTextures), S += 1, t
            }, this.resetTextureUnits = function () {
                S = 0
            }, this.setTexture2D = I, this.setTexture2DArray = function (e, i) {
                const o = r.get(e);
                e.version > 0 && o.__version !== e.version ? D(o, e, i) : n.bindTexture(t.TEXTURE_2D_ARRAY, o.__webglTexture, t.TEXTURE0 + i)
            }, this.setTexture3D = function (e, i) {
                const o = r.get(e);
                e.version > 0 && o.__version !== e.version ? D(o, e, i) : n.bindTexture(t.TEXTURE_3D, o.__webglTexture, t.TEXTURE0 + i)
            }, this.setTextureCube = function (e, a) {
                const l = r.get(e);
                e.version > 0 && l.__version !== e.version ? function (e, a, l) {
                    if (6 !== a.image.length) return;
                    const c = L(e, a),
                        u = a.source;
                    n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + l);
                    const h = r.get(u);
                    if (u.version !== h.__version || !0 === c) {
                        n.activeTexture(t.TEXTURE0 + l);
                        const e = Uo.getPrimaries(Uo.workingColorSpace),
                            r = a.colorSpace === qi ? null : Uo.getPrimaries(a.colorSpace),
                            d = a.colorSpace === qi || e === r ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                        const p = a.isCompressedTexture || a.image[0].isCompressedTexture,
                            f = a.image[0] && a.image[0].isDataTexture,
                            m = [];
                        for (let t = 0; t < 6; t++) m[t] = p || f ? f ? a.image[t].image : a.image[t] : g(a.image[t], !1, !0, i.maxCubemapSize), m[t] = F(a, m[t]);
                        const x = m[0],
                            b = A(x) || s,
                            w = o.convert(a.format, a.colorSpace),
                            C = o.convert(a.type),
                            S = y(a.internalFormat, w, C, a.colorSpace),
                            I = s && !0 !== a.isVideoTexture,
                            M = void 0 === h.__version || !0 === c,
                            T = u.dataReady;
                        let B, L = E(a, x, b);
                        if (R(t.TEXTURE_CUBE_MAP, a, b), p) {
                            I && M && n.texStorage2D(t.TEXTURE_CUBE_MAP, L, S, x.width, x.height);
                            for (let e = 0; e < 6; e++) {
                                B = m[e].mipmaps;
                                for (let r = 0; r < B.length; r++) {
                                    const i = B[r];
                                    a.format !== Ti ? null !== w ? I ? T && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, i.width, i.height, w, i.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, S, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : I ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, i.width, i.height, w, C, i.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, S, i.width, i.height, 0, w, C, i.data)
                                }
                            }
                        } else {
                            if (B = a.mipmaps, I && M) {
                                B.length > 0 && L++;
                                const e = Q(m[0]);
                                n.texStorage2D(t.TEXTURE_CUBE_MAP, L, S, e.width, e.height)
                            }
                            for (let e = 0; e < 6; e++)
                                if (f) {
                                    I ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, m[e].width, m[e].height, w, C, m[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, S, m[e].width, m[e].height, 0, w, C, m[e].data);
                                    for (let r = 0; r < B.length; r++) {
                                        const i = B[r].image[e].image;
                                        I ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, 0, 0, i.width, i.height, w, C, i.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, S, i.width, i.height, 0, w, C, i.data)
                                    }
                                } else {
                                    I ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, w, C, m[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, S, w, C, m[e]);
                                    for (let r = 0; r < B.length; r++) {
                                        const i = B[r];
                                        I ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, 0, 0, w, C, i.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, S, w, C, i.image[e])
                                    }
                                }
                        }
                        v(a, b) && _(t.TEXTURE_CUBE_MAP), h.__version = u.version, a.onUpdate && a.onUpdate(a)
                    }
                    e.__version = a.version
                }(l, e, a) : n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture, t.TEXTURE0 + a)
            }, this.rebindTextures = function (e, n, i) {
                const o = r.get(e);
                void 0 !== n && P(o.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), void 0 !== i && k(e)
            }, this.setupRenderTarget = function (e) {
                const l = e.texture,
                    c = r.get(e),
                    u = r.get(l);
                e.addEventListener("dispose", w);
                const h = e.textures,
                    d = !0 === e.isWebGLCubeRenderTarget,
                    p = h.length > 1,
                    f = A(e) || s;
                if (p || (void 0 === u.__webglTexture && (u.__webglTexture = t.createTexture()), u.__version = l.version, a.memory.textures++), d) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        if (s && l.mipmaps && l.mipmaps.length > 0) {
                            c.__webglFramebuffer[e] = [];
                            for (let n = 0; n < l.mipmaps.length; n++) c.__webglFramebuffer[e][n] = t.createFramebuffer()
                        } else c.__webglFramebuffer[e] = t.createFramebuffer()
                } else {
                    if (s && l.mipmaps && l.mipmaps.length > 0) {
                        c.__webglFramebuffer = [];
                        for (let e = 0; e < l.mipmaps.length; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                    } else c.__webglFramebuffer = t.createFramebuffer();
                    if (p)
                        if (i.drawBuffers)
                            for (let e = 0, n = h.length; e < n; e++) {
                                const n = r.get(h[e]);
                                void 0 === n.__webglTexture && (n.__webglTexture = t.createTexture(), a.memory.textures++)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (s && e.samples > 0 && !1 === N(e)) {
                        c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                        for (let n = 0; n < h.length; n++) {
                            const r = h[n];
                            c.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const i = o.convert(r.format, r.colorSpace),
                                a = o.convert(r.type),
                                s = y(r.internalFormat, i, a, r.colorSpace, !0 === e.isXRRenderTarget),
                                l = U(e);
                            t.renderbufferStorageMultisample(t.RENDERBUFFER, l, s, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), O(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                }
                if (d) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, u.__webglTexture), R(t.TEXTURE_CUBE_MAP, l, f);
                    for (let n = 0; n < 6; n++)
                        if (s && l.mipmaps && l.mipmaps.length > 0)
                            for (let r = 0; r < l.mipmaps.length; r++) P(c.__webglFramebuffer[n][r], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                        else P(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    v(l, f) && _(t.TEXTURE_CUBE_MAP), n.unbindTexture()
                } else if (p) {
                    for (let i = 0, o = h.length; i < o; i++) {
                        const o = h[i],
                            a = r.get(o);
                        n.bindTexture(t.TEXTURE_2D, a.__webglTexture), R(t.TEXTURE_2D, o, f), P(c.__webglFramebuffer, e, o, t.COLOR_ATTACHMENT0 + i, t.TEXTURE_2D, 0), v(o, f) && _(t.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let r = t.TEXTURE_2D;
                    if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (s ? r = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(r, u.__webglTexture), R(r, l, f), s && l.mipmaps && l.mipmaps.length > 0)
                        for (let n = 0; n < l.mipmaps.length; n++) P(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, r, n);
                    else P(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, r, 0);
                    v(l, f) && _(r), n.unbindTexture()
                }
                e.depthBuffer && k(e)
            }, this.updateRenderTargetMipmap = function (e) {
                const i = A(e) || s,
                    o = e.textures;
                for (let a = 0, s = o.length; a < s; a++) {
                    const s = o[a];
                    if (v(s, i)) {
                        const i = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                            o = r.get(s).__webglTexture;
                        n.bindTexture(i, o), _(i), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function (e) {
                if (s && e.samples > 0 && !1 === N(e)) {
                    const i = e.textures,
                        o = e.width,
                        a = e.height;
                    let s = t.COLOR_BUFFER_BIT;
                    const l = [],
                        u = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                        h = r.get(e),
                        d = i.length > 1;
                    if (d)
                        for (let e = 0; e < i.length; e++) n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(t.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                    for (let n = 0; n < i.length; n++) {
                        l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(u);
                        const p = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                        if (!1 === p && (e.depthBuffer && (s |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (s |= t.STENCIL_BUFFER_BIT)), d && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, h.__webglColorRenderbuffer[n]), !0 === p && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [u]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [u])), d) {
                            const e = r.get(i[n]).__webglTexture;
                            t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                        }
                        t.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, t.NEAREST), c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l)
                    }
                    if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), d)
                        for (let e = 0; e < i.length; e++) {
                            n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, h.__webglColorRenderbuffer[e]);
                            const o = r.get(i[e]).__webglTexture;
                            n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, o, 0)
                        }
                    n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = k, this.setupFrameBufferTexture = P, this.useMultisampledRTT = N
        }

        function ih(t, e, n) {
            const r = n.isWebGL2;
            return {
                convert: function (n, i = qi) {
                    let o;
                    const a = Uo.getTransfer(i);
                    if (n === xi) return t.UNSIGNED_BYTE;
                    if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
                    if (1010 === n) return t.BYTE;
                    if (1011 === n) return t.SHORT;
                    if (n === bi) return t.UNSIGNED_SHORT;
                    if (n === wi) return t.INT;
                    if (n === Ci) return t.UNSIGNED_INT;
                    if (n === Si) return t.FLOAT;
                    if (n === Ii) return r ? t.HALF_FLOAT : (o = e.get("OES_texture_half_float"), null !== o ? o.HALF_FLOAT_OES : null);
                    if (1021 === n) return t.ALPHA;
                    if (n === Ti) return t.RGBA;
                    if (1024 === n) return t.LUMINANCE;
                    if (1025 === n) return t.LUMINANCE_ALPHA;
                    if (n === Bi) return t.DEPTH_COMPONENT;
                    if (n === Ri) return t.DEPTH_STENCIL;
                    if (n === so) return o = e.get("EXT_sRGB"), null !== o ? o.SRGB_ALPHA_EXT : null;
                    if (n === Li) return t.RED;
                    if (1029 === n) return t.RED_INTEGER;
                    if (n === Di) return t.RG;
                    if (1031 === n) return t.RG_INTEGER;
                    if (1033 === n) return t.RGBA_INTEGER;
                    if (n === Pi || n === Oi || n === ki || n === Ui)
                        if (a === eo) {
                            if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === o) return null;
                            if (n === Pi) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === Oi) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === ki) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === Ui) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (o = e.get("WEBGL_compressed_texture_s3tc"), null === o) return null;
                            if (n === Pi) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === Oi) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === ki) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === Ui) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        } if (n === Ni || 35841 === n || n === Fi || 35843 === n) {
                        if (o = e.get("WEBGL_compressed_texture_pvrtc"), null === o) return null;
                        if (n === Ni) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === Fi) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (n === Qi) return o = e.get("WEBGL_compressed_texture_etc1"), null !== o ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (n === $i || n === Gi) {
                        if (o = e.get("WEBGL_compressed_texture_etc"), null === o) return null;
                        if (n === $i) return a === eo ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
                        if (n === Gi) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === Hi || 37809 === n || 37810 === n || 37811 === n || n === zi || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                        if (o = e.get("WEBGL_compressed_texture_astc"), null === o) return null;
                        if (n === Hi) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === zi) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === n) return a === eo ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === Vi || 36494 === n || 36495 === n) {
                        if (o = e.get("EXT_texture_compression_bptc"), null === o) return null;
                        if (n === Vi) return a === eo ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (36494 === n) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (36495 === n) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                        if (o = e.get("EXT_texture_compression_rgtc"), null === o) return null;
                        if (n === Vi) return o.COMPRESSED_RED_RGTC1_EXT;
                        if (36284 === n) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (36285 === n) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (36286 === n) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === Mi ? r ? t.UNSIGNED_INT_24_8 : (o = e.get("WEBGL_depth_texture"), null !== o ? o.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null
                }
            }
        }
        class oh extends ml {
            constructor(t = []) {
                super(), this.isArrayCamera = !0, this.cameras = t
            }
        }
        class ah extends ns {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }
        const sh = {
            type: "move"
        };
        class lh {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new ah, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new ah, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Zo, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Zo), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new ah, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Zo, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Zo), this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            }
            connect(t) {
                if (t && t.hand) {
                    const e = this._hand;
                    if (e)
                        for (const n of t.hand.values()) this._getHandJoint(e, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: t
                }), this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(t, e, n) {
                let r = null,
                    i = null,
                    o = null;
                const a = this._targetRay,
                    s = this._grip,
                    l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState) {
                    if (l && t.hand) {
                        o = !0;
                        for (const r of t.hand.values()) {
                            const t = e.getJointPose(r, n),
                                i = this._getHandJoint(l, r);
                            null !== t && (i.matrix.fromArray(t.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.matrixWorldNeedsUpdate = !0, i.jointRadius = t.radius), i.visible = null !== t
                        }
                        const r = l.joints["index-finger-tip"],
                            i = l.joints["thumb-tip"],
                            a = r.position.distanceTo(i.position),
                            s = .02,
                            c = .005;
                        l.inputState.pinching && a > s + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && a <= s - c && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else null !== s && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1));
                    null !== a && (r = e.getPose(t.targetRaySpace, n), null === r && null !== i && (r = i), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(sh)))
                }
                return null !== a && (a.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== o), this
            }
            _getHandJoint(t, e) {
                if (void 0 === t.joints[e.jointName]) {
                    const n = new ah;
                    n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
                }
                return t.joints[e.jointName]
            }
        }
        class ch {
            constructor() {
                this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
            }
            init(t, e, n) {
                if (null === this.texture) {
                    const r = new Wo;
                    t.properties.get(r).__webglTexture = e.texture, e.depthNear == n.depthNear && e.depthFar == n.depthFar || (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = r
                }
            }
            render(t, e) {
                if (null !== this.texture) {
                    if (null === this.mesh) {
                        const t = e.cameras[0].viewport,
                            n = new ul({
                                extensions: {
                                    fragDepth: !0
                                },
                                vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: t.z
                                    },
                                    depthHeight: {
                                        value: t.w
                                    }
                                }
                            });
                        this.mesh = new rl(new Tl(20, 20), n)
                    }
                    t.render(this.mesh, e)
                }
            }
            reset() {
                this.texture = null, this.mesh = null
            }
        }
        class uh extends uo {
            constructor(t, e) {
                super();
                const n = this;
                let r = null,
                    i = 1,
                    o = null,
                    a = "local-floor",
                    s = 1,
                    l = null,
                    c = null,
                    u = null,
                    h = null,
                    d = null,
                    p = null;
                const f = new ch,
                    m = e.getContextAttributes();
                let g = null,
                    A = null;
                const v = [],
                    _ = [],
                    y = new Co;
                let E = null;
                const x = new ml;
                x.layers.enable(1), x.viewport = new jo;
                const b = new ml;
                b.layers.enable(2), b.viewport = new jo;
                const w = [x, b],
                    C = new oh;
                C.layers.enable(1), C.layers.enable(2);
                let S = null,
                    I = null;

                function M(t) {
                    const e = _.indexOf(t.inputSource);
                    if (-1 === e) return;
                    const n = v[e];
                    void 0 !== n && (n.update(t.inputSource, t.frame, l || o), n.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    }))
                }

                function T() {
                    r.removeEventListener("select", M), r.removeEventListener("selectstart", M), r.removeEventListener("selectend", M), r.removeEventListener("squeeze", M), r.removeEventListener("squeezestart", M), r.removeEventListener("squeezeend", M), r.removeEventListener("end", T), r.removeEventListener("inputsourceschange", B);
                    for (let t = 0; t < v.length; t++) {
                        const e = _[t];
                        null !== e && (_[t] = null, v[t].disconnect(e))
                    }
                    S = null, I = null, f.reset(), t.setRenderTarget(g), d = null, h = null, u = null, r = null, A = null, O.stop(), n.isPresenting = !1, t.setPixelRatio(E), t.setSize(y.width, y.height, !1), n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function B(t) {
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e],
                            r = _.indexOf(n);
                        r >= 0 && (_[r] = null, v[r].disconnect(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e];
                        let r = _.indexOf(n);
                        if (-1 === r) {
                            for (let t = 0; t < v.length; t++) {
                                if (t >= _.length) {
                                    _.push(n), r = t;
                                    break
                                }
                                if (null === _[t]) {
                                    _[t] = n, r = t;
                                    break
                                }
                            }
                            if (-1 === r) break
                        }
                        const i = v[r];
                        i && i.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new lh, v[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new lh, v[t] = e), e.getGripSpace()
                }, this.getHand = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new lh, v[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function (t) {
                    i = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function (t) {
                    a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function () {
                    return l || o
                }, this.setReferenceSpace = function (t) {
                    l = t
                }, this.getBaseLayer = function () {
                    return null !== h ? h : d
                }, this.getBinding = function () {
                    return u
                }, this.getFrame = function () {
                    return p
                }, this.getSession = function () {
                    return r
                }, this.setSession = async function (c) {
                    if (r = c, null !== r) {
                        if (g = t.getRenderTarget(), r.addEventListener("select", M), r.addEventListener("selectstart", M), r.addEventListener("selectend", M), r.addEventListener("squeeze", M), r.addEventListener("squeezestart", M), r.addEventListener("squeezeend", M), r.addEventListener("end", T), r.addEventListener("inputsourceschange", B), !0 !== m.xrCompatible && await e.makeXRCompatible(), E = t.getPixelRatio(), t.getSize(y), void 0 === r.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== r.renderState.layers || m.antialias,
                                alpha: !0,
                                depth: m.depth,
                                stencil: m.stencil,
                                framebufferScaleFactor: i
                            };
                            d = new XRWebGLLayer(r, e, n), r.updateRenderState({
                                baseLayer: d
                            }), t.setPixelRatio(1), t.setSize(d.framebufferWidth, d.framebufferHeight, !1), A = new qo(d.framebufferWidth, d.framebufferHeight, {
                                format: Ti,
                                type: xi,
                                colorSpace: t.outputColorSpace,
                                stencilBuffer: m.stencil
                            })
                        } else {
                            let n = null,
                                o = null,
                                a = null;
                            m.depth && (a = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = m.stencil ? Ri : Bi, o = m.stencil ? Mi : Ci);
                            const s = {
                                colorFormat: e.RGBA8,
                                depthFormat: a,
                                scaleFactor: i
                            };
                            u = new XRWebGLBinding(r, e), h = u.createProjectionLayer(s), r.updateRenderState({
                                layers: [h]
                            }), t.setPixelRatio(1), t.setSize(h.textureWidth, h.textureHeight, !1), A = new qo(h.textureWidth, h.textureHeight, {
                                format: Ti,
                                type: xi,
                                depthTexture: new fc(h.textureWidth, h.textureHeight, o, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: m.stencil,
                                colorSpace: t.outputColorSpace,
                                samples: m.antialias ? 4 : 0
                            });
                            t.properties.get(A).__ignoreDepthValues = h.ignoreDepthValues
                        }
                        A.isXRRenderTarget = !0, this.setFoveation(s), l = null, o = await r.requestReferenceSpace(a), O.setContext(r), O.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }, this.getEnvironmentBlendMode = function () {
                    if (null !== r) return r.environmentBlendMode
                };
                const R = new Zo,
                    L = new Zo;

                function D(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function (t) {
                    if (null === r) return;
                    null !== f.texture && (t.near = f.depthNear, t.far = f.depthFar), C.near = b.near = x.near = t.near, C.far = b.far = x.far = t.far, S === C.near && I === C.far || (r.updateRenderState({
                        depthNear: C.near,
                        depthFar: C.far
                    }), S = C.near, I = C.far, x.near = S, x.far = I, b.near = S, b.far = I, x.updateProjectionMatrix(), b.updateProjectionMatrix(), t.updateProjectionMatrix());
                    const e = t.parent,
                        n = C.cameras;
                    D(C, e);
                    for (let t = 0; t < n.length; t++) D(n[t], e);
                    2 === n.length ? function (t, e, n) {
                            R.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
                            const r = R.distanceTo(L),
                                i = e.projectionMatrix.elements,
                                o = n.projectionMatrix.elements,
                                a = i[14] / (i[10] - 1),
                                s = i[14] / (i[10] + 1),
                                l = (i[9] + 1) / i[5],
                                c = (i[9] - 1) / i[5],
                                u = (i[8] - 1) / i[0],
                                h = (o[8] + 1) / o[0],
                                d = a * u,
                                p = a * h,
                                f = r / (-u + h),
                                m = f * -u;
                            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                            const g = a + f,
                                A = s + f,
                                v = d - m,
                                _ = p + (r - m),
                                y = l * s / A * g,
                                E = c * s / A * g;
                            t.projectionMatrix.makePerspective(v, _, y, E, g, A), t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                        }(C, x, b) : C.projectionMatrix.copy(x.projectionMatrix),
                        function (t, e, n) {
                            null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld));
                            t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0), t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * mo * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1)
                        }(t, C, e)
                }, this.getCamera = function () {
                    return C
                }, this.getFoveation = function () {
                    if (null !== h || null !== d) return s
                }, this.setFoveation = function (t) {
                    s = t, null !== h && (h.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
                }, this.hasDepthSensing = function () {
                    return null !== f.texture
                };
                let P = null;
                const O = new Il;
                O.setAnimationLoop((function (e, i) {
                    if (c = i.getViewerPose(l || o), p = i, null !== c) {
                        const e = c.views;
                        null !== d && (t.setRenderTargetFramebuffer(A, d.framebuffer), t.setRenderTarget(A));
                        let n = !1;
                        e.length !== C.cameras.length && (C.cameras.length = 0, n = !0);
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            let o = null;
                            if (null !== d) o = d.getViewport(i);
                            else {
                                const e = u.getViewSubImage(h, i);
                                o = e.viewport, 0 === r && (t.setRenderTargetTextures(A, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(A))
                            }
                            let a = w[r];
                            void 0 === a && (a = new ml, a.layers.enable(r), a.viewport = new jo, w[r] = a), a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.projectionMatrix.fromArray(i.projectionMatrix), a.projectionMatrixInverse.copy(a.projectionMatrix).invert(), a.viewport.set(o.x, o.y, o.width, o.height), 0 === r && (C.matrix.copy(a.matrix), C.matrix.decompose(C.position, C.quaternion, C.scale)), !0 === n && C.cameras.push(a)
                        }
                        const i = r.enabledFeatures;
                        if (i && i.includes("depth-sensing")) {
                            const n = u.getDepthInformation(e[0]);
                            n && n.isValid && n.texture && f.init(t, n, r.renderState)
                        }
                    }
                    for (let t = 0; t < v.length; t++) {
                        const e = _[t],
                            n = v[t];
                        null !== e && void 0 !== n && n.update(e, i, l || o)
                    }
                    f.render(t, C), P && P(e, i), i.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: i
                    }), p = null
                })), this.setAnimationLoop = function (t) {
                    P = t
                }, this.dispose = function () {}
            }
        }
        const hh = new Fa,
            dh = new Ta;

        function ph(t, e) {
            function n(t, e) {
                !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
            }

            function r(r, i) {
                r.opacity.value = i.opacity, i.color && r.diffuse.value.copy(i.color), i.emissive && r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (r.map.value = i.map, n(i.map, r.mapTransform)), i.alphaMap && (r.alphaMap.value = i.alphaMap, n(i.alphaMap, r.alphaMapTransform)), i.bumpMap && (r.bumpMap.value = i.bumpMap, n(i.bumpMap, r.bumpMapTransform), r.bumpScale.value = i.bumpScale, i.side === Yr && (r.bumpScale.value *= -1)), i.normalMap && (r.normalMap.value = i.normalMap, n(i.normalMap, r.normalMapTransform), r.normalScale.value.copy(i.normalScale), i.side === Yr && r.normalScale.value.negate()), i.displacementMap && (r.displacementMap.value = i.displacementMap, n(i.displacementMap, r.displacementMapTransform), r.displacementScale.value = i.displacementScale, r.displacementBias.value = i.displacementBias), i.emissiveMap && (r.emissiveMap.value = i.emissiveMap, n(i.emissiveMap, r.emissiveMapTransform)), i.specularMap && (r.specularMap.value = i.specularMap, n(i.specularMap, r.specularMapTransform)), i.alphaTest > 0 && (r.alphaTest.value = i.alphaTest);
                const o = e.get(i),
                    a = o.envMap,
                    s = o.envMapRotation;
                if (a && (r.envMap.value = a, hh.copy(s), hh.x *= -1, hh.y *= -1, hh.z *= -1, a.isCubeTexture && !1 === a.isRenderTargetTexture && (hh.y *= -1, hh.z *= -1), r.envMapRotation.value.setFromMatrix4(dh.makeRotationFromEuler(hh)), r.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, r.reflectivity.value = i.reflectivity, r.ior.value = i.ior, r.refractionRatio.value = i.refractionRatio), i.lightMap) {
                    r.lightMap.value = i.lightMap;
                    const e = !0 === t._useLegacyLights ? Math.PI : 1;
                    r.lightMapIntensity.value = i.lightMapIntensity * e, n(i.lightMap, r.lightMapTransform)
                }
                i.aoMap && (r.aoMap.value = i.aoMap, r.aoMapIntensity.value = i.aoMapIntensity, n(i.aoMap, r.aoMapTransform))
            }
            return {
                refreshFogUniforms: function (e, n) {
                    n.color.getRGB(e.fogColor.value, ll(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function (t, i, o, a, s) {
                    i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(t, i) : i.isMeshToonMaterial ? (r(t, i), function (t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(t, i)) : i.isMeshPhongMaterial ? (r(t, i), function (t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                    }(t, i)) : i.isMeshStandardMaterial ? (r(t, i), function (t, r) {
                        t.metalness.value = r.metalness, r.metalnessMap && (t.metalnessMap.value = r.metalnessMap, n(r.metalnessMap, t.metalnessMapTransform));
                        t.roughness.value = r.roughness, r.roughnessMap && (t.roughnessMap.value = r.roughnessMap, n(r.roughnessMap, t.roughnessMapTransform));
                        const i = e.get(r).envMap;
                        i && (t.envMapIntensity.value = r.envMapIntensity)
                    }(t, i), i.isMeshPhysicalMaterial && function (t, e, r) {
                        t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, n(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform)));
                        e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, n(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), e.side === Yr && t.clearcoatNormalScale.value.negate()));
                        e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, n(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform)));
                        e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = r.texture, t.transmissionSamplerSize.value.set(r.width, r.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, n(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, n(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor));
                        e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, n(e.anisotropyMap, t.anisotropyMapTransform)));
                        t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, n(e.specularColorMap, t.specularColorMapTransform));
                        e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, n(e.specularIntensityMap, t.specularIntensityMapTransform))
                    }(t, i, s)) : i.isMeshMatcapMaterial ? (r(t, i), function (t, e) {
                        e.matcap && (t.matcap.value = e.matcap)
                    }(t, i)) : i.isMeshDepthMaterial ? r(t, i) : i.isMeshDistanceMaterial ? (r(t, i), function (t, n) {
                        const r = e.get(n).light;
                        t.referencePosition.value.setFromMatrixPosition(r.matrixWorld), t.nearDistance.value = r.shadow.camera.near, t.farDistance.value = r.shadow.camera.far
                    }(t, i)) : i.isMeshNormalMaterial ? r(t, i) : i.isLineBasicMaterial ? (function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, n(e.map, t.mapTransform))
                    }(t, i), i.isLineDashedMaterial && function (t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, i)) : i.isPointsMaterial ? function (t, e, r, i) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * r, t.scale.value = .5 * i, e.map && (t.map.value = e.map, n(e.map, t.uvTransform));
                        e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, i, o, a) : i.isSpriteMaterial ? function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, n(e.map, t.mapTransform));
                        e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }

        function fh(t, e, n, r) {
            let i = {},
                o = {},
                a = [];
            const s = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

            function l(t, e, n, r) {
                const i = t.value,
                    o = e + "_" + n;
                if (void 0 === r[o]) return r[o] = "number" == typeof i || "boolean" == typeof i ? i : i.clone(), !0; {
                    const t = r[o];
                    if ("number" == typeof i || "boolean" == typeof i) {
                        if (t !== i) return r[o] = i, !0
                    } else if (!1 === t.equals(i)) return t.copy(i), !0
                }
                return !1
            }

            function c(t) {
                const e = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof t || "boolean" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e
            }

            function u(e) {
                const n = e.target;
                n.removeEventListener("dispose", u);
                const r = a.indexOf(n.__bindingPointIndex);
                a.splice(r, 1), t.deleteBuffer(i[n.id]), delete i[n.id], delete o[n.id]
            }
            return {
                bind: function (t, e) {
                    const n = e.program;
                    r.uniformBlockBinding(t, n)
                },
                update: function (n, h) {
                    let d = i[n.id];
                    void 0 === d && (! function (t) {
                        const e = t.uniforms;
                        let n = 0;
                        const r = 16;
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = Array.isArray(e[t]) ? e[t] : [e[t]];
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t],
                                    o = Array.isArray(e.value) ? e.value : [e.value];
                                for (let t = 0, i = o.length; t < i; t++) {
                                    const i = c(o[t]),
                                        a = n % r;
                                    0 !== a && r - a < i.boundary && (n += r - a), e.__data = new Float32Array(i.storage / Float32Array.BYTES_PER_ELEMENT), e.__offset = n, n += i.storage
                                }
                            }
                        }
                        const i = n % r;
                        i > 0 && (n += r - i);
                        t.__size = n, t.__cache = {}
                    }(n), d = function (e) {
                        const n = function () {
                            for (let t = 0; t < s; t++)
                                if (-1 === a.indexOf(t)) return a.push(t), t;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }();
                        e.__bindingPointIndex = n;
                        const r = t.createBuffer(),
                            i = e.__size,
                            o = e.usage;
                        return t.bindBuffer(t.UNIFORM_BUFFER, r), t.bufferData(t.UNIFORM_BUFFER, i, o), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, n, r), r
                    }(n), i[n.id] = d, n.addEventListener("dispose", u));
                    const p = h.program;
                    r.updateUBOMapping(n, p);
                    const f = e.render.frame;
                    o[n.id] !== f && (! function (e) {
                        const n = i[e.id],
                            r = e.uniforms,
                            o = e.__cache;
                        t.bindBuffer(t.UNIFORM_BUFFER, n);
                        for (let e = 0, n = r.length; e < n; e++) {
                            const n = Array.isArray(r[e]) ? r[e] : [r[e]];
                            for (let r = 0, i = n.length; r < i; r++) {
                                const i = n[r];
                                if (!0 === l(i, e, r, o)) {
                                    const e = i.__offset,
                                        n = Array.isArray(i.value) ? i.value : [i.value];
                                    let r = 0;
                                    for (let o = 0; o < n.length; o++) {
                                        const a = n[o],
                                            s = c(a);
                                        "number" == typeof a || "boolean" == typeof a ? (i.__data[0] = a, t.bufferSubData(t.UNIFORM_BUFFER, e + r, i.__data)) : a.isMatrix3 ? (i.__data[0] = a.elements[0], i.__data[1] = a.elements[1], i.__data[2] = a.elements[2], i.__data[3] = 0, i.__data[4] = a.elements[3], i.__data[5] = a.elements[4], i.__data[6] = a.elements[5], i.__data[7] = 0, i.__data[8] = a.elements[6], i.__data[9] = a.elements[7], i.__data[10] = a.elements[8], i.__data[11] = 0) : (a.toArray(i.__data, r), r += s.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    t.bufferSubData(t.UNIFORM_BUFFER, e, i.__data)
                                }
                            }
                        }
                        t.bindBuffer(t.UNIFORM_BUFFER, null)
                    }(n), o[n.id] = f)
                },
                dispose: function () {
                    for (const e in i) t.deleteBuffer(i[e]);
                    a = [], i = {}, o = {}
                }
            }
        }
        class mh {
            constructor(t = {}) {
                const {
                    canvas: e = Bo(),
                    context: n = null,
                    depth: r = !0,
                    stencil: i = !0,
                    alpha: o = !1,
                    antialias: a = !1,
                    premultipliedAlpha: s = !0,
                    preserveDrawingBuffer: l = !1,
                    powerPreference: c = "default",
                    failIfMajorPerformanceCaveat: u = !1
                } = t;
                let h;
                this.isWebGLRenderer = !0, h = null !== n ? n.getContextAttributes().alpha : o;
                const d = new Uint32Array(4),
                    p = new Int32Array(4);
                let f = null,
                    m = null;
                const g = [],
                    A = [];
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Yi, this._useLegacyLights = !1, this.toneMapping = ei, this.toneMappingExposure = 1;
                const v = this;
                let _ = !1,
                    y = 0,
                    E = 0,
                    x = null,
                    b = -1,
                    w = null;
                const C = new jo,
                    S = new jo;
                let I = null;
                const M = new vs(0);
                let T = 0,
                    B = e.width,
                    R = e.height,
                    L = 1,
                    D = null,
                    P = null;
                const O = new jo(0, 0, B, R),
                    k = new jo(0, 0, B, R);
                let U = !1;
                const N = new Sl;
                let F = !1,
                    Q = !1,
                    $ = null;
                const G = new Ta,
                    H = new Co,
                    z = new Zo,
                    V = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function W() {
                    return null === x ? L : 1
                }
                let j, X, q, Y, K, J, Z, tt, et, nt, rt, it, ot, at, st, lt, ct, ut, ht, dt, pt, ft, mt, gt, At = n;

                function vt(t, n) {
                    for (let r = 0; r < t.length; r++) {
                        const i = t[r],
                            o = e.getContext(i, n);
                        if (null !== o) return o
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: r,
                        stencil: i,
                        antialias: a,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Vr}`), e.addEventListener("webglcontextlost", Et, !1), e.addEventListener("webglcontextrestored", xt, !1), e.addEventListener("webglcontextcreationerror", bt, !1), null === At) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === v.isWebGL1Renderer && e.shift(), At = vt(e, t), null === At) throw vt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" != typeof WebGLRenderingContext && At instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === At.getShaderPrecisionFormat && (At.getShaderPrecisionFormat = function () {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw console.error("THREE.WebGLRenderer: " + t.message), t
                }

                function _t() {
                    j = new ac(At), X = new Fl(At, j, t), j.init(X), ft = new ih(At, j, X), q = new nh(At, j, X), Y = new cc(At), K = new Gu, J = new rh(At, j, q, K, X, ft, Y), Z = new $l(v), tt = new oc(v), et = new Ml(At, X), mt = new Ul(At, j, et, X), nt = new sc(At, et, Y, mt), rt = new pc(At, nt, et, Y), ht = new dc(At, X, J), lt = new Ql(K), it = new $u(v, Z, tt, j, X, mt, lt), ot = new ph(v, K), at = new Wu, st = new Ju(j, X), ut = new kl(v, Z, tt, q, rt, h, s), ct = new eh(v, rt, X), gt = new fh(At, Y, X, q), dt = new Nl(At, j, Y, X), pt = new lc(At, j, Y, X), Y.programs = it.programs, v.capabilities = X, v.extensions = j, v.properties = K, v.renderLists = at, v.shadowMap = ct, v.state = q, v.info = Y
                }
                _t();
                const yt = new uh(v, At);

                function Et(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
                }

                function xt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
                    const t = Y.autoReset,
                        e = ct.enabled,
                        n = ct.autoUpdate,
                        r = ct.needsUpdate,
                        i = ct.type;
                    _t(), Y.autoReset = t, ct.enabled = e, ct.autoUpdate = n, ct.needsUpdate = r, ct.type = i
                }

                function bt(t) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
                }

                function wt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", wt),
                        function (t) {
                            (function (t) {
                                const e = K.get(t).programs;
                                void 0 !== e && (e.forEach((function (t) {
                                    it.releaseProgram(t)
                                })), t.isShaderMaterial && it.releaseShaderCache(t))
                            })(t), K.remove(t)
                        }(e)
                }

                function Ct(t, e, n) {
                    !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass ? (t.side = Yr, t.needsUpdate = !0, Pt(t, e, n), t.side = qr, t.needsUpdate = !0, Pt(t, e, n), t.side = 2) : Pt(t, e, n)
                }
                this.xr = yt, this.getContext = function () {
                    return At
                }, this.getContextAttributes = function () {
                    return At.getContextAttributes()
                }, this.forceContextLoss = function () {
                    const t = j.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function () {
                    const t = j.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function () {
                    return L
                }, this.setPixelRatio = function (t) {
                    void 0 !== t && (L = t, this.setSize(B, R, !1))
                }, this.getSize = function (t) {
                    return t.set(B, R)
                }, this.setSize = function (t, n, r = !0) {
                    yt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (B = t, R = n, e.width = Math.floor(t * L), e.height = Math.floor(n * L), !0 === r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function (t) {
                    return t.set(B * L, R * L).floor()
                }, this.setDrawingBufferSize = function (t, n, r) {
                    B = t, R = n, L = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function (t) {
                    return t.copy(C)
                }, this.getViewport = function (t) {
                    return t.copy(O)
                }, this.setViewport = function (t, e, n, r) {
                    t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, r), q.viewport(C.copy(O).multiplyScalar(L).round())
                }, this.getScissor = function (t) {
                    return t.copy(k)
                }, this.setScissor = function (t, e, n, r) {
                    t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, n, r), q.scissor(S.copy(k).multiplyScalar(L).round())
                }, this.getScissorTest = function () {
                    return U
                }, this.setScissorTest = function (t) {
                    q.setScissorTest(U = t)
                }, this.setOpaqueSort = function (t) {
                    D = t
                }, this.setTransparentSort = function (t) {
                    P = t
                }, this.getClearColor = function (t) {
                    return t.copy(ut.getClearColor())
                }, this.setClearColor = function () {
                    ut.setClearColor.apply(ut, arguments)
                }, this.getClearAlpha = function () {
                    return ut.getClearAlpha()
                }, this.setClearAlpha = function () {
                    ut.setClearAlpha.apply(ut, arguments)
                }, this.clear = function (t = !0, e = !0, n = !0) {
                    let r = 0;
                    if (t) {
                        let t = !1;
                        if (null !== x) {
                            const e = x.texture.format;
                            t = 1033 === e || 1031 === e || 1029 === e
                        }
                        if (t) {
                            const t = x.texture.type,
                                e = t === xi || t === Ci || t === bi || t === Mi || 1017 === t || 1018 === t,
                                n = ut.getClearColor(),
                                r = ut.getClearAlpha(),
                                i = n.r,
                                o = n.g,
                                a = n.b;
                            e ? (d[0] = i, d[1] = o, d[2] = a, d[3] = r, At.clearBufferuiv(At.COLOR, 0, d)) : (p[0] = i, p[1] = o, p[2] = a, p[3] = r, At.clearBufferiv(At.COLOR, 0, p))
                        } else r |= At.COLOR_BUFFER_BIT
                    }
                    e && (r |= At.DEPTH_BUFFER_BIT), n && (r |= At.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), At.clear(r)
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                }, this.dispose = function () {
                    e.removeEventListener("webglcontextlost", Et, !1), e.removeEventListener("webglcontextrestored", xt, !1), e.removeEventListener("webglcontextcreationerror", bt, !1), at.dispose(), st.dispose(), K.dispose(), Z.dispose(), tt.dispose(), rt.dispose(), mt.dispose(), gt.dispose(), it.dispose(), yt.dispose(), yt.removeEventListener("sessionstart", It), yt.removeEventListener("sessionend", Mt), $ && ($.dispose(), $ = null), Tt.stop()
                }, this.renderBufferDirect = function (t, e, n, r, i, o) {
                    null === e && (e = V);
                    const a = i.isMesh && i.matrixWorld.determinant() < 0,
                        s = function (t, e, n, r, i) {
                            !0 !== e.isScene && (e = V);
                            J.resetTextureUnits();
                            const o = e.fog,
                                a = r.isMeshStandardMaterial ? e.environment : null,
                                s = null === x ? v.outputColorSpace : !0 === x.isXRRenderTarget ? x.texture.colorSpace : Ki,
                                l = (r.isMeshStandardMaterial ? tt : Z).get(r.envMap || a),
                                c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                u = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0),
                                h = !!n.morphAttributes.position,
                                d = !!n.morphAttributes.normal,
                                p = !!n.morphAttributes.color;
                            let f = ei;
                            r.toneMapped && (null !== x && !0 !== x.isXRRenderTarget || (f = v.toneMapping));
                            const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                A = void 0 !== g ? g.length : 0,
                                _ = K.get(r),
                                y = m.state.lights;
                            if (!0 === F && (!0 === Q || t !== w)) {
                                const e = t === w && r.id === b;
                                lt.setState(r, t, e)
                            }
                            let E = !1;
                            r.version === _.__version ? _.needsLights && _.lightsStateVersion !== y.state.version || _.outputColorSpace !== s || i.isBatchedMesh && !1 === _.batching ? E = !0 : i.isBatchedMesh || !0 !== _.batching ? i.isInstancedMesh && !1 === _.instancing ? E = !0 : i.isInstancedMesh || !0 !== _.instancing ? i.isSkinnedMesh && !1 === _.skinning ? E = !0 : i.isSkinnedMesh || !0 !== _.skinning ? i.isInstancedMesh && !0 === _.instancingColor && null === i.instanceColor || i.isInstancedMesh && !1 === _.instancingColor && null !== i.instanceColor || i.isInstancedMesh && !0 === _.instancingMorph && null === i.morphTexture || i.isInstancedMesh && !1 === _.instancingMorph && null !== i.morphTexture || _.envMap !== l || !0 === r.fog && _.fog !== o ? E = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === lt.numPlanes && _.numIntersection === lt.numIntersection ? (_.vertexAlphas !== c || _.vertexTangents !== u || _.morphTargets !== h || _.morphNormals !== d || _.morphColors !== p || _.toneMapping !== f || !0 === X.isWebGL2 && _.morphTargetsCount !== A) && (E = !0) : E = !0 : E = !0 : E = !0 : E = !0 : (E = !0, _.__version = r.version);
                            let C = _.currentProgram;
                            !0 === E && (C = Pt(r, e, i));
                            let S = !1,
                                I = !1,
                                M = !1;
                            const T = C.getUniforms(),
                                B = _.uniforms;
                            q.useProgram(C.program) && (S = !0, I = !0, M = !0);
                            r.id !== b && (b = r.id, I = !0);
                            if (S || w !== t) {
                                T.setValue(At, "projectionMatrix", t.projectionMatrix), T.setValue(At, "viewMatrix", t.matrixWorldInverse);
                                const e = T.map.cameraPosition;
                                void 0 !== e && e.setValue(At, z.setFromMatrixPosition(t.matrixWorld)), X.logarithmicDepthBuffer && T.setValue(At, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && T.setValue(At, "isOrthographic", !0 === t.isOrthographicCamera), w !== t && (w = t, I = !0, M = !0)
                            }
                            if (i.isSkinnedMesh) {
                                T.setOptional(At, i, "bindMatrix"), T.setOptional(At, i, "bindMatrixInverse");
                                const t = i.skeleton;
                                t && (X.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), T.setValue(At, "boneTexture", t.boneTexture, J)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            i.isBatchedMesh && (T.setOptional(At, i, "batchingTexture"), T.setValue(At, "batchingTexture", i._matricesTexture, J));
                            const D = n.morphAttributes;
                            (void 0 !== D.position || void 0 !== D.normal || void 0 !== D.color && !0 === X.isWebGL2) && ht.update(i, n, C);
                            (I || _.receiveShadow !== i.receiveShadow) && (_.receiveShadow = i.receiveShadow, T.setValue(At, "receiveShadow", i.receiveShadow));
                            r.isMeshGouraudMaterial && null !== r.envMap && (B.envMap.value = l, B.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                            I && (T.setValue(At, "toneMappingExposure", v.toneMappingExposure), _.needsLights && (O = M, (P = B).ambientLightColor.needsUpdate = O, P.lightProbe.needsUpdate = O, P.directionalLights.needsUpdate = O, P.directionalLightShadows.needsUpdate = O, P.pointLights.needsUpdate = O, P.pointLightShadows.needsUpdate = O, P.spotLights.needsUpdate = O, P.spotLightShadows.needsUpdate = O, P.rectAreaLights.needsUpdate = O, P.hemisphereLights.needsUpdate = O), o && !0 === r.fog && ot.refreshFogUniforms(B, o), ot.refreshMaterialUniforms(B, r, L, R, $), _u.upload(At, Ot(_), B, J));
                            var P, O;
                            r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (_u.upload(At, Ot(_), B, J), r.uniformsNeedUpdate = !1);
                            r.isSpriteMaterial && T.setValue(At, "center", i.center);
                            if (T.setValue(At, "modelViewMatrix", i.modelViewMatrix), T.setValue(At, "normalMatrix", i.normalMatrix), T.setValue(At, "modelMatrix", i.matrixWorld), r.isShaderMaterial || r.isRawShaderMaterial) {
                                const t = r.uniformsGroups;
                                for (let e = 0, n = t.length; e < n; e++)
                                    if (X.isWebGL2) {
                                        const n = t[e];
                                        gt.update(n, C), gt.bind(n, C)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return C
                        }(t, e, n, r, i);
                    q.setMaterial(r, a);
                    let l = n.index,
                        c = 1;
                    if (!0 === r.wireframe) {
                        if (l = nt.getWireframeAttribute(n), void 0 === l) return;
                        c = 2
                    }
                    const u = n.drawRange,
                        h = n.attributes.position;
                    let d = u.start * c,
                        p = (u.start + u.count) * c;
                    null !== o && (d = Math.max(d, o.start * c), p = Math.min(p, (o.start + o.count) * c)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != h && (d = Math.max(d, 0), p = Math.min(p, h.count));
                    const f = p - d;
                    if (f < 0 || f === 1 / 0) return;
                    let g;
                    mt.setup(i, r, s, n, l);
                    let A = dt;
                    if (null !== l && (g = et.get(l), A = pt, A.setIndex(g)), i.isMesh) !0 === r.wireframe ? (q.setLineWidth(r.wireframeLinewidth * W()), A.setMode(At.LINES)) : A.setMode(At.TRIANGLES);
                    else if (i.isLine) {
                        let t = r.linewidth;
                        void 0 === t && (t = 1), q.setLineWidth(t * W()), i.isLineSegments ? A.setMode(At.LINES) : i.isLineLoop ? A.setMode(At.LINE_LOOP) : A.setMode(At.LINE_STRIP)
                    } else i.isPoints ? A.setMode(At.POINTS) : i.isSprite && A.setMode(At.TRIANGLES);
                    if (i.isBatchedMesh) A.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount);
                    else if (i.isInstancedMesh) A.renderInstances(d, f, i.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                            e = Math.min(n.instanceCount, t);
                        A.renderInstances(d, f, e)
                    } else A.render(d, f)
                }, this.compile = function (t, e, n = null) {
                    null === n && (n = t), m = st.get(n), m.init(), A.push(m), n.traverseVisible((function (t) {
                        t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
                    })), t !== n && t.traverseVisible((function (t) {
                        t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
                    })), m.setupLights(v._useLegacyLights);
                    const r = new Set;
                    return t.traverse((function (t) {
                        const e = t.material;
                        if (e)
                            if (Array.isArray(e))
                                for (let i = 0; i < e.length; i++) {
                                    const o = e[i];
                                    Ct(o, n, t), r.add(o)
                                } else Ct(e, n, t), r.add(e)
                    })), A.pop(), m = null, r
                }, this.compileAsync = function (t, e, n = null) {
                    const r = this.compile(t, e, n);
                    return new Promise((e => {
                        function n() {
                            r.forEach((function (t) {
                                K.get(t).currentProgram.isReady() && r.delete(t)
                            })), 0 !== r.size ? setTimeout(n, 10) : e(t)
                        }
                        null !== j.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }))
                };
                let St = null;

                function It() {
                    Tt.stop()
                }

                function Mt() {
                    Tt.start()
                }
                const Tt = new Il;

                function Bt(t, e, n, r) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || N.intersectsSprite(t)) {
                            r && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
                            const e = rt.update(t),
                                i = t.material;
                            i.visible && f.push(t, e, i, n, z.z, null)
                        }
                    } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || N.intersectsObject(t))) {
                        const e = rt.update(t),
                            i = t.material;
                        if (r && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(), z.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(), z.copy(e.boundingSphere.center)), z.applyMatrix4(t.matrixWorld).applyMatrix4(G)), Array.isArray(i)) {
                            const r = e.groups;
                            for (let o = 0, a = r.length; o < a; o++) {
                                const a = r[o],
                                    s = i[a.materialIndex];
                                s && s.visible && f.push(t, e, s, n, z.z, a)
                            }
                        } else i.visible && f.push(t, e, i, n, z.z, null)
                    }
                    const i = t.children;
                    for (let t = 0, o = i.length; t < o; t++) Bt(i[t], e, n, r)
                }

                function Rt(t, e, n, r) {
                    const i = t.opaque,
                        o = t.transmissive,
                        a = t.transparent;
                    m.setupLightsView(n), !0 === F && lt.setGlobalState(v.clippingPlanes, n), o.length > 0 && function (t, e, n, r) {
                        const i = !0 === n.isScene ? n.overrideMaterial : null;
                        if (null !== i) return;
                        const o = X.isWebGL2;
                        null === $ && ($ = new qo(1, 1, {
                            generateMipmaps: !0,
                            type: j.has("EXT_color_buffer_half_float") ? Ii : xi,
                            minFilter: Ei,
                            samples: o ? 4 : 0
                        }));
                        v.getDrawingBufferSize(H), o ? $.setSize(H.x, H.y) : $.setSize(Eo(H.x), Eo(H.y));
                        const a = v.getRenderTarget();
                        v.setRenderTarget($), v.getClearColor(M), T = v.getClearAlpha(), T < 1 && v.setClearColor(16777215, .5);
                        v.clear();
                        const s = v.toneMapping;
                        v.toneMapping = ei, Lt(t, n, r), J.updateMultisampleRenderTarget($), J.updateRenderTargetMipmap($);
                        let l = !1;
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = e[t],
                                o = i.object,
                                a = i.geometry,
                                s = i.material,
                                c = i.group;
                            if (2 === s.side && o.layers.test(r.layers)) {
                                const t = s.side;
                                s.side = Yr, s.needsUpdate = !0, Dt(o, n, r, a, s, c), s.side = t, s.needsUpdate = !0, l = !0
                            }
                        }!0 === l && (J.updateMultisampleRenderTarget($), J.updateRenderTargetMipmap($));
                        v.setRenderTarget(a), v.setClearColor(M, T), v.toneMapping = s
                    }(i, o, e, n), r && q.viewport(C.copy(r)), i.length > 0 && Lt(i, e, n), o.length > 0 && Lt(o, e, n), a.length > 0 && Lt(a, e, n), q.buffers.depth.setTest(!0), q.buffers.depth.setMask(!0), q.buffers.color.setMask(!0), q.setPolygonOffset(!1)
                }

                function Lt(t, e, n) {
                    const r = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let i = 0, o = t.length; i < o; i++) {
                        const o = t[i],
                            a = o.object,
                            s = o.geometry,
                            l = null === r ? o.material : r,
                            c = o.group;
                        a.layers.test(n.layers) && Dt(a, e, n, s, l, c)
                    }
                }

                function Dt(t, e, n, r, i, o) {
                    t.onBeforeRender(v, e, n, r, i, o), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), i.onBeforeRender(v, e, n, r, t, o), !0 === i.transparent && 2 === i.side && !1 === i.forceSinglePass ? (i.side = Yr, i.needsUpdate = !0, v.renderBufferDirect(n, e, r, i, t, o), i.side = qr, i.needsUpdate = !0, v.renderBufferDirect(n, e, r, i, t, o), i.side = 2) : v.renderBufferDirect(n, e, r, i, t, o), t.onAfterRender(v, e, n, r, i, o)
                }

                function Pt(t, e, n) {
                    !0 !== e.isScene && (e = V);
                    const r = K.get(t),
                        i = m.state.lights,
                        o = m.state.shadowsArray,
                        a = i.state.version,
                        s = it.getParameters(t, i.state, o, e, n),
                        l = it.getProgramCacheKey(s);
                    let c = r.programs;
                    r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = (t.isMeshStandardMaterial ? tt : Z).get(t.envMap || r.environment), r.envMapRotation = null !== r.environment && null === t.envMap ? e.environmentRotation : t.envMapRotation, void 0 === c && (t.addEventListener("dispose", wt), c = new Map, r.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (r.currentProgram === u && r.lightsStateVersion === a) return kt(t, s), u
                    } else s.uniforms = it.getUniforms(t), t.onBuild(n, s, v), t.onBeforeCompile(s, v), u = it.acquireProgram(s, l), c.set(l, u), r.uniforms = s.uniforms;
                    const h = r.uniforms;
                    return (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = lt.uniform), kt(t, s), r.needsLights = function (t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), r.lightsStateVersion = a, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotLightMatrix.value = i.state.spotLightMatrix, h.spotLightMap.value = i.state.spotLightMap, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix), r.currentProgram = u, r.uniformsList = null, u
                }

                function Ot(t) {
                    if (null === t.uniformsList) {
                        const e = t.currentProgram.getUniforms();
                        t.uniformsList = _u.seqWithValue(e.seq, t.uniforms)
                    }
                    return t.uniformsList
                }

                function kt(t, e) {
                    const n = K.get(t);
                    n.outputColorSpace = e.outputColorSpace, n.batching = e.batching, n.instancing = e.instancing, n.instancingColor = e.instancingColor, n.instancingMorph = e.instancingMorph, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                }
                Tt.setAnimationLoop((function (t) {
                    St && St(t)
                })), "undefined" != typeof self && Tt.setContext(self), this.setAnimationLoop = function (t) {
                    St = t, yt.setAnimationLoop(t), null === t ? Tt.stop() : Tt.start()
                }, yt.addEventListener("sessionstart", It), yt.addEventListener("sessionend", Mt), this.render = function (t, e) {
                    if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === _) return;
                    !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === yt.enabled && !0 === yt.isPresenting && (!0 === yt.cameraAutoUpdate && yt.updateCamera(e), e = yt.getCamera()), !0 === t.isScene && t.onBeforeRender(v, t, e, x), m = st.get(t, A.length), m.init(), A.push(m), G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), N.setFromProjectionMatrix(G), Q = this.localClippingEnabled, F = lt.init(this.clippingPlanes, Q), f = at.get(t, g.length), f.init(), g.push(f), Bt(t, e, 0, v.sortObjects), f.finish(), !0 === v.sortObjects && f.sort(D, P), this.info.render.frame++, !0 === F && lt.beginShadows();
                    const n = m.state.shadowsArray;
                    if (ct.render(n, t, e), !0 === F && lt.endShadows(), !0 === this.info.autoReset && this.info.reset(), !1 !== yt.enabled && !1 !== yt.isPresenting && !1 !== yt.hasDepthSensing() || ut.render(f, t), m.setupLights(v._useLegacyLights), e.isArrayCamera) {
                        const n = e.cameras;
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = n[e];
                            Rt(f, t, r, r.viewport)
                        }
                    } else Rt(f, t, e);
                    null !== x && (J.updateMultisampleRenderTarget(x), J.updateRenderTargetMipmap(x)), !0 === t.isScene && t.onAfterRender(v, t, e), mt.resetDefaultState(), b = -1, w = null, A.pop(), m = A.length > 0 ? A[A.length - 1] : null, g.pop(), f = g.length > 0 ? g[g.length - 1] : null
                }, this.getActiveCubeFace = function () {
                    return y
                }, this.getActiveMipmapLevel = function () {
                    return E
                }, this.getRenderTarget = function () {
                    return x
                }, this.setRenderTargetTextures = function (t, e, n) {
                    K.get(t.texture).__webglTexture = e, K.get(t.depthTexture).__webglTexture = n;
                    const r = K.get(t);
                    r.__hasExternalTextures = !0, r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === j.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1)
                }, this.setRenderTargetFramebuffer = function (t, e) {
                    const n = K.get(t);
                    n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                }, this.setRenderTarget = function (t, e = 0, n = 0) {
                    x = t, y = e, E = n;
                    let r = !0,
                        i = null,
                        o = !1,
                        a = !1;
                    if (t) {
                        const s = K.get(t);
                        void 0 !== s.__useDefaultFramebuffer ? (q.bindFramebuffer(At.FRAMEBUFFER, null), r = !1) : void 0 === s.__webglFramebuffer ? J.setupRenderTarget(t) : s.__hasExternalTextures && J.rebindTextures(t, K.get(t.texture).__webglTexture, K.get(t.depthTexture).__webglTexture);
                        const l = t.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                        const c = K.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (i = Array.isArray(c[e]) ? c[e][n] : c[e], o = !0) : i = X.isWebGL2 && t.samples > 0 && !1 === J.useMultisampledRTT(t) ? K.get(t).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, C.copy(t.viewport), S.copy(t.scissor), I = t.scissorTest
                    } else C.copy(O).multiplyScalar(L).floor(), S.copy(k).multiplyScalar(L).floor(), I = U;
                    if (q.bindFramebuffer(At.FRAMEBUFFER, i) && X.drawBuffers && r && q.drawBuffers(t, i), q.viewport(C), q.scissor(S), q.setScissorTest(I), o) {
                        const r = K.get(t.texture);
                        At.framebufferTexture2D(At.FRAMEBUFFER, At.COLOR_ATTACHMENT0, At.TEXTURE_CUBE_MAP_POSITIVE_X + e, r.__webglTexture, n)
                    } else if (a) {
                        const r = K.get(t.texture),
                            i = e || 0;
                        At.framebufferTextureLayer(At.FRAMEBUFFER, At.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i)
                    }
                    b = -1
                }, this.readRenderTargetPixels = function (t, e, n, r, i, o, a) {
                    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let s = K.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s) {
                        q.bindFramebuffer(At.FRAMEBUFFER, s);
                        try {
                            const a = t.texture,
                                s = a.format,
                                l = a.type;
                            if (s !== Ti && ft.convert(s) !== At.getParameter(At.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === Ii && (j.has("EXT_color_buffer_half_float") || X.isWebGL2 && j.has("EXT_color_buffer_float"));
                            if (!(l === xi || ft.convert(l) === At.getParameter(At.IMPLEMENTATION_COLOR_READ_TYPE) || l === Si && (X.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && At.readPixels(e, n, r, i, ft.convert(s), ft.convert(l), o)
                        } finally {
                            const t = null !== x ? K.get(x).__webglFramebuffer : null;
                            q.bindFramebuffer(At.FRAMEBUFFER, t)
                        }
                    }
                }, this.copyFramebufferToTexture = function (t, e, n = 0) {
                    const r = Math.pow(2, -n),
                        i = Math.floor(e.image.width * r),
                        o = Math.floor(e.image.height * r);
                    J.setTexture2D(e, 0), At.copyTexSubImage2D(At.TEXTURE_2D, n, 0, 0, t.x, t.y, i, o), q.unbindTexture()
                }, this.copyTextureToTexture = function (t, e, n, r = 0) {
                    const i = e.image.width,
                        o = e.image.height,
                        a = ft.convert(n.format),
                        s = ft.convert(n.type);
                    J.setTexture2D(n, 0), At.pixelStorei(At.UNPACK_FLIP_Y_WEBGL, n.flipY), At.pixelStorei(At.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), At.pixelStorei(At.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? At.texSubImage2D(At.TEXTURE_2D, r, t.x, t.y, i, o, a, s, e.image.data) : e.isCompressedTexture ? At.compressedTexSubImage2D(At.TEXTURE_2D, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : At.texSubImage2D(At.TEXTURE_2D, r, t.x, t.y, a, s, e.image), 0 === r && n.generateMipmaps && At.generateMipmap(At.TEXTURE_2D), q.unbindTexture()
                }, this.copyTextureToTexture3D = function (t, e, n, r, i = 0) {
                    if (v.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const o = Math.round(t.max.x - t.min.x),
                        a = Math.round(t.max.y - t.min.y),
                        s = t.max.z - t.min.z + 1,
                        l = ft.convert(r.format),
                        c = ft.convert(r.type);
                    let u;
                    if (r.isData3DTexture) J.setTexture3D(r, 0), u = At.TEXTURE_3D;
                    else {
                        if (!r.isDataArrayTexture && !r.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        J.setTexture2DArray(r, 0), u = At.TEXTURE_2D_ARRAY
                    }
                    At.pixelStorei(At.UNPACK_FLIP_Y_WEBGL, r.flipY), At.pixelStorei(At.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), At.pixelStorei(At.UNPACK_ALIGNMENT, r.unpackAlignment);
                    const h = At.getParameter(At.UNPACK_ROW_LENGTH),
                        d = At.getParameter(At.UNPACK_IMAGE_HEIGHT),
                        p = At.getParameter(At.UNPACK_SKIP_PIXELS),
                        f = At.getParameter(At.UNPACK_SKIP_ROWS),
                        m = At.getParameter(At.UNPACK_SKIP_IMAGES),
                        g = n.isCompressedTexture ? n.mipmaps[i] : n.image;
                    At.pixelStorei(At.UNPACK_ROW_LENGTH, g.width), At.pixelStorei(At.UNPACK_IMAGE_HEIGHT, g.height), At.pixelStorei(At.UNPACK_SKIP_PIXELS, t.min.x), At.pixelStorei(At.UNPACK_SKIP_ROWS, t.min.y), At.pixelStorei(At.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isData3DTexture ? At.texSubImage3D(u, i, e.x, e.y, e.z, o, a, s, l, c, g.data) : r.isCompressedArrayTexture ? At.compressedTexSubImage3D(u, i, e.x, e.y, e.z, o, a, s, l, g.data) : At.texSubImage3D(u, i, e.x, e.y, e.z, o, a, s, l, c, g), At.pixelStorei(At.UNPACK_ROW_LENGTH, h), At.pixelStorei(At.UNPACK_IMAGE_HEIGHT, d), At.pixelStorei(At.UNPACK_SKIP_PIXELS, p), At.pixelStorei(At.UNPACK_SKIP_ROWS, f), At.pixelStorei(At.UNPACK_SKIP_IMAGES, m), 0 === i && r.generateMipmaps && At.generateMipmap(u), q.unbindTexture()
                }, this.initTexture = function (t) {
                    t.isCubeTexture ? J.setTextureCube(t, 0) : t.isData3DTexture ? J.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? J.setTexture2DArray(t, 0) : J.setTexture2D(t, 0), q.unbindTexture()
                }, this.resetState = function () {
                    y = 0, E = 0, x = null, q.reset(), mt.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            get coordinateSystem() {
                return lo
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(t) {
                this._outputColorSpace = t;
                const e = this.getContext();
                e.drawingBufferColorSpace = t === Ji ? "display-p3" : "srgb", e.unpackColorSpace = Uo.workingColorSpace === Zi ? "display-p3" : "srgb"
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
            }
            set useLegacyLights(t) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t
            }
        }(class extends mh {}).prototype.isWebGL1Renderer = !0;
        class gh extends ns {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Fa, this.environmentRotation = new Fa, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentRotation.copy(t.environmentRotation), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), e.object.environmentRotation = this.environmentRotation.toArray(), e
            }
        }
        class Ah {
            constructor(t, e) {
                this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = oo, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.version = 0, this.uuid = go()
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            get updateRange() {
                return Lo("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
            }
            setUsage(t) {
                return this.usage = t, this
            }
            addUpdateRange(t, e) {
                this.updateRanges.push({
                    start: t,
                    count: e
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
            }
            copyAt(t, e, n) {
                t *= this.stride, n *= e.stride;
                for (let r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = go()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(e, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = go()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const vh = new Zo;
        class _h {
            constructor(t, e, n, r = !1) {
                this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = r
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++) vh.fromBufferAttribute(this, e), vh.applyMatrix4(t), this.setXYZ(e, vh.x, vh.y, vh.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) vh.fromBufferAttribute(this, e), vh.applyNormalMatrix(t), this.setXYZ(e, vh.x, vh.y, vh.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) vh.fromBufferAttribute(this, e), vh.transformDirection(t), this.setXYZ(e, vh.x, vh.y, vh.z);
                return this
            }
            getComponent(t, e) {
                let n = this.array[t * this.data.stride + this.offset + e];
                return this.normalized && (n = xo(n, this.array)), n
            }
            setComponent(t, e, n) {
                return this.normalized && (n = bo(n, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n, this
            }
            setX(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
            }
            setY(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }
            setZ(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }
            setW(t, e) {
                return this.normalized && (e = bo(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }
            getX(t) {
                let e = this.data.array[t * this.data.stride + this.offset];
                return this.normalized && (e = xo(e, this.array)), e
            }
            getY(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 1];
                return this.normalized && (e = xo(e, this.array)), e
            }
            getZ(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 2];
                return this.normalized && (e = xo(e, this.array)), e
            }
            getW(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 3];
                return this.normalized && (e = xo(e, this.array)), e
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = bo(e, this.array), n = bo(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            }
            setXYZ(t, e, n, r) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = bo(e, this.array), n = bo(n, this.array), r = bo(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
            }
            setXYZW(t, e, n, r, i) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = bo(e, this.array), n = bo(n, this.array), r = bo(r, this.array), i = bo(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
            }
            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return new Ms(new this.array.constructor(t), this.itemSize, this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new _h(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const yh = new Zo,
            Eh = new jo,
            xh = new jo,
            bh = new Zo,
            wh = new Ta,
            Ch = new Zo,
            Sh = new ya,
            Ih = new Ta,
            Mh = new Ma;
        class Th extends rl {
            constructor(t, e) {
                super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = ci, this.bindMatrix = new Ta, this.bindMatrixInverse = new Ta, this.boundingBox = null, this.boundingSphere = null
            }
            computeBoundingBox() {
                const t = this.geometry;
                null === this.boundingBox && (this.boundingBox = new na), this.boundingBox.makeEmpty();
                const e = t.getAttribute("position");
                for (let t = 0; t < e.count; t++) this.getVertexPosition(t, Ch), this.boundingBox.expandByPoint(Ch)
            }
            computeBoundingSphere() {
                const t = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new ya), this.boundingSphere.makeEmpty();
                const e = t.getAttribute("position");
                for (let t = 0; t < e.count; t++) this.getVertexPosition(t, Ch), this.boundingSphere.expandByPoint(Ch)
            }
            copy(t, e) {
                return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            }
            raycast(t, e) {
                const n = this.material,
                    r = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), Sh.copy(this.boundingSphere), Sh.applyMatrix4(r), !1 !== t.ray.intersectsSphere(Sh) && (Ih.copy(r).invert(), Mh.copy(t.ray).applyMatrix4(Ih), null !== this.boundingBox && !1 === Mh.intersectsBox(this.boundingBox) || this._computeIntersections(t, e, Mh)))
            }
            getVertexPosition(t, e) {
                return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
            }
            bind(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new jo,
                    e = this.geometry.attributes.skinWeight;
                for (let n = 0, r = e.count; n < r; n++) {
                    t.fromBufferAttribute(e, n);
                    const r = 1 / t.manhattanLength();
                    r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.bindMode === ci ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(t, e) {
                const n = this.skeleton,
                    r = this.geometry;
                Eh.fromBufferAttribute(r.attributes.skinIndex, t), xh.fromBufferAttribute(r.attributes.skinWeight, t), yh.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const r = xh.getComponent(t);
                    if (0 !== r) {
                        const i = Eh.getComponent(t);
                        wh.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), e.addScaledVector(bh.copy(yh).applyMatrix4(wh), r)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class Bh extends ns {
            constructor() {
                super(), this.isBone = !0, this.type = "Bone"
            }
        }
        class Rh extends Wo {
            constructor(t = null, e = 1, n = 1, r, i, o, a, s, l = 1003, c = 1003, u, h) {
                super(null, o, a, s, l, c, r, i, u, h), this.isDataTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        const Lh = new Ta,
            Dh = new Ta;
        class Ph {
            constructor(t = [], e = []) {
                this.uuid = go(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init()
            }
            init() {
                const t = this.bones,
                    e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                else if (t.length !== e.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Ta)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new Ta;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones,
                    e = this.boneInverses,
                    n = this.boneMatrices,
                    r = this.boneTexture;
                for (let r = 0, i = t.length; r < i; r++) {
                    const i = t[r] ? t[r].matrixWorld : Dh;
                    Lh.multiplyMatrices(i, e[r]), Lh.toArray(n, 16 * r)
                }
                null !== r && (r.needsUpdate = !0)
            }
            clone() {
                return new Ph(this.bones, this.boneInverses)
            }
            computeBoneTexture() {
                let t = Math.sqrt(4 * this.bones.length);
                t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
                const e = new Float32Array(t * t * 4);
                e.set(this.boneMatrices);
                const n = new Rh(e, t, t, Ti, Si);
                return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this
            }
            getBoneByName(t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t) return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let n = 0, r = t.bones.length; n < r; n++) {
                    const r = t.bones[n];
                    let i = e[r];
                    void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new Bh), this.bones.push(i), this.boneInverses.push((new Ta).fromArray(t.boneInverses[n]))
                }
                return this.init(), this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones,
                    n = this.boneInverses;
                for (let r = 0, i = e.length; r < i; r++) {
                    const i = e[r];
                    t.bones.push(i.uuid);
                    const o = n[r];
                    t.boneInverses.push(o.toArray())
                }
                return t
            }
        }
        class Oh extends Ms {
            constructor(t, e, n, r = 1) {
                super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
            }
            copy(t) {
                return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }
        const kh = new Ta,
            Uh = new Ta,
            Nh = [],
            Fh = new na,
            Qh = new Ta,
            $h = new rl,
            Gh = new ya;
        class Hh extends rl {
            constructor(t, e, n) {
                super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new Oh(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                for (let t = 0; t < n; t++) this.setMatrixAt(t, Qh)
            }
            computeBoundingBox() {
                const t = this.geometry,
                    e = this.count;
                null === this.boundingBox && (this.boundingBox = new na), null === t.boundingBox && t.computeBoundingBox(), this.boundingBox.makeEmpty();
                for (let n = 0; n < e; n++) this.getMatrixAt(n, kh), Fh.copy(t.boundingBox).applyMatrix4(kh), this.boundingBox.union(Fh)
            }
            computeBoundingSphere() {
                const t = this.geometry,
                    e = this.count;
                null === this.boundingSphere && (this.boundingSphere = new ya), null === t.boundingSphere && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                for (let n = 0; n < e; n++) this.getMatrixAt(n, kh), Gh.copy(t.boundingSphere).applyMatrix4(kh), this.boundingSphere.union(Gh)
            }
            copy(t, e) {
                return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            getMorphAt(t, e) {
                const n = e.morphTargetInfluences,
                    r = this.morphTexture.source.data.data,
                    i = t * (n.length + 1) + 1;
                for (let t = 0; t < n.length; t++) n[t] = r[i + t]
            }
            raycast(t, e) {
                const n = this.matrixWorld,
                    r = this.count;
                if ($h.geometry = this.geometry, $h.material = this.material, void 0 !== $h.material && (null === this.boundingSphere && this.computeBoundingSphere(), Gh.copy(this.boundingSphere), Gh.applyMatrix4(n), !1 !== t.ray.intersectsSphere(Gh)))
                    for (let i = 0; i < r; i++) {
                        this.getMatrixAt(i, kh), Uh.multiplyMatrices(n, kh), $h.matrixWorld = Uh, $h.raycast(t, Nh);
                        for (let t = 0, n = Nh.length; t < n; t++) {
                            const n = Nh[t];
                            n.instanceId = i, n.object = this, e.push(n)
                        }
                        Nh.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new Oh(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            setMorphAt(t, e) {
                const n = e.morphTargetInfluences,
                    r = n.length + 1;
                null === this.morphTexture && (this.morphTexture = new Rh(new Float32Array(r * this.count), r, this.count, Li, Si));
                const i = this.morphTexture.source.data.data;
                let o = 0;
                for (let t = 0; t < n.length; t++) o += n[t];
                const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
                    s = r * t;
                i[s] = a, i.set(n, s + 1)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class zh extends Es {
            constructor(t) {
                super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new vs(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
            }
        }
        const Vh = new Zo,
            Wh = new Zo,
            jh = new Ta,
            Xh = new Ma,
            qh = new ya;
        class Yh extends ns {
            constructor(t = new Fs, e = new zh) {
                super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [0];
                    for (let t = 1, r = e.count; t < r; t++) Vh.fromBufferAttribute(e, t - 1), Wh.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Vh.distanceTo(Wh);
                    t.setAttribute("lineDistance", new Rs(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    i = t.params.Line.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), qh.copy(n.boundingSphere), qh.applyMatrix4(r), qh.radius += i, !1 === t.ray.intersectsSphere(qh)) return;
                jh.copy(r).invert(), Xh.copy(t.ray).applyMatrix4(jh);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    s = a * a,
                    l = new Zo,
                    c = new Zo,
                    u = new Zo,
                    h = new Zo,
                    d = this.isLineSegments ? 2 : 1,
                    p = n.index,
                    f = n.attributes.position;
                if (null !== p) {
                    for (let n = Math.max(0, o.start), r = Math.min(p.count, o.start + o.count) - 1; n < r; n += d) {
                        const r = p.getX(n),
                            i = p.getX(n + 1);
                        l.fromBufferAttribute(f, r), c.fromBufferAttribute(f, i);
                        if (Xh.distanceSqToSegment(l, c, h, u) > s) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const o = t.ray.origin.distanceTo(h);
                        o < t.near || o > t.far || e.push({
                            distance: o,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let n = Math.max(0, o.start), r = Math.min(f.count, o.start + o.count) - 1; n < r; n += d) {
                        l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1);
                        if (Xh.distanceSqToSegment(l, c, h, u) > s) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const r = t.ray.origin.distanceTo(h);
                        r < t.near || r > t.far || e.push({
                            distance: r,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }
        const Kh = new Zo,
            Jh = new Zo;
        class Zh extends Yh {
            constructor(t, e) {
                super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [];
                    for (let t = 0, r = e.count; t < r; t += 2) Kh.fromBufferAttribute(e, t), Jh.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Kh.distanceTo(Jh);
                    t.setAttribute("lineDistance", new Rs(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class td extends Yh {
            constructor(t, e) {
                super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
            }
        }
        class ed extends Es {
            constructor(t) {
                super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new vs(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
            }
        }
        const nd = new Ta,
            rd = new Ma,
            id = new ya,
            od = new Zo;
        class ad extends ns {
            constructor(t = new Fs, e = new ed) {
                super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    i = t.params.Points.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), id.copy(n.boundingSphere), id.applyMatrix4(r), id.radius += i, !1 === t.ray.intersectsSphere(id)) return;
                nd.copy(r).invert(), rd.copy(t.ray).applyMatrix4(nd);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    s = a * a,
                    l = n.index,
                    c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, o.start), i = Math.min(l.count, o.start + o.count); n < i; n++) {
                        const i = l.getX(n);
                        od.fromBufferAttribute(c, i), sd(od, i, s, r, t, e, this)
                    }
                } else {
                    for (let n = Math.max(0, o.start), i = Math.min(c.count, o.start + o.count); n < i; n++) od.fromBufferAttribute(c, n), sd(od, n, s, r, t, e, this)
                }
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }

        function sd(t, e, n, r, i, o, a) {
            const s = rd.distanceSqToPoint(t);
            if (s < n) {
                const n = new Zo;
                rd.closestPointToPoint(t, n), n.applyMatrix4(r);
                const l = i.ray.origin.distanceTo(n);
                if (l < i.near || l > i.far) return;
                o.push({
                    distance: l,
                    distanceToRay: Math.sqrt(s),
                    point: n,
                    index: e,
                    face: null,
                    object: a
                })
            }
        }
        class ld extends Wo {
            constructor(t, e, n, r, i, o, a, s, l, c, u, h) {
                super(null, o, a, s, l, c, r, i, u, h), this.isCompressedTexture = !0, this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        class cd extends ld {
            constructor(t, e, n, r, i, o) {
                super(t, e, n, i, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = fi
            }
        }
        class ud extends ld {
            constructor(t, e, n) {
                super(void 0, t[0].width, t[0].height, e, n, ui), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = t
            }
        }
        class hd extends Es {
            constructor(t) {
                super(), this.isMeshStandardMaterial = !0, this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new vs(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new vs(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Co(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Fa, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
            }
        }
        class dd extends hd {
            constructor(t) {
                super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Co(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function () {
                        return Ao(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function (t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new vs(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new vs(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new vs(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(t) {
                this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(t) {
                this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
            }
            get sheen() {
                return this._sheen
            }
            set sheen(t) {
                this._sheen > 0 != t > 0 && this.version++, this._sheen = t
            }
            get transmission() {
                return this._transmission
            }
            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++, this._transmission = t
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
            }
        }
        class pd extends Es {
            constructor(t) {
                super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new vs(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new vs(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Co(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Fa, this.combine = Jr, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
            }
        }

        function fd(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        }

        function md(t) {
            const e = t.length,
                n = new Array(e);
            for (let t = 0; t !== e; ++t) n[t] = t;
            return n.sort((function (e, n) {
                return t[e] - t[n]
            })), n
        }

        function gd(t, e, n) {
            const r = t.length,
                i = new t.constructor(r);
            for (let o = 0, a = 0; a !== r; ++o) {
                const r = n[o] * e;
                for (let n = 0; n !== e; ++n) i[a++] = t[r + n]
            }
            return i
        }

        function Ad(t, e, n, r) {
            let i = 1,
                o = t[0];
            for (; void 0 !== o && void 0 === o[r];) o = t[i++];
            if (void 0 === o) return;
            let a = o[r];
            if (void 0 !== a)
                if (Array.isArray(a))
                    do {
                        a = o[r], void 0 !== a && (e.push(o.time), n.push.apply(n, a)), o = t[i++]
                    } while (void 0 !== o);
                else if (void 0 !== a.toArray)
                do {
                    a = o[r], void 0 !== a && (e.push(o.time), a.toArray(n, n.length)), o = t[i++]
                } while (void 0 !== o);
            else
                do {
                    a = o[r], void 0 !== a && (e.push(o.time), n.push(a)), o = t[i++]
                } while (void 0 !== o)
        }
        class vd {
            constructor(t, e, n, r) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex,
                    r = e[n],
                    i = e[n - 1];
                t: {
                    e: {
                        let o;n: {
                            r: if (!(t < r)) {
                                for (let o = n + 2;;) {
                                    if (void 0 === r) {
                                        if (t < i) break r;
                                        return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                    }
                                    if (n === o) break;
                                    if (i = r, r = e[++n], t < r) break e
                                }
                                o = e.length;
                                break n
                            }if (t >= i) break t; {
                                const a = e[1];
                                t < a && (n = 2, i = a);
                                for (let o = n - 2;;) {
                                    if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === o) break;
                                    if (r = i, i = e[--n - 1], t >= i) break e
                                }
                                o = n, n = 0
                            }
                        }
                        for (; n < o;) {
                            const r = n + o >>> 1;
                            t < e[r] ? o = r : n = r + 1
                        }
                        if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0,
                        this.copySampleValue_(0);
                        if (void 0 === r) return n = e.length,
                        this._cachedIndex = n,
                        this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, t, r)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    i = t * r;
                for (let t = 0; t !== r; ++t) e[t] = n[i + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class _d extends vd {
            constructor(t, e, n, r) {
                super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: 2400,
                    endingEnd: 2400
                }
            }
            intervalChanged_(t, e, n) {
                const r = this.parameterPositions;
                let i = t - 2,
                    o = t + 1,
                    a = r[i],
                    s = r[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case 2401:
                        i = t, a = 2 * e - n;
                        break;
                    case 2402:
                        i = r.length - 2, a = e + r[i] - r[i + 1];
                        break;
                    default:
                        i = t, a = n
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        o = t, s = 2 * n - e;
                        break;
                    case 2402:
                        o = 1, s = n + r[1] - r[0];
                        break;
                    default:
                        o = t - 1, s = e
                }
                const l = .5 * (n - e),
                    c = this.valueSize;
                this._weightPrev = l / (e - a), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = o * c
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = t * a,
                    l = s - a,
                    c = this._offsetPrev,
                    u = this._offsetNext,
                    h = this._weightPrev,
                    d = this._weightNext,
                    p = (n - e) / (r - e),
                    f = p * p,
                    m = f * p,
                    g = -h * m + 2 * h * f - h * p,
                    A = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
                    v = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                    _ = d * m - d * f;
                for (let t = 0; t !== a; ++t) i[t] = g * o[c + t] + A * o[l + t] + v * o[s + t] + _ * o[u + t];
                return i
            }
        }
        class yd extends vd {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = t * a,
                    l = s - a,
                    c = (n - e) / (r - e),
                    u = 1 - c;
                for (let t = 0; t !== a; ++t) i[t] = o[l + t] * u + o[s + t] * c;
                return i
            }
        }
        class Ed extends vd {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class xd {
            constructor(t, e, n, r) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = fd(e, this.TimeBufferType), this.values = fd(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: fd(t.times, Array),
                        values: fd(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new Ed(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new yd(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new _d(this.times, this.values, this.getValueSize(), t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                    case Wi:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case ji:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case Xi:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Wi;
                    case this.InterpolantFactoryMethodLinear:
                        return ji;
                    case this.InterpolantFactoryMethodSmooth:
                        return Xi
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times,
                    r = n.length;
                let i = 0,
                    o = r - 1;
                for (; i !== r && n[i] < t;) ++i;
                for (; - 1 !== o && n[o] > e;) --o;
                if (++o, 0 !== i || o !== r) {
                    i >= o && (o = Math.max(o, 1), i = o - 1);
                    const t = this.getValueSize();
                    this.times = n.slice(i, o), this.values = this.values.slice(i * t, o * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                const n = this.times,
                    r = this.values,
                    i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                let o = null;
                for (let e = 0; e !== i; e++) {
                    const r = n[e];
                    if ("number" == typeof r && isNaN(r)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, r), t = !1;
                        break
                    }
                    if (null !== o && o > r) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, r, o), t = !1;
                        break
                    }
                    o = r
                }
                if (void 0 !== r && (a = r, ArrayBuffer.isView(a) && !(a instanceof DataView)))
                    for (let e = 0, n = r.length; e !== n; ++e) {
                        const n = r[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                            break
                        }
                    }
                var a;
                return t
            }
            optimize() {
                const t = this.times.slice(),
                    e = this.values.slice(),
                    n = this.getValueSize(),
                    r = this.getInterpolation() === Xi,
                    i = t.length - 1;
                let o = 1;
                for (let a = 1; a < i; ++a) {
                    let i = !1;
                    const s = t[a];
                    if (s !== t[a + 1] && (1 !== a || s !== t[0]))
                        if (r) i = !0;
                        else {
                            const t = a * n,
                                r = t - n,
                                o = t + n;
                            for (let a = 0; a !== n; ++a) {
                                const n = e[t + a];
                                if (n !== e[r + a] || n !== e[o + a]) {
                                    i = !0;
                                    break
                                }
                            }
                        } if (i) {
                        if (a !== o) {
                            t[o] = t[a];
                            const r = a * n,
                                i = o * n;
                            for (let t = 0; t !== n; ++t) e[i + t] = e[r + t]
                        }++o
                    }
                }
                if (i > 0) {
                    t[o] = t[i];
                    for (let t = i * n, r = o * n, a = 0; a !== n; ++a) e[r + a] = e[t + a];
                    ++o
                }
                return o !== t.length ? (this.times = t.slice(0, o), this.values = e.slice(0, o * n)) : (this.times = t, this.values = e), this
            }
            clone() {
                const t = this.times.slice(),
                    e = this.values.slice(),
                    n = new(0, this.constructor)(this.name, t, e);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        xd.prototype.TimeBufferType = Float32Array, xd.prototype.ValueBufferType = Float32Array, xd.prototype.DefaultInterpolation = ji;
        class bd extends xd {}
        bd.prototype.ValueTypeName = "bool", bd.prototype.ValueBufferType = Array, bd.prototype.DefaultInterpolation = Wi, bd.prototype.InterpolantFactoryMethodLinear = void 0, bd.prototype.InterpolantFactoryMethodSmooth = void 0;
        class wd extends xd {}
        wd.prototype.ValueTypeName = "color";
        class Cd extends xd {}
        Cd.prototype.ValueTypeName = "number";
        class Sd extends vd {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = (n - e) / (r - e);
                let l = t * a;
                for (let t = l + a; l !== t; l += 4) Jo.slerpFlat(i, 0, o, l - a, o, l, s);
                return i
            }
        }
        class Id extends xd {
            InterpolantFactoryMethodLinear(t) {
                return new Sd(this.times, this.values, this.getValueSize(), t)
            }
        }
        Id.prototype.ValueTypeName = "quaternion", Id.prototype.DefaultInterpolation = ji, Id.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Md extends xd {}
        Md.prototype.ValueTypeName = "string", Md.prototype.ValueBufferType = Array, Md.prototype.DefaultInterpolation = Wi, Md.prototype.InterpolantFactoryMethodLinear = void 0, Md.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Td extends xd {}
        Td.prototype.ValueTypeName = "vector";
        class Bd {
            constructor(t, e = -1, n, r = 2500) {
                this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = go(), this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = [],
                    n = t.tracks,
                    r = 1 / (t.fps || 1);
                for (let t = 0, i = n.length; t !== i; ++t) e.push(Rd(n[t]).scale(r));
                const i = new this(t.name, t.duration, e, t.blendMode);
                return i.uuid = t.uuid, i
            }
            static toJSON(t) {
                const e = [],
                    n = t.tracks,
                    r = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode
                    };
                for (let t = 0, r = n.length; t !== r; ++t) e.push(xd.toJSON(n[t]));
                return r
            }
            static CreateFromMorphTargetSequence(t, e, n, r) {
                const i = e.length,
                    o = [];
                for (let t = 0; t < i; t++) {
                    let a = [],
                        s = [];
                    a.push((t + i - 1) % i, t, (t + 1) % i), s.push(0, 1, 0);
                    const l = md(a);
                    a = gd(a, 1, l), s = gd(s, 1, l), r || 0 !== a[0] || (a.push(i), s.push(s[0])), o.push(new Cd(".morphTargetInfluences[" + e[t].name + "]", a, s).scale(1 / n))
                }
                return new this(t, -1, o)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e) return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const r = {},
                    i = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e],
                        o = n.name.match(i);
                    if (o && o.length > 1) {
                        const t = o[1];
                        let e = r[t];
                        e || (r[t] = e = []), e.push(n)
                    }
                }
                const o = [];
                for (const t in r) o.push(this.CreateFromMorphTargetSequence(t, r[t], e, n));
                return o
            }
            static parseAnimation(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function (t, e, n, r, i) {
                        if (0 !== n.length) {
                            const o = [],
                                a = [];
                            Ad(n, o, a, r), 0 !== o.length && i.push(new t(e, o, a))
                        }
                    },
                    r = [],
                    i = t.name || "default",
                    o = t.fps || 30,
                    a = t.blendMode;
                let s = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const i = l[t].keys;
                    if (i && 0 !== i.length)
                        if (i[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < i.length; e++)
                                if (i[e].morphTargets)
                                    for (let n = 0; n < i[e].morphTargets.length; n++) t[i[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = [],
                                    o = [];
                                for (let r = 0; r !== i[e].morphTargets.length; ++r) {
                                    const r = i[e];
                                    t.push(r.time), o.push(r.morphTarget === n ? 1 : 0)
                                }
                                r.push(new Cd(".morphTargetInfluence[" + n + "]", t, o))
                            }
                            s = t.length * o
                        } else {
                            const o = ".bones[" + e[t].name + "]";
                            n(Td, o + ".position", i, "pos", r), n(Id, o + ".quaternion", i, "rot", r), n(Td, o + ".scale", i, "scl", r)
                        }
                }
                if (0 === r.length) return null;
                return new this(i, s, r, a)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new this.constructor(this.name, this.duration, t, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function Rd(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function (t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Cd;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Td;
                    case "color":
                        return wd;
                    case "quaternion":
                        return Id;
                    case "bool":
                    case "boolean":
                        return bd;
                    case "string":
                        return Md
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = [],
                    n = [];
                Ad(t.keys, e, n, "value"), t.times = e, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }
        const Ld = {
            enabled: !1,
            files: {},
            add: function (t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function (t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function (t) {
                delete this.files[t]
            },
            clear: function () {
                this.files = {}
            }
        };
        class Dd {
            constructor(t, e, n) {
                const r = this;
                let i, o = !1,
                    a = 0,
                    s = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
                    s++, !1 === o && void 0 !== r.onStart && r.onStart(t, a, s), o = !0
                }, this.itemEnd = function (t) {
                    a++, void 0 !== r.onProgress && r.onProgress(t, a, s), a === s && (o = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function (t) {
                    void 0 !== r.onError && r.onError(t)
                }, this.resolveURL = function (t) {
                    return i ? i(t) : t
                }, this.setURLModifier = function (t) {
                    return i = t, this
                }, this.addHandler = function (t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function (t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function (t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e],
                            r = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return r
                    }
                    return null
                }
            }
        }
        const Pd = new Dd;
        class Od {
            constructor(t) {
                this.manager = void 0 !== t ? t : Pd, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function (r, i) {
                    n.load(t, r, e, i)
                }))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t, this
            }
            setWithCredentials(t) {
                return this.withCredentials = t, this
            }
            setPath(t) {
                return this.path = t, this
            }
            setResourcePath(t) {
                return this.resourcePath = t, this
            }
            setRequestHeader(t) {
                return this.requestHeader = t, this
            }
        }
        Od.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const kd = {};
        class Ud extends Error {
            constructor(t, e) {
                super(t), this.response = e
            }
        }
        class Nd extends Od {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const i = Ld.get(t);
                if (void 0 !== i) return this.manager.itemStart(t), setTimeout((() => {
                    e && e(i), this.manager.itemEnd(t)
                }), 0), i;
                if (void 0 !== kd[t]) return void kd[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: r
                });
                kd[t] = [], kd[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: r
                });
                const o = new Request(t, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    }),
                    a = this.mimeType,
                    s = this.responseType;
                fetch(o).then((e => {
                    if (200 === e.status || 0 === e.status) {
                        if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                        const n = kd[t],
                            r = e.body.getReader(),
                            i = e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
                            o = i ? parseInt(i) : 0,
                            a = 0 !== o;
                        let s = 0;
                        const l = new ReadableStream({
                            start(t) {
                                ! function e() {
                                    r.read().then((({
                                        done: r,
                                        value: i
                                    }) => {
                                        if (r) t.close();
                                        else {
                                            s += i.byteLength;
                                            const r = new ProgressEvent("progress", {
                                                lengthComputable: a,
                                                loaded: s,
                                                total: o
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(r)
                                            }
                                            t.enqueue(i), e()
                                        }
                                    }))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new Ud(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
                })).then((t => {
                    switch (s) {
                        case "arraybuffer":
                            return t.arrayBuffer();
                        case "blob":
                            return t.blob();
                        case "document":
                            return t.text().then((t => (new DOMParser).parseFromString(t, a)));
                        case "json":
                            return t.json();
                        default:
                            if (void 0 === a) return t.text(); {
                                const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                    n = e && e[1] ? e[1].toLowerCase() : void 0,
                                    r = new TextDecoder(n);
                                return t.arrayBuffer().then((t => r.decode(t)))
                            }
                    }
                })).then((e => {
                    Ld.add(t, e);
                    const n = kd[t];
                    delete kd[t];
                    for (let t = 0, r = n.length; t < r; t++) {
                        const r = n[t];
                        r.onLoad && r.onLoad(e)
                    }
                })).catch((e => {
                    const n = kd[t];
                    if (void 0 === n) throw this.manager.itemError(t), e;
                    delete kd[t];
                    for (let t = 0, r = n.length; t < r; t++) {
                        const r = n[t];
                        r.onError && r.onError(e)
                    }
                    this.manager.itemError(t)
                })).finally((() => {
                    this.manager.itemEnd(t)
                })), this.manager.itemStart(t)
            }
            setResponseType(t) {
                return this.responseType = t, this
            }
            setMimeType(t) {
                return this.mimeType = t, this
            }
        }
        class Fd extends Od {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const i = this,
                    o = Ld.get(t);
                if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () {
                    e && e(o), i.manager.itemEnd(t)
                }), 0), o;
                const a = To("img");

                function s() {
                    c(), Ld.add(t, this), e && e(this), i.manager.itemEnd(t)
                }

                function l(e) {
                    c(), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                }

                function c() {
                    a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1)
                }
                return a.addEventListener("load", s, !1), a.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a
            }
        }
        class Qd extends Od {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const i = this,
                    o = new Rh,
                    a = new Nd(this.manager);
                return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(i.withCredentials), a.load(t, (function (t) {
                    let n;
                    try {
                        n = i.parse(t)
                    } catch (t) {
                        if (void 0 === r) return void console.error(t);
                        r(t)
                    }
                    void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : fi, o.wrapT = void 0 !== n.wrapT ? n.wrapT : fi, o.magFilter = void 0 !== n.magFilter ? n.magFilter : _i, o.minFilter = void 0 !== n.minFilter ? n.minFilter : _i, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace && (o.colorSpace = n.colorSpace), void 0 !== n.flipY && (o.flipY = n.flipY), void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = Ei), 1 === n.mipmapCount && (o.minFilter = _i), void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps), o.needsUpdate = !0, e && e(o, n)
                }), n, r), o
            }
        }
        class $d extends Od {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const i = new Wo,
                    o = new Fd(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (t) {
                    i.image = t, i.needsUpdate = !0, void 0 !== e && e(i)
                }), n, r), i
            }
        }
        class Gd extends ns {
            constructor(t, e = 1) {
                super(), this.isLight = !0, this.type = "Light", this.color = new vs(t), this.intensity = e
            }
            dispose() {}
            copy(t, e) {
                return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }
        const Hd = new Ta,
            zd = new Zo,
            Vd = new Zo;
        class Wd {
            constructor(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Co(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ta, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Sl, this._frameExtents = new Co(1, 1), this._viewportCount = 1, this._viewports = [new jo(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = this.matrix;
                zd.setFromMatrixPosition(t.matrixWorld), e.position.copy(zd), Vd.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Vd), e.updateMatrixWorld(), Hd.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Hd), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Hd)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }
        class jd extends Wd {
            constructor() {
                super(new ml(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = 2 * mo * t.angle * this.focus,
                    r = this.mapSize.width / this.mapSize.height,
                    i = t.distance || e.far;
                n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t), this.focus = t.focus, this
            }
        }
        class Xd extends Gd {
            constructor(t, e, n = 0, r = Math.PI / 3, i = 0, o = 2) {
                super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ns.DEFAULT_UP), this.updateMatrix(), this.target = new ns, this.distance = n, this.angle = r, this.penumbra = i, this.decay = o, this.map = null, this.shadow = new jd
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }
        const qd = new Ta,
            Yd = new Zo,
            Kd = new Zo;
        class Jd extends Wd {
            constructor() {
                super(new ml(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Co(4, 2), this._viewportCount = 6, this._viewports = [new jo(2, 1, 1, 1), new jo(0, 1, 1, 1), new jo(3, 1, 1, 1), new jo(1, 1, 1, 1), new jo(3, 0, 1, 1), new jo(1, 0, 1, 1)], this._cubeDirections = [new Zo(1, 0, 0), new Zo(-1, 0, 0), new Zo(0, 0, 1), new Zo(0, 0, -1), new Zo(0, 1, 0), new Zo(0, -1, 0)], this._cubeUps = [new Zo(0, 1, 0), new Zo(0, 1, 0), new Zo(0, 1, 0), new Zo(0, 1, 0), new Zo(0, 0, 1), new Zo(0, 0, -1)]
            }
            updateMatrices(t, e = 0) {
                const n = this.camera,
                    r = this.matrix,
                    i = t.distance || n.far;
                i !== n.far && (n.far = i, n.updateProjectionMatrix()), Yd.setFromMatrixPosition(t.matrixWorld), n.position.copy(Yd), Kd.copy(n.position), Kd.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Kd), n.updateMatrixWorld(), r.makeTranslation(-Yd.x, -Yd.y, -Yd.z), qd.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(qd)
            }
        }
        class Zd extends Gd {
            constructor(t, e, n = 0, r = 2) {
                super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Jd
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }
        class tp extends Wd {
            constructor() {
                super(new Gl(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
            }
        }
        class ep extends Gd {
            constructor(t, e) {
                super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ns.DEFAULT_UP), this.updateMatrix(), this.target = new ns, this.shadow = new tp
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }
        class np extends Gd {
            constructor(t, e) {
                super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
            }
        }
        class rp {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.slice(0, e + 1)
            }
            static resolveURL(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
        }
        class ip extends Od {
            constructor(t) {
                super(t), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t, this
            }
            load(t, e, n, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const i = this,
                    o = Ld.get(t);
                if (void 0 !== o) return i.manager.itemStart(t), o.then ? void o.then((n => {
                    e && e(n), i.manager.itemEnd(t)
                })).catch((t => {
                    r && r(t)
                })) : (setTimeout((function () {
                    e && e(o), i.manager.itemEnd(t)
                }), 0), o);
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader;
                const s = fetch(t, a).then((function (t) {
                    return t.blob()
                })).then((function (t) {
                    return createImageBitmap(t, Object.assign(i.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function (n) {
                    return Ld.add(t, n), e && e(n), i.manager.itemEnd(t), n
                })).catch((function (e) {
                    r && r(e), Ld.remove(t), i.manager.itemError(t), i.manager.itemEnd(t)
                }));
                Ld.add(t, s), i.manager.itemStart(t)
            }
        }
        const op = "\\[\\]\\.:\\/",
            ap = new RegExp("[" + op + "]", "g"),
            sp = "[^" + op + "]",
            lp = "[^" + op.replace("\\.", "") + "]",
            cp = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", sp) + /(WCOD+)?/.source.replace("WCOD", lp) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", sp) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", sp) + "$"),
            up = ["material", "materials", "bones", "map"];
        class hp {
            constructor(t, e, n) {
                this.path = e, this.parsedPath = n || hp.parseTrackName(e), this.node = hp.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new hp.Composite(t, e, n) : new hp(t, e, n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(ap, "")
            }
            static parseTrackName(t) {
                const e = cp.exec(t);
                if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    const t = n.nodeName.substring(r + 1); - 1 !== up.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function (t) {
                            for (let r = 0; r < t.length; r++) {
                                const i = t[r];
                                if (i.name === e || i.uuid === e) return i;
                                const o = n(i.children);
                                if (o) return o
                            }
                            return null
                        },
                        r = n(t.children);
                    if (r) return r
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(), this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(), this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath,
                    n = e.objectName,
                    r = e.propertyName;
                let i = e.propertyIndex;
                if (t || (t = hp.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let r = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (let e = 0; e < t.length; e++)
                                if (t[e].name === r) {
                                    r = e;
                                    break
                                } break;
                        case "map":
                            if ("map" in t) {
                                t = t.map;
                                break
                            }
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            t = t.material.map;
                            break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== r) {
                        if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[r]
                    }
                }
                const o = t[r];
                if (void 0 === o) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
                }
                let a = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let s = this.BindingType.Direct;
                if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
                    }
                    s = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i
                } else void 0 !== o.fromArray && void 0 !== o.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (s = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][a]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        hp.Composite = class {
            constructor(t, e, n) {
                const r = n || hp.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, r)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }, hp.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, hp.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, hp.prototype.GetterByBindingType = [hp.prototype._getValue_direct, hp.prototype._getValue_array, hp.prototype._getValue_arrayElement, hp.prototype._getValue_toArray], hp.prototype.SetterByBindingTypeAndVersioning = [
            [hp.prototype._setValue_direct, hp.prototype._setValue_direct_setNeedsUpdate, hp.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [hp.prototype._setValue_array, hp.prototype._setValue_array_setNeedsUpdate, hp.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [hp.prototype._setValue_arrayElement, hp.prototype._setValue_arrayElement_setNeedsUpdate, hp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [hp.prototype._setValue_fromArray, hp.prototype._setValue_fromArray_setNeedsUpdate, hp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ];
        const dp = new Ta;
        class pp {
            constructor(t, e, n = 0, r = 1 / 0) {
                this.ray = new Ma(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new Qa, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(t, e) {
                this.ray.set(t, e)
            }
            setFromCamera(t, e) {
                e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
            }
            setFromXRController(t) {
                return dp.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(dp), this
            }
            intersectObject(t, e = !0, n = []) {
                return mp(t, this, n, e), n.sort(fp), n
            }
            intersectObjects(t, e = !0, n = []) {
                for (let r = 0, i = t.length; r < i; r++) mp(t[r], this, n, e);
                return n.sort(fp), n
            }
        }

        function fp(t, e) {
            return t.distance - e.distance
        }

        function mp(t, e, n, r) {
            if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r) {
                const r = t.children;
                for (let t = 0, i = r.length; t < i; t++) mp(r[t], e, n, !0)
            }
        }
        class gp {
            constructor(t = 1, e = 0, n = 0) {
                return this.radius = t, this.phi = e, this.theta = n, this
            }
            set(t, e, n) {
                return this.radius = t, this.phi = e, this.theta = n, this
            }
            copy(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            }
            makeSafe() {
                const t = 1e-6;
                return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
            }
            setFromVector3(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }
            setFromCartesianCoords(t, e, n) {
                return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Ao(e / this.radius, -1, 1))), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: Vr
            }
        })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Vr);
        var Ap = function (t, e) {
            return Ap = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, Ap(t, e)
        };

        function vp(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

            function n() {
                this.constructor = t
            }
            Ap(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }

        function _p(t, e, n, r) {
            return new(n || (n = Promise))((function (i, o) {
                function a(t) {
                    try {
                        l(r.next(t))
                    } catch (t) {
                        o(t)
                    }
                }

                function s(t) {
                    try {
                        l(r.throw(t))
                    } catch (t) {
                        o(t)
                    }
                }

                function l(t) {
                    var e;
                    t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) {
                        t(e)
                    }))).then(a, s)
                }
                l((r = r.apply(t, e || [])).next())
            }))
        }

        function yp(t, e) {
            var n, r, i, o, a = {
                label: 0,
                sent: function () {
                    if (1 & i[0]) throw i[1];
                    return i[1]
                },
                trys: [],
                ops: []
            };
            return o = {
                next: s(0),
                throw: s(1),
                return: s(2)
            }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
                return this
            }), o;

            function s(s) {
                return function (l) {
                    return function (s) {
                        if (n) throw new TypeError("Generator is already executing.");
                        for (; o && (o = 0, s[0] && (a = 0)), a;) try {
                            if (n = 1, r && (i = 2 & s[0] ? r.return : s[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, s[1])).done) return i;
                            switch (r = 0, i && (s = [2 & s[0], i.value]), s[0]) {
                                case 0:
                                case 1:
                                    i = s;
                                    break;
                                case 4:
                                    return a.label++, {
                                        value: s[1],
                                        done: !1
                                    };
                                case 5:
                                    a.label++, r = s[1], s = [0];
                                    continue;
                                case 7:
                                    s = a.ops.pop(), a.trys.pop();
                                    continue;
                                default:
                                    if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                        a = 0;
                                        continue
                                    }
                                    if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                        a.label = s[1];
                                        break
                                    }
                                    if (6 === s[0] && a.label < i[1]) {
                                        a.label = i[1], i = s;
                                        break
                                    }
                                    if (i && a.label < i[2]) {
                                        a.label = i[2], a.ops.push(s);
                                        break
                                    }
                                    i[2] && a.ops.pop(), a.trys.pop();
                                    continue
                            }
                            s = e.call(t, a)
                        } catch (t) {
                            s = [6, t], r = 0
                        } finally {
                            n = i = 0
                        }
                        if (5 & s[0]) throw s[1];
                        return {
                            value: s[0] ? s[1] : void 0,
                            done: !0
                        }
                    }([s, l])
                }
            }
        }

        function Ep(t) {
            var e = "function" == typeof Symbol && Symbol.iterator,
                n = e && t[e],
                r = 0;
            if (n) return n.call(t);
            if (t && "number" == typeof t.length) return {
                next: function () {
                    return t && r >= t.length && (t = void 0), {
                        value: t && t[r++],
                        done: !t
                    }
                }
            };
            throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
        }

        function xp(t, e) {
            var n = "function" == typeof Symbol && t[Symbol.iterator];
            if (!n) return t;
            var r, i, o = n.call(t),
                a = [];
            try {
                for (;
                    (void 0 === e || e-- > 0) && !(r = o.next()).done;) a.push(r.value)
            } catch (t) {
                i = {
                    error: t
                }
            } finally {
                try {
                    r && !r.done && (n = o.return) && n.call(o)
                } finally {
                    if (i) throw i.error
                }
            }
            return a
        }

        function bp(t, e, n) {
            if (n || 2 === arguments.length)
                for (var r, i = 0, o = e.length; i < o; i++) !r && i in e || (r || (r = Array.prototype.slice.call(e, 0, i)), r[i] = e[i]);
            return t.concat(r || Array.prototype.slice.call(e))
        }

        function wp(t) {
            return this instanceof wp ? (this.v = t, this) : new wp(t)
        }

        function Cp(t, e, n) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var r, i = n.apply(t, e || []),
                o = [];
            return r = {}, a("next"), a("throw"), a("return"), r[Symbol.asyncIterator] = function () {
                return this
            }, r;

            function a(t) {
                i[t] && (r[t] = function (e) {
                    return new Promise((function (n, r) {
                        o.push([t, e, n, r]) > 1 || s(t, e)
                    }))
                })
            }

            function s(t, e) {
                try {
                    (n = i[t](e)).value instanceof wp ? Promise.resolve(n.value.v).then(l, c) : u(o[0][2], n)
                } catch (t) {
                    u(o[0][3], t)
                }
                var n
            }

            function l(t) {
                s("next", t)
            }

            function c(t) {
                s("throw", t)
            }

            function u(t, e) {
                t(e), o.shift(), o.length && s(o[0][0], o[0][1])
            }
        }

        function Sp(t) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var e, n = t[Symbol.asyncIterator];
            return n ? n.call(t) : (t = Ep(t), e = {}, r("next"), r("throw"), r("return"), e[Symbol.asyncIterator] = function () {
                return this
            }, e);

            function r(n) {
                e[n] = t[n] && function (e) {
                    return new Promise((function (r, i) {
                        (function (t, e, n, r) {
                            Promise.resolve(r).then((function (e) {
                                t({
                                    value: e,
                                    done: n
                                })
                            }), e)
                        })(r, i, (e = t[n](e)).done, e.value)
                    }))
                }
            }
        }

        function Ip(t) {
            return "function" == typeof t
        }

        function Mp(t) {
            var e = t((function (t) {
                Error.call(t), t.stack = (new Error).stack
            }));
            return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e
        }
        "function" == typeof SuppressedError && SuppressedError;
        var Tp = Mp((function (t) {
            return function (e) {
                t(this), this.message = e ? e.length + " errors occurred during unsubscription:\n" + e.map((function (t, e) {
                    return e + 1 + ") " + t.toString()
                })).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = e
            }
        }));

        function Bp(t, e) {
            if (t) {
                var n = t.indexOf(e);
                0 <= n && t.splice(n, 1)
            }
        }
        var Rp = function () {
                function t(t) {
                    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null
                }
                return t.prototype.unsubscribe = function () {
                    var t, e, n, r, i;
                    if (!this.closed) {
                        this.closed = !0;
                        var o = this._parentage;
                        if (o)
                            if (this._parentage = null, Array.isArray(o)) try {
                                for (var a = Ep(o), s = a.next(); !s.done; s = a.next()) {
                                    s.value.remove(this)
                                }
                            } catch (e) {
                                t = {
                                    error: e
                                }
                            } finally {
                                try {
                                    s && !s.done && (e = a.return) && e.call(a)
                                } finally {
                                    if (t) throw t.error
                                }
                            } else o.remove(this);
                        var l = this.initialTeardown;
                        if (Ip(l)) try {
                            l()
                        } catch (t) {
                            i = t instanceof Tp ? t.errors : [t]
                        }
                        var c = this._finalizers;
                        if (c) {
                            this._finalizers = null;
                            try {
                                for (var u = Ep(c), h = u.next(); !h.done; h = u.next()) {
                                    var d = h.value;
                                    try {
                                        Pp(d)
                                    } catch (t) {
                                        i = null != i ? i : [], t instanceof Tp ? i = bp(bp([], xp(i)), xp(t.errors)) : i.push(t)
                                    }
                                }
                            } catch (t) {
                                n = {
                                    error: t
                                }
                            } finally {
                                try {
                                    h && !h.done && (r = u.return) && r.call(u)
                                } finally {
                                    if (n) throw n.error
                                }
                            }
                        }
                        if (i) throw new Tp(i)
                    }
                }, t.prototype.add = function (e) {
                    var n;
                    if (e && e !== this)
                        if (this.closed) Pp(e);
                        else {
                            if (e instanceof t) {
                                if (e.closed || e._hasParent(this)) return;
                                e._addParent(this)
                            }(this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(e)
                        }
                }, t.prototype._hasParent = function (t) {
                    var e = this._parentage;
                    return e === t || Array.isArray(e) && e.includes(t)
                }, t.prototype._addParent = function (t) {
                    var e = this._parentage;
                    this._parentage = Array.isArray(e) ? (e.push(t), e) : e ? [e, t] : t
                }, t.prototype._removeParent = function (t) {
                    var e = this._parentage;
                    e === t ? this._parentage = null : Array.isArray(e) && Bp(e, t)
                }, t.prototype.remove = function (e) {
                    var n = this._finalizers;
                    n && Bp(n, e), e instanceof t && e._removeParent(this)
                }, t.EMPTY = function () {
                    var e = new t;
                    return e.closed = !0, e
                }(), t
            }(),
            Lp = Rp.EMPTY;

        function Dp(t) {
            return t instanceof Rp || t && "closed" in t && Ip(t.remove) && Ip(t.add) && Ip(t.unsubscribe)
        }

        function Pp(t) {
            Ip(t) ? t() : t.unsubscribe()
        }
        var Op = {
                Promise: void 0
            },
            kp = {
                setTimeout: function (t, e) {
                    for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
                    return setTimeout.apply(void 0, bp([t, e], xp(n)))
                },
                clearTimeout: function (t) {
                    return clearTimeout(t)
                },
                delegate: void 0
            };

        function Up(t) {
            kp.setTimeout((function () {
                throw t
            }))
        }

        function Np() {}

        function Fp(t) {
            t()
        }
        var Qp = function (t) {
                function e(e) {
                    var n = t.call(this) || this;
                    return n.isStopped = !1, e ? (n.destination = e, Dp(e) && e.add(n)) : n.destination = zp, n
                }
                return vp(e, t), e.create = function (t, e, n) {
                    return new Gp(t, e, n)
                }, e.prototype.next = function (t) {
                    this.isStopped || this._next(t)
                }, e.prototype.error = function (t) {
                    this.isStopped || (this.isStopped = !0, this._error(t))
                }, e.prototype.complete = function () {
                    this.isStopped || (this.isStopped = !0, this._complete())
                }, e.prototype.unsubscribe = function () {
                    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null)
                }, e.prototype._next = function (t) {
                    this.destination.next(t)
                }, e.prototype._error = function (t) {
                    try {
                        this.destination.error(t)
                    } finally {
                        this.unsubscribe()
                    }
                }, e.prototype._complete = function () {
                    try {
                        this.destination.complete()
                    } finally {
                        this.unsubscribe()
                    }
                }, e
            }(Rp),
            $p = function () {
                function t(t) {
                    this.partialObserver = t
                }
                return t.prototype.next = function (t) {
                    var e = this.partialObserver;
                    if (e.next) try {
                        e.next(t)
                    } catch (t) {
                        Hp(t)
                    }
                }, t.prototype.error = function (t) {
                    var e = this.partialObserver;
                    if (e.error) try {
                        e.error(t)
                    } catch (t) {
                        Hp(t)
                    } else Hp(t)
                }, t.prototype.complete = function () {
                    var t = this.partialObserver;
                    if (t.complete) try {
                        t.complete()
                    } catch (t) {
                        Hp(t)
                    }
                }, t
            }(),
            Gp = function (t) {
                function e(e, n, r) {
                    var i, o = t.call(this) || this;
                    return i = Ip(e) || !e ? {
                        next: null != e ? e : void 0,
                        error: null != n ? n : void 0,
                        complete: null != r ? r : void 0
                    } : e, o.destination = new $p(i), o
                }
                return vp(e, t), e
            }(Qp);

        function Hp(t) {
            Up(t)
        }
        var zp = {
                closed: !0,
                next: Np,
                error: function (t) {
                    throw t
                },
                complete: Np
            },
            Vp = "function" == typeof Symbol && Symbol.observable || "@@observable";

        function Wp(t) {
            return t
        }
        var jp = function () {
            function t(t) {
                t && (this._subscribe = t)
            }
            return t.prototype.lift = function (e) {
                var n = new t;
                return n.source = this, n.operator = e, n
            }, t.prototype.subscribe = function (t, e, n) {
                var r, i = this,
                    o = (r = t) && r instanceof Qp || function (t) {
                        return t && Ip(t.next) && Ip(t.error) && Ip(t.complete)
                    }(r) && Dp(r) ? t : new Gp(t, e, n);
                return Fp((function () {
                    var t = i,
                        e = t.operator,
                        n = t.source;
                    o.add(e ? e.call(o, n) : n ? i._subscribe(o) : i._trySubscribe(o))
                })), o
            }, t.prototype._trySubscribe = function (t) {
                try {
                    return this._subscribe(t)
                } catch (e) {
                    t.error(e)
                }
            }, t.prototype.forEach = function (t, e) {
                var n = this;
                return new(e = Xp(e))((function (e, r) {
                    var i = new Gp({
                        next: function (e) {
                            try {
                                t(e)
                            } catch (t) {
                                r(t), i.unsubscribe()
                            }
                        },
                        error: r,
                        complete: e
                    });
                    n.subscribe(i)
                }))
            }, t.prototype._subscribe = function (t) {
                var e;
                return null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(t)
            }, t.prototype[Vp] = function () {
                return this
            }, t.prototype.pipe = function () {
                for (var t, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                return (0 === (t = e).length ? Wp : 1 === t.length ? t[0] : function (e) {
                    return t.reduce((function (t, e) {
                        return e(t)
                    }), e)
                })(this)
            }, t.prototype.toPromise = function (t) {
                var e = this;
                return new(t = Xp(t))((function (t, n) {
                    var r;
                    e.subscribe((function (t) {
                        return r = t
                    }), (function (t) {
                        return n(t)
                    }), (function () {
                        return t(r)
                    }))
                }))
            }, t.create = function (e) {
                return new t(e)
            }, t
        }();

        function Xp(t) {
            var e;
            return null !== (e = null != t ? t : Op.Promise) && void 0 !== e ? e : Promise
        }
        var qp = Mp((function (t) {
                return function () {
                    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed"
                }
            })),
            Yp = function (t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.closed = !1, e.currentObservers = null, e.observers = [], e.isStopped = !1, e.hasError = !1, e.thrownError = null, e
                }
                return vp(e, t), e.prototype.lift = function (t) {
                    var e = new Kp(this, this);
                    return e.operator = t, e
                }, e.prototype._throwIfClosed = function () {
                    if (this.closed) throw new qp
                }, e.prototype.next = function (t) {
                    var e = this;
                    Fp((function () {
                        var n, r;
                        if (e._throwIfClosed(), !e.isStopped) {
                            e.currentObservers || (e.currentObservers = Array.from(e.observers));
                            try {
                                for (var i = Ep(e.currentObservers), o = i.next(); !o.done; o = i.next()) {
                                    o.value.next(t)
                                }
                            } catch (t) {
                                n = {
                                    error: t
                                }
                            } finally {
                                try {
                                    o && !o.done && (r = i.return) && r.call(i)
                                } finally {
                                    if (n) throw n.error
                                }
                            }
                        }
                    }))
                }, e.prototype.error = function (t) {
                    var e = this;
                    Fp((function () {
                        if (e._throwIfClosed(), !e.isStopped) {
                            e.hasError = e.isStopped = !0, e.thrownError = t;
                            for (var n = e.observers; n.length;) n.shift().error(t)
                        }
                    }))
                }, e.prototype.complete = function () {
                    var t = this;
                    Fp((function () {
                        if (t._throwIfClosed(), !t.isStopped) {
                            t.isStopped = !0;
                            for (var e = t.observers; e.length;) e.shift().complete()
                        }
                    }))
                }, e.prototype.unsubscribe = function () {
                    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null
                }, Object.defineProperty(e.prototype, "observed", {
                    get: function () {
                        var t;
                        return (null === (t = this.observers) || void 0 === t ? void 0 : t.length) > 0
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._trySubscribe = function (e) {
                    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, e)
                }, e.prototype._subscribe = function (t) {
                    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t)
                }, e.prototype._innerSubscribe = function (t) {
                    var e = this,
                        n = this,
                        r = n.hasError,
                        i = n.isStopped,
                        o = n.observers;
                    return r || i ? Lp : (this.currentObservers = null, o.push(t), new Rp((function () {
                        e.currentObservers = null, Bp(o, t)
                    })))
                }, e.prototype._checkFinalizedStatuses = function (t) {
                    var e = this,
                        n = e.hasError,
                        r = e.thrownError,
                        i = e.isStopped;
                    n ? t.error(r) : i && t.complete()
                }, e.prototype.asObservable = function () {
                    var t = new jp;
                    return t.source = this, t
                }, e.create = function (t, e) {
                    return new Kp(t, e)
                }, e
            }(jp),
            Kp = function (t) {
                function e(e, n) {
                    var r = t.call(this) || this;
                    return r.destination = e, r.source = n, r
                }
                return vp(e, t), e.prototype.next = function (t) {
                    var e, n;
                    null === (n = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === n || n.call(e, t)
                }, e.prototype.error = function (t) {
                    var e, n;
                    null === (n = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === n || n.call(e, t)
                }, e.prototype.complete = function () {
                    var t, e;
                    null === (e = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === e || e.call(t)
                }, e.prototype._subscribe = function (t) {
                    var e, n;
                    return null !== (n = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(t)) && void 0 !== n ? n : Lp
                }, e
            }(Yp),
            Jp = function (t) {
                function e(e) {
                    var n = t.call(this) || this;
                    return n._value = e, n
                }
                return vp(e, t), Object.defineProperty(e.prototype, "value", {
                    get: function () {
                        return this.getValue()
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._subscribe = function (e) {
                    var n = t.prototype._subscribe.call(this, e);
                    return !n.closed && e.next(this._value), n
                }, e.prototype.getValue = function () {
                    var t = this,
                        e = t.hasError,
                        n = t.thrownError,
                        r = t._value;
                    if (e) throw n;
                    return this._throwIfClosed(), r
                }, e.prototype.next = function (e) {
                    t.prototype.next.call(this, this._value = e)
                }, e
            }(Yp);

        function Zp() {
            window.innerWidth < 768 && tf.layout.next("mobile"), window.innerWidth >= 768 && tf.layout.next("desktop")
        }
        var tf = {
            loading: new Jp({
                isLoading: !0,
                percent: null
            }),
            errors: new Jp({
                isError: !1,
                message: null
            }),
            layout: new Jp(null),
            resizeEvent: new Jp(!1),
            deviceOrientation: new Jp(null),
            renderingStatus: new Jp(!1),
            modelLoadingIndicator: new Jp({
                isLoading: !1,
                name: ""
            })
        };

        function ef(t) {
            return ef = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ef(t)
        }

        function nf(t, e) {
            for (var n in t) {
                var r = t[n],
                    i = ef(e[n]),
                    o = ef(r);
                "undefined" !== i && i === o && ("object" === i && "object" === o ? null === e[n] ? e[n] = t[n] : Array.isArray(e[n]) && Array.isArray(r) ? e[n] = rf(r, e[n]) : Array.isArray(e[n]) || Array.isArray(r) || null === r || nf(r, e[n]) : i === o && (e[n] = r))
            }
        }

        function rf(t, e) {
            if (Array.isArray(t) && Array.isArray(e) && 0 !== e.length) {
                var n = [],
                    r = e[0],
                    i = ef(e[0]);
                return "object" !== i ? t.forEach((function (t) {
                    i === ef(t) && n.push(t)
                })) : null === e[0] ? t.forEach((function (t) {
                    n.push(t)
                })) : Array.isArray(e[0]) ? console.log("2-d array will be skipped") : t.forEach((function (t) {
                    nf(t, r), n.push(JSON.parse(JSON.stringify(r)))
                })), n
            }
        }
        Zp(), window.addEventListener("resize", (function () {
            tf.resizeEvent.next(!0), Zp()
        }));
        for (var of = [], af = 0; af < 256; af++) of [af] = (af < 16 ? "0" : "") + af.toString(16);
        var sf = 1234567,
            lf = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function () {
                    var t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        r = 4294967295 * Math.random() | 0;
                    return (of [255 & t] + of [t >> 8 & 255] + of [t >> 16 & 255] + of [t >> 24 & 255] + "-" + of [255 & e] + of [e >> 8 & 255] + "-" + of [e >> 16 & 15 | 64] + of [e >> 24 & 255] + "-" + of [63 & n | 128] + of [n >> 8 & 255] + "-" + of [n >> 16 & 255] + of [n >> 24 & 255] + of [255 & r] + of [r >> 8 & 255] + of [r >> 16 & 255] + of [r >> 24 & 255]).toUpperCase()
                },
                clamp: function (t, e, n) {
                    return Math.max(e, Math.min(n, t))
                },
                euclideanModulo: function (t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function (t, e, n, r, i) {
                    return r + (t - e) * (i - r) / (n - e)
                },
                lerp: function (t, e, n) {
                    return (1 - n) * t + n * e
                },
                smoothstep: function (t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                },
                smootherstep: function (t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function (t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function (t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function (t) {
                    return t * (.5 - Math.random())
                },
                seededRandom: function (t) {
                    return void 0 !== t && (sf = t % 2147483647), ((sf = 16807 * sf % 2147483647) - 1) / 2147483646
                },
                degToRad: function (t) {
                    return t * lf.DEG2RAD
                },
                radToDeg: function (t) {
                    return t * lf.RAD2DEG
                },
                isPowerOfTwo: function (t) {
                    return 0 == (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function (t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function (t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                },
                setQuaternionFromProperEuler: function (t, e, n, r, i) {
                    var o = Math.cos,
                        a = Math.sin,
                        s = o(n / 2),
                        l = a(n / 2),
                        c = o((e + r) / 2),
                        u = a((e + r) / 2),
                        h = o((e - r) / 2),
                        d = a((e - r) / 2),
                        p = o((r - e) / 2),
                        f = a((r - e) / 2);
                    switch (i) {
                        case "XYX":
                            t.set(s * u, l * h, l * d, s * c);
                            break;
                        case "YZY":
                            t.set(l * d, s * u, l * h, s * c);
                            break;
                        case "ZXZ":
                            t.set(l * h, l * d, s * u, s * c);
                            break;
                        case "XZX":
                            t.set(s * u, l * f, l * p, s * c);
                            break;
                        case "YXY":
                            t.set(l * p, s * u, l * f, s * c);
                            break;
                        case "ZYZ":
                            t.set(l * f, l * p, s * u, s * c);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                    }
                }
            },
            cf = {
                container: null,
                paths: {
                    models_path: "/models/",
                    textures_path: "/textures/",
                    decoders_path: "/decoders/"
                },
                loadOnDemand: {
                    enabled: !0,
                    loadingManager: {
                        enabled: !0
                    }
                },
                useCompressedTextures: !1,
                renderer: {
                    renderOnDemand: {
                        enabled: !0
                    },
                    outputEncoding: Yi,
                    get pixelRatio() {
                        return Math.max(1, window.devicePixelRatio)
                    },
                    exposure: 1,
                    toneMapping: ei,
                    defaultRenderer: {
                        antialias: !0,
                        alpha: !0
                    }
                },
                camera: {
                    portraitAspect: .875,
                    landscapeAspect: 4 / 3.5,
                    near: 5,
                    far: 50,
                    fov: 45,
                    initPos: {
                        x: -10.873648212948423,
                        y: .4188578127354573,
                        z: 5.075787066382408
                    }
                },
                light: {
                    intensity: 1
                },
                envMap: {
                    intensity: 1.5
                },
                materials: {
                    metal: {
                        metalness: .2,
                        roughness: .3
                    },
                    wood: {
                        metalness: .2,
                        roughness: .7
                    }
                },
                aoMap: {
                    air: {
                        intensity: .5
                    },
                    powerwall: {
                        intensity: .65
                    },
                    desk: {
                        intensity: .5
                    },
                    roof: {
                        intensity: .5
                    },
                    patio: {
                        intensity: .5
                    },
                    exterior: {
                        intensity: .4
                    }
                },
                controls: {
                    thirdPerson: {
                        smoothTime: .07,
                        draggingSmoothTime: .07,
                        polarRotateSpeed: 1,
                        azimuthRotateSpeed: 1,
                        maxDistance: 4,
                        minDistance: 3,
                        maxPolarAngle: lf.degToRad(88),
                        minPolarAngle: lf.degToRad(0),
                        minAzimuthAngle: -1 / 0,
                        maxAzimuthAngle: 1 / 0,
                        minZoom: 2.25,
                        maxZoom: 10,
                        defaultZoom: 2.5
                    }
                },
                environment: {
                    assetsArray: [{
                        id: 1,
                        hdrTexturePath: "hdr/1.hdr",
                        name: "hdr-1",
                        defaultHdrIntensity: .9
                    }, {
                        id: 2,
                        hdrTexturePath: "hdr/2.hdr",
                        name: "hdr-2",
                        isDefault: !0,
                        defaultHdrIntensity: 1.5
                    }, {
                        id: 3,
                        hdrTexturePath: "hdr/3.hdr",
                        name: "hdr-3",
                        defaultHdrIntensity: .9
                    }, {
                        id: 4,
                        hdrTexturePath: "hdr/overcast.hdr",
                        name: "overcast",
                        defaultHdrIntensity: .05
                    }]
                },
                shadowMesh: {
                    opacity: .8
                },
                textures: [{
                    path: "Wood_basecolor.png",
                    name: "Wood_basecolor",
                    repeat: !0,
                    repeatSet: 50
                }, {
                    path: "Wood_normal.png",
                    name: "Wood_normal",
                    nonSrgb: !0,
                    repeat: !0,
                    repeatSet: 50
                }, {
                    path: "Metal_basecolor.png",
                    name: "Metal_basecolor",
                    repeat: !0,
                    repeatSet: 14.5
                }, {
                    path: "Metal_normal.png",
                    name: "Metal_normal",
                    nonSrgb: !0,
                    repeat: !0,
                    repeatSet: 14.5
                }, {
                    path: "grid_solar_panel_tiled_basecolor_dark.jpg",
                    name: "Solar_Panel"
                }, {
                    path: "grid_solar_panel_tiled_metallic.jpg",
                    name: "Solar_Panel_metalness"
                }, {
                    path: "Support/Deck_2K.png",
                    name: "cedar_ao_new"
                }, {
                    path: "Support/SupportPatio_2K.png",
                    name: "patio_supp_ao"
                }, {
                    path: "AO_AirEx.png",
                    ktxPath: "ktx/AO_AirEx.ktx2",
                    name: "ao_air_ex"
                }, {
                    path: "Albedo_Chair_512.jpg",
                    name: "Albedo_Chair_512"
                }, {
                    path: "Albedo_Bath_512.jpg",
                    name: "Albedo_Bath_512"
                }, {
                    path: "Albedo_Faucet_512.jpg",
                    name: "Albedo_Faucet_512"
                }, {
                    path: "Albedo_Oven_512.jpg",
                    name: "Albedo_Oven_512"
                }, {
                    path: "Albedo_Shelves_512.jpg",
                    name: "Albedo_Shelves_512"
                }, {
                    path: "Albedo_Wood_512.jpg",
                    name: "Albedo_Wood_512"
                }, {
                    path: "Albedo_Lamp_512.jpg",
                    name: "Albedo_Lamp_512"
                }, {
                    path: "Albedo_Sofa_512.jpg",
                    name: "Albedo_Sofa_512"
                }, {
                    path: "Albedo_Bed_512.jpg",
                    name: "Albedo_Bed_512"
                }, {
                    path: "Air_purification.jpg",
                    name: "Air_purification"
                }, {
                    path: "Oak_Wood_Varnished_Albedo_2Kt.jpg",
                    name: "Oak_Wood_Varnished_Albedo_2Kt",
                    repeat: !0
                }, {
                    path: "glass_orm.png",
                    name: "glass_orm",
                    repeat: !0
                }, {
                    path: "AO_channels.png",
                    name: "AO_channels"
                }, {
                    path: "Tesla_BaseColor.webp",
                    name: "Tesla_BaseColor"
                }, {
                    path: "Tesla_AO.webp",
                    name: "Tesla_AO"
                }, {
                    path: "TeslaFloor_AO.webp",
                    name: "TeslaFloor_AO"
                }, {
                    path: "TeslaWall_AO.webp",
                    name: "TeslaWall_AO"
                }],
                models: {
                    samara: {
                        complectationVars: {
                            Powerwall: {
                                variants: [{
                                    id: lf.generateUUID(),
                                    name: "Tesla Powerwall 3"
                                }, {
                                    id: lf.generateUUID(),
                                    name: "No Powerwall"
                                }]
                            },
                            Trim: {
                                variants: [{
                                    id: lf.generateUUID(),
                                    name: "wood"
                                }, {
                                    id: lf.generateUUID(),
                                    name: "metal"
                                }]
                            },
                            Support: {
                                variants: [{
                                    id: 1,
                                    name: "Bone white base",
                                    hex: 16580093
                                }, {
                                    id: 2,
                                    name: "Parchment base",
                                    hex: 14736851
                                }, {
                                    id: 5,
                                    name: "Dark bronze base",
                                    hex: 4341304
                                }]
                            },
                            Color: {
                                variants: [{
                                    id: 1,
                                    name: "Bone white base",
                                    hex: 16580093
                                }, {
                                    id: 2,
                                    name: "Parchment base",
                                    hex: 14736851
                                }, {
                                    id: 3,
                                    name: "Driftwood base",
                                    hex: 14475231
                                }, {
                                    id: 4,
                                    name: "Evergreen base",
                                    hex: 3426105
                                }, {
                                    id: 5,
                                    name: "Dark bronze base",
                                    hex: 4341304
                                }]
                            },
                            Roof: {
                                get camera() {
                                    return "XL 8" === tf.complectation.value.layout ? "roof-XL 8" : "roof"
                                },
                                variants: [{
                                    id: 8,
                                    name: "Dark Bronze Roof",
                                    hex: 3091755
                                }, {
                                    id: 7,
                                    name: "Metallic Silver Roof",
                                    hex: 13487565
                                }]
                            },
                            Layout: {
                                variants: [{
                                    camera: "front",
                                    name: "onebed"
                                }, {
                                    camera: "front",
                                    name: "studio"
                                }, {
                                    camera: "front",
                                    name: "twobed"
                                }, {
                                    camera: "right",
                                    name: "XL 8"
                                }, {
                                    camera: "right",
                                    name: "XL 10"
                                }]
                            },
                            Front: {
                                get camera() {
                                    return ["XL 8", "XL 10"].includes(tf.complectation.value.layout) ? "right" : "front"
                                },
                                variants: [{
                                    name: "window",
                                    include: {
                                        layouts: ["studio", "onebed", "twobed", "XL 8", "XL 10"]
                                    }
                                }, {
                                    name: "double doors",
                                    include: {
                                        layouts: ["studio", "onebed", "twobed", "XL 8", "XL 10"]
                                    }
                                }]
                            },
                            "Primary bedroom": {
                                get camera() {
                                    return "XL 8" === tf.complectation.value.layout ? "front" : "XL 10" === tf.complectation.value.layout ? "left" : void 0
                                },
                                variants: [{
                                    name: "window",
                                    include: {
                                        layouts: ["XL 8", "XL 10"]
                                    }
                                }, {
                                    name: "double doors",
                                    include: {
                                        layouts: ["XL 8", "XL 10"]
                                    }
                                }]
                            },
                            Left: {
                                camera: "left",
                                variants: [{
                                    name: "window",
                                    include: {
                                        layouts: ["studio", "onebed", "twobed"]
                                    }
                                }, {
                                    name: "double doors",
                                    include: {
                                        layouts: ["studio", "onebed", "twobed"]
                                    }
                                }]
                            },
                            Right: {
                                camera: "right",
                                variants: [{
                                    name: "window",
                                    include: {
                                        layouts: ["studio"]
                                    }
                                }, {
                                    name: "double doors",
                                    include: {
                                        layouts: ["studio"]
                                    }
                                }]
                            },
                            "Living room": {
                                camera: "rear",
                                variants: [{
                                    name: "window",
                                    include: {
                                        layouts: ["XL 8", "XL 10"]
                                    }
                                }, {
                                    name: "double doors",
                                    include: {
                                        layouts: ["XL 8", "XL 10"]
                                    }
                                }]
                            },
                            "Secondary bedroom": {
                                camera: "rear",
                                variants: [{
                                    name: "window",
                                    include: {
                                        layouts: ["XL 8", "XL 10"]
                                    }
                                }, {
                                    name: "double doors",
                                    include: {
                                        layouts: ["XL 8", "XL 10"]
                                    }
                                }]
                            },
                            Solar: {
                                get camera() {
                                    return "XL 8" === tf.complectation.value.layout ? "roof-XL 8" : "roof"
                                },
                                variants: [{
                                    name: "no-solar"
                                }, {
                                    name: "solar-full"
                                }, {
                                    name: "solar-half"
                                }]
                            }
                        },
                        modelScaleAspectValue: 150,
                        assetsArray: [{
                            name: "onebed",
                            totalAssetsCount: 41,
                            path: "1B.glb",
                            textures: [{
                                path: "Wall_i_1B.png",
                                name: "Wall_i_1B"
                            }, {
                                path: "Wood_1B.png",
                                name: "Wood_1B"
                            }, {
                                path: "Floor_1B.png",
                                name: "Floor_1B"
                            }, {
                                path: "1_1B.png",
                                name: "1_1B"
                            }, {
                                path: "2_1B.png",
                                name: "2_1B"
                            }, {
                                path: "3_1B.png",
                                name: "3_1B"
                            }, {
                                path: "4_1B.png",
                                name: "4_1B"
                            }, {
                                path: "Wall_e_1B_2.webp",
                                name: "exterior_ao_onebed_nosolar"
                            }, {
                                path: "Wall_e_1B_1.webp",
                                name: "exterior_ao_onebed_solar_no_cables"
                            }, {
                                path: "AO_RoofSolarFull - no cables.png",
                                name: "roof_solar_full_ao_onebed_no_cables"
                            }, {
                                path: "AO_RoofSolarOne - no cables.png",
                                name: "roof_solar_half_ao_onebed_no_cables"
                            }, {
                                path: "AO_1BedRoof_SolarClean_1K.png",
                                name: "roof_solar_none_ao_onebed"
                            }]
                        }, {
                            name: "studio",
                            totalAssetsCount: 47,
                            path: "Studio.glb",
                            textures: [{
                                path: "Wall_i_S.png",
                                name: "Wall_i_S"
                            }, {
                                path: "1_S.png",
                                name: "1_S"
                            }, {
                                path: "2_S.png",
                                name: "2_S"
                            }, {
                                path: "3_S.png",
                                name: "3_S"
                            }, {
                                path: "4_S.png",
                                name: "4_S"
                            }, {
                                path: "5_S.png",
                                name: "5_S"
                            }, {
                                path: "6_S.png",
                                name: "6_S"
                            }, {
                                path: "Shelves_studio.webp",
                                name: "Shelves_studio"
                            }, {
                                path: "Wall_e_S_1.webp",
                                name: "exterior_ao_studio_no_cables"
                            }, {
                                path: "Wall_e_S_2.webp",
                                name: "exterior_ao_studio_nosolar"
                            }, {
                                path: "Wall_e_S_1_D.webp",
                                name: "studio_exterior_ao_stairs_solar_no_cables"
                            }, {
                                path: "Wall_e_S_2_D.webp",
                                name: "studio_exterior_ao_stairs_no_solar"
                            }, {
                                path: "S_AO_RoofSolarFull - no cables.png",
                                name: "roof_solar_full_ao_studio_no_cables"
                            }, {
                                path: "S_AO_RoofSolarOne - no cables.png",
                                name: "roof_solar_half_ao_studio_no_cables"
                            }, {
                                path: "AO_RoofSolarClean_S_1K.png",
                                name: "roof_solar_none_ao_studio"
                            }, {
                                path: "Albedo_Chair1_S_512.jpg",
                                name: "Albedo_Chair1_S_512"
                            }, {
                                path: "Floor_S.png",
                                name: "Floor_S"
                            }, {
                                path: "Wood_S.png",
                                name: "Wood_S"
                            }]
                        }, {
                            name: "twobed",
                            totalAssetsCount: 41,
                            path: "2B.glb",
                            textures: [{
                                path: "Wall_i_2B.png",
                                name: "Wall_i_2B"
                            }, {
                                path: "1_2B.png",
                                name: "1_2B"
                            }, {
                                path: "2_2B.png",
                                name: "2_2B"
                            }, {
                                path: "3_2B.png",
                                name: "3_2B"
                            }, {
                                path: "4_2B.png",
                                name: "4_2B"
                            }, {
                                path: "Wall_e_2B_1.webp",
                                name: "exterior_ao_twobed_solar_no_cables"
                            }, {
                                path: "Wall_e_2B_2.webp",
                                name: "exterior_ao_twobed_nosolar"
                            }, {
                                path: "Roof_2B_Clean_1Kt.webp",
                                name: "roof_solar_none_ao_twobed"
                            }, {
                                path: "Roof_2B_Full_1Kt - no cables.webp",
                                name: "roof_solar_full_ao_twobed_no_cables"
                            }, {
                                path: "Roof_2B_One_1Kt - no cables.webp",
                                name: "roof_solar_half_ao_twobed_no_cables"
                            }, {
                                path: "Floor_2B.png",
                                name: "Floor_2B"
                            }, {
                                path: "Wood_2B.png",
                                name: "Wood_2B"
                            }]
                        }, {
                            name: "XL 8",
                            totalAssetsCount: 50,
                            path: "XL8.glb",
                            textures: [{
                                path: "1_2BA.png",
                                name: "1_2BA"
                            }, {
                                path: "2_2BA.png",
                                name: "2_2BA"
                            }, {
                                path: "3_2BA.png",
                                name: "3_2BA"
                            }, {
                                path: "4_2BA.png",
                                name: "4_2BA"
                            }, {
                                path: "5_2BA.png",
                                name: "5_2BA"
                            }, {
                                path: "6_2BA.png",
                                name: "6_2BA"
                            }, {
                                path: "7_2BA.png",
                                name: "7_2BA"
                            }, {
                                path: "8_2BA.png",
                                name: "8_2BA"
                            }, {
                                path: "AO_XL8_1.webp",
                                name: "AO_XL8_1"
                            }, {
                                path: "AO_XL8.webp",
                                name: "AO_XL8"
                            }, {
                                path: "Roof_XL8_Clear.png",
                                name: "Roof_2BA_Clear"
                            }, {
                                path: "Roof_XL8_Full.png",
                                name: "Roof_2BA_Full"
                            }, {
                                path: "Roof_XL8_One.png",
                                name: "Roof_2BA_One"
                            }, {
                                path: "Shelves_XL8.png",
                                name: "Shelves_XL8"
                            }, {
                                path: "Base_2BA.png",
                                name: "Base_2BA"
                            }, {
                                path: "Chair_XL8.png",
                                name: "Chair_2BA"
                            }, {
                                path: "Floor_XL8.png",
                                name: "Floor_2BA"
                            }, {
                                path: "Sofa_2BA_1K.png",
                                name: "Sofa_2BA"
                            }, {
                                path: "Wall_XL8.png",
                                name: "Wall_2BA_1K"
                            }, {
                                path: "Wood_XL8.png",
                                name: "Wood_2BA"
                            }, {
                                path: "Technique_XL8.png",
                                name: "Technique_2BA"
                            }]
                        }, {
                            name: "XL 10",
                            totalAssetsCount: 51,
                            path: "XL10.glb",
                            textures: [{
                                path: "XL10-no-solar.png",
                                name: "XL10-no-solar"
                            }, {
                                path: "XL10-solar-half.png",
                                name: "XL10-solar-half"
                            }, {
                                path: "XL10-solar-full.png",
                                name: "XL10-solar-full"
                            }, {
                                path: "1_XL10.png",
                                name: "1_XL10"
                            }, {
                                path: "2_XL10.png",
                                name: "2_XL10"
                            }, {
                                path: "3_XL10.png",
                                name: "3_XL10"
                            }, {
                                path: "4_XL10.png",
                                name: "4_XL10"
                            }, {
                                path: "5_XL10.png",
                                name: "5_XL10"
                            }, {
                                path: "6_XL10.png",
                                name: "6_XL10"
                            }, {
                                path: "7_XL10.png",
                                name: "7_XL10"
                            }, {
                                path: "8_XL10.png",
                                name: "8_XL10"
                            }, {
                                path: "AO_XL10.webp",
                                name: "AO_XL10"
                            }, {
                                path: "AO_XL10_1.webp",
                                name: "AO_XL10_1"
                            }, {
                                path: "Floor_XL10.png",
                                name: "Floor_XL10"
                            }, {
                                path: "Chair_XL10.png",
                                name: "Chair_XL10"
                            }, {
                                path: "Wall_XL10.png",
                                name: "Wall_XL10"
                            }, {
                                path: "Shelves_XL10.png",
                                name: "Shelves_XL10"
                            }, {
                                path: "Base_2BA.png",
                                name: "Base_2BA"
                            }, {
                                path: "Wood_XL8.png",
                                name: "Wood_2BA"
                            }, {
                                path: "Technique_XL8.png",
                                name: "Technique_2BA"
                            }]
                        }],
                        scale: {
                            x: .3,
                            y: .3,
                            z: .3
                        },
                        rotation: Math.PI
                    }
                }
            };

        function uf(t) {
            return uf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, uf(t)
        }

        function hf() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            hf = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == uf(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError(uf(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function df(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function pf(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, ff(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function ff(t) {
            var e = function (t, e) {
                if ("object" != uf(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != uf(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == uf(e) ? e : String(e)
        }
        var mf = function () {
            function t(e) {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.targetIndex = 0, this.engine = e, this.targetPositions = [{
                    name: "front",
                    x: 0,
                    y: .4188578127354573,
                    z: 12
                }, {
                    name: "rear",
                    x: 0,
                    y: .4188578127354573,
                    z: -12
                }, {
                    x: 11.407499969005585,
                    y: .4188578127354573,
                    z: 0
                }, {
                    x: 0,
                    y: .4188578127354573,
                    z: -12
                }, {
                    name: "left",
                    x: -11.407499969005585,
                    y: .4188578127354573,
                    z: 0
                }, {
                    name: "right",
                    x: 11.407499969005585,
                    y: .4188578127354573,
                    z: 0
                }, {
                    name: "roof",
                    x: 10.906420218726824,
                    y: 1.3678992277499347,
                    z: -4.81444178646579
                }, {
                    name: "roof-XL 8",
                    x: -10.906420218726824,
                    y: 1.3678992277499347,
                    z: 4.81444178646579
                }]
            }
            var e, n;
            return pf(t, [{
                key: "setPositionSpherical",
                value: function (t, e, n, r) {
                    var i = this,
                        o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : En.easeInOut,
                        a = this.getControls().camera,
                        s = (new Zo).copy(a.position),
                        l = new Zo(a.position.x, a.position.y, a.position.z),
                        c = new Zo(t, e, n);
                    l.normalize(), c.normalize();
                    var u, h = new Jo(0, 0, 0, 1),
                        d = (new Jo).setFromUnitVectors(l, c),
                        p = new Jo,
                        f = a.position.clone(),
                        m = {
                            t: 0
                        },
                        g = zr.timeline();
                    return {
                        start: function () {
                            return new Promise((function (t) {
                                u = g.to(m, {
                                    t: 1,
                                    ease: o,
                                    duration: r,
                                    onComplete: function () {
                                        tf.renderingStatus.next(!1), t()
                                    },
                                    onInterrupt: function () {
                                        tf.renderingStatus.next(!1), t()
                                    },
                                    onUpdate: function () {
                                        f.set(s.x, s.y, s.z), p.slerpQuaternions(h, d, m.t), f.applyQuaternion(p), i.engine.controls.setPosition(f.x, f.y, f.z, !1), a.lookAt(0, 0, 0), tf.renderingStatus.next(!0)
                                    }
                                })
                            }))
                        },
                        cancel: function () {
                            u && g.remove(u)
                        }
                    }
                }
            }, {
                key: "setLookAt",
                value: function (t, e, n, r, i, o, a) {
                    var s = this,
                        l = this.engine.controls.getTarget(),
                        c = {
                            x: r,
                            y: i,
                            z: o
                        },
                        u = this.engine.controls.getPosition(),
                        h = {
                            x: t,
                            y: e,
                            z: n
                        },
                        d = zr.timeline();
                    return d.to({
                        t: 0
                    }, {
                        t: 1,
                        duration: a,
                        onStart: function () {
                            tf.renderingStatus.next(!0)
                        },
                        onComplete: function () {
                            s.engine.controls.enabled = !0, tf.renderingStatus.next(!1)
                        },
                        onUpdate: function () {
                            tf.renderingStatus.next(!0);
                            var t = d.progress();
                            s.engine.controls.enabled = !1, s.engine.controls.lerpLookAt(u.x, u.y, u.z, l.x, l.y, l.z, h.x, h.y, h.z, c.x, c.y, c.z, t, !0)
                        }
                    }), this.engine.update(), d
                }
            }, {
                key: "getControls",
                value: function () {
                    return this.engine.controls
                }
            }, {
                key: "setPosition",
                value: (e = hf().mark((function t(e, n) {
                    var r, i, o, a, s, l, c, u, h, d = this,
                        p = arguments;
                    return hf().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if (r = !(p.length > 2 && void 0 !== p[2]) || p[2], void 0 === n ? (this.targetIndex += e, this.targetIndex >= this.targetPositions.length ? this.targetIndex = 0 : this.targetIndex < 0 && (this.targetIndex = this.targetPositions.length - 1)) : (i = this.targetPositions.find((function (t) {
                                        return t.name === n
                                    })), this.targetIndex = this.targetPositions.indexOf(i)), o = this.engine.controls.getPosition(), a = this.targetPositions[this.targetIndex], s = .05, !(Math.abs(o.x - a.x) <= s && Math.abs(o.y - a.y) <= s && Math.abs(o.z - a.z) <= s)) {
                                    t.next = 7;
                                    break
                                }
                                return t.abrupt("return", "Positions are same");
                            case 7:
                                return l = {
                                    t: 0
                                }, c = this.engine.controls.getTarget(), u = this.engine.controls.getTarget(), (h = zr.timeline()).to(l, {
                                    t: 1,
                                    duration: r ? .3 : .01,
                                    onStart: function () {
                                        tf.renderingStatus.next(!0)
                                    },
                                    onComplete: function () {
                                        d.engine.controls.enabled = !0, tf.renderingStatus.next(!1)
                                    },
                                    onUpdate: function () {
                                        tf.renderingStatus.next(!0);
                                        var t = h.progress();
                                        d.engine.controls.enabled = !1, d.engine.controls.lerpLookAt(o.x, o.y, o.z, c.x, c.y, c.z, a.x, a.y, a.z, u.x, u.y, u.z, t, r)
                                    }
                                }), this.engine.update(), t.abrupt("return", h);
                            case 14:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                })), n = function () {
                    var t = this,
                        n = arguments;
                    return new Promise((function (r, i) {
                        var o = e.apply(t, n);

                        function a(t) {
                            df(o, r, i, a, s, "next", t)
                        }

                        function s(t) {
                            df(o, r, i, a, s, "throw", t)
                        }
                        a(void 0)
                    }))
                }, function (t, e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setDefaultCam",
                value: function () {
                    var t = cf.models.samara.complectationVars.Layout.variants.find((function (t) {
                            return t.name === tf.complectation.value.layout
                        })).camera,
                        e = this.targetPositions.find((function (e) {
                            return e.name === t
                        }));
                    this.engine.controls.setPosition(e.x, e.y, e.z)
                }
            }]), t
        }();
        /*!
         * camera-controls
         * https://github.com/yomotsu/camera-controls
         * (c) 2017 @yomotsu
         * Released under the MIT License.
         */
        const gf = 1,
            Af = 2,
            vf = 4,
            _f = Object.freeze({
                NONE: 0,
                ROTATE: 1,
                TRUCK: 2,
                OFFSET: 4,
                DOLLY: 8,
                ZOOM: 16,
                TOUCH_ROTATE: 32,
                TOUCH_TRUCK: 64,
                TOUCH_OFFSET: 128,
                TOUCH_DOLLY: 256,
                TOUCH_ZOOM: 512,
                TOUCH_DOLLY_TRUCK: 1024,
                TOUCH_DOLLY_OFFSET: 2048,
                TOUCH_DOLLY_ROTATE: 4096,
                TOUCH_ZOOM_TRUCK: 8192,
                TOUCH_ZOOM_OFFSET: 16384,
                TOUCH_ZOOM_ROTATE: 32768
            }),
            yf = 0,
            Ef = 1,
            xf = -1;

        function bf(t) {
            return t.isPerspectiveCamera
        }

        function wf(t) {
            return t.isOrthographicCamera
        }
        const Cf = 2 * Math.PI,
            Sf = Math.PI / 2,
            If = 1e-5,
            Mf = Math.PI / 180;

        function Tf(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function Bf(t, e = If) {
            return Math.abs(t) < e
        }

        function Rf(t, e, n = If) {
            return Bf(t - e, n)
        }

        function Lf(t, e) {
            return Math.round(t / e) * e
        }

        function Df(t) {
            return isFinite(t) ? t : t < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE
        }

        function Pf(t) {
            return Math.abs(t) < Number.MAX_VALUE ? t : t * (1 / 0)
        }

        function Of(t, e, n, r, i = 1 / 0, o) {
            const a = 2 / (r = Math.max(1e-4, r)),
                s = a * o,
                l = 1 / (1 + s + .48 * s * s + .235 * s * s * s);
            let c = t - e;
            const u = e,
                h = i * r;
            c = Tf(c, -h, h), e = t - c;
            const d = (n.value + a * c) * o;
            n.value = (n.value - a * d) * l;
            let p = e + (c + d) * l;
            return u - t > 0 == p > u && (p = u, n.value = (p - u) / o), p
        }

        function kf(t, e, n, r, i = 1 / 0, o, a) {
            const s = 2 / (r = Math.max(1e-4, r)),
                l = s * o,
                c = 1 / (1 + l + .48 * l * l + .235 * l * l * l);
            let u = e.x,
                h = e.y,
                d = e.z,
                p = t.x - u,
                f = t.y - h,
                m = t.z - d;
            const g = u,
                A = h,
                v = d,
                _ = i * r,
                y = p * p + f * f + m * m;
            if (y > _ * _) {
                const t = Math.sqrt(y);
                p = p / t * _, f = f / t * _, m = m / t * _
            }
            u = t.x - p, h = t.y - f, d = t.z - m;
            const E = (n.x + s * p) * o,
                x = (n.y + s * f) * o,
                b = (n.z + s * m) * o;
            n.x = (n.x - s * E) * c, n.y = (n.y - s * x) * c, n.z = (n.z - s * b) * c, a.x = u + (p + E) * c, a.y = h + (f + x) * c, a.z = d + (m + b) * c;
            const w = g - t.x,
                C = A - t.y,
                S = v - t.z;
            return w * (a.x - g) + C * (a.y - A) + S * (a.z - v) > 0 && (a.x = g, a.y = A, a.z = v, n.x = (a.x - g) / o, n.y = (a.y - A) / o, n.z = (a.z - v) / o), a
        }

        function Uf(t, e) {
            e.set(0, 0), t.forEach((t => {
                e.x += t.clientX, e.y += t.clientY
            })), e.x /= t.length, e.y /= t.length
        }

        function Nf(t, e) {
            return !!wf(t) && (console.warn(`${e} is not supported in OrthographicCamera`), !0)
        }
        class Ff {
            constructor() {
                this._listeners = {}
            }
            addEventListener(t, e) {
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            }
            removeAllEventListeners(t) {
                t ? Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0) : this._listeners = {}
            }
            dispatchEvent(t) {
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t)
                }
            }
        }
        var Qf;
        const $f = 1 / 8,
            Gf = /Mac/.test(null === (Qf = null === globalThis || void 0 === globalThis ? void 0 : globalThis.navigator) || void 0 === Qf ? void 0 : Qf.platform);
        let Hf, zf, Vf, Wf, jf, Xf, qf, Yf, Kf, Jf, Zf, tm, em, nm, rm, im, om, am, sm, lm, cm, um, hm;
        class dm extends Ff {
            static install(t) {
                Hf = t.THREE, zf = Object.freeze(new Hf.Vector3(0, 0, 0)), Vf = Object.freeze(new Hf.Vector3(0, 1, 0)), Wf = Object.freeze(new Hf.Vector3(0, 0, 1)), jf = new Hf.Vector2, Xf = new Hf.Vector3, qf = new Hf.Vector3, Yf = new Hf.Vector3, Kf = new Hf.Vector3, Jf = new Hf.Vector3, Zf = new Hf.Vector3, tm = new Hf.Vector3, em = new Hf.Vector3, nm = new Hf.Vector3, rm = new Hf.Spherical, im = new Hf.Spherical, om = new Hf.Box3, am = new Hf.Box3, sm = new Hf.Sphere, lm = new Hf.Quaternion, cm = new Hf.Quaternion, um = new Hf.Matrix4, hm = new Hf.Raycaster
            }
            static get ACTION() {
                return _f
            }
            constructor(t, e) {
                super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = .01, this.maxZoom = 1 / 0, this.smoothTime = .25, this.draggingSmoothTime = .125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = .01, this.colliderMeshes = [], this.cancel = () => {}, this._enabled = !0, this._state = _f.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect, this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = yf, this._thetaVelocity = {
                    value: 0
                }, this._phiVelocity = {
                    value: 0
                }, this._radiusVelocity = {
                    value: 0
                }, this._targetVelocity = new Hf.Vector3, this._focalOffsetVelocity = new Hf.Vector3, this._zoomVelocity = {
                    value: 0
                }, this._truckInternal = (t, e, n) => {
                    let r, i;
                    if (bf(this._camera)) {
                        const n = Xf.copy(this._camera.position).sub(this._target),
                            o = this._camera.getEffectiveFOV() * Mf,
                            a = n.length() * Math.tan(.5 * o);
                        r = this.truckSpeed * t * a / this._elementRect.height, i = this.truckSpeed * e * a / this._elementRect.height
                    } else {
                        if (!wf(this._camera)) return; {
                            const n = this._camera;
                            r = t * (n.right - n.left) / n.zoom / this._elementRect.width, i = e * (n.top - n.bottom) / n.zoom / this._elementRect.height
                        }
                    }
                    this.verticalDragToForward ? (n ? this.setFocalOffset(this._focalOffsetEnd.x + r, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(r, 0, !0), this.forward(-i, !0)) : n ? this.setFocalOffset(this._focalOffsetEnd.x + r, this._focalOffsetEnd.y + i, this._focalOffsetEnd.z, !0) : this.truck(r, i, !0)
                }, this._rotateInternal = (t, e) => {
                    const n = Cf * this.azimuthRotateSpeed * t / this._elementRect.height,
                        r = Cf * this.polarRotateSpeed * e / this._elementRect.height;
                    this.rotate(n, r, !0)
                }, this._dollyInternal = (t, e, n) => {
                    const r = Math.pow(.95, -t * this.dollySpeed),
                        i = this._sphericalEnd.radius,
                        o = this._sphericalEnd.radius * r,
                        a = Tf(o, this.minDistance, this.maxDistance),
                        s = a - o;
                    this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(o, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(s, !0), this._dollyToNoClamp(a, !0)) : this._dollyToNoClamp(a, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? o : a) - i, this._dollyControlCoord.set(e, n)), this._lastDollyDirection = Math.sign(-t)
                }, this._zoomInternal = (t, e, n) => {
                    const r = Math.pow(.95, t * this.dollySpeed),
                        i = this._zoom,
                        o = this._zoom * r;
                    this.zoomTo(o, !0), this.dollyToCursor && (this._changedZoom += o - i, this._dollyControlCoord.set(e, n))
                }, void 0 === Hf && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = (new Hf.Quaternion).setFromUnitVectors(this._camera.up, Vf), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = _f.NONE, this._target = new Hf.Vector3, this._targetEnd = this._target.clone(), this._focalOffset = new Hf.Vector3, this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = (new Hf.Spherical).setFromVector3(Xf.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [new Hf.Vector3, new Hf.Vector3, new Hf.Vector3, new Hf.Vector3], this._updateNearPlaneCorners(), this._boundary = new Hf.Box3(new Hf.Vector3(-1 / 0, -1 / 0, -1 / 0), new Hf.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new Hf.Vector2, this.mouseButtons = {
                    left: _f.ROTATE,
                    middle: _f.DOLLY,
                    right: _f.TRUCK,
                    wheel: bf(this._camera) ? _f.DOLLY : wf(this._camera) ? _f.ZOOM : _f.NONE
                }, this.touches = {
                    one: _f.TOUCH_ROTATE,
                    two: bf(this._camera) ? _f.TOUCH_DOLLY_TRUCK : wf(this._camera) ? _f.TOUCH_ZOOM_TRUCK : _f.NONE,
                    three: _f.TOUCH_TRUCK
                };
                const n = new Hf.Vector2,
                    r = new Hf.Vector2,
                    i = new Hf.Vector2,
                    o = t => {
                        if (!this._enabled || !this._domElement) return;
                        if (0 !== this._interactiveArea.left || 0 !== this._interactiveArea.top || 1 !== this._interactiveArea.width || 1 !== this._interactiveArea.height) {
                            const e = this._domElement.getBoundingClientRect(),
                                n = t.clientX / e.width,
                                r = t.clientY / e.height;
                            if (n < this._interactiveArea.left || n > this._interactiveArea.right || r < this._interactiveArea.top || r > this._interactiveArea.bottom) return
                        }
                        const e = "mouse" !== t.pointerType ? null : (t.buttons & gf) === gf ? gf : (t.buttons & vf) === vf ? vf : (t.buttons & Af) === Af ? Af : null;
                        if (null !== e) {
                            const t = this._findPointerByMouseButton(e);
                            t && this._disposePointer(t)
                        }
                        if ((t.buttons & gf) === gf && this._lockedPointer) return;
                        const n = {
                            pointerId: t.pointerId,
                            clientX: t.clientX,
                            clientY: t.clientY,
                            deltaX: 0,
                            deltaY: 0,
                            mouseButton: e
                        };
                        this._activePointers.push(n), this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                            passive: !1
                        }), this._domElement.ownerDocument.removeEventListener("pointerup", s), this._domElement.ownerDocument.addEventListener("pointermove", a, {
                            passive: !1
                        }), this._domElement.ownerDocument.addEventListener("pointerup", s), this._isDragging = !0, h(t)
                    },
                    a = t => {
                        t.cancelable && t.preventDefault();
                        const e = t.pointerId,
                            n = this._lockedPointer || this._findPointerById(e);
                        if (n) {
                            if (n.clientX = t.clientX, n.clientY = t.clientY, n.deltaX = t.movementX, n.deltaY = t.movementY, this._state = 0, "touch" === t.pointerType) switch (this._activePointers.length) {
                                case 1:
                                    this._state = this.touches.one;
                                    break;
                                case 2:
                                    this._state = this.touches.two;
                                    break;
                                case 3:
                                    this._state = this.touches.three
                            } else(!this._isDragging && this._lockedPointer || this._isDragging && (t.buttons & gf) === gf) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (t.buttons & vf) === vf && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (t.buttons & Af) === Af && (this._state = this._state | this.mouseButtons.right);
                            d()
                        }
                    },
                    s = t => {
                        const e = this._findPointerById(t.pointerId);
                        if (!e || e !== this._lockedPointer) {
                            if (e && this._disposePointer(e), "touch" === t.pointerType) switch (this._activePointers.length) {
                                case 0:
                                    this._state = _f.NONE;
                                    break;
                                case 1:
                                    this._state = this.touches.one;
                                    break;
                                case 2:
                                    this._state = this.touches.two;
                                    break;
                                case 3:
                                    this._state = this.touches.three
                            } else this._state = _f.NONE;
                            p()
                        }
                    };
                let l = -1;
                const c = t => {
                        if (!this._domElement) return;
                        if (!this._enabled || this.mouseButtons.wheel === _f.NONE) return;
                        if (0 !== this._interactiveArea.left || 0 !== this._interactiveArea.top || 1 !== this._interactiveArea.width || 1 !== this._interactiveArea.height) {
                            const e = this._domElement.getBoundingClientRect(),
                                n = t.clientX / e.width,
                                r = t.clientY / e.height;
                            if (n < this._interactiveArea.left || n > this._interactiveArea.right || r < this._interactiveArea.top || r > this._interactiveArea.bottom) return
                        }
                        if (t.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === _f.ROTATE || this.mouseButtons.wheel === _f.TRUCK) {
                            const t = performance.now();
                            l - t < 1e3 && this._getClientRect(this._elementRect), l = t
                        }
                        const e = Gf ? -1 : -3,
                            n = 1 === t.deltaMode ? t.deltaY / e : t.deltaY / (10 * e),
                            r = this.dollyToCursor ? (t.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0,
                            i = this.dollyToCursor ? (t.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
                        switch (this.mouseButtons.wheel) {
                            case _f.ROTATE:
                                this._rotateInternal(t.deltaX, t.deltaY), this._isUserControllingRotate = !0;
                                break;
                            case _f.TRUCK:
                                this._truckInternal(t.deltaX, t.deltaY, !1), this._isUserControllingTruck = !0;
                                break;
                            case _f.OFFSET:
                                this._truckInternal(t.deltaX, t.deltaY, !0), this._isUserControllingOffset = !0;
                                break;
                            case _f.DOLLY:
                                this._dollyInternal(-n, r, i), this._isUserControllingDolly = !0;
                                break;
                            case _f.ZOOM:
                                this._zoomInternal(-n, r, i), this._isUserControllingZoom = !0
                        }
                        this.dispatchEvent({
                            type: "control"
                        })
                    },
                    u = t => {
                        if (this._domElement && this._enabled) {
                            if (this.mouseButtons.right === dm.ACTION.NONE) {
                                const e = t instanceof PointerEvent ? t.pointerId : 0,
                                    n = this._findPointerById(e);
                                return n && this._disposePointer(n), this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                                    passive: !1
                                }), void this._domElement.ownerDocument.removeEventListener("pointerup", s)
                            }
                            t.preventDefault()
                        }
                    },
                    h = t => {
                        if (!this._enabled) return;
                        Uf(this._activePointers, jf), this._getClientRect(this._elementRect), n.copy(jf), r.copy(jf);
                        if (this._activePointers.length >= 2) {
                            const t = jf.x - this._activePointers[1].clientX,
                                e = jf.y - this._activePointers[1].clientY,
                                n = Math.sqrt(t * t + e * e);
                            i.set(0, n);
                            const o = .5 * (this._activePointers[0].clientX + this._activePointers[1].clientX),
                                a = .5 * (this._activePointers[0].clientY + this._activePointers[1].clientY);
                            r.set(o, a)
                        }
                        if (this._state = 0, t)
                            if ("pointerType" in t && "touch" === t.pointerType) switch (this._activePointers.length) {
                                case 1:
                                    this._state = this.touches.one;
                                    break;
                                case 2:
                                    this._state = this.touches.two;
                                    break;
                                case 3:
                                    this._state = this.touches.three
                            } else this._lockedPointer || (t.buttons & gf) !== gf || (this._state = this._state | this.mouseButtons.left), (t.buttons & vf) === vf && (this._state = this._state | this.mouseButtons.middle), (t.buttons & Af) === Af && (this._state = this._state | this.mouseButtons.right);
                            else this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
                        (this._state & _f.ROTATE) !== _f.ROTATE && (this._state & _f.TOUCH_ROTATE) !== _f.TOUCH_ROTATE && (this._state & _f.TOUCH_DOLLY_ROTATE) !== _f.TOUCH_DOLLY_ROTATE && (this._state & _f.TOUCH_ZOOM_ROTATE) !== _f.TOUCH_ZOOM_ROTATE || (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), (this._state & _f.TRUCK) !== _f.TRUCK && (this._state & _f.TOUCH_TRUCK) !== _f.TOUCH_TRUCK && (this._state & _f.TOUCH_DOLLY_TRUCK) !== _f.TOUCH_DOLLY_TRUCK && (this._state & _f.TOUCH_ZOOM_TRUCK) !== _f.TOUCH_ZOOM_TRUCK || (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), (this._state & _f.DOLLY) !== _f.DOLLY && (this._state & _f.TOUCH_DOLLY) !== _f.TOUCH_DOLLY && (this._state & _f.TOUCH_DOLLY_TRUCK) !== _f.TOUCH_DOLLY_TRUCK && (this._state & _f.TOUCH_DOLLY_OFFSET) !== _f.TOUCH_DOLLY_OFFSET && (this._state & _f.TOUCH_DOLLY_ROTATE) !== _f.TOUCH_DOLLY_ROTATE || (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), (this._state & _f.ZOOM) !== _f.ZOOM && (this._state & _f.TOUCH_ZOOM) !== _f.TOUCH_ZOOM && (this._state & _f.TOUCH_ZOOM_TRUCK) !== _f.TOUCH_ZOOM_TRUCK && (this._state & _f.TOUCH_ZOOM_OFFSET) !== _f.TOUCH_ZOOM_OFFSET && (this._state & _f.TOUCH_ZOOM_ROTATE) !== _f.TOUCH_ZOOM_ROTATE || (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), (this._state & _f.OFFSET) !== _f.OFFSET && (this._state & _f.TOUCH_OFFSET) !== _f.TOUCH_OFFSET && (this._state & _f.TOUCH_DOLLY_OFFSET) !== _f.TOUCH_DOLLY_OFFSET && (this._state & _f.TOUCH_ZOOM_OFFSET) !== _f.TOUCH_ZOOM_OFFSET || (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({
                            type: "controlstart"
                        })
                    },
                    d = () => {
                        if (!this._enabled || !this._dragNeedsUpdate) return;
                        this._dragNeedsUpdate = !1, Uf(this._activePointers, jf);
                        const t = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null,
                            e = t ? -t.deltaX : r.x - jf.x,
                            o = t ? -t.deltaY : r.y - jf.y;
                        if (r.copy(jf), (this._state & _f.ROTATE) !== _f.ROTATE && (this._state & _f.TOUCH_ROTATE) !== _f.TOUCH_ROTATE && (this._state & _f.TOUCH_DOLLY_ROTATE) !== _f.TOUCH_DOLLY_ROTATE && (this._state & _f.TOUCH_ZOOM_ROTATE) !== _f.TOUCH_ZOOM_ROTATE || (this._rotateInternal(e, o), this._isUserControllingRotate = !0), (this._state & _f.DOLLY) === _f.DOLLY || (this._state & _f.ZOOM) === _f.ZOOM) {
                            const t = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0,
                                e = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0,
                                r = this.dollyDragInverted ? -1 : 1;
                            (this._state & _f.DOLLY) === _f.DOLLY ? (this._dollyInternal(r * o * $f, t, e), this._isUserControllingDolly = !0) : (this._zoomInternal(r * o * $f, t, e), this._isUserControllingZoom = !0)
                        }
                        if ((this._state & _f.TOUCH_DOLLY) === _f.TOUCH_DOLLY || (this._state & _f.TOUCH_ZOOM) === _f.TOUCH_ZOOM || (this._state & _f.TOUCH_DOLLY_TRUCK) === _f.TOUCH_DOLLY_TRUCK || (this._state & _f.TOUCH_ZOOM_TRUCK) === _f.TOUCH_ZOOM_TRUCK || (this._state & _f.TOUCH_DOLLY_OFFSET) === _f.TOUCH_DOLLY_OFFSET || (this._state & _f.TOUCH_ZOOM_OFFSET) === _f.TOUCH_ZOOM_OFFSET || (this._state & _f.TOUCH_DOLLY_ROTATE) === _f.TOUCH_DOLLY_ROTATE || (this._state & _f.TOUCH_ZOOM_ROTATE) === _f.TOUCH_ZOOM_ROTATE) {
                            const t = jf.x - this._activePointers[1].clientX,
                                e = jf.y - this._activePointers[1].clientY,
                                n = Math.sqrt(t * t + e * e),
                                o = i.y - n;
                            i.set(0, n);
                            const a = this.dollyToCursor ? (r.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0,
                                s = this.dollyToCursor ? (r.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
                            (this._state & _f.TOUCH_DOLLY) === _f.TOUCH_DOLLY || (this._state & _f.TOUCH_DOLLY_ROTATE) === _f.TOUCH_DOLLY_ROTATE || (this._state & _f.TOUCH_DOLLY_TRUCK) === _f.TOUCH_DOLLY_TRUCK || (this._state & _f.TOUCH_DOLLY_OFFSET) === _f.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(o * $f, a, s), this._isUserControllingDolly = !0) : (this._zoomInternal(o * $f, a, s), this._isUserControllingZoom = !0)
                        }(this._state & _f.TRUCK) !== _f.TRUCK && (this._state & _f.TOUCH_TRUCK) !== _f.TOUCH_TRUCK && (this._state & _f.TOUCH_DOLLY_TRUCK) !== _f.TOUCH_DOLLY_TRUCK && (this._state & _f.TOUCH_ZOOM_TRUCK) !== _f.TOUCH_ZOOM_TRUCK || (this._truckInternal(e, o, !1), this._isUserControllingTruck = !0), (this._state & _f.OFFSET) !== _f.OFFSET && (this._state & _f.TOUCH_OFFSET) !== _f.TOUCH_OFFSET && (this._state & _f.TOUCH_DOLLY_OFFSET) !== _f.TOUCH_DOLLY_OFFSET && (this._state & _f.TOUCH_ZOOM_OFFSET) !== _f.TOUCH_ZOOM_OFFSET || (this._truckInternal(e, o, !0), this._isUserControllingOffset = !0), this.dispatchEvent({
                            type: "control"
                        })
                    },
                    p = () => {
                        Uf(this._activePointers, jf), r.copy(jf), this._dragNeedsUpdate = !1, (0 === this._activePointers.length || 1 === this._activePointers.length && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), 0 === this._activePointers.length && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                            passive: !1
                        }), this._domElement.ownerDocument.removeEventListener("pointerup", s), this.dispatchEvent({
                            type: "controlend"
                        }))
                    };
                this.lockPointer = () => {
                    this._enabled && this._domElement && (this.cancel(), this._lockedPointer = {
                        pointerId: -1,
                        clientX: 0,
                        clientY: 0,
                        deltaX: 0,
                        deltaY: 0,
                        mouseButton: null
                    }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                        passive: !1
                    }), this._domElement.ownerDocument.removeEventListener("pointerup", s), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", f), this._domElement.ownerDocument.addEventListener("pointerlockerror", m), this._domElement.ownerDocument.addEventListener("pointermove", a, {
                        passive: !1
                    }), this._domElement.ownerDocument.addEventListener("pointerup", s), h())
                }, this.unlockPointer = () => {
                    var t, e, n;
                    null !== this._lockedPointer && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), null === (t = this._domElement) || void 0 === t || t.ownerDocument.exitPointerLock(), null === (e = this._domElement) || void 0 === e || e.ownerDocument.removeEventListener("pointerlockchange", f), null === (n = this._domElement) || void 0 === n || n.ownerDocument.removeEventListener("pointerlockerror", m), this.cancel()
                };
                const f = () => {
                        this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer()
                    },
                    m = () => {
                        this.unlockPointer()
                    };
                this._addAllEventListeners = t => {
                    this._domElement = t, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o), this._domElement.addEventListener("pointercancel", s), this._domElement.addEventListener("wheel", c, {
                        passive: !1
                    }), this._domElement.addEventListener("contextmenu", u)
                }, this._removeAllEventListeners = () => {
                    this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o), this._domElement.removeEventListener("pointercancel", s), this._domElement.removeEventListener("wheel", c, {
                        passive: !1
                    }), this._domElement.removeEventListener("contextmenu", u), this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                        passive: !1
                    }), this._domElement.ownerDocument.removeEventListener("pointerup", s), this._domElement.ownerDocument.removeEventListener("pointerlockchange", f), this._domElement.ownerDocument.removeEventListener("pointerlockerror", m))
                }, this.cancel = () => {
                    this._state !== _f.NONE && (this._state = _f.NONE, this._activePointers.length = 0, p())
                }, e && this.connect(e), this.update(0)
            }
            get camera() {
                return this._camera
            }
            set camera(t) {
                this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0
            }
            get enabled() {
                return this._enabled
            }
            set enabled(t) {
                this._enabled = t, this._domElement && (t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""))
            }
            get active() {
                return !this._hasRested
            }
            get currentAction() {
                return this._state
            }
            get distance() {
                return this._spherical.radius
            }
            set distance(t) {
                this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = !0)
            }
            get azimuthAngle() {
                return this._spherical.theta
            }
            set azimuthAngle(t) {
                this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = !0)
            }
            get polarAngle() {
                return this._spherical.phi
            }
            set polarAngle(t) {
                this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = !0)
            }
            get boundaryEnclosesCamera() {
                return this._boundaryEnclosesCamera
            }
            set boundaryEnclosesCamera(t) {
                this._boundaryEnclosesCamera = t, this._needsUpdate = !0
            }
            set interactiveArea(t) {
                this._interactiveArea.width = Tf(t.width, 0, 1), this._interactiveArea.height = Tf(t.height, 0, 1), this._interactiveArea.x = Tf(t.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Tf(t.y, 0, 1 - this._interactiveArea.height)
            }
            addEventListener(t, e) {
                super.addEventListener(t, e)
            }
            removeEventListener(t, e) {
                super.removeEventListener(t, e)
            }
            rotate(t, e, n = !1) {
                return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, n)
            }
            rotateAzimuthTo(t, e = !1) {
                return this.rotateTo(t, this._sphericalEnd.phi, e)
            }
            rotatePolarTo(t, e = !1) {
                return this.rotateTo(this._sphericalEnd.theta, t, e)
            }
            rotateTo(t, e, n = !1) {
                this._isUserControllingRotate = !1;
                const r = Tf(t, this.minAzimuthAngle, this.maxAzimuthAngle),
                    i = Tf(e, this.minPolarAngle, this.maxPolarAngle);
                this._sphericalEnd.theta = r, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
                const o = !n || Rf(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Rf(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
                return this._createOnRestPromise(o)
            }
            dolly(t, e = !1) {
                return this.dollyTo(this._sphericalEnd.radius - t, e)
            }
            dollyTo(t, e = !1) {
                return this._isUserControllingDolly = !1, this._lastDollyDirection = yf, this._changedDolly = 0, this._dollyToNoClamp(Tf(t, this.minDistance, this.maxDistance), e)
            }
            _dollyToNoClamp(t, e = !1) {
                const n = this._sphericalEnd.radius;
                if (this.colliderMeshes.length >= 1) {
                    const e = this._collisionTest(),
                        r = Rf(e, this._spherical.radius);
                    if (!(n > t) && r) return Promise.resolve();
                    this._sphericalEnd.radius = Math.min(t, e)
                } else this._sphericalEnd.radius = t;
                this._needsUpdate = !0, e || (this._spherical.radius = this._sphericalEnd.radius);
                const r = !e || Rf(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
                return this._createOnRestPromise(r)
            }
            dollyInFixed(t, e = !1) {
                this._targetEnd.add(this._getCameraDirection(Kf).multiplyScalar(t)), e || this._target.copy(this._targetEnd);
                const n = !e || Rf(this._target.x, this._targetEnd.x, this.restThreshold) && Rf(this._target.y, this._targetEnd.y, this.restThreshold) && Rf(this._target.z, this._targetEnd.z, this.restThreshold);
                return this._createOnRestPromise(n)
            }
            zoom(t, e = !1) {
                return this.zoomTo(this._zoomEnd + t, e)
            }
            zoomTo(t, e = !1) {
                this._isUserControllingZoom = !1, this._zoomEnd = Tf(t, this.minZoom, this.maxZoom), this._needsUpdate = !0, e || (this._zoom = this._zoomEnd);
                const n = !e || Rf(this._zoom, this._zoomEnd, this.restThreshold);
                return this._changedZoom = 0, this._createOnRestPromise(n)
            }
            pan(t, e, n = !1) {
                return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, n)
            }
            truck(t, e, n = !1) {
                this._camera.updateMatrix(), Jf.setFromMatrixColumn(this._camera.matrix, 0), Zf.setFromMatrixColumn(this._camera.matrix, 1), Jf.multiplyScalar(t), Zf.multiplyScalar(-e);
                const r = Xf.copy(Jf).add(Zf),
                    i = qf.copy(this._targetEnd).add(r);
                return this.moveTo(i.x, i.y, i.z, n)
            }
            forward(t, e = !1) {
                Xf.setFromMatrixColumn(this._camera.matrix, 0), Xf.crossVectors(this._camera.up, Xf), Xf.multiplyScalar(t);
                const n = qf.copy(this._targetEnd).add(Xf);
                return this.moveTo(n.x, n.y, n.z, e)
            }
            elevate(t, e = !1) {
                return Xf.copy(this._camera.up).multiplyScalar(t), this.moveTo(this._targetEnd.x + Xf.x, this._targetEnd.y + Xf.y, this._targetEnd.z + Xf.z, e)
            }
            moveTo(t, e, n, r = !1) {
                this._isUserControllingTruck = !1;
                const i = Xf.set(t, e, n).sub(this._targetEnd);
                this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = !0, r || this._target.copy(this._targetEnd);
                const o = !r || Rf(this._target.x, this._targetEnd.x, this.restThreshold) && Rf(this._target.y, this._targetEnd.y, this.restThreshold) && Rf(this._target.z, this._targetEnd.z, this.restThreshold);
                return this._createOnRestPromise(o)
            }
            lookInDirectionOf(t, e, n, r = !1) {
                const i = Xf.set(t, e, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
                return this.setPosition(i.x, i.y, i.z, r)
            }
            fitToBox(t, e, {
                cover: n = !1,
                paddingLeft: r = 0,
                paddingRight: i = 0,
                paddingBottom: o = 0,
                paddingTop: a = 0
            } = {}) {
                const s = [],
                    l = t.isBox3 ? om.copy(t) : om.setFromObject(t);
                l.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
                const c = Lf(this._sphericalEnd.theta, Sf),
                    u = Lf(this._sphericalEnd.phi, Sf);
                s.push(this.rotateTo(c, u, e));
                const h = Xf.setFromSpherical(this._sphericalEnd).normalize(),
                    d = lm.setFromUnitVectors(h, Wf),
                    p = Rf(Math.abs(h.y), 1);
                p && d.multiply(cm.setFromAxisAngle(Vf, c)), d.multiply(this._yAxisUpSpaceInverse);
                const f = am.makeEmpty();
                qf.copy(l.min).applyQuaternion(d), f.expandByPoint(qf), qf.copy(l.min).setX(l.max.x).applyQuaternion(d), f.expandByPoint(qf), qf.copy(l.min).setY(l.max.y).applyQuaternion(d), f.expandByPoint(qf), qf.copy(l.max).setZ(l.min.z).applyQuaternion(d), f.expandByPoint(qf), qf.copy(l.min).setZ(l.max.z).applyQuaternion(d), f.expandByPoint(qf), qf.copy(l.max).setY(l.min.y).applyQuaternion(d), f.expandByPoint(qf), qf.copy(l.max).setX(l.min.x).applyQuaternion(d), f.expandByPoint(qf), qf.copy(l.max).applyQuaternion(d), f.expandByPoint(qf), f.min.x -= r, f.min.y -= o, f.max.x += i, f.max.y += a, d.setFromUnitVectors(Wf, h), p && d.premultiply(cm.invert()), d.premultiply(this._yAxisUpSpace);
                const m = f.getSize(Xf),
                    g = f.getCenter(qf).applyQuaternion(d);
                if (bf(this._camera)) {
                    const t = this.getDistanceToFitBox(m.x, m.y, m.z, n);
                    s.push(this.moveTo(g.x, g.y, g.z, e)), s.push(this.dollyTo(t, e)), s.push(this.setFocalOffset(0, 0, 0, e))
                } else if (wf(this._camera)) {
                    const t = this._camera,
                        r = t.right - t.left,
                        i = t.top - t.bottom,
                        o = n ? Math.max(r / m.x, i / m.y) : Math.min(r / m.x, i / m.y);
                    s.push(this.moveTo(g.x, g.y, g.z, e)), s.push(this.zoomTo(o, e)), s.push(this.setFocalOffset(0, 0, 0, e))
                }
                return Promise.all(s)
            }
            fitToSphere(t, e) {
                const n = [],
                    r = t instanceof Hf.Sphere ? sm.copy(t) : dm.createBoundingSphere(t, sm);
                if (n.push(this.moveTo(r.center.x, r.center.y, r.center.z, e)), bf(this._camera)) {
                    const t = this.getDistanceToFitSphere(r.radius);
                    n.push(this.dollyTo(t, e))
                } else if (wf(this._camera)) {
                    const t = this._camera.right - this._camera.left,
                        i = this._camera.top - this._camera.bottom,
                        o = 2 * r.radius,
                        a = Math.min(t / o, i / o);
                    n.push(this.zoomTo(a, e))
                }
                return n.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(n)
            }
            setLookAt(t, e, n, r, i, o, a = !1) {
                this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = yf, this._changedDolly = 0;
                const s = qf.set(r, i, o),
                    l = Xf.set(t, e, n);
                this._targetEnd.copy(s), this._sphericalEnd.setFromVector3(l.sub(s).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
                const c = !a || Rf(this._target.x, this._targetEnd.x, this.restThreshold) && Rf(this._target.y, this._targetEnd.y, this.restThreshold) && Rf(this._target.z, this._targetEnd.z, this.restThreshold) && Rf(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Rf(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Rf(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
                return this._createOnRestPromise(c)
            }
            lerpLookAt(t, e, n, r, i, o, a, s, l, c, u, h, d, p = !1) {
                this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = yf, this._changedDolly = 0;
                const f = Xf.set(r, i, o),
                    m = qf.set(t, e, n);
                rm.setFromVector3(m.sub(f).applyQuaternion(this._yAxisUpSpace));
                const g = Yf.set(c, u, h),
                    A = qf.set(a, s, l);
                im.setFromVector3(A.sub(g).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(f.lerp(g, d));
                const v = im.theta - rm.theta,
                    _ = im.phi - rm.phi,
                    y = im.radius - rm.radius;
                this._sphericalEnd.set(rm.radius + y * d, rm.phi + _ * d, rm.theta + v * d), this.normalizeRotations(), this._needsUpdate = !0, p || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
                const E = !p || Rf(this._target.x, this._targetEnd.x, this.restThreshold) && Rf(this._target.y, this._targetEnd.y, this.restThreshold) && Rf(this._target.z, this._targetEnd.z, this.restThreshold) && Rf(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Rf(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Rf(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
                return this._createOnRestPromise(E)
            }
            setPosition(t, e, n, r = !1) {
                return this.setLookAt(t, e, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, r)
            }
            setTarget(t, e, n, r = !1) {
                const i = this.getPosition(Xf),
                    o = this.setLookAt(i.x, i.y, i.z, t, e, n, r);
                return this._sphericalEnd.phi = Tf(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o
            }
            setFocalOffset(t, e, n, r = !1) {
                this._isUserControllingOffset = !1, this._focalOffsetEnd.set(t, e, n), this._needsUpdate = !0, r || this._focalOffset.copy(this._focalOffsetEnd);
                const i = !r || Rf(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Rf(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Rf(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
                return this._createOnRestPromise(i)
            }
            setOrbitPoint(t, e, n) {
                this._camera.updateMatrixWorld(), Jf.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Zf.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), tm.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
                const r = Xf.set(t, e, n),
                    i = r.distanceTo(this._camera.position),
                    o = r.sub(this._camera.position);
                Jf.multiplyScalar(o.x), Zf.multiplyScalar(o.y), tm.multiplyScalar(o.z), Xf.copy(Jf).add(Zf).add(tm), Xf.z = Xf.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Xf.x, Xf.y, -Xf.z, !1), this.moveTo(t, e, n, !1)
            }
            setBoundary(t) {
                if (!t) return this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), void(this._needsUpdate = !0);
                this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0
            }
            setViewport(t, e, n, r) {
                null !== t ? (this._viewport = this._viewport || new Hf.Vector4, "number" == typeof t ? this._viewport.set(t, e, n, r) : this._viewport.copy(t)) : this._viewport = null
            }
            getDistanceToFitBox(t, e, n, r = !1) {
                if (Nf(this._camera, "getDistanceToFitBox")) return this._spherical.radius;
                const i = t / e,
                    o = this._camera.getEffectiveFOV() * Mf,
                    a = this._camera.aspect;
                return .5 * ((r ? i > a : i < a) ? e : t / a) / Math.tan(.5 * o) + .5 * n
            }
            getDistanceToFitSphere(t) {
                if (Nf(this._camera, "getDistanceToFitSphere")) return this._spherical.radius;
                const e = this._camera.getEffectiveFOV() * Mf,
                    n = 2 * Math.atan(Math.tan(.5 * e) * this._camera.aspect),
                    r = 1 < this._camera.aspect ? e : n;
                return t / Math.sin(.5 * r)
            }
            getTarget(t, e = !0) {
                return (t && t.isVector3 ? t : new Hf.Vector3).copy(e ? this._targetEnd : this._target)
            }
            getPosition(t, e = !0) {
                return (t && t.isVector3 ? t : new Hf.Vector3).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target)
            }
            getSpherical(t, e = !0) {
                return (t && t instanceof Hf.Spherical ? t : new Hf.Spherical).copy(e ? this._sphericalEnd : this._spherical)
            }
            getFocalOffset(t, e = !0) {
                return (t && t.isVector3 ? t : new Hf.Vector3).copy(e ? this._focalOffsetEnd : this._focalOffset)
            }
            normalizeRotations() {
                this._sphericalEnd.theta = this._sphericalEnd.theta % Cf, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Cf), this._spherical.theta += Cf * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Cf)
            }
            reset(t = !1) {
                if (!Rf(this._camera.up.x, this._cameraUp0.x) || !Rf(this._camera.up.y, this._cameraUp0.y) || !Rf(this._camera.up.z, this._cameraUp0.z)) {
                    this._camera.up.copy(this._cameraUp0);
                    const t = this.getPosition(Xf);
                    this.updateCameraUp(), this.setPosition(t.x, t.y, t.z)
                }
                const e = [this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t), this.zoomTo(this._zoom0, t)];
                return Promise.all(e)
            }
            saveState() {
                this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset)
            }
            updateCameraUp() {
                this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Vf), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()
            }
            applyCameraUp() {
                const t = Xf.subVectors(this._target, this._camera.position).normalize(),
                    e = qf.crossVectors(t, this._camera.up);
                this._camera.up.crossVectors(e, t).normalize(), this._camera.updateMatrixWorld();
                const n = this.getPosition(Xf);
                this.updateCameraUp(), this.setPosition(n.x, n.y, n.z)
            }
            update(t) {
                const e = this._sphericalEnd.theta - this._spherical.theta,
                    n = this._sphericalEnd.phi - this._spherical.phi,
                    r = this._sphericalEnd.radius - this._spherical.radius,
                    i = em.subVectors(this._targetEnd, this._target),
                    o = nm.subVectors(this._focalOffsetEnd, this._focalOffset),
                    a = this._zoomEnd - this._zoom;
                if (Bf(e)) this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
                else {
                    const e = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
                    this._spherical.theta = Of(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, e, 1 / 0, t), this._needsUpdate = !0
                }
                if (Bf(n)) this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
                else {
                    const e = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
                    this._spherical.phi = Of(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, e, 1 / 0, t), this._needsUpdate = !0
                }
                if (Bf(r)) this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
                else {
                    const e = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
                    this._spherical.radius = Of(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, e, this.maxSpeed, t), this._needsUpdate = !0
                }
                if (Bf(i.x) && Bf(i.y) && Bf(i.z)) this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
                else {
                    const e = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
                    kf(this._target, this._targetEnd, this._targetVelocity, e, this.maxSpeed, t, this._target), this._needsUpdate = !0
                }
                if (Bf(o.x) && Bf(o.y) && Bf(o.z)) this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
                else {
                    const e = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
                    kf(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, e, this.maxSpeed, t, this._focalOffset), this._needsUpdate = !0
                }
                if (Bf(a)) this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
                else {
                    const e = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
                    this._zoom = Of(this._zoom, this._zoomEnd, this._zoomVelocity, e, 1 / 0, t)
                }
                if (this.dollyToCursor)
                    if (bf(this._camera) && 0 !== this._changedDolly) {
                        const t = this._spherical.radius - this._lastDistance,
                            e = this._camera,
                            n = this._getCameraDirection(Kf),
                            r = Xf.copy(n).cross(e.up).normalize();
                        0 === r.lengthSq() && (r.x = 1);
                        const i = qf.crossVectors(r, n),
                            o = this._sphericalEnd.radius * Math.tan(e.getEffectiveFOV() * Mf * .5),
                            a = (this._sphericalEnd.radius - t - this._sphericalEnd.radius) / this._sphericalEnd.radius,
                            s = Yf.copy(this._targetEnd).add(r.multiplyScalar(this._dollyControlCoord.x * o * e.aspect)).add(i.multiplyScalar(this._dollyControlCoord.y * o)),
                            l = Xf.copy(this._targetEnd).lerp(s, a),
                            c = this._lastDollyDirection === Ef && this._spherical.radius <= this.minDistance,
                            u = this._lastDollyDirection === xf && this.maxDistance <= this._spherical.radius;
                        if (this.infinityDolly && (c || u)) {
                            this._sphericalEnd.radius -= t, this._spherical.radius -= t;
                            const e = qf.copy(n).multiplyScalar(-t);
                            l.add(e)
                        }
                        this._boundary.clampPoint(l, l);
                        const h = qf.subVectors(l, this._targetEnd);
                        this._targetEnd.copy(l), this._target.add(h), this._changedDolly -= t, Bf(this._changedDolly) && (this._changedDolly = 0)
                    } else if (wf(this._camera) && 0 !== this._changedZoom) {
                    const t = this._zoom - this._lastZoom,
                        e = this._camera,
                        n = Xf.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                        r = qf.set(0, 0, -1).applyQuaternion(e.quaternion),
                        i = Yf.copy(n).add(r.multiplyScalar(-n.dot(e.up))),
                        o = -(this._zoom - t - this._zoom) / this._zoom,
                        a = this._getCameraDirection(Kf),
                        s = this._targetEnd.dot(a),
                        l = Xf.copy(this._targetEnd).lerp(i, o),
                        c = l.dot(a),
                        u = a.multiplyScalar(c - s);
                    l.sub(u), this._boundary.clampPoint(l, l);
                    const h = qf.subVectors(l, this._targetEnd);
                    this._targetEnd.copy(l), this._target.add(h), this._changedZoom -= t, Bf(this._changedZoom) && (this._changedZoom = 0)
                }
                this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
                const s = this._collisionTest();
                this._spherical.radius = Math.min(this._spherical.radius, s), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target);
                (!Bf(this._focalOffset.x) || !Bf(this._focalOffset.y) || !Bf(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Jf.setFromMatrixColumn(this._camera.matrix, 0), Zf.setFromMatrixColumn(this._camera.matrix, 1), tm.setFromMatrixColumn(this._camera.matrix, 2), Jf.multiplyScalar(this._focalOffset.x), Zf.multiplyScalar(-this._focalOffset.y), tm.multiplyScalar(this._focalOffset.z), Xf.copy(Jf).add(Zf).add(tm), this._camera.position.add(Xf)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Xf.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
                const l = this._needsUpdate;
                return l && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({
                    type: "wake"
                }), this.dispatchEvent({
                    type: "update"
                })) : l ? (this.dispatchEvent({
                    type: "update"
                }), Bf(e, this.restThreshold) && Bf(n, this.restThreshold) && Bf(r, this.restThreshold) && Bf(i.x, this.restThreshold) && Bf(i.y, this.restThreshold) && Bf(i.z, this.restThreshold) && Bf(o.x, this.restThreshold) && Bf(o.y, this.restThreshold) && Bf(o.z, this.restThreshold) && Bf(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({
                    type: "rest"
                }))) : !l && this._updatedLastTime && this.dispatchEvent({
                    type: "sleep"
                }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = l, this._needsUpdate = !1, l
            }
            toJSON() {
                return JSON.stringify({
                    enabled: this._enabled,
                    minDistance: this.minDistance,
                    maxDistance: Df(this.maxDistance),
                    minZoom: this.minZoom,
                    maxZoom: Df(this.maxZoom),
                    minPolarAngle: this.minPolarAngle,
                    maxPolarAngle: Df(this.maxPolarAngle),
                    minAzimuthAngle: Df(this.minAzimuthAngle),
                    maxAzimuthAngle: Df(this.maxAzimuthAngle),
                    smoothTime: this.smoothTime,
                    draggingSmoothTime: this.draggingSmoothTime,
                    dollySpeed: this.dollySpeed,
                    truckSpeed: this.truckSpeed,
                    dollyToCursor: this.dollyToCursor,
                    verticalDragToForward: this.verticalDragToForward,
                    target: this._targetEnd.toArray(),
                    position: Xf.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
                    zoom: this._zoomEnd,
                    focalOffset: this._focalOffsetEnd.toArray(),
                    target0: this._target0.toArray(),
                    position0: this._position0.toArray(),
                    zoom0: this._zoom0,
                    focalOffset0: this._focalOffset0.toArray()
                })
            }
            fromJSON(t, e = !1) {
                const n = JSON.parse(t);
                this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = Pf(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = Pf(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = Pf(n.maxPolarAngle), this.minAzimuthAngle = Pf(n.minAzimuthAngle), this.maxAzimuthAngle = Pf(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], e), rm.setFromVector3(Xf.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(rm.theta, rm.phi, e), this.dollyTo(rm.radius, e), this.zoomTo(n.zoom, e), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], e), this._needsUpdate = !0
            }
            connect(t) {
                this._domElement ? console.warn("camera-controls is already connected.") : (t.setAttribute("data-camera-controls-version", "2.8.3"), this._addAllEventListeners(t), this._getClientRect(this._elementRect))
            }
            disconnect() {
                this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0)
            }
            dispose() {
                this.removeAllEventListeners(), this.disconnect()
            }
            _getTargetDirection(t) {
                return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)
            }
            _getCameraDirection(t) {
                return this._getTargetDirection(t).negate()
            }
            _findPointerById(t) {
                return this._activePointers.find((e => e.pointerId === t))
            }
            _findPointerByMouseButton(t) {
                return this._activePointers.find((e => e.mouseButton === t))
            }
            _disposePointer(t) {
                this._activePointers.splice(this._activePointers.indexOf(t), 1)
            }
            _encloseToBoundary(t, e, n) {
                const r = e.lengthSq();
                if (0 === r) return t;
                const i = qf.copy(e).add(t),
                    o = this._boundary.clampPoint(i, Yf).sub(i),
                    a = o.lengthSq();
                if (0 === a) return t.add(e);
                if (a === r) return t;
                if (0 === n) return t.add(e).add(o); {
                    const r = 1 + n * a / e.dot(o);
                    return t.add(qf.copy(e).multiplyScalar(r)).add(o.multiplyScalar(1 - n))
                }
            }
            _updateNearPlaneCorners() {
                if (bf(this._camera)) {
                    const t = this._camera,
                        e = t.near,
                        n = t.getEffectiveFOV() * Mf,
                        r = Math.tan(.5 * n) * e,
                        i = r * t.aspect;
                    this._nearPlaneCorners[0].set(-i, -r, 0), this._nearPlaneCorners[1].set(i, -r, 0), this._nearPlaneCorners[2].set(i, r, 0), this._nearPlaneCorners[3].set(-i, r, 0)
                } else if (wf(this._camera)) {
                    const t = this._camera,
                        e = 1 / t.zoom,
                        n = t.left * e,
                        r = t.right * e,
                        i = t.top * e,
                        o = t.bottom * e;
                    this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(r, i, 0), this._nearPlaneCorners[2].set(r, o, 0), this._nearPlaneCorners[3].set(n, o, 0)
                }
            }
            _collisionTest() {
                let t = 1 / 0;
                if (!(this.colliderMeshes.length >= 1)) return t;
                if (Nf(this._camera, "_collisionTest")) return t;
                const e = this._getTargetDirection(Kf);
                um.lookAt(zf, e, this._camera.up);
                for (let n = 0; n < 4; n++) {
                    const r = qf.copy(this._nearPlaneCorners[n]);
                    r.applyMatrix4(um);
                    const i = Yf.addVectors(this._target, r);
                    hm.set(i, e), hm.far = this._spherical.radius + 1;
                    const o = hm.intersectObjects(this.colliderMeshes);
                    0 !== o.length && o[0].distance < t && (t = o[0].distance)
                }
                return t
            }
            _getClientRect(t) {
                if (!this._domElement) return;
                const e = this._domElement.getBoundingClientRect();
                return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t
            }
            _createOnRestPromise(t) {
                return t ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({
                    type: "transitionstart"
                }), new Promise((t => {
                    const e = () => {
                        this.removeEventListener("rest", e), t()
                    };
                    this.addEventListener("rest", e)
                })))
            }
            _addAllEventListeners(t) {}
            _removeAllEventListeners() {}
            get dampingFactor() {
                return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0
            }
            set dampingFactor(t) {
                console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")
            }
            get draggingDampingFactor() {
                return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0
            }
            set draggingDampingFactor(t) {
                console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")
            }
            static createBoundingSphere(t, e = new Hf.Sphere) {
                const n = e,
                    r = n.center;
                om.makeEmpty(), t.traverseVisible((t => {
                    t.isMesh && om.expandByObject(t)
                })), om.getCenter(r);
                let i = 0;
                return t.traverseVisible((t => {
                    if (!t.isMesh) return;
                    const e = t,
                        n = e.geometry.clone();
                    n.applyMatrix4(e.matrixWorld);
                    const o = n.attributes.position;
                    for (let t = 0, e = o.count; t < e; t++) Xf.fromBufferAttribute(o, t), i = Math.max(i, r.distanceToSquared(Xf))
                })), n.radius = Math.sqrt(i), n
            }
        }

        function pm(t) {
            return pm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, pm(t)
        }

        function fm(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, mm(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function mm(t) {
            var e = function (t, e) {
                if ("object" != pm(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != pm(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == pm(e) ? e : String(e)
        }
        var gm = function () {
            function t(e) {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.engine = e
            }
            return fm(t, [{
                key: "initControls",
                value: function (t) {
                    if (!t) {
                        var e = {
                            Vector2: Co,
                            Vector3: Zo,
                            Vector4: jo,
                            Quaternion: Jo,
                            Matrix4: Ta,
                            Spherical: gp,
                            Box3: na,
                            Sphere: ya,
                            Raycaster: pp,
                            MathUtils: {
                                DEG2RAD: lf.DEG2RAD,
                                clamp: lf.clamp
                            }
                        };
                        dm.install({
                            THREE: e
                        })
                    }
                    var n = dm.ACTION.NONE;
                    this.engine.controls = new dm(this.engine.camera, cf.container), this.engine.controls.mouseButtons.wheel = n, this.engine.controls.mouseButtons.middle = n, this.engine.controls.touches.two = n, this.engine.controls.touches.three = n, this.engine.controls.mouseButtons.right = n, this.engine.controls.restThreshold = 3, this.setThirdPersonParams()
                }
            }, {
                key: "setThirdPersonParams",
                value: function () {
                    this.engine.controls.minZoom = cf.controls.thirdPerson.minZoom, this.engine.controls.maxZoom = cf.controls.thirdPerson.maxZoom, this.engine.controls.smoothTime = cf.controls.thirdPerson.smoothTime, this.engine.controls.draggingSmoothTime = cf.controls.thirdPerson.draggingSmoothTime, this.engine.controls.azimuthRotateSpeed = cf.controls.thirdPerson.azimuthRotateSpeed, this.engine.controls.polarRotateSpeed = cf.controls.thirdPerson.polarRotateSpeed, this.engine.controls.maxPolarAngle = cf.controls.thirdPerson.maxPolarAngle, this.engine.controls.minPolarAngle = cf.controls.thirdPerson.minPolarAngle, this.engine.controls.minAzimuthAngle = cf.controls.thirdPerson.minAzimuthAngle, this.engine.controls.maxAzimuthAngle = cf.controls.thirdPerson.maxAzimuthAngle, this.engine.controls.normalizeRotations()
                }
            }]), t
        }();
        class Am {
            constructor(t = 4) {
                this.pool = t, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
            }
            _initWorker(t) {
                if (!this.workers[t]) {
                    const e = this.workerCreator();
                    e.addEventListener("message", this._onMessage.bind(this, t)), this.workers[t] = e
                }
            }
            _getIdleWorker() {
                for (let t = 0; t < this.pool; t++)
                    if (!(this.workerStatus & 1 << t)) return t;
                return -1
            }
            _onMessage(t, e) {
                const n = this.workersResolve[t];
                if (n && n(e), this.queue.length) {
                    const {
                        resolve: e,
                        msg: n,
                        transfer: r
                    } = this.queue.shift();
                    this.workersResolve[t] = e, this.workers[t].postMessage(n, r)
                } else this.workerStatus ^= 1 << t
            }
            setWorkerCreator(t) {
                this.workerCreator = t
            }
            setWorkerLimit(t) {
                this.pool = t
            }
            postMessage(t, e) {
                return new Promise((n => {
                    const r = this._getIdleWorker(); - 1 !== r ? (this._initWorker(r), this.workerStatus |= 1 << r, this.workersResolve[r] = n, this.workers[r].postMessage(t, e)) : this.queue.push({
                        resolve: n,
                        msg: t,
                        transfer: e
                    })
                }))
            }
            dispose() {
                this.workers.forEach((t => t.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
            }
        }
        const vm = 2,
            _m = 0,
            ym = 1,
            Em = 10;
        class xm {
            constructor() {
                this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                    vendorId: 0,
                    descriptorType: 0,
                    descriptorBlockSize: 0,
                    versionNumber: 2,
                    colorModel: 0,
                    colorPrimaries: 1,
                    transferFunction: 2,
                    flags: 0,
                    texelBlockDimension: [0, 0, 0, 0],
                    bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                    samples: []
                }], this.keyValue = {}, this.globalData = null
            }
        }
        class bm {
            constructor(t, e, n, r) {
                this._dataView = new DataView(t.buffer, t.byteOffset + e, n), this._littleEndian = r, this._offset = 0
            }
            _nextUint8() {
                const t = this._dataView.getUint8(this._offset);
                return this._offset += 1, t
            }
            _nextUint16() {
                const t = this._dataView.getUint16(this._offset, this._littleEndian);
                return this._offset += 2, t
            }
            _nextUint32() {
                const t = this._dataView.getUint32(this._offset, this._littleEndian);
                return this._offset += 4, t
            }
            _nextUint64() {
                const t = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                return this._offset += 8, t
            }
            _nextInt32() {
                const t = this._dataView.getInt32(this._offset, this._littleEndian);
                return this._offset += 4, t
            }
            _skip(t) {
                return this._offset += t, this
            }
            _scan(t, e = 0) {
                const n = this._offset;
                let r = 0;
                for (; this._dataView.getUint8(this._offset) !== e && r < t;) r++, this._offset++;
                return r < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r)
            }
        }
        const wm = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

        function Cm(t) {
            return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(t) : Buffer.from(t).toString("utf8")
        }
        let Sm, Im, Mm;
        const Tm = {
            env: {
                emscripten_notify_memory_growth: function (t) {
                    Mm = new Uint8Array(Im.exports.memory.buffer)
                }
            }
        };
        class Bm {
            init() {
                return Sm || (Sm = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + Rm).then((t => t.arrayBuffer())).then((t => WebAssembly.instantiate(t, Tm))).then(this._init) : WebAssembly.instantiate(Buffer.from(Rm, "base64"), Tm).then(this._init), Sm)
            }
            _init(t) {
                Im = t.instance, Tm.env.emscripten_notify_memory_growth(0)
            }
            decode(t, e = 0) {
                if (!Im) throw new Error("ZSTDDecoder: Await .init() before decoding.");
                const n = t.byteLength,
                    r = Im.exports.malloc(n);
                Mm.set(t, r), e = e || Number(Im.exports.ZSTD_findDecompressedSize(r, n));
                const i = Im.exports.malloc(e),
                    o = Im.exports.ZSTD_decompress(i, e, r, n),
                    a = Mm.slice(i, i + o);
                return Im.exports.free(r), Im.exports.free(i), a
            }
        }
        const Rm = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",
            Lm = new WeakMap;
        let Dm, Pm = 0;
        class Om extends Od {
            constructor(t) {
                super(t), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Am, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
            }
            setTranscoderPath(t) {
                return this.transcoderPath = t, this
            }
            setWorkerLimit(t) {
                return this.workerPool.setWorkerLimit(t), this
            }
            async detectSupportAsync(t) {
                return this.workerConfig = {
                    astcSupported: await t.hasFeatureAsync("texture-compression-astc"),
                    etc1Supported: await t.hasFeatureAsync("texture-compression-etc1"),
                    etc2Supported: await t.hasFeatureAsync("texture-compression-etc2"),
                    dxtSupported: await t.hasFeatureAsync("texture-compression-bc"),
                    bptcSupported: await t.hasFeatureAsync("texture-compression-bptc"),
                    pvrtcSupported: await t.hasFeatureAsync("texture-compression-pvrtc")
                }, this
            }
            detectSupport(t) {
                return !0 === t.isWebGPURenderer ? this.workerConfig = {
                    astcSupported: t.hasFeature("texture-compression-astc"),
                    etc1Supported: t.hasFeature("texture-compression-etc1"),
                    etc2Supported: t.hasFeature("texture-compression-etc2"),
                    dxtSupported: t.hasFeature("texture-compression-bc"),
                    bptcSupported: t.hasFeature("texture-compression-bptc"),
                    pvrtcSupported: t.hasFeature("texture-compression-pvrtc")
                } : (this.workerConfig = {
                    astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"),
                    etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"),
                    etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"),
                    dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"),
                    bptcSupported: t.extensions.has("EXT_texture_compression_bptc"),
                    pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                }, t.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)), this
            }
            init() {
                if (!this.transcoderPending) {
                    const t = new Nd(this.manager);
                    t.setPath(this.transcoderPath), t.setWithCredentials(this.withCredentials);
                    const e = t.loadAsync("basis_transcoder.js"),
                        n = new Nd(this.manager);
                    n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
                    const r = n.loadAsync("basis_transcoder.wasm");
                    this.transcoderPending = Promise.all([e, r]).then((([t, e]) => {
                        const n = Om.BasisWorker.toString(),
                            r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Om.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Om.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Om.BasisFormat), "/* basis_transcoder.js */", t, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([r])), this.transcoderBinary = e, this.workerPool.setWorkerCreator((() => {
                            const t = new Worker(this.workerSourceURL),
                                e = this.transcoderBinary.slice(0);
                            return t.postMessage({
                                type: "init",
                                config: this.workerConfig,
                                transcoderBinary: e
                            }, [e]), t
                        }))
                    })), Pm > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), Pm++
                }
                return this.transcoderPending
            }
            load(t, e, n, r) {
                if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                const i = new Nd(this.manager);
                i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials), i.load(t, (t => {
                    if (Lm.has(t)) {
                        return Lm.get(t).promise.then(e).catch(r)
                    }
                    this._createTexture(t).then((t => e ? e(t) : null)).catch(r)
                }), n, r)
            }
            _createTextureFrom(t, e) {
                const {
                    faces: n,
                    width: r,
                    height: i,
                    format: o,
                    type: a,
                    error: s,
                    dfdFlags: l
                } = t;
                if ("error" === a) return Promise.reject(s);
                let c;
                if (6 === e.faceCount) c = new ud(n, o, xi);
                else {
                    const t = n[0].mipmaps;
                    c = e.layerCount > 1 ? new cd(t, r, i, e.layerCount, o, xi) : new ld(t, r, i, o, xi)
                }
                return c.minFilter = 1 === n[0].mipmaps.length ? _i : Ei, c.magFilter = _i, c.generateMipmaps = !1, c.needsUpdate = !0, c.colorSpace = Fm(e), c.premultiplyAlpha = !!(1 & l), c
            }
            async _createTexture(t, e = {}) {
                const n = function (t) {
                    const e = new Uint8Array(t.buffer, t.byteOffset, wm.length);
                    if (e[0] !== wm[0] || e[1] !== wm[1] || e[2] !== wm[2] || e[3] !== wm[3] || e[4] !== wm[4] || e[5] !== wm[5] || e[6] !== wm[6] || e[7] !== wm[7] || e[8] !== wm[8] || e[9] !== wm[9] || e[10] !== wm[10] || e[11] !== wm[11]) throw new Error("Missing KTX 2.0 identifier.");
                    const n = new xm,
                        r = 17 * Uint32Array.BYTES_PER_ELEMENT,
                        i = new bm(t, wm.length, r, !0);
                    n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();
                    const o = i._nextUint32();
                    n.supercompressionScheme = i._nextUint32();
                    const a = i._nextUint32(),
                        s = i._nextUint32(),
                        l = i._nextUint32(),
                        c = i._nextUint32(),
                        u = i._nextUint64(),
                        h = i._nextUint64(),
                        d = new bm(t, wm.length + r, 3 * o * 8, !0);
                    for (let e = 0; e < o; e++) n.levels.push({
                        levelData: new Uint8Array(t.buffer, t.byteOffset + d._nextUint64(), d._nextUint64()),
                        uncompressedByteLength: d._nextUint64()
                    });
                    const p = new bm(t, a, s, !0),
                        f = {
                            vendorId: p._skip(4)._nextUint16(),
                            descriptorType: p._nextUint16(),
                            versionNumber: p._nextUint16(),
                            descriptorBlockSize: p._nextUint16(),
                            colorModel: p._nextUint8(),
                            colorPrimaries: p._nextUint8(),
                            transferFunction: p._nextUint8(),
                            flags: p._nextUint8(),
                            texelBlockDimension: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()],
                            bytesPlane: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()],
                            samples: []
                        },
                        m = (f.descriptorBlockSize / 4 - 6) / 4;
                    for (let t = 0; t < m; t++) {
                        const e = {
                            bitOffset: p._nextUint16(),
                            bitLength: p._nextUint8(),
                            channelType: p._nextUint8(),
                            samplePosition: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()],
                            sampleLower: -1 / 0,
                            sampleUpper: 1 / 0
                        };
                        64 & e.channelType ? (e.sampleLower = p._nextInt32(), e.sampleUpper = p._nextInt32()) : (e.sampleLower = p._nextUint32(), e.sampleUpper = p._nextUint32()), f.samples[t] = e
                    }
                    n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f);
                    const g = new bm(t, l, c, !0);
                    for (; g._offset < c;) {
                        const t = g._nextUint32(),
                            e = g._scan(t),
                            r = Cm(e),
                            i = g._scan(t - e.byteLength);
                        n.keyValue[r] = r.match(/^ktx/i) ? Cm(i) : i, g._offset % 4 && g._skip(4 - g._offset % 4)
                    }
                    if (h <= 0) return n;
                    const A = new bm(t, u, h, !0),
                        v = A._nextUint16(),
                        _ = A._nextUint16(),
                        y = A._nextUint32(),
                        E = A._nextUint32(),
                        x = A._nextUint32(),
                        b = A._nextUint32(),
                        w = [];
                    for (let t = 0; t < o; t++) w.push({
                        imageFlags: A._nextUint32(),
                        rgbSliceByteOffset: A._nextUint32(),
                        rgbSliceByteLength: A._nextUint32(),
                        alphaSliceByteOffset: A._nextUint32(),
                        alphaSliceByteLength: A._nextUint32()
                    });
                    const C = u + A._offset,
                        S = C + y,
                        I = S + E,
                        M = I + x,
                        T = new Uint8Array(t.buffer, t.byteOffset + C, y),
                        B = new Uint8Array(t.buffer, t.byteOffset + S, E),
                        R = new Uint8Array(t.buffer, t.byteOffset + I, x),
                        L = new Uint8Array(t.buffer, t.byteOffset + M, b);
                    return n.globalData = {
                        endpointCount: v,
                        selectorCount: _,
                        imageDescs: w,
                        endpointsData: T,
                        selectorsData: B,
                        tablesData: R,
                        extendedData: L
                    }, n
                }(new Uint8Array(t));
                if (0 !== n.vkFormat) return async function (t) {
                    const {
                        vkFormat: e
                    } = t;
                    if (void 0 === Um[e]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                    let n;
                    2 === t.supercompressionScheme && (Dm || (Dm = new Promise((async t => {
                        const e = new Bm;
                        await e.init(), t(e)
                    }))), n = await Dm);
                    const r = [];
                    for (let i = 0; i < t.levels.length; i++) {
                        const o = Math.max(1, t.pixelWidth >> i),
                            a = Math.max(1, t.pixelHeight >> i),
                            s = t.pixelDepth ? Math.max(1, t.pixelDepth >> i) : 0,
                            l = t.levels[i];
                        let c, u;
                        if (0 === t.supercompressionScheme) c = l.levelData;
                        else {
                            if (2 !== t.supercompressionScheme) throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                            c = n.decode(l.levelData, l.uncompressedByteLength)
                        }
                        u = Nm[e] === Si ? new Float32Array(c.buffer, c.byteOffset, c.byteLength / Float32Array.BYTES_PER_ELEMENT) : Nm[e] === Ii ? new Uint16Array(c.buffer, c.byteOffset, c.byteLength / Uint16Array.BYTES_PER_ELEMENT) : c, r.push({
                            data: u,
                            width: o,
                            height: a,
                            depth: s
                        })
                    }
                    let i;
                    if (km.has(Um[e])) i = 0 === t.pixelDepth ? new Rh(r[0].data, t.pixelWidth, t.pixelHeight) : new Ko(r[0].data, t.pixelWidth, t.pixelHeight, t.pixelDepth);
                    else {
                        if (t.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                        i = new ld(r, t.pixelWidth, t.pixelHeight)
                    }
                    return i.mipmaps = r, i.type = Nm[e], i.format = Um[e], i.colorSpace = Fm(t), i.needsUpdate = !0, Promise.resolve(i)
                }(n);
                const r = e,
                    i = this.init().then((() => this.workerPool.postMessage({
                        type: "transcode",
                        buffer: t,
                        taskConfig: r
                    }, [t]))).then((t => this._createTextureFrom(t.data, n)));
                return Lm.set(t, {
                    promise: i
                }), i
            }
            dispose() {
                return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Pm--, this
            }
        }
        Om.BasisFormat = {
            ETC1S: 0,
            UASTC_4x4: 1
        }, Om.TranscoderFormat = {
            ETC1: 0,
            ETC2: 1,
            BC1: 2,
            BC3: 3,
            BC4: 4,
            BC5: 5,
            BC7_M6_OPAQUE_ONLY: 6,
            BC7_M5: 7,
            PVRTC1_4_RGB: 8,
            PVRTC1_4_RGBA: 9,
            ASTC_4x4: 10,
            ATC_RGB: 11,
            ATC_RGBA_INTERPOLATED_ALPHA: 12,
            RGBA32: 13,
            RGB565: 14,
            BGR565: 15,
            RGBA4444: 16
        }, Om.EngineFormat = {
            RGBAFormat: Ti,
            RGBA_ASTC_4x4_Format: Hi,
            RGBA_BPTC_Format: Vi,
            RGBA_ETC2_EAC_Format: Gi,
            RGBA_PVRTC_4BPPV1_Format: Fi,
            RGBA_S3TC_DXT5_Format: Ui,
            RGB_ETC1_Format: Qi,
            RGB_ETC2_Format: $i,
            RGB_PVRTC_4BPPV1_Format: Ni,
            RGB_S3TC_DXT1_Format: Pi
        }, Om.BasisWorker = function () {
            let t, e, n;
            const r = _EngineFormat,
                i = _TranscoderFormat,
                o = _BasisFormat;
            self.addEventListener("message", (function (a) {
                const h = a.data;
                switch (h.type) {
                    case "init":
                        t = h.config, d = h.transcoderBinary, e = new Promise((t => {
                            n = {
                                wasmBinary: d,
                                onRuntimeInitialized: t
                            }, BASIS(n)
                        })).then((() => {
                            n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                        }));
                        break;
                    case "transcode":
                        e.then((() => {
                            try {
                                const {
                                    faces: e,
                                    buffers: a,
                                    width: d,
                                    height: p,
                                    hasAlpha: f,
                                    format: m,
                                    dfdFlags: g
                                } = function (e) {
                                    const a = new n.KTX2File(new Uint8Array(e));

                                    function h() {
                                        a.close(), a.delete()
                                    }
                                    if (!a.isValid()) throw h(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                    const d = a.isUASTC() ? o.UASTC_4x4 : o.ETC1S,
                                        p = a.getWidth(),
                                        f = a.getHeight(),
                                        m = a.getLayers() || 1,
                                        g = a.getLevels(),
                                        A = a.getFaces(),
                                        v = a.getHasAlpha(),
                                        _ = a.getDFDFlags(),
                                        {
                                            transcoderFormat: y,
                                            engineFormat: E
                                        } = function (e, n, a, u) {
                                            let h, d;
                                            const p = e === o.ETC1S ? s : l;
                                            for (let r = 0; r < p.length; r++) {
                                                const i = p[r];
                                                if (t[i.if] && (i.basisFormat.includes(e) && !(u && i.transcoderFormat.length < 2) && (!i.needsPowerOfTwo || c(n) && c(a)))) return h = i.transcoderFormat[u ? 1 : 0], d = i.engineFormat[u ? 1 : 0], {
                                                    transcoderFormat: h,
                                                    engineFormat: d
                                                }
                                            }
                                            return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), h = i.RGBA32, d = r.RGBAFormat, {
                                                transcoderFormat: h,
                                                engineFormat: d
                                            }
                                        }(d, p, f, v);
                                    if (!p || !f || !g) throw h(), new Error("THREE.KTX2Loader:\tInvalid texture");
                                    if (!a.startTranscoding()) throw h(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                                    const x = [],
                                        b = [];
                                    for (let t = 0; t < A; t++) {
                                        const e = [];
                                        for (let n = 0; n < g; n++) {
                                            const r = [];
                                            let i, o;
                                            for (let e = 0; e < m; e++) {
                                                const s = a.getImageLevelInfo(n, e, t);
                                                0 !== t || 0 !== n || 0 !== e || s.origWidth % 4 == 0 && s.origHeight % 4 == 0 || console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), g > 1 ? (i = s.origWidth, o = s.origHeight) : (i = s.width, o = s.height);
                                                const l = new Uint8Array(a.getImageTranscodedSizeInBytes(n, e, 0, y));
                                                if (!a.transcodeImage(l, n, e, t, y, 0, -1, -1)) throw h(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                                r.push(l)
                                            }
                                            const s = u(r);
                                            e.push({
                                                data: s,
                                                width: i,
                                                height: o
                                            }), b.push(s.buffer)
                                        }
                                        x.push({
                                            mipmaps: e,
                                            width: p,
                                            height: f,
                                            format: E
                                        })
                                    }
                                    return h(), {
                                        faces: x,
                                        buffers: b,
                                        width: p,
                                        height: f,
                                        hasAlpha: v,
                                        format: E,
                                        dfdFlags: _
                                    }
                                }(h.buffer);
                                self.postMessage({
                                    type: "transcode",
                                    id: h.id,
                                    faces: e,
                                    width: d,
                                    height: p,
                                    hasAlpha: f,
                                    format: m,
                                    dfdFlags: g
                                }, a)
                            } catch (t) {
                                console.error(t), self.postMessage({
                                    type: "error",
                                    id: h.id,
                                    error: t.message
                                })
                            }
                        }))
                }
                var d
            }));
            const a = [{
                    if: "astcSupported",
                    basisFormat: [o.UASTC_4x4],
                    transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
                    engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
                    priorityETC1S: 1 / 0,
                    priorityUASTC: 1,
                    needsPowerOfTwo: !1
                }, {
                    if: "bptcSupported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [i.BC7_M5, i.BC7_M5],
                    engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
                    priorityETC1S: 3,
                    priorityUASTC: 2,
                    needsPowerOfTwo: !1
                }, {
                    if: "dxtSupported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [i.BC1, i.BC3],
                    engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
                    priorityETC1S: 4,
                    priorityUASTC: 5,
                    needsPowerOfTwo: !1
                }, {
                    if: "etc2Supported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [i.ETC1, i.ETC2],
                    engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
                    priorityETC1S: 1,
                    priorityUASTC: 3,
                    needsPowerOfTwo: !1
                }, {
                    if: "etc1Supported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [i.ETC1],
                    engineFormat: [r.RGB_ETC1_Format],
                    priorityETC1S: 2,
                    priorityUASTC: 4,
                    needsPowerOfTwo: !1
                }, {
                    if: "pvrtcSupported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
                    engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
                    priorityETC1S: 5,
                    priorityUASTC: 6,
                    needsPowerOfTwo: !0
                }],
                s = a.sort((function (t, e) {
                    return t.priorityETC1S - e.priorityETC1S
                })),
                l = a.sort((function (t, e) {
                    return t.priorityUASTC - e.priorityUASTC
                }));

            function c(t) {
                return t <= 2 || 0 == (t & t - 1) && 0 !== t
            }

            function u(t) {
                if (1 === t.length) return t[0];
                let e = 0;
                for (let n = 0; n < t.length; n++) {
                    e += t[n].byteLength
                }
                const n = new Uint8Array(e);
                let r = 0;
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    n.set(i, r), r += i.byteLength
                }
                return n
            }
        };
        const km = new Set([Ti, Di, Li]),
            Um = {
                109: Ti,
                97: Ti,
                37: Ti,
                43: Ti,
                103: Di,
                83: Di,
                16: Di,
                22: Di,
                100: Li,
                76: Li,
                15: Li,
                9: Li,
                166: zi,
                165: zi
            },
            Nm = {
                109: Si,
                97: Ii,
                37: xi,
                43: xi,
                103: Si,
                83: Ii,
                16: xi,
                22: xi,
                100: Si,
                76: Ii,
                15: xi,
                9: xi,
                166: xi,
                165: xi
            };

        function Fm(t) {
            const e = t.dataFormatDescriptor[0];
            return e.colorPrimaries === ym ? e.transferFunction === vm ? Yi : Ki : e.colorPrimaries === Em ? e.transferFunction === vm ? Ji : Zi : (e.colorPrimaries === _m || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), qi)
        }
        class Qm extends Qd {
            constructor(t) {
                super(t), this.type = Ii
            }
            parse(t) {
                const e = function (t, e) {
                        switch (t) {
                            case 1:
                                throw new Error("THREE.RGBELoader: Read Error: " + (e || ""));
                            case 2:
                                throw new Error("THREE.RGBELoader: Write Error: " + (e || ""));
                            case 3:
                                throw new Error("THREE.RGBELoader: Bad File Format: " + (e || ""));
                            default:
                                throw new Error("THREE.RGBELoader: Memory Error: " + (e || ""))
                        }
                    },
                    n = function (t, e, n) {
                        e = e || 1024;
                        let r = t.pos,
                            i = -1,
                            o = 0,
                            a = "",
                            s = String.fromCharCode.apply(null, new Uint16Array(t.subarray(r, r + 128)));
                        for (; 0 > (i = s.indexOf("\n")) && o < e && r < t.byteLength;) a += s, o += s.length, r += 128, s += String.fromCharCode.apply(null, new Uint16Array(t.subarray(r, r + 128)));
                        return -1 < i && (t.pos += o + i + 1, a + s.slice(0, i))
                    },
                    r = function (t, e, n, r) {
                        const i = t[e + 3],
                            o = Math.pow(2, i - 128) / 255;
                        n[r + 0] = t[e + 0] * o, n[r + 1] = t[e + 1] * o, n[r + 2] = t[e + 2] * o, n[r + 3] = 1
                    },
                    i = function (t, e, n, r) {
                        const i = t[e + 3],
                            o = Math.pow(2, i - 128) / 255;
                        n[r + 0] = Cs.toHalfFloat(Math.min(t[e + 0] * o, 65504)), n[r + 1] = Cs.toHalfFloat(Math.min(t[e + 1] * o, 65504)), n[r + 2] = Cs.toHalfFloat(Math.min(t[e + 2] * o, 65504)), n[r + 3] = Cs.toHalfFloat(1)
                    },
                    o = new Uint8Array(t);
                o.pos = 0;
                const a = function (t) {
                        const r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                            i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                            o = /^\s*FORMAT=(\S+)\s*$/,
                            a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                            s = {
                                valid: 0,
                                string: "",
                                comments: "",
                                programtype: "RGBE",
                                format: "",
                                gamma: 1,
                                exposure: 1,
                                width: 0,
                                height: 0
                            };
                        let l, c;
                        for ((t.pos >= t.byteLength || !(l = n(t))) && e(1, "no header found"), (c = l.match(/^#\?(\S+)/)) || e(3, "bad initial token"), s.valid |= 1, s.programtype = c[1], s.string += l + "\n"; l = n(t), !1 !== l;)
                            if (s.string += l + "\n", "#" !== l.charAt(0)) {
                                if ((c = l.match(r)) && (s.gamma = parseFloat(c[1])), (c = l.match(i)) && (s.exposure = parseFloat(c[1])), (c = l.match(o)) && (s.valid |= 2, s.format = c[1]), (c = l.match(a)) && (s.valid |= 4, s.height = parseInt(c[1], 10), s.width = parseInt(c[2], 10)), 2 & s.valid && 4 & s.valid) break
                            } else s.comments += l + "\n";
                        return 2 & s.valid || e(3, "missing format specifier"), 4 & s.valid || e(3, "missing image size specifier"), s
                    }(o),
                    s = a.width,
                    l = a.height,
                    c = function (t, n, r) {
                        const i = n;
                        if (i < 8 || i > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2]) return new Uint8Array(t);
                        i !== (t[2] << 8 | t[3]) && e(3, "wrong scanline width");
                        const o = new Uint8Array(4 * n * r);
                        o.length || e(4, "unable to allocate buffer space");
                        let a = 0,
                            s = 0;
                        const l = 4 * i,
                            c = new Uint8Array(4),
                            u = new Uint8Array(l);
                        let h = r;
                        for (; h > 0 && s < t.byteLength;) {
                            s + 4 > t.byteLength && e(1), c[0] = t[s++], c[1] = t[s++], c[2] = t[s++], c[3] = t[s++], 2 == c[0] && 2 == c[1] && (c[2] << 8 | c[3]) == i || e(3, "bad rgbe scanline format");
                            let n, r = 0;
                            for (; r < l && s < t.byteLength;) {
                                n = t[s++];
                                const i = n > 128;
                                if (i && (n -= 128), (0 === n || r + n > l) && e(3, "bad scanline data"), i) {
                                    const e = t[s++];
                                    for (let t = 0; t < n; t++) u[r++] = e
                                } else u.set(t.subarray(s, s + n), r), r += n, s += n
                            }
                            const d = i;
                            for (let t = 0; t < d; t++) {
                                let e = 0;
                                o[a] = u[t + e], e += i, o[a + 1] = u[t + e], e += i, o[a + 2] = u[t + e], e += i, o[a + 3] = u[t + e], a += 4
                            }
                            h--
                        }
                        return o
                    }(o.subarray(o.pos), s, l);
                let u, h, d;
                switch (this.type) {
                    case Si:
                        d = c.length / 4;
                        const t = new Float32Array(4 * d);
                        for (let e = 0; e < d; e++) r(c, 4 * e, t, 4 * e);
                        u = t, h = Si;
                        break;
                    case Ii:
                        d = c.length / 4;
                        const e = new Uint16Array(4 * d);
                        for (let t = 0; t < d; t++) i(c, 4 * t, e, 4 * t);
                        u = e, h = Ii;
                        break;
                    default:
                        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
                }
                return {
                    width: s,
                    height: l,
                    data: u,
                    header: a.string,
                    gamma: a.gamma,
                    exposure: a.exposure,
                    type: h
                }
            }
            setDataType(t) {
                return this.type = t, this
            }
            load(t, e, n, r) {
                return super.load(t, (function (t, n) {
                    switch (t.type) {
                        case Si:
                        case Ii:
                            t.colorSpace = Ki, t.minFilter = _i, t.magFilter = _i, t.generateMipmaps = !1, t.flipY = !0
                    }
                    e && e(t, n)
                }), n, r)
            }
        }

        function $m(t, e) {
            for (var n = t.length, r = 0; r < n; ++r)
                if (e(t[r], r)) return !0;
            return !1
        }

        function Gm(t, e) {
            for (var n = t.length, r = 0; r < n; ++r)
                if (e(t[r], r)) return t[r];
            return null
        }

        function Hm(t) {
            var e = t;
            if (void 0 === e) {
                if ("undefined" == typeof navigator || !navigator) return "";
                e = navigator.userAgent || ""
            }
            return e.toLowerCase()
        }

        function zm(t, e) {
            try {
                return new RegExp(t, "g").exec(e)
            } catch (t) {
                return null
            }
        }

        function Vm(t) {
            return t.replace(/_/g, ".")
        }

        function Wm(t, e) {
            var n = null,
                r = "-1";
            return $m(t, (function (t) {
                var i = zm("(" + t.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", e);
                return !(!i || t.brand) && (n = t, r = i[3] || "-1", t.versionAlias ? r = t.versionAlias : t.versionTest && (r = function (t, e) {
                    var n = zm("(" + t + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", e);
                    return n ? n[3] : ""
                }(t.versionTest.toLowerCase(), e) || r), r = Vm(r), !0)
            })), {
                preset: n,
                version: r
            }
        }

        function jm(t, e) {
            var n = {
                brand: "",
                version: "-1"
            };
            return $m(t, (function (t) {
                var r = Xm(e, t);
                return !!r && (n.brand = t.id, n.version = t.versionAlias || r.version, "-1" !== n.version)
            })), n
        }

        function Xm(t, e) {
            return Gm(t, (function (t) {
                var n = t.brand;
                return zm("" + e.test, n.toLowerCase())
            }))
        }
        var qm = [{
                test: "phantomjs",
                id: "phantomjs"
            }, {
                test: "whale",
                id: "whale"
            }, {
                test: "edgios|edge|edg",
                id: "edge"
            }, {
                test: "msie|trident|windows phone",
                id: "ie",
                versionTest: "iemobile|msie|rv"
            }, {
                test: "miuibrowser",
                id: "miui browser"
            }, {
                test: "samsungbrowser",
                id: "samsung internet"
            }, {
                test: "samsung",
                id: "samsung internet",
                versionTest: "version"
            }, {
                test: "chrome|crios",
                id: "chrome"
            }, {
                test: "firefox|fxios",
                id: "firefox"
            }, {
                test: "android",
                id: "android browser",
                versionTest: "version"
            }, {
                test: "safari|iphone|ipad|ipod",
                id: "safari",
                versionTest: "version"
            }],
            Ym = [{
                test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
                id: "chrome",
                versionTest: "chrome"
            }, {
                test: "chromium",
                id: "chrome"
            }, {
                test: "whale",
                id: "chrome",
                versionAlias: "-1",
                brand: !0
            }],
            Km = [{
                test: "applewebkit",
                id: "webkit",
                versionTest: "applewebkit|safari"
            }],
            Jm = [{
                test: "(?=(iphone|ipad))(?!(.*version))",
                id: "webview"
            }, {
                test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
                id: "webview"
            }, {
                test: "webview",
                id: "webview"
            }],
            Zm = [{
                test: "windows phone",
                id: "windows phone"
            }, {
                test: "windows 2000",
                id: "window",
                versionAlias: "5.0"
            }, {
                test: "windows nt",
                id: "window"
            }, {
                test: "win32|windows",
                id: "window"
            }, {
                test: "iphone|ipad|ipod",
                id: "ios",
                versionTest: "iphone os|cpu os"
            }, {
                test: "macos|macintel|mac os x",
                id: "mac"
            }, {
                test: "android|linux armv81",
                id: "android"
            }, {
                test: "tizen",
                id: "tizen"
            }, {
                test: "webos|web0s",
                id: "webos"
            }];

        function tg(t) {
            return !!Wm(Jm, t).preset
        }
        const eg = function (t) {
            return void 0 === t && function () {
                if ("undefined" == typeof navigator || !navigator || !navigator.userAgentData) return !1;
                var t = navigator.userAgentData,
                    e = t.brands || t.uaList;
                return !(!e || !e.length)
            }() ? function (t) {
                var e = navigator.userAgentData,
                    n = (e.uaList || e.brands).slice(),
                    r = e.mobile || !1,
                    i = n[0],
                    o = (e.platform || navigator.platform).toLowerCase(),
                    a = {
                        name: i.brand,
                        version: i.version,
                        majorVersion: -1,
                        webkit: !1,
                        webkitVersion: "-1",
                        chromium: !1,
                        chromiumVersion: "-1",
                        webview: !!jm(Jm, n).brand || tg(Hm())
                    },
                    s = {
                        name: "unknown",
                        version: "-1",
                        majorVersion: -1
                    };
                a.webkit = !a.chromium && $m(Km, (function (t) {
                    return Xm(n, t)
                }));
                var l = jm(Ym, n);
                if (a.chromium = !!l.brand, a.chromiumVersion = l.version, !a.chromium) {
                    var c = jm(Km, n);
                    a.webkit = !!c.brand, a.webkitVersion = c.version
                }
                var u = Gm(Zm, (function (t) {
                    return new RegExp("" + t.test, "g").exec(o)
                }));
                s.name = u ? u.id : "";
                var h = jm(qm, n);
                return a.name = h.brand || a.name, a.version = h.brand && t ? t.uaFullVersion : h.version, a.webkit && (s.name = r ? "ios" : "mac"), "ios" === s.name && a.webview && (a.version = "-1"), s.version = Vm(s.version), a.version = Vm(a.version), s.majorVersion = parseInt(s.version, 10), a.majorVersion = parseInt(a.version, 10), {
                    browser: a,
                    os: s,
                    isMobile: r,
                    isHints: !0
                }
            }() : function (t) {
                var e = Hm(t),
                    n = !!/mobi/g.exec(e),
                    r = {
                        name: "unknown",
                        version: "-1",
                        majorVersion: -1,
                        webview: tg(e),
                        chromium: !1,
                        chromiumVersion: "-1",
                        webkit: !1,
                        webkitVersion: "-1"
                    },
                    i = {
                        name: "unknown",
                        version: "-1",
                        majorVersion: -1
                    },
                    o = Wm(qm, e),
                    a = o.preset,
                    s = o.version,
                    l = Wm(Zm, e),
                    c = l.preset,
                    u = l.version,
                    h = Wm(Ym, e);
                if (r.chromium = !!h.preset, r.chromiumVersion = h.version, !r.chromium) {
                    var d = Wm(Km, e);
                    r.webkit = !!d.preset, r.webkitVersion = d.version
                }
                return c && (i.name = c.id, i.version = u, i.majorVersion = parseInt(u, 10)), a && (r.name = a.id, r.version = s, r.webview && "ios" === i.name && "safari" !== r.name && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
                    browser: r,
                    os: i,
                    isMobile: n,
                    isHints: !1
                }
            }(t)
        };
        var ng = eg(),
            rg = new Dd;

        function ig(t) {
            return ig = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ig(t)
        }

        function og(t, e, n) {
            return (e = ug(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function ag() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            ag = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == ig(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError(ig(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function sg(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function lg(t) {
            return function () {
                var e = this,
                    n = arguments;
                return new Promise((function (r, i) {
                    var o = t.apply(e, n);

                    function a(t) {
                        sg(o, r, i, a, s, "next", t)
                    }

                    function s(t) {
                        sg(o, r, i, a, s, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }

        function cg(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, ug(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function ug(t) {
            var e = function (t, e) {
                if ("object" != ig(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != ig(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == ig(e) ? e : String(e)
        }
        rg.onStart = function (t, e, n) {}, rg.onProgress = function (t, e, n) {
            if (cf.loadOnDemand.loadingManager.enabled) {
                var r = cf.models.samara.assetsArray.find((function (t) {
                        return t.name === tf.complectation.value.layout
                    })),
                    i = Math.min((e / r.totalAssetsCount * 100).toFixed(), 100);
                tf.loading.next({
                    isLoading: !0,
                    percent: Number(i)
                })
            }
        }, rg.onLoad = function (t, e, n) {}, rg.onError = function (t) {
            tf.errors.next({
                isError: !0,
                message: "Error ".concat(t)
            })
        };
        var hg = function () {
            function t() {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t)
            }
            var e, n, r;
            return cg(t, [{
                key: "init",
                value: (r = lg(ag().mark((function t(e) {
                    return ag().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                this.engine = e, cf.useCompressedTextures && (null === this.engine.renderer.getContext().getExtension("WEBGL_compressed_texture_s3tc_srgb") && (console.warn("WEBGL_compressed_texture_s3tc_srgb is not supported"), cf.useCompressedTextures = !1), this.ktx2Loader = new Om(rg), this.ktx2Loader.setTranscoderPath("".concat(cf.paths.decoders_path, "basis/")), this.ktx2Loader.detectSupport(this.engine.renderer)), this.rgbeLoader = new Qm(rg), "mac" === ng.os.name && "safari" === ng.browser.name && "12.1.2" === ng.browser.version && this.rgbeLoader.setDataType(Si), "ios" === ng.os.name && (window.createImageBitmap = void 0), this.textureLoader = new $d(rg), this.path = cf.paths.textures_path, this.textureLoader.setPath(this.path), this.rgbeLoader.setPath(this.path);
                            case 9:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function (t) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "load",
                value: (n = lg(ag().mark((function t(e) {
                    var n, r = this;
                    return ag().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return n = [].concat(cf.textures.flatMap((function (t) {
                                    return t.loadedTexture ? [] : r.loadTexture(t, "map")
                                })), cf.models.samara.assetsArray.flatMap((function (t) {
                                    return t.texturesPromises = t.texturesPromises || [], e || t.name === r.engine.assets.initialAsset ? t.textures.flatMap((function (e) {
                                        if (!e.loadedTexture) {
                                            var n = r.loadTexture(e, "map");
                                            return t.texturesPromises.push(n), n
                                        }
                                        return []
                                    })) : []
                                })), e ? [] : cf.environment.assetsArray.flatMap(function () {
                                    var t = lg(ag().mark((function t(e) {
                                        return ag().wrap((function (t) {
                                            for (;;) switch (t.prev = t.next) {
                                                case 0:
                                                    if (!cf.loadOnDemand.enabled) {
                                                        t.next = 4;
                                                        break
                                                    }
                                                    return t.abrupt("return", r.loadTexture(e, "pmrem"));
                                                case 4:
                                                    return t.abrupt("return", Promise.resolve({
                                                        name: e.name,
                                                        status: "skipped"
                                                    }));
                                                case 5:
                                                case "end":
                                                    return t.stop()
                                            }
                                        }), t)
                                    })));
                                    return function (e) {
                                        return t.apply(this, arguments)
                                    }
                                }())), t.abrupt("return", Promise.all(n));
                            case 2:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                }))), function (t) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "getHdrTexture",
                value: function (t) {
                    return cf.environment.assetsArray.find((function (e) {
                        return e.name === t
                    })).loadedHDRTexture
                }
            }, {
                key: "getTexture",
                value: function (t) {
                    var e = cf.textures.find((function (e) {
                        return e.name === t
                    }));
                    if (e || cf.models.samara.assetsArray.filter((function (n) {
                            return n.textures.some((function (n) {
                                n.name === t && (e = n)
                            }))
                        })), e) return e.loadedTexture;
                    console.error(t)
                }
            }, {
                key: "loadTexture",
                value: (e = lg(ag().mark((function t(e, n) {
                    var r, i, o;
                    return ag().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if (t.prev = 0, "pmrem" !== n) {
                                    t.next = 7;
                                    break
                                }
                                return t.next = 4, this.rgbeLoader.loadAsync(e.hdrTexturePath);
                            case 4:
                                r = t.sent, i = new _l(256).fromEquirectangularTexture(this.engine.renderer, r), e.loadedHDRTexture = i.texture;
                            case 7:
                                if ("map" !== n) {
                                    t.next = 21;
                                    break
                                }
                                if (e.loadedTexture) {
                                    t.next = 21;
                                    break
                                }
                                if (!e.ktxPath || !cf.useCompressedTextures) {
                                    t.next = 15;
                                    break
                                }
                                return t.next = 12, this.ktx2Loader.loadAsync(this.path + e.ktxPath);
                            case 12:
                                t.t0 = t.sent, t.next = 18;
                                break;
                            case 15:
                                return t.next = 17, this.textureLoader.loadAsync(e.path);
                            case 17:
                                t.t0 = t.sent;
                            case 18:
                                o = t.t0, this.setupTexture(o, e), e.loadedTexture = o;
                            case 21:
                                return t.abrupt("return", Promise.resolve(og({}, e.name, "loaded")));
                            case 24:
                                return t.prev = 24, t.t1 = t.catch(0), t.abrupt("return", Promise.reject(t.t1));
                            case 27:
                            case "end":
                                return t.stop()
                        }
                    }), t, this, [
                        [0, 24]
                    ])
                }))), function (t, n) {
                    return e.apply(this, arguments)
                })
            }, {
                key: "setupTexture",
                value: function (t, e) {
                    e.anisotropy && (t.anisotropy = this.engine.renderer.capabilities.getMaxAnisotropy()), e.repeat && (t.wrapT = t.wrapS = pi, e.repeatSet && t.repeat.set(e.repeatSet, e.repeatSet)), e.nonSrgb || (t.colorSpace = Yi), e.rotation && (t.rotation = e.rotation), t.flipY = !1
                }
            }]), t
        }();

        function dg(t) {
            return dg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, dg(t)
        }

        function pg(t, e) {
            var n = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var r = Object.getOwnPropertySymbols(t);
                e && (r = r.filter((function (e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), n.push.apply(n, r)
            }
            return n
        }

        function fg(t) {
            for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2 ? pg(Object(n), !0).forEach((function (e) {
                    mg(t, e, n[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : pg(Object(n)).forEach((function (e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                }))
            }
            return t
        }

        function mg(t, e, n) {
            return e = function (t) {
                var e = function (t, e) {
                    if ("object" != dg(t) || !t) return t;
                    var n = t[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(t, e);
                        if ("object" != dg(r)) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === e ? String : Number)(t)
                }(t, "string");
                return "symbol" == dg(e) ? e : String(e)
            }(e), e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function gg(t, e, n) {
            return e = vg(e),
                function (t, e) {
                    if (e && ("object" === dg(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return _g(t)
                }(t, Ag() ? Reflect.construct(e, [], vg(t).constructor) : e.apply(t, n))
        }

        function Ag() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {})))
            } catch (t) {}
            return (Ag = function () {
                return !!t
            })()
        }

        function vg(t) {
            return vg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, vg(t)
        }

        function _g(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function yg(t, e) {
            return yg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, yg(t, e)
        }
        var Eg = function (t) {
            function e() {
                var t, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 6;
                return function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), (t = gg(this, e)).materialType = "MeshTransmissionMaterial", t.uniforms = {
                    chromaticAberration: {
                        value: .05
                    },
                    anisotrophicBlur: {
                        value: .9
                    },
                    time: {
                        value: 0
                    },
                    distortion: {
                        value: 0
                    },
                    distortionScale: {
                        value: .5
                    },
                    temporalDistortion: {
                        value: 0
                    }
                }, t.onBeforeCompile = function (e) {
                    e.uniforms = fg(fg({}, e.uniforms), t.uniforms), e.fragmentShader = "\n      uniform float chromaticAberration;            \n      uniform float anisotrophicBlur;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      float seed = 0.0;\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n      float rand() {\n        float result = random(vec3(gl_FragCoord.xy, seed));\n        seed += 1.0;\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\n" + e.fragmentShader, e.fragmentShader = e.fragmentShader.replace("#include <transmission_pars_fragment>", "\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef texture2DLodEXT\n              return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n            #else\n              return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\n"), e.fragmentShader = e.fragmentShader.replace("#include <transmission_fragment>", "\n        // Improve the refraction to use the world pos\n        material.transmission = transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand();\n        float thickness_smear = thickness * max(pow(roughness, 0.33), anisotrophicBlur);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ".concat(n, ".0; i ++) {\n          vec3 sampleNorm = normalize(n + roughness * roughness * 2.0 * normalize(vec3(rand() - 0.5, rand() - 0.5, rand() - 0.5)) * pow(rand(), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(").concat(n, "),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(").concat(n, ")) , material.thickness + thickness_smear * (i + randomCoords) / float(").concat(n, "),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(").concat(n, ")), material.thickness + thickness_smear * (i + randomCoords) / float(").concat(n, "),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ").concat(n, ".0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n"))
                }, Object.keys(t.uniforms).forEach((function (e) {
                    return Object.defineProperty(_g(t), e, {
                        get: function () {
                            return t.uniforms[e].value
                        },
                        set: function (n) {
                            return t.uniforms[e].value = n
                        }
                    })
                })), t
            }
            return function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && yg(t, e)
            }(e, t), n = e, Object.defineProperty(n, "prototype", {
                writable: !1
            }), n;
            var n
        }(dd);

        function xg(t) {
            return xg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, xg(t)
        }

        function bg(t, e) {
            return function (t) {
                if (Array.isArray(t)) return t
            }(t) || function (t, e) {
                var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != n) {
                    var r, i, o, a, s = [],
                        l = !0,
                        c = !1;
                    try {
                        if (o = (n = n.call(t)).next, 0 === e);
                        else
                            for (; !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                    } catch (t) {
                        c = !0, i = t
                    } finally {
                        try {
                            if (!l && null != n.return && (a = n.return(), Object(a) !== a)) return
                        } finally {
                            if (c) throw i
                        }
                    }
                    return s
                }
            }(t, e) || function (t, e) {
                if (!t) return;
                if ("string" == typeof t) return wg(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return wg(t, e)
            }(t, e) || function () {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function wg(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r
        }

        function Cg(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Sg(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function Sg(t) {
            var e = function (t, e) {
                if ("object" != xg(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != xg(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == xg(e) ? e : String(e)
        }
        var Ig = function () {
            function t() {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.textures = new hg, this.allMaterials = new Map, this.transmissiveMaterials = new Set
            }
            return Cg(t, [{
                key: "applyTextures",
                value: function (t, e, n) {
                    t instanceof ns && t.traverse((function (t) {
                        t.material && (e && (t.material.map = e), n && (t.material.normalMap = n))
                    })), t instanceof rl && (e && (t.material.map = e), n && (t.material.normalMap = n))
                }
            }, {
                key: "setupFurniture",
                value: function (t) {
                    "Chair1_S" === t.name && this.applyTextures(t, this.textures.getTexture("Albedo_Chair1_S_512")), ["Chair_S", "Chair_1B", "Chair_2B"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Chair_512")), ["Const_Bath_S", "Const_Bath_1B", "Const_Bath_2B"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Bath_512")), ["Faucet_S", "Faucet_1B", "Faucet_2B"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Faucet_512")), ["Oven_S", "Oven", "Oven_2B"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Oven_512")), ["Shelves_1B", "Shelves_2B"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Shelves_512")), "Shelves_S" === t.name && this.applyTextures(t, this.textures.getTexture("Shelves_studio")), "Shelves_2BA" === t.name && this.applyTextures(t, this.textures.getTexture("Shelves_XL8")), "Shelves_XL10" === t.name && this.applyTextures(t, this.textures.getTexture("Shelves_XL10")), ["Bed_2B", "Bed_1B", "Bed_S", "Bed_2BA", "Bed_XL10"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Bed_512")), ["Lampe", "Lampe_2B"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Lamp_512")), ["Sofa", "Sofa_2B", "Sofa_XL10"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Albedo_Sofa_512")), ["Sofa_2BA"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Sofa_2BA")), ["Chair_2BA"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Chair_2BA")), ["Chair_XL10"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Chair_XL10")), ["Base_2BA_1", "Base_XL10_1"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Base_2BA")), ["WoodFurniture_2BA", "WoodFurniture_XL10"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Wood_2BA")), ["Technique_2BA_1", "Technique_XL10_1"].includes(t.name) && this.applyTextures(t, this.textures.getTexture("Technique_2BA"))
                }
            }, {
                key: "setupMaterials",
                value: function (t, e) {
                    var n = this;
                    if (!this.glassClearMaterial && (this.glassClearMaterial = new dd({
                            transmission: .6,
                            color: new vs(8882055).convertLinearToSRGB(),
                            depthWrite: !1,
                            metalnessMap: this.textures.getTexture("glass_orm"),
                            roughnessMap: this.textures.getTexture("glass_orm"),
                            name: "Glass Clear",
                            roughness: 0
                        })), !this.exteriorMaterial && (this.exteriorMaterial = new dd({
                            color: new vs(cf.models.samara.complectationVars.Color.variants[0].hex),
                            roughness: cf.materials.metal.roughness,
                            metalness: cf.materials.metal.metalness,
                            aoMapIntensity: cf.aoMap.exterior.intensity
                        })), !this.roofMaterial && (this.roofMaterial = new dd({
                            color: new vs(cf.models.samara.complectationVars.Roof.variants[0].hex),
                            roughness: .7,
                            metalness: .2,
                            aoMapIntensity: cf.aoMap.roof.intensity
                        })), !this.shadowMaterial && (this.shadowMaterial = new pd({
                            color: 16777215,
                            transparent: !0,
                            opacity: cf.shadowMesh.opacity,
                            side: 2,
                            depthWrite: !1
                        })), t.name.includes("Spigot") && (t.material.color = new vs(13081949).convertLinearToSRGB(), t.material.roughness = 0, t.material.metalness = 1), t.name.includes("Sanr") && (t.visible = !1), "Floor_XL10_1" === t.name && (t.material.map = this.textures.getTexture("Floor_XL10")), "Floor_2BA_1" === t.name && (t.material.map = this.textures.getTexture("Floor_2BA")), "Floor_S" === t.name && (t.material.map = this.textures.getTexture("Floor_S")), "Floor_1B" === t.name && (t.material.map = this.textures.getTexture("Floor_1B")), "Floor_2B" === t.name && (t.material.map = this.textures.getTexture("Floor_2B")), "Wall_i_1B" === t.name && (t.material.map = this.textures.getTexture("Wall_i_1B")), t.material && "Wall_studio" === t.material.name && (t.material.map = this.textures.getTexture("Wall_i_S")), t.material && t.material.name.includes("Faucet") && (t.material.metalness = 1), t.material && "Wall_2BA_XL 8" === t.material.name && (t.material.map = this.textures.getTexture("Wall_2BA_1K")), t.material && "Wall_XL10_XL 10" === t.material.name && (t.material.map = this.textures.getTexture("Wall_XL10")), "Wall_i_2B" === t.name && (t.material.map = this.textures.getTexture("Wall_i_2B")), "WoodFurniture_S" === t.name && (t.material.map = this.textures.getTexture("Wood_S")), "WoodFurniture_1B" === t.name && (t.material.map = this.textures.getTexture("Wood_1B")), "WoodFurniture_2B" === t.name && (t.material.map = this.textures.getTexture("Wood_2B")), t.material) {
                        for (var r = ["_studio", "_onebed", "_twobed", "_XL 8", "_XL 10"], i = function () {
                                var e = bg(a[o], 2),
                                    i = e[0],
                                    s = e[1];
                                if (r.some((function (e) {
                                        return t.material.name === i + e
                                    }))) {
                                    if (s.setEmissive && (t.material.emissive = new vs(16777215)), s.setBaseTextures && (t.material.map = n.textures.getTexture("Tesla_BaseColor"), t.material.aoMap = n.textures.getTexture("Tesla_AO"), t.material.aoMapIntensity = cf.aoMap.powerwall.intensity, t.material.aoMap.channel = 1), s.transparent && (t.material.transparent = !0, t.material.opacity = s.opacity), s.mapTexture && (t.material.map = n.textures.getTexture(s.mapTexture)), s.adjustPosition) {
                                        var l = r.find((function (e) {
                                                return t.material.name.endsWith(e)
                                            })) || "",
                                            c = "function" == typeof s.adjustPosition ? s.adjustPosition(l) : Array.isArray(s.adjustPosition) ? s.adjustPosition : [s.adjustPosition],
                                            u = "function" == typeof s.positionOffset ? s.positionOffset(l) : Array.isArray(s.positionOffset) ? s.positionOffset : [s.positionOffset];
                                        c.forEach((function (e, n) {
                                            var r = u[n] || u[0];
                                            t.position[e] += r
                                        }))
                                    }
                                    return void 0 !== s.renderOrder && (t.renderOrder = s.renderOrder), 1
                                }
                            }, o = 0, a = Object.entries({
                                Tesla: {
                                    setEmissive: !0,
                                    setBaseTextures: !0,
                                    adjustPosition: "y",
                                    positionOffset: 0
                                },
                                Tesla_box: {
                                    setBaseTextures: !0,
                                    adjustPosition: "y",
                                    positionOffset: 0
                                },
                                Tesla_wall: {
                                    transparent: !0,
                                    opacity: .4,
                                    mapTexture: "TeslaWall_AO",
                                    adjustPosition: function (t) {
                                        return ["_studio", "_onebed", "_twobed", "_XL 10"].includes(t) ? ["z", "y"] : "_XL 8" === t ? ["x", "y"] : void 0
                                    },
                                    positionOffset: function (t) {
                                        return "_XL 10" === t ? [-.01, -.015] : [.01, -.015]
                                    },
                                    renderOrder: 10
                                },
                                Tesla_floor: {
                                    transparent: !0,
                                    opacity: .4,
                                    mapTexture: "TeslaFloor_AO",
                                    adjustPosition: "y",
                                    positionOffset: .001,
                                    renderOrder: 10
                                }
                            }); o < a.length && !i(); o++);
                        if (t.material.name.includes("Shelves") && (t.material.color = new vs(15132390)), ["Glass_Bath_S", "Glass_Bath_1B", "Glass_Bath_2B"].includes(t.name) && (t.material = this.glassClearMaterial.clone(), t.material.name = "Glass Bath_".concat(e)), ["glassDoor_onebed", "glassDoor_studio", "glassDoor_twobed"].includes(t.material.name) && (t.material = this.glassClearMaterial.clone(), t.material.name = "Glass Door_".concat(e), t.material.transmission = .2), ["glassClear_onebed", "glassClear_studio", "glassClear_twobed", "glassClear_XL 8", "glassDoor_XL 8", "glassDoor_XL 10", "glassClear_XL 10"].includes(t.material.name) && (t.material = this.glassClearMaterial.clone(), t.material.name = "Glass Clear_".concat(e)), ["Air_onebed", "Air_studio", "Air_twobed", "Air_XL 8", "Air_XL 10"].includes(t.material.name) && (t.material.map = this.textures.getTexture("Air_purification"), t.material.aoMap = this.textures.getTexture("ao_air_ex"), t.material.aoMapIntensity = cf.aoMap.air.intensity), ["Color_Exterior_channels_onebed", "Color_Exterior_channels_twobed", "Color_Exterior_channels_studio", "Color_Exterior_channels_XL 8", "Color_Exterior_channels_XL 10"].includes(t.material.name) && (t.material.map = null, t.material.aoMap = this.textures.getTexture("AO_channels"), t.material.aoMapIntensity = cf.aoMap.exterior.intensity, t.renderOrder = 20), "Color_Exterior_onebed" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.name = "Base Color Material_onebed"), "Color_Exterior_twobed" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.name = "Base Color Material_twobed"), "Color_Exterior_XL 8" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.name = "Base Color Material_XL 8"), "Color_Exterior_XL 10" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.name = "Base Color Material_XL 10"), "Color_Exterior_studio" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.name = "Base Color Material_studio", t.material.aoMapIntensity = cf.aoMap.exterior.intensity), ["Metal_details_studio", "Metal_details_onebed", "Metal_details_twobed", "Metal_details_XL 8", "Metal_details_XL 10"].includes(t.material.name)) {
                            var s = t.material.name;
                            t.material = this.exteriorMaterial.clone(), t.material.name = s, t.material.aoMapIntensity = cf.aoMap.exterior.intensity, t.renderOrder = 20
                        }
                        t.name.includes("Exhaust") && (t.renderOrder = 20), "Frame_Around_studio" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.roughness = 1, t.material.name = "Frame_Around_studio"), "Frame_Around_onebed" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.roughness = 1, t.material.name = "Frame_Around_onebed"), "Frame_Around_twobed" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.roughness = 1, t.material.name = "Frame_Around_twobed"), "Frame_Around_XL 8" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.roughness = 1, t.material.name = "Frame_Around_XL 8"), "Frame_Around_XL 10" === t.material.name && (t.material = this.exteriorMaterial.clone(), t.material.roughness = 1, t.material.name = "Frame_Around_XL 10");
                        if (["studio", "onebed", "twobed", "XL 8", "XL 10"].forEach((function (e) {
                                t.material.name === "Color_Exterior_Wood_".concat(e) && (t.material = n.exteriorMaterial.clone(), t.material.roughness = 1, t.material.name = "Frame_Windows_".concat(e))
                            })), ["Color_Exterior_walls_studio", "Color_Exterior_walls_onebed", "Color_Exterior_walls_twobed", "Color_Exterior_walls_XL 8", "Color_Exterior_walls_XL 10"].includes(t.material.name)) {
                            var l = t.material.name;
                            t.material = this.exteriorMaterial.clone(), t.material.name = l, t.material.normalMap = this.textures.getTexture("Metal_normal"), t.material.map = this.textures.getTexture("Metal_basecolor"), t.material.normalScale = new Co(.7, .7), t.material.normalMap.offset.x = t.material.map.offset.x = .45
                        }
                        if (["Solar_Panel_onebed", "Solar_Panel_studio", "Solar_Panel_twobed", "Solar_Panel_XL 8", "Solar_Panel_XL 10"].includes(t.material.name) && (t.material.normalScale = new Co(.01, -.01), t.material.map = this.textures.getTexture("Solar_Panel"), t.material.metalnessMap = this.textures.getTexture("Solar_Panel_metalness")), ["Cedar_onebed", "Cedar_studio", "Cedar_twobed", "Cedar_XL 8", "Cedar_XL 10"].includes(t.material.name) && (t.material.color = new vs(16777215), t.material.roughness = .7, t.material.aoMap = this.textures.getTexture("cedar_ao_new"), t.material.aoMapIntensity = cf.aoMap.desk.intensity, t.material.map = this.textures.getTexture("Oak_Wood_Varnished_Albedo_2Kt")), ["Color_ExteriorSupp_onebed", "Color_ExteriorSupp_studio", "Color_ExteriorSupp_twobed", "Color_ExteriorSupp_XL 8", "Color_ExteriorSupp_XL 10"].includes(t.material.name)) {
                            var c = t.material.name;
                            t.material = this.exteriorMaterial.clone(), t.material.name = c, t.material.aoMap = this.textures.getTexture("patio_supp_ao"), t.material.aoMapIntensity = cf.aoMap.patio.intensity
                        }
                        if ("Color_Roof_onebed" === t.material.name && (t.material = this.roofMaterial.clone(), t.material.name = "Roof Material_onebed"), "Color_Roof_studio" === t.material.name && (t.material = this.roofMaterial.clone(), t.material.name = "Roof Material_studio"), "Color_Roof_twobed" === t.material.name && (t.material = this.roofMaterial.clone(), t.material.name = "Roof Material_twobed"), "Color_Roof_XL 8" === t.material.name && (t.material = this.roofMaterial.clone(), t.material.name = "Roof Material_XL 8"), "Color_Roof_XL 10" === t.material.name && (t.material = this.roofMaterial.clone(), t.material.name = "Roof Material_XL 10"), t.material.envMap = this.textures.getHdrTexture("hdr-2"), t.material.envMapIntensity = cf.envMap.intensity, this.allMaterials.has(t.material.name) || this.allMaterials.set(t.material.name, t.material), t.material = this.allMaterials.get(t.material.name), t.material.transmission && !this.transmissiveMaterials.has(t.material.name)) {
                            var u = t.material,
                                h = u.ior,
                                d = u.transmission,
                                p = u.color,
                                f = u.thickness;
                            u.clearcoat, u.clearcoatRoughness;
                            var m = u.roughness,
                                g = u.name;
                            t.material = new Eg(10), Object.assign(t.material, {
                                transmission: d,
                                roughness: m,
                                thickness: f,
                                ior: h,
                                color: p,
                                name: g
                            }), this.transmissiveMaterials.add(t.material)
                        }
                    }
                }
            }]), t
        }();

        function Mg(t, e) {
            if (0 === e) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), t;
            if (2 === e || 1 === e) {
                let n = t.getIndex();
                if (null === n) {
                    const e = [],
                        r = t.getAttribute("position");
                    if (void 0 === r) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                    for (let t = 0; t < r.count; t++) e.push(t);
                    t.setIndex(e), n = t.getIndex()
                }
                const r = n.count - 2,
                    i = [];
                if (2 === e)
                    for (let t = 1; t <= r; t++) i.push(n.getX(0)), i.push(n.getX(t)), i.push(n.getX(t + 1));
                else
                    for (let t = 0; t < r; t++) t % 2 == 0 ? (i.push(n.getX(t)), i.push(n.getX(t + 1)), i.push(n.getX(t + 2))) : (i.push(n.getX(t + 2)), i.push(n.getX(t + 1)), i.push(n.getX(t)));
                i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const o = t.clone();
                return o.setIndex(i), o.clearGroups(), o
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), t
        }

        function Tg() {
            let t = {};
            return {
                get: function (e) {
                    return t[e]
                },
                add: function (e, n) {
                    t[e] = n
                },
                remove: function (e) {
                    delete t[e]
                },
                removeAll: function () {
                    t = {}
                }
            }
        }
        const Bg = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class Rg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const t = this.parser,
                    e = this.parser.json.nodes || [];
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n];
                    r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && t._addNodeRef(this.cache, r.extensions[this.name].light)
                }
            }
            _loadLight(t) {
                const e = this.parser,
                    n = "light:" + t;
                let r = e.cache.get(n);
                if (r) return r;
                const i = e.json,
                    o = ((i.extensions && i.extensions[this.name] || {}).lights || [])[t];
                let a;
                const s = new vs(16777215);
                void 0 !== o.color && s.setRGB(o.color[0], o.color[1], o.color[2], Ki);
                const l = void 0 !== o.range ? o.range : 0;
                switch (o.type) {
                    case "directional":
                        a = new ep(s), a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    case "point":
                        a = new Zd(s), a.distance = l;
                        break;
                    case "spot":
                        a = new Xd(s), a.distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                }
                return a.position.set(0, 0, 0), a.decay = 2, gA(a, o), void 0 !== o.intensity && (a.intensity = o.intensity), a.name = e.createUniqueName(o.name || "light_" + t), r = Promise.resolve(a), e.cache.add(n, r), r
            }
            getDependency(t, e) {
                if ("light" === t) return this._loadLight(e)
            }
            createNodeAttachment(t) {
                const e = this,
                    n = this.parser,
                    r = n.json.nodes[t],
                    i = (r.extensions && r.extensions[this.name] || {}).light;
                return void 0 === i ? null : this._loadLight(i).then((function (t) {
                    return n._getNodeRef(e.cache, i, t)
                }))
            }
        }
        class Lg {
            constructor() {
                this.name = Bg.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return xs
            }
            extendParams(t, e, n) {
                const r = [];
                t.color = new vs(1, 1, 1), t.opacity = 1;
                const i = e.pbrMetallicRoughness;
                if (i) {
                    if (Array.isArray(i.baseColorFactor)) {
                        const e = i.baseColorFactor;
                        t.color.setRGB(e[0], e[1], e[2], Ki), t.opacity = e[3]
                    }
                    void 0 !== i.baseColorTexture && r.push(n.assignTexture(t, "map", i.baseColorTexture, Yi))
                }
                return Promise.all(r)
            }
        }
        class Dg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const r = n.extensions[this.name].emissiveStrength;
                return void 0 !== r && (e.emissiveIntensity = r), Promise.resolve()
            }
        }
        class Pg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                if (void 0 !== o.clearcoatFactor && (e.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && i.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (e.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && i.push(n.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (i.push(n.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                    const t = o.clearcoatNormalTexture.scale;
                    e.clearcoatNormalScale = new Co(t, t)
                }
                return Promise.all(i)
            }
        }
        class Og {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.iridescenceFactor && (e.iridescence = o.iridescenceFactor), void 0 !== o.iridescenceTexture && i.push(n.assignTexture(e, "iridescenceMap", o.iridescenceTexture)), void 0 !== o.iridescenceIor && (e.iridescenceIOR = o.iridescenceIor), void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]), void 0 !== o.iridescenceThicknessMinimum && (e.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), void 0 !== o.iridescenceThicknessMaximum && (e.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), void 0 !== o.iridescenceThicknessTexture && i.push(n.assignTexture(e, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(i)
            }
        }
        class kg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_SHEEN
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [];
                e.sheenColor = new vs(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
                const o = r.extensions[this.name];
                if (void 0 !== o.sheenColorFactor) {
                    const t = o.sheenColorFactor;
                    e.sheenColor.setRGB(t[0], t[1], t[2], Ki)
                }
                return void 0 !== o.sheenRoughnessFactor && (e.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && i.push(n.assignTexture(e, "sheenColorMap", o.sheenColorTexture, Yi)), void 0 !== o.sheenRoughnessTexture && i.push(n.assignTexture(e, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i)
            }
        }
        class Ug {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.transmissionFactor && (e.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && i.push(n.assignTexture(e, "transmissionMap", o.transmissionTexture)), Promise.all(i)
            }
        }
        class Ng {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_VOLUME
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                e.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && i.push(n.assignTexture(e, "thicknessMap", o.thicknessTexture)), e.attenuationDistance = o.attenuationDistance || 1 / 0;
                const a = o.attenuationColor || [1, 1, 1];
                return e.attenuationColor = (new vs).setRGB(a[0], a[1], a[2], Ki), Promise.all(i)
            }
        }
        class Fg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_IOR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const r = n.extensions[this.name];
                return e.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
            }
        }
        class Qg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                e.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && i.push(n.assignTexture(e, "specularIntensityMap", o.specularTexture));
                const a = o.specularColorFactor || [1, 1, 1];
                return e.specularColor = (new vs).setRGB(a[0], a[1], a[2], Ki), void 0 !== o.specularColorTexture && i.push(n.assignTexture(e, "specularColorMap", o.specularColorTexture, Yi)), Promise.all(i)
            }
        }
        class $g {
            constructor(t) {
                this.parser = t, this.name = Bg.EXT_MATERIALS_BUMP
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return e.bumpScale = void 0 !== o.bumpFactor ? o.bumpFactor : 1, void 0 !== o.bumpTexture && i.push(n.assignTexture(e, "bumpMap", o.bumpTexture)), Promise.all(i)
            }
        }
        class Gg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? dd : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    r = n.json.materials[t];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.anisotropyStrength && (e.anisotropy = o.anisotropyStrength), void 0 !== o.anisotropyRotation && (e.anisotropyRotation = o.anisotropyRotation), void 0 !== o.anisotropyTexture && i.push(n.assignTexture(e, "anisotropyMap", o.anisotropyTexture)), Promise.all(i)
            }
        }
        class Hg {
            constructor(t) {
                this.parser = t, this.name = Bg.KHR_TEXTURE_BASISU
            }
            loadTexture(t) {
                const e = this.parser,
                    n = e.json,
                    r = n.textures[t];
                if (!r.extensions || !r.extensions[this.name]) return null;
                const i = r.extensions[this.name],
                    o = e.options.ktx2Loader;
                if (!o) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return e.loadTextureImage(t, i.source, o)
            }
        }
        class zg {
            constructor(t) {
                this.parser = t, this.name = Bg.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name,
                    n = this.parser,
                    r = n.json,
                    i = r.textures[t];
                if (!i.extensions || !i.extensions[e]) return null;
                const o = i.extensions[e],
                    a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const t = n.options.manager.getHandler(a.uri);
                    null !== t && (s = t)
                }
                return this.detectSupport().then((function (i) {
                    if (i) return n.loadTextureImage(t, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(t)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function (t) {
                    const e = new Image;
                    e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function () {
                        t(1 === e.height)
                    }
                }))), this.isSupported
            }
        }
        class Vg {
            constructor(t) {
                this.parser = t, this.name = Bg.EXT_TEXTURE_AVIF, this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name,
                    n = this.parser,
                    r = n.json,
                    i = r.textures[t];
                if (!i.extensions || !i.extensions[e]) return null;
                const o = i.extensions[e],
                    a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const t = n.options.manager.getHandler(a.uri);
                    null !== t && (s = t)
                }
                return this.detectSupport().then((function (i) {
                    if (i) return n.loadTextureImage(t, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(t)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function (t) {
                    const e = new Image;
                    e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function () {
                        t(1 === e.height)
                    }
                }))), this.isSupported
            }
        }
        class Wg {
            constructor(t) {
                this.name = Bg.EXT_MESHOPT_COMPRESSION, this.parser = t
            }
            loadBufferView(t) {
                const e = this.parser.json,
                    n = e.bufferViews[t];
                if (n.extensions && n.extensions[this.name]) {
                    const t = n.extensions[this.name],
                        r = this.parser.getDependency("buffer", t.buffer),
                        i = this.parser.options.meshoptDecoder;
                    if (!i || !i.supported) {
                        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return r.then((function (e) {
                        const n = t.byteOffset || 0,
                            r = t.byteLength || 0,
                            o = t.count,
                            a = t.byteStride,
                            s = new Uint8Array(e, n, r);
                        return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(o, a, s, t.mode, t.filter).then((function (t) {
                            return t.buffer
                        })) : i.ready.then((function () {
                            const e = new ArrayBuffer(o * a);
                            return i.decodeGltfBuffer(new Uint8Array(e), o, a, s, t.mode, t.filter), e
                        }))
                    }))
                }
                return null
            }
        }
        class jg {
            constructor(t) {
                this.name = Bg.EXT_MESH_GPU_INSTANCING, this.parser = t
            }
            createNodeMesh(t) {
                const e = this.parser.json,
                    n = e.nodes[t];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                const r = e.meshes[n.mesh];
                for (const t of r.primitives)
                    if (t.mode !== iA.TRIANGLES && t.mode !== iA.TRIANGLE_STRIP && t.mode !== iA.TRIANGLE_FAN && void 0 !== t.mode) return null;
                const i = n.extensions[this.name].attributes,
                    o = [],
                    a = {};
                for (const t in i) o.push(this.parser.getDependency("accessor", i[t]).then((e => (a[t] = e, a[t]))));
                return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(t)), Promise.all(o).then((t => {
                    const e = t.pop(),
                        n = e.isGroup ? e.children : [e],
                        r = t[0].count,
                        i = [];
                    for (const t of n) {
                        const e = new Ta,
                            n = new Zo,
                            o = new Jo,
                            s = new Zo(1, 1, 1),
                            l = new Hh(t.geometry, t.material, r);
                        for (let t = 0; t < r; t++) a.TRANSLATION && n.fromBufferAttribute(a.TRANSLATION, t), a.ROTATION && o.fromBufferAttribute(a.ROTATION, t), a.SCALE && s.fromBufferAttribute(a.SCALE, t), l.setMatrixAt(t, e.compose(n, o, s));
                        for (const e in a)
                            if ("_COLOR_0" === e) {
                                const t = a[e];
                                l.instanceColor = new Oh(t.array, t.itemSize, t.normalized)
                            } else "TRANSLATION" !== e && "ROTATION" !== e && "SCALE" !== e && t.geometry.setAttribute(e, a[e]);
                        ns.prototype.copy.call(l, t), this.parser.assignFinalMaterial(l), i.push(l)
                    }
                    return e.isGroup ? (e.clear(), e.add(...i), e) : i[0]
                })))
            }
        }
        const Xg = "glTF",
            qg = 1313821514,
            Yg = 5130562;
        class Kg {
            constructor(t) {
                this.name = Bg.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const e = new DataView(t, 0, 12),
                    n = new TextDecoder;
                if (this.header = {
                        magic: n.decode(new Uint8Array(t.slice(0, 4))),
                        version: e.getUint32(4, !0),
                        length: e.getUint32(8, !0)
                    }, this.header.magic !== Xg) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const r = this.header.length - 12,
                    i = new DataView(t, 12);
                let o = 0;
                for (; o < r;) {
                    const e = i.getUint32(o, !0);
                    o += 4;
                    const r = i.getUint32(o, !0);
                    if (o += 4, r === qg) {
                        const r = new Uint8Array(t, 12 + o, e);
                        this.content = n.decode(r)
                    } else if (r === Yg) {
                        const n = 12 + o;
                        this.body = t.slice(n, n + e)
                    }
                    o += e
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class Jg {
            constructor(t, e) {
                if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = Bg.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
            }
            decodePrimitive(t, e) {
                const n = this.json,
                    r = this.dracoLoader,
                    i = t.extensions[this.name].bufferView,
                    o = t.extensions[this.name].attributes,
                    a = {},
                    s = {},
                    l = {};
                for (const t in o) {
                    const e = cA[t] || t.toLowerCase();
                    a[e] = o[t]
                }
                for (const e in t.attributes) {
                    const r = cA[e] || e.toLowerCase();
                    if (void 0 !== o[e]) {
                        const i = n.accessors[t.attributes[e]],
                            o = oA[i.componentType];
                        l[r] = o.name, s[r] = !0 === i.normalized
                    }
                }
                return e.getDependency("bufferView", i).then((function (t) {
                    return new Promise((function (e, n) {
                        r.decodeDracoFile(t, (function (t) {
                            for (const e in t.attributes) {
                                const n = t.attributes[e],
                                    r = s[e];
                                void 0 !== r && (n.normalized = r)
                            }
                            e(t)
                        }), a, l, Ki, n)
                    }))
                }))
            }
        }
        class Zg {
            constructor() {
                this.name = Bg.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(t, e) {
                return void 0 !== e.texCoord && e.texCoord !== t.channel || void 0 !== e.offset || void 0 !== e.rotation || void 0 !== e.scale ? (t = t.clone(), void 0 !== e.texCoord && (t.channel = e.texCoord), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0, t) : t
            }
        }
        class tA {
            constructor() {
                this.name = Bg.KHR_MESH_QUANTIZATION
            }
        }
        class eA extends vd {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    i = t * r * 3 + r;
                for (let t = 0; t !== r; t++) e[t] = n[i + t];
                return e
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = 2 * a,
                    l = 3 * a,
                    c = r - e,
                    u = (n - e) / c,
                    h = u * u,
                    d = h * u,
                    p = t * l,
                    f = p - l,
                    m = -2 * d + 3 * h,
                    g = d - h,
                    A = 1 - m,
                    v = g - h + u;
                for (let t = 0; t !== a; t++) {
                    const e = o[f + t + a],
                        n = o[f + t + s] * c,
                        r = o[p + t + a],
                        l = o[p + t] * c;
                    i[t] = A * e + v * n + m * r + g * l
                }
                return i
            }
        }
        const nA = new Jo;
        class rA extends eA {
            interpolate_(t, e, n, r) {
                const i = super.interpolate_(t, e, n, r);
                return nA.fromArray(i).normalize().toArray(i), i
            }
        }
        const iA = {
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6
            },
            oA = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            aA = {
                9728: gi,
                9729: _i,
                9984: Ai,
                9985: yi,
                9986: vi,
                9987: Ei
            },
            sA = {
                33071: fi,
                33648: mi,
                10497: pi
            },
            lA = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            cA = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv1",
                TEXCOORD_2: "uv2",
                TEXCOORD_3: "uv3",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            uA = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            hA = {
                CUBICSPLINE: void 0,
                LINEAR: ji,
                STEP: Wi
            },
            dA = "OPAQUE",
            pA = "MASK",
            fA = "BLEND";

        function mA(t, e, n) {
            for (const r in n.extensions) void 0 === t[r] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = n.extensions[r])
        }

        function gA(t, e) {
            void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
        }

        function AA(t, e) {
            if (t.updateMorphTargets(), void 0 !== e.weights)
                for (let n = 0, r = e.weights.length; n < r; n++) t.morphTargetInfluences[n] = e.weights[n];
            if (e.extras && Array.isArray(e.extras.targetNames)) {
                const n = e.extras.targetNames;
                if (t.morphTargetInfluences.length === n.length) {
                    t.morphTargetDictionary = {};
                    for (let e = 0, r = n.length; e < r; e++) t.morphTargetDictionary[n[e]] = e
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function vA(t) {
            let e;
            const n = t.extensions && t.extensions[Bg.KHR_DRACO_MESH_COMPRESSION];
            if (e = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + _A(n.attributes) : t.indices + ":" + _A(t.attributes) + ":" + t.mode, void 0 !== t.targets)
                for (let n = 0, r = t.targets.length; n < r; n++) e += ":" + _A(t.targets[n]);
            return e
        }

        function _A(t) {
            let e = "";
            const n = Object.keys(t).sort();
            for (let r = 0, i = n.length; r < i; r++) e += n[r] + ":" + t[n[r]] + ";";
            return e
        }

        function yA(t) {
            switch (t) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const EA = new Ta;
        class xA {
            constructor(t = {}, e = {}) {
                this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new Tg, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                let n = !1,
                    r = !1,
                    i = -1;
                "undefined" != typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), r = navigator.userAgent.indexOf("Firefox") > -1, i = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || r && i < 98 ? this.textureLoader = new $d(this.options.manager) : this.textureLoader = new ip(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Nd(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(t) {
                this.extensions = t
            }
            setPlugins(t) {
                this.plugins = t
            }
            parse(t, e) {
                const n = this,
                    r = this.json,
                    i = this.extensions;
                this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function (t) {
                    return t._markDefs && t._markDefs()
                })), Promise.all(this._invokeAll((function (t) {
                    return t.beforeRoot && t.beforeRoot()
                }))).then((function () {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                })).then((function (e) {
                    const o = {
                        scene: e[0][r.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: r.asset,
                        parser: n,
                        userData: {}
                    };
                    return mA(i, o, r), gA(o, r), Promise.all(n._invokeAll((function (t) {
                        return t.afterRoot && t.afterRoot(o)
                    }))).then((function () {
                        t(o)
                    }))
                })).catch(e)
            }
            _markDefs() {
                const t = this.json.nodes || [],
                    e = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n].joints;
                    for (let e = 0, n = r.length; e < n; e++) t[r[e]].isBone = !0
                }
                for (let e = 0, r = t.length; e < r; e++) {
                    const r = t[e];
                    void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera)
                }
            }
            _addNodeRef(t, e) {
                void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
            }
            _getNodeRef(t, e, n) {
                if (t.refs[e] <= 1) return n;
                const r = n.clone(),
                    i = (t, e) => {
                        const n = this.associations.get(t);
                        null != n && this.associations.set(e, n);
                        for (const [n, r] of t.children.entries()) i(r, e.children[n])
                    };
                return i(n, r), r.name += "_instance_" + t.uses[e]++, r
            }
            _invokeOne(t) {
                const e = Object.values(this.plugins);
                e.push(this);
                for (let n = 0; n < e.length; n++) {
                    const r = t(e[n]);
                    if (r) return r
                }
                return null
            }
            _invokeAll(t) {
                const e = Object.values(this.plugins);
                e.unshift(this);
                const n = [];
                for (let r = 0; r < e.length; r++) {
                    const i = t(e[r]);
                    i && n.push(i)
                }
                return n
            }
            getDependency(t, e) {
                const n = t + ":" + e;
                let r = this.cache.get(n);
                if (!r) {
                    switch (t) {
                        case "scene":
                            r = this.loadScene(e);
                            break;
                        case "node":
                            r = this._invokeOne((function (t) {
                                return t.loadNode && t.loadNode(e)
                            }));
                            break;
                        case "mesh":
                            r = this._invokeOne((function (t) {
                                return t.loadMesh && t.loadMesh(e)
                            }));
                            break;
                        case "accessor":
                            r = this.loadAccessor(e);
                            break;
                        case "bufferView":
                            r = this._invokeOne((function (t) {
                                return t.loadBufferView && t.loadBufferView(e)
                            }));
                            break;
                        case "buffer":
                            r = this.loadBuffer(e);
                            break;
                        case "material":
                            r = this._invokeOne((function (t) {
                                return t.loadMaterial && t.loadMaterial(e)
                            }));
                            break;
                        case "texture":
                            r = this._invokeOne((function (t) {
                                return t.loadTexture && t.loadTexture(e)
                            }));
                            break;
                        case "skin":
                            r = this.loadSkin(e);
                            break;
                        case "animation":
                            r = this._invokeOne((function (t) {
                                return t.loadAnimation && t.loadAnimation(e)
                            }));
                            break;
                        case "camera":
                            r = this.loadCamera(e);
                            break;
                        default:
                            if (r = this._invokeOne((function (n) {
                                    return n != this && n.getDependency && n.getDependency(t, e)
                                })), !r) throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(n, r)
                }
                return r
            }
            getDependencies(t) {
                let e = this.cache.get(t);
                if (!e) {
                    const n = this,
                        r = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                    e = Promise.all(r.map((function (e, r) {
                        return n.getDependency(t, r)
                    }))), this.cache.add(t, e)
                }
                return e
            }
            loadBuffer(t) {
                const e = this.json.buffers[t],
                    n = this.fileLoader;
                if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[Bg.KHR_BINARY_GLTF].body);
                const r = this.options;
                return new Promise((function (t, i) {
                    n.load(rp.resolveURL(e.uri, r.path), t, void 0, (function () {
                        i(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                    }))
                }))
            }
            loadBufferView(t) {
                const e = this.json.bufferViews[t];
                return this.getDependency("buffer", e.buffer).then((function (t) {
                    const n = e.byteLength || 0,
                        r = e.byteOffset || 0;
                    return t.slice(r, r + n)
                }))
            }
            loadAccessor(t) {
                const e = this,
                    n = this.json,
                    r = this.json.accessors[t];
                if (void 0 === r.bufferView && void 0 === r.sparse) {
                    const t = lA[r.type],
                        e = oA[r.componentType],
                        n = !0 === r.normalized,
                        i = new e(r.count * t);
                    return Promise.resolve(new Ms(i, t, n))
                }
                const i = [];
                return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then((function (t) {
                    const i = t[0],
                        o = lA[r.type],
                        a = oA[r.componentType],
                        s = a.BYTES_PER_ELEMENT,
                        l = s * o,
                        c = r.byteOffset || 0,
                        u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                        h = !0 === r.normalized;
                    let d, p;
                    if (u && u !== l) {
                        const t = Math.floor(c / u),
                            n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + t + ":" + r.count;
                        let l = e.cache.get(n);
                        l || (d = new a(i, t * u, r.count * u / s), l = new Ah(d, u / s), e.cache.add(n, l)), p = new _h(l, o, c % u / s, h)
                    } else d = null === i ? new a(r.count * o) : new a(i, c, r.count * o), p = new Ms(d, o, h);
                    if (void 0 !== r.sparse) {
                        const e = lA.SCALAR,
                            n = oA[r.sparse.indices.componentType],
                            s = r.sparse.indices.byteOffset || 0,
                            l = r.sparse.values.byteOffset || 0,
                            c = new n(t[1], s, r.sparse.count * e),
                            u = new a(t[2], l, r.sparse.count * o);
                        null !== i && (p = new Ms(p.array.slice(), p.itemSize, p.normalized));
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            if (p.setX(e, u[t * o]), o >= 2 && p.setY(e, u[t * o + 1]), o >= 3 && p.setZ(e, u[t * o + 2]), o >= 4 && p.setW(e, u[t * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }))
            }
            loadTexture(t) {
                const e = this.json,
                    n = this.options,
                    r = e.textures[t].source,
                    i = e.images[r];
                let o = this.textureLoader;
                if (i.uri) {
                    const t = n.manager.getHandler(i.uri);
                    null !== t && (o = t)
                }
                return this.loadTextureImage(t, r, o)
            }
            loadTextureImage(t, e, n) {
                const r = this,
                    i = this.json,
                    o = i.textures[t],
                    a = i.images[e],
                    s = (a.uri || a.bufferView) + ":" + o.sampler;
                if (this.textureCache[s]) return this.textureCache[s];
                const l = this.loadImageSource(e, n).then((function (e) {
                    e.flipY = !1, e.name = o.name || a.name || "", "" === e.name && "string" == typeof a.uri && !1 === a.uri.startsWith("data:image/") && (e.name = a.uri);
                    const n = (i.samplers || {})[o.sampler] || {};
                    return e.magFilter = aA[n.magFilter] || _i, e.minFilter = aA[n.minFilter] || Ei, e.wrapS = sA[n.wrapS] || pi, e.wrapT = sA[n.wrapT] || pi, r.associations.set(e, {
                        textures: t
                    }), e
                })).catch((function () {
                    return null
                }));
                return this.textureCache[s] = l, l
            }
            loadImageSource(t, e) {
                const n = this,
                    r = this.json,
                    i = this.options;
                if (void 0 !== this.sourceCache[t]) return this.sourceCache[t].then((t => t.clone()));
                const o = r.images[t],
                    a = self.URL || self.webkitURL;
                let s = o.uri || "",
                    l = !1;
                if (void 0 !== o.bufferView) s = n.getDependency("bufferView", o.bufferView).then((function (t) {
                    l = !0;
                    const e = new Blob([t], {
                        type: o.mimeType
                    });
                    return s = a.createObjectURL(e), s
                }));
                else if (void 0 === o.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                const c = Promise.resolve(s).then((function (t) {
                    return new Promise((function (n, r) {
                        let o = n;
                        !0 === e.isImageBitmapLoader && (o = function (t) {
                            const e = new Wo(t);
                            e.needsUpdate = !0, n(e)
                        }), e.load(rp.resolveURL(t, i.path), o, void 0, r)
                    }))
                })).then((function (t) {
                    var e;
                    return !0 === l && a.revokeObjectURL(s), t.userData.mimeType = o.mimeType || ((e = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), t
                })).catch((function (t) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", s), t
                }));
                return this.sourceCache[t] = c, c
            }
            assignTexture(t, e, n, r) {
                const i = this;
                return this.getDependency("texture", n.index).then((function (o) {
                    if (!o) return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((o = o.clone()).channel = n.texCoord), i.extensions[Bg.KHR_TEXTURE_TRANSFORM]) {
                        const t = void 0 !== n.extensions ? n.extensions[Bg.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (t) {
                            const e = i.associations.get(o);
                            o = i.extensions[Bg.KHR_TEXTURE_TRANSFORM].extendTexture(o, t), i.associations.set(o, e)
                        }
                    }
                    return void 0 !== r && (o.colorSpace = r), t[e] = o, o
                }))
            }
            assignFinalMaterial(t) {
                const e = t.geometry;
                let n = t.material;
                const r = void 0 === e.attributes.tangent,
                    i = void 0 !== e.attributes.color,
                    o = void 0 === e.attributes.normal;
                if (t.isPoints) {
                    const t = "PointsMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new ed, Es.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
                } else if (t.isLine) {
                    const t = "LineBasicMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new zh, Es.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, this.cache.add(t, e)), n = e
                }
                if (r || i || o) {
                    let t = "ClonedMaterial:" + n.uuid + ":";
                    r && (t += "derivative-tangents:"), i && (t += "vertex-colors:"), o && (t += "flat-shading:");
                    let e = this.cache.get(t);
                    e || (e = n.clone(), i && (e.vertexColors = !0), o && (e.flatShading = !0), r && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
                }
                t.material = n
            }
            getMaterialType() {
                return hd
            }
            loadMaterial(t) {
                const e = this,
                    n = this.json,
                    r = this.extensions,
                    i = n.materials[t];
                let o;
                const a = {},
                    s = [];
                if ((i.extensions || {})[Bg.KHR_MATERIALS_UNLIT]) {
                    const t = r[Bg.KHR_MATERIALS_UNLIT];
                    o = t.getMaterialType(), s.push(t.extendParams(a, i, e))
                } else {
                    const n = i.pbrMetallicRoughness || {};
                    if (a.color = new vs(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const t = n.baseColorFactor;
                        a.color.setRGB(t[0], t[1], t[2], Ki), a.opacity = t[3]
                    }
                    void 0 !== n.baseColorTexture && s.push(e.assignTexture(a, "map", n.baseColorTexture, Yi)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (s.push(e.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), s.push(e.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne((function (e) {
                        return e.getMaterialType && e.getMaterialType(t)
                    })), s.push(Promise.all(this._invokeAll((function (e) {
                        return e.extendMaterialParams && e.extendMaterialParams(t, a)
                    }))))
                }!0 === i.doubleSided && (a.side = 2);
                const l = i.alphaMode || dA;
                if (l === fA ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, l === pA && (a.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && o !== xs && (s.push(e.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new Co(1, 1), void 0 !== i.normalTexture.scale)) {
                    const t = i.normalTexture.scale;
                    a.normalScale.set(t, t)
                }
                if (void 0 !== i.occlusionTexture && o !== xs && (s.push(e.assignTexture(a, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (a.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && o !== xs) {
                    const t = i.emissiveFactor;
                    a.emissive = (new vs).setRGB(t[0], t[1], t[2], Ki)
                }
                return void 0 !== i.emissiveTexture && o !== xs && s.push(e.assignTexture(a, "emissiveMap", i.emissiveTexture, Yi)), Promise.all(s).then((function () {
                    const n = new o(a);
                    return i.name && (n.name = i.name), gA(n, i), e.associations.set(n, {
                        materials: t
                    }), i.extensions && mA(r, n, i), n
                }))
            }
            createUniqueName(t) {
                const e = hp.sanitizeNodeName(t || "");
                return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e)
            }
            loadGeometries(t) {
                const e = this,
                    n = this.extensions,
                    r = this.primitiveCache;

                function i(t) {
                    return n[Bg.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function (n) {
                        return bA(n, t, e)
                    }))
                }
                const o = [];
                for (let n = 0, a = t.length; n < a; n++) {
                    const a = t[n],
                        s = vA(a),
                        l = r[s];
                    if (l) o.push(l.promise);
                    else {
                        let t;
                        t = a.extensions && a.extensions[Bg.KHR_DRACO_MESH_COMPRESSION] ? i(a) : bA(new Fs, a, e), r[s] = {
                            primitive: a,
                            promise: t
                        }, o.push(t)
                    }
                }
                return Promise.all(o)
            }
            loadMesh(t) {
                const e = this,
                    n = this.json,
                    r = this.extensions,
                    i = n.meshes[t],
                    o = i.primitives,
                    a = [];
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = void 0 === o[t].material ? (void 0 === (s = this.cache).DefaultMaterial && (s.DefaultMaterial = new hd({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: qr
                    })), s.DefaultMaterial) : this.getDependency("material", o[t].material);
                    a.push(e)
                }
                var s;
                return a.push(e.loadGeometries(o)), Promise.all(a).then((function (n) {
                    const a = n.slice(0, n.length - 1),
                        s = n[n.length - 1],
                        l = [];
                    for (let n = 0, c = s.length; n < c; n++) {
                        const c = s[n],
                            u = o[n];
                        let h;
                        const d = a[n];
                        if (u.mode === iA.TRIANGLES || u.mode === iA.TRIANGLE_STRIP || u.mode === iA.TRIANGLE_FAN || void 0 === u.mode) h = !0 === i.isSkinnedMesh ? new Th(c, d) : new rl(c, d), !0 === h.isSkinnedMesh && h.normalizeSkinWeights(), u.mode === iA.TRIANGLE_STRIP ? h.geometry = Mg(h.geometry, 1) : u.mode === iA.TRIANGLE_FAN && (h.geometry = Mg(h.geometry, 2));
                        else if (u.mode === iA.LINES) h = new Zh(c, d);
                        else if (u.mode === iA.LINE_STRIP) h = new Yh(c, d);
                        else if (u.mode === iA.LINE_LOOP) h = new td(c, d);
                        else {
                            if (u.mode !== iA.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                            h = new ad(c, d)
                        }
                        Object.keys(h.geometry.morphAttributes).length > 0 && AA(h, i), h.name = e.createUniqueName(i.name || "mesh_" + t), gA(h, i), u.extensions && mA(r, h, u), e.assignFinalMaterial(h), l.push(h)
                    }
                    for (let n = 0, r = l.length; n < r; n++) e.associations.set(l[n], {
                        meshes: t,
                        primitives: n
                    });
                    if (1 === l.length) return i.extensions && mA(r, l[0], i), l[0];
                    const c = new ah;
                    i.extensions && mA(r, c, i), e.associations.set(c, {
                        meshes: t
                    });
                    for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
                    return c
                }))
            }
            loadCamera(t) {
                let e;
                const n = this.json.cameras[t],
                    r = n[n.type];
                if (r) return "perspective" === n.type ? e = new ml(wo.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (e = new Gl(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (e.name = this.createUniqueName(n.name)), gA(e, n), Promise.resolve(e);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(t) {
                const e = this.json.skins[t],
                    n = [];
                for (let t = 0, r = e.joints.length; t < r; t++) n.push(this._loadNodeShallow(e.joints[t]));
                return void 0 !== e.inverseBindMatrices ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function (t) {
                    const n = t.pop(),
                        r = t,
                        i = [],
                        o = [];
                    for (let t = 0, a = r.length; t < a; t++) {
                        const a = r[t];
                        if (a) {
                            i.push(a);
                            const e = new Ta;
                            null !== n && e.fromArray(n.array, 16 * t), o.push(e)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                    }
                    return new Ph(i, o)
                }))
            }
            loadAnimation(t) {
                const e = this.json,
                    n = this,
                    r = e.animations[t],
                    i = r.name ? r.name : "animation_" + t,
                    o = [],
                    a = [],
                    s = [],
                    l = [],
                    c = [];
                for (let t = 0, e = r.channels.length; t < e; t++) {
                    const e = r.channels[t],
                        n = r.samplers[e.sampler],
                        i = e.target,
                        u = i.node,
                        h = void 0 !== r.parameters ? r.parameters[n.input] : n.input,
                        d = void 0 !== r.parameters ? r.parameters[n.output] : n.output;
                    void 0 !== i.node && (o.push(this.getDependency("node", u)), a.push(this.getDependency("accessor", h)), s.push(this.getDependency("accessor", d)), l.push(n), c.push(i))
                }
                return Promise.all([Promise.all(o), Promise.all(a), Promise.all(s), Promise.all(l), Promise.all(c)]).then((function (t) {
                    const e = t[0],
                        r = t[1],
                        o = t[2],
                        a = t[3],
                        s = t[4],
                        l = [];
                    for (let t = 0, i = e.length; t < i; t++) {
                        const i = e[t],
                            c = r[t],
                            u = o[t],
                            h = a[t],
                            d = s[t];
                        if (void 0 === i) continue;
                        i.updateMatrix && i.updateMatrix();
                        const p = n._createAnimationTracks(i, c, u, h, d);
                        if (p)
                            for (let t = 0; t < p.length; t++) l.push(p[t])
                    }
                    return new Bd(i, void 0, l)
                }))
            }
            createNodeMesh(t) {
                const e = this.json,
                    n = this,
                    r = e.nodes[t];
                return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function (t) {
                    const e = n._getNodeRef(n.meshCache, r.mesh, t);
                    return void 0 !== r.weights && e.traverse((function (t) {
                        if (t.isMesh)
                            for (let e = 0, n = r.weights.length; e < n; e++) t.morphTargetInfluences[e] = r.weights[e]
                    })), e
                }))
            }
            loadNode(t) {
                const e = this,
                    n = this.json.nodes[t],
                    r = e._loadNodeShallow(t),
                    i = [],
                    o = n.children || [];
                for (let t = 0, n = o.length; t < n; t++) i.push(e.getDependency("node", o[t]));
                const a = void 0 === n.skin ? Promise.resolve(null) : e.getDependency("skin", n.skin);
                return Promise.all([r, Promise.all(i), a]).then((function (t) {
                    const e = t[0],
                        n = t[1],
                        r = t[2];
                    null !== r && e.traverse((function (t) {
                        t.isSkinnedMesh && t.bind(r, EA)
                    }));
                    for (let t = 0, r = n.length; t < r; t++) e.add(n[t]);
                    return e
                }))
            }
            _loadNodeShallow(t) {
                const e = this.json,
                    n = this.extensions,
                    r = this;
                if (void 0 !== this.nodeCache[t]) return this.nodeCache[t];
                const i = e.nodes[t],
                    o = i.name ? r.createUniqueName(i.name) : "",
                    a = [],
                    s = r._invokeOne((function (e) {
                        return e.createNodeMesh && e.createNodeMesh(t)
                    }));
                return s && a.push(s), void 0 !== i.camera && a.push(r.getDependency("camera", i.camera).then((function (t) {
                    return r._getNodeRef(r.cameraCache, i.camera, t)
                }))), r._invokeAll((function (e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t)
                })).forEach((function (t) {
                    a.push(t)
                })), this.nodeCache[t] = Promise.all(a).then((function (e) {
                    let a;
                    if (a = !0 === i.isBone ? new Bh : e.length > 1 ? new ah : 1 === e.length ? e[0] : new ns, a !== e[0])
                        for (let t = 0, n = e.length; t < n; t++) a.add(e[t]);
                    if (i.name && (a.userData.name = i.name, a.name = o), gA(a, i), i.extensions && mA(n, a, i), void 0 !== i.matrix) {
                        const t = new Ta;
                        t.fromArray(i.matrix), a.applyMatrix4(t)
                    } else void 0 !== i.translation && a.position.fromArray(i.translation), void 0 !== i.rotation && a.quaternion.fromArray(i.rotation), void 0 !== i.scale && a.scale.fromArray(i.scale);
                    return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = t, a
                })), this.nodeCache[t]
            }
            loadScene(t) {
                const e = this.extensions,
                    n = this.json.scenes[t],
                    r = this,
                    i = new ah;
                n.name && (i.name = r.createUniqueName(n.name)), gA(i, n), n.extensions && mA(e, i, n);
                const o = n.nodes || [],
                    a = [];
                for (let t = 0, e = o.length; t < e; t++) a.push(r.getDependency("node", o[t]));
                return Promise.all(a).then((function (t) {
                    for (let e = 0, n = t.length; e < n; e++) i.add(t[e]);
                    return r.associations = (t => {
                        const e = new Map;
                        for (const [t, n] of r.associations)(t instanceof Es || t instanceof Wo) && e.set(t, n);
                        return t.traverse((t => {
                            const n = r.associations.get(t);
                            null != n && e.set(t, n)
                        })), e
                    })(i), i
                }))
            }
            _createAnimationTracks(t, e, n, r, i) {
                const o = [],
                    a = t.name ? t.name : t.uuid,
                    s = [];
                let l;
                switch (uA[i.path] === uA.weights ? t.traverse((function (t) {
                        t.morphTargetInfluences && s.push(t.name ? t.name : t.uuid)
                    })) : s.push(a), uA[i.path]) {
                    case uA.weights:
                        l = Cd;
                        break;
                    case uA.rotation:
                        l = Id;
                        break;
                    case uA.position:
                    case uA.scale:
                        l = Td;
                        break;
                    default:
                        if (1 === n.itemSize) l = Cd;
                        else l = Td
                }
                const c = void 0 !== r.interpolation ? hA[r.interpolation] : ji,
                    u = this._getArrayFromAccessor(n);
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = new l(s[t] + "." + uA[i.path], e.array, u, c);
                    "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(n), o.push(n)
                }
                return o
            }
            _getArrayFromAccessor(t) {
                let e = t.array;
                if (t.normalized) {
                    const t = yA(e.constructor),
                        n = new Float32Array(e.length);
                    for (let r = 0, i = e.length; r < i; r++) n[r] = e[r] * t;
                    e = n
                }
                return e
            }
            _createCubicSplineTrackInterpolant(t) {
                t.createInterpolant = function (t) {
                    return new(this instanceof Id ? rA : eA)(this.times, this.values, this.getValueSize() / 3, t)
                }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }

        function bA(t, e, n) {
            const r = e.attributes,
                i = [];

            function o(e, r) {
                return n.getDependency("accessor", e).then((function (e) {
                    t.setAttribute(r, e)
                }))
            }
            for (const e in r) {
                const n = cA[e] || e.toLowerCase();
                n in t.attributes || i.push(o(r[e], n))
            }
            if (void 0 !== e.indices && !t.index) {
                const r = n.getDependency("accessor", e.indices).then((function (e) {
                    t.setIndex(e)
                }));
                i.push(r)
            }
            return Uo.workingColorSpace !== Ki && "COLOR_0" in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Uo.workingColorSpace}" not supported.`), gA(t, e),
                function (t, e, n) {
                    const r = e.attributes,
                        i = new na;
                    if (void 0 === r.POSITION) return; {
                        const t = n.json.accessors[r.POSITION],
                            e = t.min,
                            o = t.max;
                        if (void 0 === e || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (i.set(new Zo(e[0], e[1], e[2]), new Zo(o[0], o[1], o[2])), t.normalized) {
                            const e = yA(oA[t.componentType]);
                            i.min.multiplyScalar(e), i.max.multiplyScalar(e)
                        }
                    }
                    const o = e.targets;
                    if (void 0 !== o) {
                        const t = new Zo,
                            e = new Zo;
                        for (let r = 0, i = o.length; r < i; r++) {
                            const i = o[r];
                            if (void 0 !== i.POSITION) {
                                const r = n.json.accessors[i.POSITION],
                                    o = r.min,
                                    a = r.max;
                                if (void 0 !== o && void 0 !== a) {
                                    if (e.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))), e.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))), e.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))), r.normalized) {
                                        const t = yA(oA[r.componentType]);
                                        e.multiplyScalar(t)
                                    }
                                    t.max(e)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        i.expandByVector(t)
                    }
                    t.boundingBox = i;
                    const a = new ya;
                    i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, t.boundingSphere = a
                }(t, e, n), Promise.all(i).then((function () {
                    return void 0 !== e.targets ? function (t, e, n) {
                        let r = !1,
                            i = !1,
                            o = !1;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), void 0 !== n.COLOR_0 && (o = !0), r && i && o) break
                        }
                        if (!r && !i && !o) return Promise.resolve(t);
                        const a = [],
                            s = [],
                            l = [];
                        for (let c = 0, u = e.length; c < u; c++) {
                            const u = e[c];
                            if (r) {
                                const e = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : t.attributes.position;
                                a.push(e)
                            }
                            if (i) {
                                const e = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : t.attributes.normal;
                                s.push(e)
                            }
                            if (o) {
                                const e = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : t.attributes.color;
                                l.push(e)
                            }
                        }
                        return Promise.all([Promise.all(a), Promise.all(s), Promise.all(l)]).then((function (e) {
                            const n = e[0],
                                a = e[1],
                                s = e[2];
                            return r && (t.morphAttributes.position = n), i && (t.morphAttributes.normal = a), o && (t.morphAttributes.color = s), t.morphTargetsRelative = !0, t
                        }))
                    }(t, e.targets, n) : t
                }))
        }
        const wA = new WeakMap;

        function CA() {
            let t, e;

            function n(t, e, n, r, i, o) {
                const a = o.num_components(),
                    s = n.num_points() * a,
                    l = s * i.BYTES_PER_ELEMENT,
                    c = function (t, e) {
                        switch (e) {
                            case Float32Array:
                                return t.DT_FLOAT32;
                            case Int8Array:
                                return t.DT_INT8;
                            case Int16Array:
                                return t.DT_INT16;
                            case Int32Array:
                                return t.DT_INT32;
                            case Uint8Array:
                                return t.DT_UINT8;
                            case Uint16Array:
                                return t.DT_UINT16;
                            case Uint32Array:
                                return t.DT_UINT32
                        }
                    }(t, i),
                    u = t._malloc(l);
                e.GetAttributeDataArrayForAllPoints(n, o, c, l, u);
                const h = new i(t.HEAPF32.buffer, u, s).slice();
                return t._free(u), {
                    name: r,
                    array: h,
                    itemSize: a
                }
            }
            onmessage = function (r) {
                const i = r.data;
                switch (i.type) {
                    case "init":
                        t = i.decoderConfig, e = new Promise((function (e) {
                            t.onModuleLoaded = function (t) {
                                e({
                                    draco: t
                                })
                            }, DracoDecoderModule(t)
                        }));
                        break;
                    case "decode":
                        const r = i.buffer,
                            o = i.taskConfig;
                        e.then((t => {
                            const e = t.draco,
                                a = new e.Decoder;
                            try {
                                const t = function (t, e, r, i) {
                                        const o = i.attributeIDs,
                                            a = i.attributeTypes;
                                        let s, l;
                                        const c = e.GetEncodedGeometryType(r);
                                        if (c === t.TRIANGULAR_MESH) s = new t.Mesh, l = e.DecodeArrayToMesh(r, r.byteLength, s);
                                        else {
                                            if (c !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            s = new t.PointCloud, l = e.DecodeArrayToPointCloud(r, r.byteLength, s)
                                        }
                                        if (!l.ok() || 0 === s.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                        const u = {
                                            index: null,
                                            attributes: []
                                        };
                                        for (const r in o) {
                                            const l = self[a[r]];
                                            let c, h;
                                            if (i.useUniqueIDs) h = o[r], c = e.GetAttributeByUniqueId(s, h);
                                            else {
                                                if (h = e.GetAttributeId(s, t[o[r]]), -1 === h) continue;
                                                c = e.GetAttribute(s, h)
                                            }
                                            const d = n(t, e, s, r, l, c);
                                            "color" === r && (d.vertexColorSpace = i.vertexColorSpace), u.attributes.push(d)
                                        }
                                        c === t.TRIANGULAR_MESH && (u.index = function (t, e, n) {
                                            const r = n.num_faces(),
                                                i = 3 * r,
                                                o = 4 * i,
                                                a = t._malloc(o);
                                            e.GetTrianglesUInt32Array(n, o, a);
                                            const s = new Uint32Array(t.HEAPF32.buffer, a, i).slice();
                                            return t._free(a), {
                                                array: s,
                                                itemSize: 1
                                            }
                                        }(t, e, s));
                                        return t.destroy(s), u
                                    }(e, a, new Int8Array(r), o),
                                    s = t.attributes.map((t => t.array.buffer));
                                t.index && s.push(t.index.array.buffer), self.postMessage({
                                    type: "decode",
                                    id: i.id,
                                    geometry: t
                                }, s)
                            } catch (t) {
                                console.error(t), self.postMessage({
                                    type: "error",
                                    id: i.id,
                                    error: t.message
                                })
                            } finally {
                                e.destroy(a)
                            }
                        }))
                }
            }
        }
        var SA = new class extends Od {
                constructor(t) {
                    super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (t) {
                        return new Pg(t)
                    })), this.register((function (t) {
                        return new Hg(t)
                    })), this.register((function (t) {
                        return new zg(t)
                    })), this.register((function (t) {
                        return new Vg(t)
                    })), this.register((function (t) {
                        return new kg(t)
                    })), this.register((function (t) {
                        return new Ug(t)
                    })), this.register((function (t) {
                        return new Ng(t)
                    })), this.register((function (t) {
                        return new Fg(t)
                    })), this.register((function (t) {
                        return new Dg(t)
                    })), this.register((function (t) {
                        return new Qg(t)
                    })), this.register((function (t) {
                        return new Og(t)
                    })), this.register((function (t) {
                        return new Gg(t)
                    })), this.register((function (t) {
                        return new $g(t)
                    })), this.register((function (t) {
                        return new Rg(t)
                    })), this.register((function (t) {
                        return new Wg(t)
                    })), this.register((function (t) {
                        return new jg(t)
                    }))
                }
                load(t, e, n, r) {
                    const i = this;
                    let o;
                    if ("" !== this.resourcePath) o = this.resourcePath;
                    else if ("" !== this.path) {
                        const e = rp.extractUrlBase(t);
                        o = rp.resolveURL(e, this.path)
                    } else o = rp.extractUrlBase(t);
                    this.manager.itemStart(t);
                    const a = function (e) {
                            r ? r(e) : console.error(e), i.manager.itemError(t), i.manager.itemEnd(t)
                        },
                        s = new Nd(this.manager);
                    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function (n) {
                        try {
                            i.parse(n, o, (function (n) {
                                e(n), i.manager.itemEnd(t)
                            }), a)
                        } catch (t) {
                            a(t)
                        }
                    }), n, a)
                }
                setDRACOLoader(t) {
                    return this.dracoLoader = t, this
                }
                setDDSLoader() {
                    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                }
                setKTX2Loader(t) {
                    return this.ktx2Loader = t, this
                }
                setMeshoptDecoder(t) {
                    return this.meshoptDecoder = t, this
                }
                register(t) {
                    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
                }
                unregister(t) {
                    return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
                }
                parse(t, e, n, r) {
                    let i;
                    const o = {},
                        a = {},
                        s = new TextDecoder;
                    if ("string" == typeof t) i = JSON.parse(t);
                    else if (t instanceof ArrayBuffer) {
                        if (s.decode(new Uint8Array(t, 0, 4)) === Xg) {
                            try {
                                o[Bg.KHR_BINARY_GLTF] = new Kg(t)
                            } catch (t) {
                                return void(r && r(t))
                            }
                            i = JSON.parse(o[Bg.KHR_BINARY_GLTF].content)
                        } else i = JSON.parse(s.decode(t))
                    } else i = t;
                    if (void 0 === i.asset || i.asset.version[0] < 2) return void(r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                    const l = new xA(i, {
                        path: e || this.resourcePath || "",
                        crossOrigin: this.crossOrigin,
                        requestHeader: this.requestHeader,
                        manager: this.manager,
                        ktx2Loader: this.ktx2Loader,
                        meshoptDecoder: this.meshoptDecoder
                    });
                    l.fileLoader.setRequestHeader(this.requestHeader);
                    for (let t = 0; t < this.pluginCallbacks.length; t++) {
                        const e = this.pluginCallbacks[t](l);
                        e.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[e.name] = e, o[e.name] = !0
                    }
                    if (i.extensionsUsed)
                        for (let t = 0; t < i.extensionsUsed.length; ++t) {
                            const e = i.extensionsUsed[t],
                                n = i.extensionsRequired || [];
                            switch (e) {
                                case Bg.KHR_MATERIALS_UNLIT:
                                    o[e] = new Lg;
                                    break;
                                case Bg.KHR_DRACO_MESH_COMPRESSION:
                                    o[e] = new Jg(i, this.dracoLoader);
                                    break;
                                case Bg.KHR_TEXTURE_TRANSFORM:
                                    o[e] = new Zg;
                                    break;
                                case Bg.KHR_MESH_QUANTIZATION:
                                    o[e] = new tA;
                                    break;
                                default:
                                    n.indexOf(e) >= 0 && void 0 === a[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                            }
                        }
                    l.setExtensions(o), l.setPlugins(a), l.parse(n, r)
                }
                parseAsync(t, e) {
                    const n = this;
                    return new Promise((function (r, i) {
                        n.parse(t, e, r, i)
                    }))
                }
            }(rg),
            IA = new class extends Od {
                constructor(t) {
                    super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                        position: "POSITION",
                        normal: "NORMAL",
                        color: "COLOR",
                        uv: "TEX_COORD"
                    }, this.defaultAttributeTypes = {
                        position: "Float32Array",
                        normal: "Float32Array",
                        color: "Float32Array",
                        uv: "Float32Array"
                    }
                }
                setDecoderPath(t) {
                    return this.decoderPath = t, this
                }
                setDecoderConfig(t) {
                    return this.decoderConfig = t, this
                }
                setWorkerLimit(t) {
                    return this.workerLimit = t, this
                }
                load(t, e, n, r) {
                    const i = new Nd(this.manager);
                    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(t, (t => {
                        this.parse(t, e, r)
                    }), n, r)
                }
                parse(t, e, n = (() => {})) {
                    this.decodeDracoFile(t, e, null, null, Yi).catch(n)
                }
                decodeDracoFile(t, e, n, r, i = Ki, o = (() => {})) {
                    const a = {
                        attributeIDs: n || this.defaultAttributeIDs,
                        attributeTypes: r || this.defaultAttributeTypes,
                        useUniqueIDs: !!n,
                        vertexColorSpace: i
                    };
                    return this.decodeGeometry(t, a).then(e).catch(o)
                }
                decodeGeometry(t, e) {
                    const n = JSON.stringify(e);
                    if (wA.has(t)) {
                        const e = wA.get(t);
                        if (e.key === n) return e.promise;
                        if (0 === t.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                    }
                    let r;
                    const i = this.workerNextTaskID++,
                        o = t.byteLength,
                        a = this._getWorker(i, o).then((n => (r = n, new Promise(((n, o) => {
                            r._callbacks[i] = {
                                resolve: n,
                                reject: o
                            }, r.postMessage({
                                type: "decode",
                                id: i,
                                taskConfig: e,
                                buffer: t
                            }, [t])
                        }))))).then((t => this._createGeometry(t.geometry)));
                    return a.catch((() => !0)).then((() => {
                        r && i && this._releaseTask(r, i)
                    })), wA.set(t, {
                        key: n,
                        promise: a
                    }), a
                }
                _createGeometry(t) {
                    const e = new Fs;
                    t.index && e.setIndex(new Ms(t.index.array, 1));
                    for (let n = 0; n < t.attributes.length; n++) {
                        const r = t.attributes[n],
                            i = r.name,
                            o = r.array,
                            a = r.itemSize,
                            s = new Ms(o, a);
                        "color" === i && (this._assignVertexColorSpace(s, r.vertexColorSpace), s.normalized = o instanceof Float32Array == !1), e.setAttribute(i, s)
                    }
                    return e
                }
                _assignVertexColorSpace(t, e) {
                    if (e !== Yi) return;
                    const n = new vs;
                    for (let e = 0, r = t.count; e < r; e++) n.fromBufferAttribute(t, e).convertSRGBToLinear(), t.setXYZ(e, n.r, n.g, n.b)
                }
                _loadLibrary(t, e) {
                    const n = new Nd(this.manager);
                    return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise(((e, r) => {
                        n.load(t, e, void 0, r)
                    }))
                }
                preload() {
                    return this._initDecoder(), this
                }
                _initDecoder() {
                    if (this.decoderPending) return this.decoderPending;
                    const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                        e = [];
                    return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then((e => {
                        const n = e[0];
                        t || (this.decoderConfig.wasmBinary = e[1]);
                        const r = CA.toString(),
                            i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([i]))
                    })), this.decoderPending
                }
                _getWorker(t, e) {
                    return this._initDecoder().then((() => {
                        if (this.workerPool.length < this.workerLimit) {
                            const t = new Worker(this.workerSourceURL);
                            t._callbacks = {}, t._taskCosts = {}, t._taskLoad = 0, t.postMessage({
                                type: "init",
                                decoderConfig: this.decoderConfig
                            }), t.onmessage = function (e) {
                                const n = e.data;
                                switch (n.type) {
                                    case "decode":
                                        t._callbacks[n.id].resolve(n);
                                        break;
                                    case "error":
                                        t._callbacks[n.id].reject(n);
                                        break;
                                    default:
                                        console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                                }
                            }, this.workerPool.push(t)
                        } else this.workerPool.sort((function (t, e) {
                            return t._taskLoad > e._taskLoad ? -1 : 1
                        }));
                        const n = this.workerPool[this.workerPool.length - 1];
                        return n._taskCosts[t] = e, n._taskLoad += e, n
                    }))
                }
                _releaseTask(t, e) {
                    t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e]
                }
                debug() {
                    console.log("Task load: ", this.workerPool.map((t => t._taskLoad)))
                }
                dispose() {
                    for (let t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate();
                    return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
                }
            };

        function MA(t, e) {
            return IA.setDecoderPath("".concat(e, "draco/")), new Promise((function (e, n) {
                SA.load(t, (function (t) {
                    e(t)
                }))
            }))
        }

        function TA(t) {
            return TA = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, TA(t)
        }

        function BA() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            BA = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == TA(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError(TA(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function RA(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function LA(t) {
            return function () {
                var e = this,
                    n = arguments;
                return new Promise((function (r, i) {
                    var o = t.apply(e, n);

                    function a(t) {
                        RA(o, r, i, a, s, "next", t)
                    }

                    function s(t) {
                        RA(o, r, i, a, s, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }

        function DA(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, PA(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function PA(t) {
            var e = function (t, e) {
                if ("object" != TA(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != TA(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == TA(e) ? e : String(e)
        }

        function OA(t, e, n) {
            return e = UA(e),
                function (t, e) {
                    if (e && ("object" === TA(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, kA() ? Reflect.construct(e, [], UA(t).constructor) : e.apply(t, n))
        }

        function kA() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {})))
            } catch (t) {}
            return (kA = function () {
                return !!t
            })()
        }

        function UA(t) {
            return UA = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, UA(t)
        }

        function NA(t, e) {
            return NA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, NA(t, e)
        }
        SA.setDRACOLoader(IA);
        var FA = function (t) {
            function e(t) {
                var n;
                return function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), (n = OA(this, e)).textures = new hg, n.materials = new Ig, n.engine = t, n
            }
            var n;
            return function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && NA(t, e)
            }(e, t), DA(e, [{
                key: "load",
                value: (n = LA(BA().mark((function t(e) {
                    var n, r, i = this;
                    return BA().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return n = function () {
                                    var t = LA(BA().mark((function t(n) {
                                        return BA().wrap((function (t) {
                                            for (;;) switch (t.prev = t.next) {
                                                case 0:
                                                    return t.abrupt("return", Promise.all(n.map(function () {
                                                        var t = LA(BA().mark((function t(n) {
                                                            var r;
                                                            return BA().wrap((function (t) {
                                                                for (;;) switch (t.prev = t.next) {
                                                                    case 0:
                                                                        if (!(n.name === i.engine.assets.initialAsset && !e || e && n.name !== i.engine.assets.initialAsset)) {
                                                                            t.next = 8;
                                                                            break
                                                                        }
                                                                        return r = MA("".concat(cf.paths.models_path, "samara/").concat(n.path), cf.paths.decoders_path), n.modelPromise = r, t.next = 5, r;
                                                                    case 5:
                                                                        return t.t0 = t.sent, t.t1 = n.name, t.abrupt("return", {
                                                                            file: t.t0,
                                                                            name: t.t1
                                                                        });
                                                                    case 8:
                                                                    case "end":
                                                                        return t.stop()
                                                                }
                                                            }), t)
                                                        })));
                                                        return function (e) {
                                                            return t.apply(this, arguments)
                                                        }
                                                    }())));
                                                case 1:
                                                case "end":
                                                    return t.stop()
                                            }
                                        }), t)
                                    })));
                                    return function (e) {
                                        return t.apply(this, arguments)
                                    }
                                }(), t.next = 3, n(cf.models.samara.assetsArray);
                            case 3:
                                r = t.sent, e || r.filter((function (t) {
                                    return void 0 !== t
                                })).forEach((function (t) {
                                    i["".concat(t.name, "_assets")] = [t.file]
                                }));
                            case 5:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                }))), function (t) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setup",
                value: function (t) {
                    var e = this;
                    t && (this.group = new ah, this.group.name = "Scene children", this.add(this.group), this.engine.scene.add(this), this.name = "Scene parent"), t && (this.group.scale.set(cf.models.samara.scale.x, cf.models.samara.scale.y, cf.models.samara.scale.z), this.group.rotation.y = cf.models.samara.rotation);
                    var n = this.getAssets();
                    t || (n = cf.models.samara.assetsArray.filter((function (t) {
                        return t.name !== e.engine.assets.initialAsset
                    })).flatMap((function (t) {
                        return e.getAssets(t.name)
                    })));
                    n || (n = []), n.forEach((function (n) {
                        n && n.scene.traverse((function (n) {
                            if (n instanceof ns && ["1Bedroom", "2Bedroom", "Studio", "2BedroomA", "XL10"].includes(n.name)) {
                                var r = {
                                    "1Bedroom": "onebed",
                                    Studio: "studio",
                                    "2Bedroom": "twobed",
                                    "2BedroomA": "XL 8",
                                    XL10: "XL 10"
                                };
                                r[n.name] && (["2BedroomA", "XL10"].includes(n.name) && (n.rotation.y = .5 * -Math.PI), n.name = r[n.name], n.traverse((function (t) {
                                    t instanceof rl && (t.material && (t.material = t.material.clone(), t.material.name = "".concat(t.material.name, "_").concat(n.name)), e.materials.setupMaterials(t, n.name)), e.materials.setupFurniture(t, n.name)
                                })), n.box = e.computeBoundingBox(n), e.setupShadow(n), e.group.add(n), t && (e.group.box = e.computeBoundingBox(e.group), e.centerModels(e, 0, .05, 0)), n.visible = !1)
                            }
                        }))
                    }))
                }
            }, {
                key: "getAssets",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tf.complectation.value.layout;
                    return this["".concat(t, "_assets")]
                }
            }, {
                key: "setupShadow",
                value: function (t) {
                    var e = {
                            onebed: {
                                width: 1.75,
                                height: 1.75
                            },
                            studio: {
                                width: 1.4,
                                height: 1.4
                            },
                            twobed: {
                                width: 1.922,
                                height: 1.922
                            },
                            "XL 8": {
                                width: 1.75,
                                height: 1.75
                            },
                            "XL 10": {
                                width: 1.755,
                                height: 1.755
                            }
                        } [t.name],
                        n = e.width,
                        r = e.height,
                        i = new Tl(n, r),
                        o = new rl(i, this.materials.shadowMaterial.clone());
                    return o.box = this.computeBoundingBox(o), o.name = "".concat(t.name, "_shadow"), o.visible = !1, o.rotation.set(.5 * -Math.PI, cf.models.samara.rotation, 0), o.scale.set(3, 3, 3), this.add(o), o.position.y = -.51885, "twobed" === t.name && (o.position.x -= .16), ["XL 8", "XL 10"].includes(t.name) && (o.rotation.z = .5 * Math.PI), o
                }
            }, {
                key: "computeBoundingBox",
                value: function (t) {
                    return (new na).setFromObject(t)
                }
            }, {
                key: "centerModels",
                value: function (t, e, n, r) {
                    var i = (new na).setFromObject(t).getCenter(new Zo);
                    t.position.y += this.engine.scene.position.y - i.y + n
                }
            }]), e
        }(ah);

        function QA(t) {
            return new Promise((function (e) {
                return setTimeout(e, t)
            }))
        }

        function $A(t) {
            return $A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, $A(t)
        }

        function GA(t, e, n) {
            return (e = jA(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function HA() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            HA = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == $A(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError($A(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function zA(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function VA(t) {
            return function () {
                var e = this,
                    n = arguments;
                return new Promise((function (r, i) {
                    var o = t.apply(e, n);

                    function a(t) {
                        zA(o, r, i, a, s, "next", t)
                    }

                    function s(t) {
                        zA(o, r, i, a, s, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }

        function WA(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, jA(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function jA(t) {
            var e = function (t, e) {
                if ("object" != $A(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != $A(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == $A(e) ? e : String(e)
        }
        var XA = function () {
                function t(e) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.engine = e
                }
                var e, n, r, i;
                return WA(t, [{
                    key: "testContextLoss",
                    value: (i = VA(HA().mark((function t() {
                        var e, n, r = arguments;
                        return HA().wrap((function (t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    e = r.length > 0 && void 0 !== r[0] ? r[0] : 1, n = 0;
                                case 2:
                                    if (!(n < e)) {
                                        t.next = 10;
                                        break
                                    }
                                    return t.next = 5, QA(3e3);
                                case 5:
                                    this.engine.renderer.forceContextLoss(), n === e - 1 && console.log("All iterations complete");
                                case 7:
                                    n++, t.next = 2;
                                    break;
                                case 10:
                                case "end":
                                    return t.stop()
                            }
                        }), t, this)
                    }))), function () {
                        return i.apply(this, arguments)
                    })
                }, {
                    key: "testDestroy",
                    value: (r = VA(HA().mark((function t() {
                        var e, n, r = arguments;
                        return HA().wrap((function (t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    e = r.length > 0 && void 0 !== r[0] ? r[0] : 1, n = 0;
                                case 2:
                                    if (!(n < e)) {
                                        t.next = 14;
                                        break
                                    }
                                    return t.next = 5, QA(3e3);
                                case 5:
                                    return cf.container.removeChild(this.engine.renderer.domElement), this.engine.destroy(), t.next = 9, QA(3e3);
                                case 9:
                                    this.engine.init(), n === e - 1 && console.log("All iterations complete");
                                case 11:
                                    n++, t.next = 2;
                                    break;
                                case 14:
                                case "end":
                                    return t.stop()
                            }
                        }), t, this)
                    }))), function () {
                        return r.apply(this, arguments)
                    })
                }, {
                    key: "testRandomComplectation",
                    value: (n = VA(HA().mark((function t() {
                        var e, n, r, i = this,
                            o = arguments;
                        return HA().wrap((function (t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    e = o.length > 0 && void 0 !== o[0] ? o[0] : 1, n = HA().mark((function t() {
                                        var n;
                                        return HA().wrap((function (t) {
                                            for (;;) switch (t.prev = t.next) {
                                                case 0:
                                                    return t.next = 2, QA(100);
                                                case 2:
                                                    n = cf.models.samara.complectationVars, Object.keys(n).forEach((function (t) {
                                                        var e = n[t].variants[Math.floor(Math.random() * n[t].variants.length)];
                                                        i.engine.options.setOption(GA({}, t.toLowerCase(), e.name))
                                                    })), r === e - 1 && console.log("All iterations complete");
                                                case 5:
                                                case "end":
                                                    return t.stop()
                                            }
                                        }), t)
                                    })), r = 0;
                                case 3:
                                    if (!(r < e)) {
                                        t.next = 8;
                                        break
                                    }
                                    return t.delegateYield(n(), "t0", 5);
                                case 5:
                                    r++, t.next = 3;
                                    break;
                                case 8:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), function () {
                        return n.apply(this, arguments)
                    })
                }, {
                    key: "testLayoutChange",
                    value: (e = VA(HA().mark((function t() {
                        var e, n, r, i = arguments;
                        return HA().wrap((function (t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    e = i.length > 0 && void 0 !== i[0] ? i[0] : 1, n = 100, r = 0;
                                case 3:
                                    if (!(r < e)) {
                                        t.next = 20;
                                        break
                                    }
                                    return t.next = 6, QA(n);
                                case 6:
                                    return this.engine.options.setOption({
                                        layout: "studio"
                                    }), t.next = 9, QA(n);
                                case 9:
                                    return this.engine.options.setOption({
                                        layout: "onebed"
                                    }), t.next = 12, QA(n);
                                case 12:
                                    return this.engine.options.setOption({
                                        layout: "twobed"
                                    }), t.next = 15, QA(n);
                                case 15:
                                    this.engine.options.setOption({
                                        layout: "XL 8"
                                    }), r === e - 1 && console.log("All iterations complete");
                                case 17:
                                    r++, t.next = 3;
                                    break;
                                case 20:
                                case "end":
                                    return t.stop()
                            }
                        }), t, this)
                    }))), function () {
                        return e.apply(this, arguments)
                    })
                }]), t
            }(),
            qA = function (t) {
                return t && "number" == typeof t.length && "function" != typeof t
            };

        function YA(t) {
            return Ip(null == t ? void 0 : t.then)
        }

        function KA(t) {
            return Ip(t[Vp])
        }

        function JA(t) {
            return Symbol.asyncIterator && Ip(null == t ? void 0 : t[Symbol.asyncIterator])
        }

        function ZA(t) {
            return new TypeError("You provided " + (null !== t && "object" == typeof t ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")
        }
        var tv = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";

        function ev(t) {
            return Ip(null == t ? void 0 : t[tv])
        }

        function nv(t) {
            return Cp(this, arguments, (function () {
                var e, n, r;
                return yp(this, (function (i) {
                    switch (i.label) {
                        case 0:
                            e = t.getReader(), i.label = 1;
                        case 1:
                            i.trys.push([1, , 9, 10]), i.label = 2;
                        case 2:
                            return [4, wp(e.read())];
                        case 3:
                            return n = i.sent(), r = n.value, n.done ? [4, wp(void 0)] : [3, 5];
                        case 4:
                            return [2, i.sent()];
                        case 5:
                            return [4, wp(r)];
                        case 6:
                            return [4, i.sent()];
                        case 7:
                            return i.sent(), [3, 2];
                        case 8:
                            return [3, 10];
                        case 9:
                            return e.releaseLock(), [7];
                        case 10:
                            return [2]
                    }
                }))
            }))
        }

        function rv(t) {
            return Ip(null == t ? void 0 : t.getReader)
        }

        function iv(t) {
            if (t instanceof jp) return t;
            if (null != t) {
                if (KA(t)) return r = t, new jp((function (t) {
                    var e = r[Vp]();
                    if (Ip(e.subscribe)) return e.subscribe(t);
                    throw new TypeError("Provided object does not correctly implement Symbol.observable")
                }));
                if (qA(t)) return n = t, new jp((function (t) {
                    for (var e = 0; e < n.length && !t.closed; e++) t.next(n[e]);
                    t.complete()
                }));
                if (YA(t)) return function (t) {
                    return new jp((function (e) {
                        t.then((function (t) {
                            e.closed || (e.next(t), e.complete())
                        }), (function (t) {
                            return e.error(t)
                        })).then(null, Up)
                    }))
                }(t);
                if (JA(t)) return ov(t);
                if (ev(t)) return e = t, new jp((function (t) {
                    var n, r;
                    try {
                        for (var i = Ep(e), o = i.next(); !o.done; o = i.next()) {
                            var a = o.value;
                            if (t.next(a), t.closed) return
                        }
                    } catch (t) {
                        n = {
                            error: t
                        }
                    } finally {
                        try {
                            o && !o.done && (r = i.return) && r.call(i)
                        } finally {
                            if (n) throw n.error
                        }
                    }
                    t.complete()
                }));
                if (rv(t)) return ov(nv(t))
            }
            var e, n, r;
            throw ZA(t)
        }

        function ov(t) {
            return new jp((function (e) {
                (function (t, e) {
                    var n, r, i, o;
                    return _p(this, void 0, void 0, (function () {
                        var a, s;
                        return yp(this, (function (l) {
                            switch (l.label) {
                                case 0:
                                    l.trys.push([0, 5, 6, 11]), n = Sp(t), l.label = 1;
                                case 1:
                                    return [4, n.next()];
                                case 2:
                                    if ((r = l.sent()).done) return [3, 4];
                                    if (a = r.value, e.next(a), e.closed) return [2];
                                    l.label = 3;
                                case 3:
                                    return [3, 1];
                                case 4:
                                    return [3, 11];
                                case 5:
                                    return s = l.sent(), i = {
                                        error: s
                                    }, [3, 11];
                                case 6:
                                    return l.trys.push([6, , 9, 10]), r && !r.done && (o = n.return) ? [4, o.call(n)] : [3, 8];
                                case 7:
                                    l.sent(), l.label = 8;
                                case 8:
                                    return [3, 10];
                                case 9:
                                    if (i) throw i.error;
                                    return [7];
                                case 10:
                                    return [7];
                                case 11:
                                    return e.complete(), [2]
                            }
                        }))
                    }))
                })(t, e).catch((function (t) {
                    return e.error(t)
                }))
            }))
        }

        function av(t) {
            return function (e) {
                if (function (t) {
                        return Ip(null == t ? void 0 : t.lift)
                    }(e)) return e.lift((function (e) {
                    try {
                        return t(e, this)
                    } catch (t) {
                        this.error(t)
                    }
                }));
                throw new TypeError("Unable to lift unknown Observable type")
            }
        }

        function sv(t, e, n, r, i) {
            return new lv(t, e, n, r, i)
        }
        var lv = function (t) {
            function e(e, n, r, i, o, a) {
                var s = t.call(this, e) || this;
                return s.onFinalize = o, s.shouldUnsubscribe = a, s._next = n ? function (t) {
                    try {
                        n(t)
                    } catch (t) {
                        e.error(t)
                    }
                } : t.prototype._next, s._error = i ? function (t) {
                    try {
                        i(t)
                    } catch (t) {
                        e.error(t)
                    } finally {
                        this.unsubscribe()
                    }
                } : t.prototype._error, s._complete = r ? function () {
                    try {
                        r()
                    } catch (t) {
                        e.error(t)
                    } finally {
                        this.unsubscribe()
                    }
                } : t.prototype._complete, s
            }
            return vp(e, t), e.prototype.unsubscribe = function () {
                var e;
                if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                    var n = this.closed;
                    t.prototype.unsubscribe.call(this), !n && (null === (e = this.onFinalize) || void 0 === e || e.call(this))
                }
            }, e
        }(Qp);

        function cv(t, e) {
            return av((function (n, r) {
                var i = 0;
                n.subscribe(sv(r, (function (n) {
                    r.next(t.call(e, n, i++))
                })))
            }))
        }

        function uv(t, e, n, r, i) {
            void 0 === r && (r = 0), void 0 === i && (i = !1);
            var o = e.schedule((function () {
                n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe()
            }), r);
            if (t.add(o), !i) return o
        }

        function hv(t, e, n) {
            return void 0 === n && (n = 1 / 0), Ip(e) ? hv((function (n, r) {
                return cv((function (t, i) {
                    return e(n, t, r, i)
                }))(iv(t(n, r)))
            }), n) : ("number" == typeof e && (n = e), av((function (e, r) {
                return function (t, e, n, r, i, o, a, s) {
                    var l = [],
                        c = 0,
                        u = 0,
                        h = !1,
                        d = function () {
                            !h || l.length || c || e.complete()
                        },
                        p = function (t) {
                            c++;
                            var i = !1;
                            iv(n(t, u++)).subscribe(sv(e, (function (t) {
                                e.next(t)
                            }), (function () {
                                i = !0
                            }), void 0, (function () {
                                if (i) try {
                                    for (c--; l.length && c < r;) t = void 0, t = l.shift(), a || p(t);
                                    d()
                                } catch (t) {
                                    e.error(t)
                                }
                                var t
                            })))
                        };
                    return t.subscribe(sv(e, (function (t) {
                            return c < r ? p(t) : l.push(t)
                        }), (function () {
                            h = !0, d()
                        }))),
                        function () {}
                }(e, r, t, n)
            })))
        }
        var dv = Array.isArray;

        function pv(t) {
            return cv((function (e) {
                return function (t, e) {
                    return dv(e) ? t.apply(void 0, bp([], xp(e))) : t(e)
                }(t, e)
            }))
        }
        var fv = ["addListener", "removeListener"],
            mv = ["addEventListener", "removeEventListener"],
            gv = ["on", "off"];

        function Av(t, e, n, r) {
            if (Ip(n) && (r = n, n = void 0), r) return Av(t, e, n).pipe(pv(r));
            var i = xp(function (t) {
                    return Ip(t.addEventListener) && Ip(t.removeEventListener)
                }(t) ? mv.map((function (r) {
                    return function (i) {
                        return t[r](e, i, n)
                    }
                })) : function (t) {
                    return Ip(t.addListener) && Ip(t.removeListener)
                }(t) ? fv.map(vv(t, e)) : function (t) {
                    return Ip(t.on) && Ip(t.off)
                }(t) ? gv.map(vv(t, e)) : [], 2),
                o = i[0],
                a = i[1];
            if (!o && qA(t)) return hv((function (t) {
                return Av(t, e, n)
            }))(iv(t));
            if (!o) throw new TypeError("Invalid event target");
            return new jp((function (t) {
                var e = function () {
                    for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                    return t.next(1 < e.length ? e : e[0])
                };
                return o(e),
                    function () {
                        return a(e)
                    }
            }))
        }

        function vv(t, e) {
            return function (n) {
                return function (r) {
                    return t[n](e, r)
                }
            }
        }
        var _v = function (t) {
                function e(e, n) {
                    return t.call(this) || this
                }
                return vp(e, t), e.prototype.schedule = function (t, e) {
                    return this
                }, e
            }(Rp),
            yv = function (t, e) {
                for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
                return setInterval.apply(void 0, bp([t, e], xp(n)))
            },
            Ev = function (t) {
                return clearInterval(t)
            },
            xv = function (t) {
                function e(e, n) {
                    var r = t.call(this, e, n) || this;
                    return r.scheduler = e, r.work = n, r.pending = !1, r
                }
                return vp(e, t), e.prototype.schedule = function (t, e) {
                    var n;
                    if (void 0 === e && (e = 0), this.closed) return this;
                    this.state = t;
                    var r = this.id,
                        i = this.scheduler;
                    return null != r && (this.id = this.recycleAsyncId(i, r, e)), this.pending = !0, this.delay = e, this.id = null !== (n = this.id) && void 0 !== n ? n : this.requestAsyncId(i, this.id, e), this
                }, e.prototype.requestAsyncId = function (t, e, n) {
                    return void 0 === n && (n = 0), yv(t.flush.bind(t, this), n)
                }, e.prototype.recycleAsyncId = function (t, e, n) {
                    if (void 0 === n && (n = 0), null != n && this.delay === n && !1 === this.pending) return e;
                    null != e && Ev(e)
                }, e.prototype.execute = function (t, e) {
                    if (this.closed) return new Error("executing a cancelled action");
                    this.pending = !1;
                    var n = this._execute(t, e);
                    if (n) return n;
                    !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
                }, e.prototype._execute = function (t, e) {
                    var n, r = !1;
                    try {
                        this.work(t)
                    } catch (t) {
                        r = !0, n = t || new Error("Scheduled action threw falsy error")
                    }
                    if (r) return this.unsubscribe(), n
                }, e.prototype.unsubscribe = function () {
                    if (!this.closed) {
                        var e = this.id,
                            n = this.scheduler,
                            r = n.actions;
                        this.work = this.state = this.scheduler = null, this.pending = !1, Bp(r, this), null != e && (this.id = this.recycleAsyncId(n, e, null)), this.delay = null, t.prototype.unsubscribe.call(this)
                    }
                }, e
            }(_v),
            bv = function () {
                return Date.now()
            },
            wv = function () {
                function t(e, n) {
                    void 0 === n && (n = t.now), this.schedulerActionCtor = e, this.now = n
                }
                return t.prototype.schedule = function (t, e, n) {
                    return void 0 === e && (e = 0), new this.schedulerActionCtor(this, t).schedule(n, e)
                }, t.now = bv, t
            }(),
            Cv = function (t) {
                function e(e, n) {
                    void 0 === n && (n = wv.now);
                    var r = t.call(this, e, n) || this;
                    return r.actions = [], r._active = !1, r
                }
                return vp(e, t), e.prototype.flush = function (t) {
                    var e = this.actions;
                    if (this._active) e.push(t);
                    else {
                        var n;
                        this._active = !0;
                        do {
                            if (n = t.execute(t.state, t.delay)) break
                        } while (t = e.shift());
                        if (this._active = !1, n) {
                            for (; t = e.shift();) t.unsubscribe();
                            throw n
                        }
                    }
                }, e
            }(wv),
            Sv = new Cv(xv),
            Iv = Sv;

        function Mv(t) {
            return t && Ip(t.schedule)
        }

        function Tv(t, e, n) {
            void 0 === t && (t = 0), void 0 === n && (n = Iv);
            var r = -1;
            return null != e && (Mv(e) ? n = e : r = e), new jp((function (e) {
                var i, o = (i = t) instanceof Date && !isNaN(i) ? +t - n.now() : t;
                o < 0 && (o = 0);
                var a = 0;
                return n.schedule((function () {
                    e.closed || (e.next(a++), 0 <= r ? this.schedule(void 0, r) : e.complete())
                }), o)
            }))
        }

        function Bv(t) {
            return void 0 === t && (t = 1 / 0), hv(Wp, t)
        }
        var Rv = new jp((function (t) {
            return t.complete()
        }));

        function Lv(t) {
            return t[t.length - 1]
        }

        function Dv(t) {
            return Mv(Lv(t)) ? t.pop() : void 0
        }

        function Pv(t, e) {
            return void 0 === e && (e = 0), av((function (n, r) {
                n.subscribe(sv(r, (function (n) {
                    return uv(r, t, (function () {
                        return r.next(n)
                    }), e)
                }), (function () {
                    return uv(r, t, (function () {
                        return r.complete()
                    }), e)
                }), (function (n) {
                    return uv(r, t, (function () {
                        return r.error(n)
                    }), e)
                })))
            }))
        }

        function Ov(t, e) {
            return void 0 === e && (e = 0), av((function (n, r) {
                r.add(t.schedule((function () {
                    return n.subscribe(r)
                }), e))
            }))
        }

        function kv(t, e) {
            if (!t) throw new Error("Iterable cannot be null");
            return new jp((function (n) {
                uv(n, e, (function () {
                    var r = t[Symbol.asyncIterator]();
                    uv(n, e, (function () {
                        r.next().then((function (t) {
                            t.done ? n.complete() : n.next(t.value)
                        }))
                    }), 0, !0)
                }))
            }))
        }

        function Uv(t, e) {
            if (null != t) {
                if (KA(t)) return function (t, e) {
                    return iv(t).pipe(Ov(e), Pv(e))
                }(t, e);
                if (qA(t)) return function (t, e) {
                    return new jp((function (n) {
                        var r = 0;
                        return e.schedule((function () {
                            r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule())
                        }))
                    }))
                }(t, e);
                if (YA(t)) return function (t, e) {
                    return iv(t).pipe(Ov(e), Pv(e))
                }(t, e);
                if (JA(t)) return kv(t, e);
                if (ev(t)) return function (t, e) {
                    return new jp((function (n) {
                        var r;
                        return uv(n, e, (function () {
                                r = t[tv](), uv(n, e, (function () {
                                    var t, e, i;
                                    try {
                                        e = (t = r.next()).value, i = t.done
                                    } catch (t) {
                                        return void n.error(t)
                                    }
                                    i ? n.complete() : n.next(e)
                                }), 0, !0)
                            })),
                            function () {
                                return Ip(null == r ? void 0 : r.return) && r.return()
                            }
                    }))
                }(t, e);
                if (rv(t)) return function (t, e) {
                    return kv(nv(t), e)
                }(t, e)
            }
            throw ZA(t)
        }

        function Nv(t, e) {
            return e ? Uv(t, e) : iv(t)
        }

        function Fv() {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            var n = Dv(t),
                r = function (t, e) {
                    return "number" == typeof Lv(t) ? t.pop() : e
                }(t, 1 / 0),
                i = t;
            return i.length ? 1 === i.length ? iv(i[0]) : Bv(r)(Nv(i, n)) : Rv
        }

        function Qv() {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            return Bv(1)(Nv(t, Dv(t)))
        }

        function $v(t) {
            return cv((function () {
                return t
            }))
        }
        var Gv = n(486),
            Hv = n.n(Gv);

        function zv(t) {
            return zv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, zv(t)
        }

        function Vv(t, e, n) {
            return (e = qv(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Wv(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function (t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return jv(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jv(t, e)
                    }(t)) || e) {
                    n && (t = n);
                    var r = 0,
                        i = function () {};
                    return {
                        s: i,
                        n: function () {
                            return r >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[r++]
                            }
                        },
                        e: function (t) {
                            throw t
                        },
                        f: i
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, a = !0,
                s = !1;
            return {
                s: function () {
                    n = n.call(t)
                },
                n: function () {
                    var t = n.next();
                    return a = t.done, t
                },
                e: function (t) {
                    s = !0, o = t
                },
                f: function () {
                    try {
                        a || null == n.return || n.return()
                    } finally {
                        if (s) throw o
                    }
                }
            }
        }

        function jv(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r
        }

        function Xv(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, qv(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function qv(t) {
            var e = function (t, e) {
                if ("object" != zv(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != zv(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == zv(e) ? e : String(e)
        }
        var Yv = function () {
            function t() {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t)
            }
            return Xv(t, [{
                key: "checkSomeOptionInIncludeAdded",
                value: function (t, e) {
                    var n, r = !1,
                        i = Wv(t.layouts);
                    try {
                        for (i.s(); !(n = i.n()).done;) {
                            var o = n.value;
                            if (this.checkOptionAdded(o, e, !0)) {
                                r = !0;
                                break
                            }
                        }
                    } catch (t) {
                        i.e(t)
                    } finally {
                        i.f()
                    }
                    return r
                }
            }, {
                key: "checkOptionAdded",
                value: function (t, e, n) {
                    return t = Hv().isString(t) && !n ? Vv({}, e.toLowerCase(), t) : Hv().isString(t) && n ? {
                        layout: t
                    } : Vv({}, e.toLowerCase(), t.name), Hv().some([tf.complectation.value], t)
                }
            }, {
                key: "setOption",
                value: function (t) {
                    var e = tf.complectation.value,
                        n = Object.assign(e, t);
                    n.changedValue = Object.keys(t)[0], tf.complectation.next(n)
                }
            }]), t
        }();

        function Kv(t) {
            return Kv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Kv(t)
        }

        function Jv(t) {
            return function (t) {
                if (Array.isArray(t)) return Zv(t)
            }(t) || function (t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
            }(t) || function (t, e) {
                if (!t) return;
                if ("string" == typeof t) return Zv(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Zv(t, e)
            }(t) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Zv(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r
        }

        function t_() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            t_ = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == Kv(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError(Kv(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function e_(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function n_(t) {
            return function () {
                var e = this,
                    n = arguments;
                return new Promise((function (r, i) {
                    var o = t.apply(e, n);

                    function a(t) {
                        e_(o, r, i, a, s, "next", t)
                    }

                    function s(t) {
                        e_(o, r, i, a, s, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }

        function r_(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, i_(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function i_(t) {
            var e = function (t, e) {
                if ("object" != Kv(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != Kv(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == Kv(e) ? e : String(e)
        }
        var o_ = function () {
            function t(e) {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.engine = e, this.initialAsset = tf.complectation.value.layout, this.promises = new Map
            }
            var e, n, r;
            return r_(t, [{
                key: "loadAndSetup",
                value: (r = n_(t_().mark((function t() {
                    var e;
                    return t_().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return e = Promise.all([this.engine.models.load(), this.engine.textures.load()]), t.next = 3, e;
                            case 3:
                                this.engine.models.setup(!0);
                            case 4:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function () {
                    return r.apply(this, arguments)
                })
            }, {
                key: "loadAndSetupRest",
                value: (n = n_(t_().mark((function t() {
                    var e, n = this;
                    return t_().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return e = Promise.all([this.engine.textures.load(!0), this.engine.models.load(!0)]), cf.models.samara.assetsArray.forEach((function (t) {
                                    n.promises.has(t.name) || t.name === n.initialAsset || n.promises.set(t.name, new Promise((function (e) {
                                        Promise.all([t.modelPromise].concat(Jv(t.texturesPromises))).then(function () {
                                            var r = n_(t_().mark((function r(i) {
                                                return t_().wrap((function (r) {
                                                    for (;;) switch (r.prev = r.next) {
                                                        case 0:
                                                            return r.next = 2, t.modelPromise;
                                                        case 2:
                                                            r.t0 = r.sent, n.engine.models["".concat(t.name, "_assets")] = [r.t0], n.engine.models.setup(), e(i);
                                                        case 6:
                                                        case "end":
                                                            return r.stop()
                                                    }
                                                }), r)
                                            })));
                                            return function (t) {
                                                return r.apply(this, arguments)
                                            }
                                        }())
                                    })))
                                })), t.next = 4, e;
                            case 4:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function () {
                    return n.apply(this, arguments)
                })
            }, {
                key: "checkAssetLoadedAndSetupComplete",
                value: (e = n_(t_().mark((function t(e) {
                    var n;
                    return t_().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return tf.modelLoadingIndicator.next({
                                    isLoading: !0,
                                    name: e
                                }), n = this.promises.get(e), t.next = 4, n;
                            case 4:
                                tf.modelLoadingIndicator.next({
                                    isLoading: !1
                                });
                            case 5:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function (t) {
                    return e.apply(this, arguments)
                })
            }]), t
        }();

        function a_(t) {
            return a_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, a_(t)
        }

        function s_() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            s_ = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == a_(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError(a_(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function l_(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function c_(t) {
            return function () {
                var e = this,
                    n = arguments;
                return new Promise((function (r, i) {
                    var o = t.apply(e, n);

                    function a(t) {
                        l_(o, r, i, a, s, "next", t)
                    }

                    function s(t) {
                        l_(o, r, i, a, s, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }

        function u_(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, h_(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function h_(t) {
            var e = function (t, e) {
                if ("object" != a_(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != a_(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == a_(e) ? e : String(e)
        }
        var d_ = function () {
            function t(e) {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), e && nf(e, cf)
            }
            var e, n, r, i;
            return u_(t, [{
                key: "init",
                value: (i = c_(s_().mark((function t(e) {
                    var n = this;
                    return s_().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if (!e && !this.renderer) {
                                    t.next = 9;
                                    break
                                }
                                cf.container.appendChild(this.renderer.domElement), this.cameraControls.initControls(!0), this.onResize(), this.initListeners(), this.addSubs(), this.startRendering(), t.next = 46;
                                break;
                            case 9:
                                return this.textures = new hg, this.options = new Yv, this.render = function (t, e, r) {
                                    return n.animate(t, e, r)
                                }, this.renderer = new mh({
                                    antialias: cf.renderer.defaultRenderer.antialias,
                                    alpha: cf.renderer.defaultRenderer.alpha,
                                    premultipliedAlpha: !0,
                                    preserveDrawingBuffer: !0
                                }), this.renderer.setClearColor(0, 0), this.renderer.setPixelRatio(cf.renderer.pixelRatio), this.renderer.physicallyCorrectLights = !0, this.renderer.outputColorSpace = cf.renderer.outputEncoding, this.renderer.toneMappingExposure = cf.renderer.exposure, this.renderer.toneMapping = cf.renderer.toneMapping, this.scene = new gh, this.camera = new ml(cf.camera.fov, cf.container.clientWidth / cf.container.clientHeight, cf.camera.near, cf.camera.far), this.camera.position.set(cf.camera.initPos.x, cf.camera.initPos.y, cf.camera.initPos.z), this.camera.zoom = cf.controls.thirdPerson.defaultZoom, this.cameraControls = new gm(this), cf.container.appendChild(this.renderer.domElement), this.cameraControls.initControls(), this.ambientLight = new np(16777215, cf.light.intensity), this.scene.add(this.ambientLight), this.models = new FA(this), this.textures.init(this), this.assets = new o_(this), t.next = 33, this.assets.loadAndSetup();
                            case 33:
                                return cf.loadOnDemand.loadingManager.enabled = !1, this.assets.loadAndSetupRest(), this.renderer.compile(this.scene, this.camera), this.CameraGsap = new mf(this), this.initListeners(), this.setupPerspectiveView(), this.onResize(), this.addSubs(), this.startRendering(), t.next = 44, QA(1);
                            case 44:
                                tf.loading.next({
                                    isLoading: !1
                                }), this.tests = new XA(this);
                            case 46:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function (t) {
                    return i.apply(this, arguments)
                })
            }, {
                key: "pauseRendering",
                value: function () {
                    zr.ticker.remove(this.render)
                }
            }, {
                key: "startRendering",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                        e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    zr.ticker.add(this.render, t, e)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.sub.unsubscribe(), this.removeListeners(), this.pauseRendering()
                }
            }, {
                key: "addSubs",
                value: function () {
                    var t = this;
                    this.sub = tf.complectation.subscribe((function (e) {
                        t.onComplectationChange()
                    }));
                    var e, n, r = Av(cf.container, "mousemove"),
                        i = Av(cf.container, "keyup"),
                        o = Av(cf.container, "touchstart"),
                        a = Tv(1e3),
                        s = Tv(5e3);
                    this.sub.add(Fv(i, r, o, tf.renderingStatus).subscribe((function () {
                        t.renderingActive || (t.startRendering(), t.renderingActive = !0)
                    }))), this.sub.add(Fv(i, r, o, tf.renderingStatus).pipe(function () {
                        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
                        var n = Dv(t);
                        return av((function (e, r) {
                            (n ? Qv(t, e, n) : Qv(t, e)).subscribe(r)
                        }))
                    }("initial"), (e = function () {
                        return Fv(a.pipe($v(0)), s.pipe($v(1)))
                    }, av((function (t, r) {
                        var i = null,
                            o = 0,
                            a = !1,
                            s = function () {
                                return a && !i && r.complete()
                            };
                        t.subscribe(sv(r, (function (t) {
                            null == i || i.unsubscribe();
                            var a = 0,
                                l = o++;
                            iv(e(t, l)).subscribe(i = sv(r, (function (e) {
                                return r.next(n ? n(t, e, l, a++) : e)
                            }), (function () {
                                i = null, s()
                            })))
                        }), (function () {
                            a = !0, s()
                        })))
                    })))).subscribe((function (e) {
                        0 === e && t.renderingActive && (t.pauseRendering(), t.renderingActive = !1)
                    })))
                }
            }, {
                key: "initListeners",
                value: function () {
                    var t = this;
                    this.listeners = [{
                        eventTarget: document,
                        eventName: "visibilitychange",
                        eventFunction: function () {
                            return t.onVisibilityChange()
                        }
                    }, {
                        eventTarget: this.renderer.domElement,
                        eventName: "webglcontextlost",
                        eventFunction: function () {
                            return t.onContextLoss()
                        }
                    }, {
                        eventTarget: this.renderer.domElement,
                        eventName: "webglcontextrestored",
                        eventFunction: function () {
                            return t.onContextRestored()
                        }
                    }, {
                        eventTarget: window,
                        eventName: "resize",
                        eventFunction: function () {
                            return t.onResize()
                        }
                    }, {
                        eventTarget: this.controls,
                        eventName: "sleep",
                        eventFunction: function () {
                            return t.onControlsEnd()
                        }
                    }, {
                        eventTarget: this.controls,
                        eventName: "change",
                        eventFunction: function () {
                            return t.onControlsUpdate()
                        }
                    }, {
                        eventTarget: this.controls,
                        eventName: "update",
                        eventFunction: function () {
                            return t.onControlsUpdate()
                        }
                    }, {
                        eventTarget: this.controls,
                        eventName: "end",
                        eventFunction: function () {
                            return t.onControlsEnd()
                        }
                    }], this.listeners.forEach((function (t) {
                        t.eventTarget.addEventListener(t.eventName, t.eventFunction)
                    }))
                }
            }, {
                key: "onControlsUpdate",
                value: function () {
                    tf.renderingStatus.next(!0)
                }
            }, {
                key: "onControlsEnd",
                value: function () {
                    tf.renderingStatus.next(!1)
                }
            }, {
                key: "removeListeners",
                value: function () {
                    this.listeners.forEach((function (t) {
                        t.eventTarget.removeEventListener(t.eventName, t.eventFunction)
                    }))
                }
            }, {
                key: "onVisibilityChange",
                value: function () {
                    "visible" === document.visibilityState ? this.startRendering() : this.pauseRendering()
                }
            }, {
                key: "materialGsap",
                value: function (t, e, n) {
                    var r = {
                        duration: .01,
                        onUpdate: function () {
                            return tf.renderingStatus.next(!0)
                        },
                        onComplete: function () {
                            return tf.renderingStatus.next(!1)
                        }
                    };
                    if ("color" === t.name) {
                        var i = new vs(t.value);
                        r.r = i.r, r.g = i.g, r.b = i.b
                    } else r[t.name] = t.value;
                    var o = [];
                    e && e.length > 0 && e.filter((function (t) {
                        return void 0 !== t
                    })).forEach((function (e) {
                        o.push("color" === t.name ? e.color : e)
                    })), Array.isArray(n) && this.scene.traverse((function (e) {
                        e instanceof rl && e.material && n.includes(e.material.name) && o.push("color" === t.name ? e.material.color : e.material)
                    })), o.length > 0 && zr.timeline().to(o, r)
                }
            }, {
                key: "setupPerspectiveView",
                value: function (t, e) {
                    void 0 !== t && (cf.camera.fov = t), void 0 !== e && (cf.models.samara.modelScaleAspectValue = e);
                    var n = cf.camera.fov / cf.models.samara.modelScaleAspectValue;
                    this.scene.scale.set(3.33 * n, 3.33 * n, 3.33 * n), this.camera.fov = cf.camera.fov, this.camera.updateProjectionMatrix(), this.update()
                }
            }, {
                key: "onResize",
                value: function () {
                    if (cf.container) {
                        var t = cf.container.clientWidth,
                            e = cf.container.clientHeight;
                        this.renderer.setSize(t, e), this.camera.aspect = t / e;
                        var n = t < e ? cf.camera.portraitAspect : cf.camera.landscapeAspect;
                        if (this.camera.aspect > n) this.camera.fov = cf.camera.fov;
                        else {
                            var r = Math.tan(lf.degToRad(cf.camera.fov / 2)) / (this.camera.aspect / n);
                            this.camera.fov = 2 * lf.radToDeg(Math.atan(r))
                        }
                        this.camera.updateProjectionMatrix(), this.update()
                    }
                }
            }, {
                key: "renderOnce",
                value: function () {
                    this.renderer.render(this.scene, this.camera)
                }
            }, {
                key: "onContextLoss",
                value: (r = c_(s_().mark((function t() {
                    return s_().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return tf.errors.next({
                                    isError: !0,
                                    message: "Restoring context, please wait."
                                }), t.next = 3, QA(1);
                            case 3:
                                this.renderer.forceContextRestore();
                            case 4:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function () {
                    return r.apply(this, arguments)
                })
            }, {
                key: "onContextRestored",
                value: (n = c_(s_().mark((function t() {
                    var e, n, r = this;
                    return s_().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return cf.environment.assetsArray.forEach((function (t) {
                                    t.loadedHDRTexture = null
                                })), e = cf.environment.assetsArray.find((function (t) {
                                    return t.isDefault
                                })), t.next = 4, this.textures.loadTexture(e, "pmrem");
                            case 4:
                                this.scene.traverse((function (t) {
                                    t.material && t.material.envMap && (t.material.envMap = r.textures.getHdrTexture(e.name), t.material.envMapIntensity = e.defaultHdrIntensity)
                                })), n = function (t) {
                                    for (var e in t.needsUpdate = !0, t) t[e] && t[e].isTexture && "envMap" !== e && (t[e].needsUpdate = !0)
                                }, this.scene.traverse((function (t) {
                                    if (t.geometry) {
                                        for (var e in t.geometry.attributes) t.geometry.attributes[e].needsUpdate = !0;
                                        t.geometry.index && (t.geometry.index.needsUpdate = !0)
                                    }
                                    t.material && (t.material.length ? t.material.forEach(n) : n(t.material))
                                })), this.update(), tf.errors.next({
                                    isError: !1
                                });
                            case 9:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function () {
                    return n.apply(this, arguments)
                })
            }, {
                key: "getParams",
                value: function () {
                    return cf
                }
            }, {
                key: "getState",
                value: function () {
                    return tf
                }
            }, {
                key: "status",
                value: function () {
                    return tf.loading
                }
            }, {
                key: "update",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .1;
                    zr.timeline().to({
                        val: 0
                    }, {
                        val: 1,
                        duration: t,
                        onStart: function () {
                            return tf.renderingStatus.next(!0)
                        },
                        onUpdate: function () {
                            return tf.renderingStatus.next(!0)
                        },
                        onComplete: function () {
                            return tf.renderingStatus.next(!1)
                        }
                    })
                }
            }, {
                key: "animate",
                value: function (t, e, n) {
                    var r = e / 1e3;
                    this.controls && this.controls.update(r), this.renderer.render(this.scene, this.camera), this.models.materials.transmissiveMaterials.forEach((function (t) {
                        t.time += r
                    })), this.stats && this.stats.update()
                }
            }, {
                key: "setOption",
                value: function (t) {
                    this.options.setOption(t)
                }
            }, {
                key: "onComplectationChange",
                value: (e = c_(s_().mark((function t() {
                    var e, n, r = this;
                    return s_().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if (e = tf.complectation.value, this.models.getAssets(e.layout)) {
                                    t.next = 4;
                                    break
                                }
                                return t.next = 4, this.assets.checkAssetLoadedAndSetupComplete(e.layout);
                            case 4:
                                n = function (t) {
                                    return r.models.materials.allMaterials.get(t)
                                }, cf.models.samara.complectationVars.Support.variants.forEach((function (t) {
                                    t.name === e.support && r.materialGsap({
                                        name: "color",
                                        value: t.hex
                                    }, ["Color_ExteriorSupp_studio", "Color_ExteriorSupp_onebed", "Color_ExteriorSupp_twobed", "Color_ExteriorSupp_XL 8", "Color_ExteriorSupp_XL 10"].map((function (t) {
                                        return n(t)
                                    })))
                                })), cf.models.samara.complectationVars.Color.variants.forEach((function (t) {
                                    t.name !== e.color.name && t.name !== e.color || r.materialGsap({
                                        name: "color",
                                        value: t.hex
                                    }, ["Base Color Material_onebed", "Base Color Material_twobed", "Base Color Material_XL 8", "Base Color Material_XL 10", "Base Color Material_studio", "Color_Exterior_walls_studio", "Color_Exterior_walls_onebed", "Color_Exterior_walls_twobed", "Color_Exterior_walls_XL 8", "Color_Exterior_walls_XL 10", "Color_Exterior_channels_studio", "Color_Exterior_channels_onebed", "Color_Exterior_channels_twobed", "Color_Exterior_channels_XL 8", "Color_Exterior_channels_XL 10", "Metal_details_studio", "Frame_Around_studio", "Frame_Windows_studio", "Metal_details_onebed", "Frame_Around_onebed", "Frame_Windows_onebed", "Metal_details_twobed", "Frame_Around_twobed", "Frame_Windows_twobed", "Metal_details_XL 8", "Frame_Around_XL 8", "Frame_Windows_XL 8", "Metal_details_XL 10", "Frame_Around_XL 10", "Frame_Windows_XL 10"].map((function (t) {
                                        return n(t)
                                    })))
                                })), cf.models.samara.complectationVars.Roof.variants.forEach((function (t) {
                                    t.name !== e.roof.name && t.name !== e.roof || r.materialGsap({
                                        name: "color",
                                        value: t.hex
                                    }, ["Roof Material_onebed", "Roof Material_studio", "Roof Material_twobed", "Roof Material_XL 8", "Roof Material_XL 10"].map((function (t) {
                                        return n(t)
                                    })))
                                })), this.materialGsap({
                                    name: "metalness",
                                    value: "Metallic Silver Roof" === e.roof.name ? 1 : .5
                                }, ["Roof Material_onebed", "Roof Material_studio", "Roof Material_twobed", "Roof Material_XL 8", "Roof Material_XL 10"].map((function (t) {
                                    return n(t)
                                }))), this.materialGsap({
                                    name: "roughness",
                                    value: "Metallic Silver Roof" === e.roof.name ? .4 : .5
                                }, ["Roof Material_onebed", "Roof Material_studio", "Roof Material_twobed", "Roof Material_XL 8", "Roof Material_XL 10"].map((function (t) {
                                    return n(t)
                                }))), this.models.traverse((function (t) {
                                    if ("Tesla" === t.name && (t.visible = "Tesla Powerwall 3" === e.powerwall), ["onebed_shadow", "studio_shadow", "twobed_shadow", "XL 8_shadow", "XL 10_shadow"].includes(t.name)) {
                                        var n = t.name.split("_")[0];
                                        t.visible = n === e.layout
                                    }
                                    if (["twobed", "onebed", "studio", "XL 8", "XL 10"].some((function (e) {
                                            return e === t.name
                                        })) && (t.visible = t.name === e.layout), ["Socket_e_Front_2B", "Socket_e_Front_1B", "Socket_e_Front_S"].includes(t.name) && (t.visible = "double doors" === e.front), ["Socket_e_Left_2B", "Socket_e_Left_1B", "Socket_e_Left_S"].includes(t.name) && (t.visible = "left-doors" === e.left), t.material && ["Color_Exterior_channels_onebed", "Color_Exterior_channels_twobed", "Color_Exterior_channels_studio", "Color_Exterior_channels_XL 8", "Color_Exterior_channels_XL 10"].includes(t.material.name) && (t.visible = "metal" === e.trim), t.material && t.material.name.includes("Metal_details") && (t.material.visible = "metal" === e.trim), "wood" === e.trim && t.material && ["Color_Exterior_walls_studio", "Color_Exterior_walls_onebed", "Color_Exterior_walls_twobed", "Color_Exterior_walls_XL 8", "Color_Exterior_walls_XL 10"].includes(t.material.name) && (t.material.roughness = cf.materials.wood.roughness, t.material.metalness = cf.materials.wood.metalness, t.material.normalMap = r.textures.getTexture("Wood_normal"), t.material.map = null, t.material.map = r.textures.getTexture("Wood_basecolor"), t.material.normalScale = new Co(1, 1)), "metal" === e.trim && t.material && ["Color_Exterior_walls_studio", "Color_Exterior_walls_onebed", "Color_Exterior_walls_twobed", "Color_Exterior_walls_XL 8", "Color_Exterior_walls_XL 10"].includes(t.material.name) && (t.material.roughness = cf.materials.metal.roughness, t.material.metalness = cf.materials.metal.metalness, t.material.normalMap = r.textures.getTexture("Metal_normal"), t.material.map = r.textures.getTexture("Metal_basecolor"), t.material.normalScale = new Co(.7, .7)), ["LWRWR_2BA", "LWRWR_XL10"].includes(t.name) && (t.visible = "window" === e["living room"] && "window" === e["secondary bedroom"]), ["LDRWR_2BA", "LDRWR_XL10"].includes(t.name) && (t.visible = "window" === e["living room"] && "double doors" === e["secondary bedroom"]), ["LWRDR_2BA", "LWRDR_XL10"].includes(t.name) && (t.visible = "double doors" === e["living room"] && "window" === e["secondary bedroom"]), ["LDRDR_Rear_2BA", "LDRDR_Rear_XL10"].includes(t.name) && (t.visible = "double doors" === e["living room"] && "double doors" === e["secondary bedroom"]), t.material && ["Color_Exterior_walls_onebed", "Base Color Material_onebed", "Metal_details_onebed"].includes(t.material.name) && (["solar-half", "solar-full"].includes(e.solar) && "No Powerwall" === e.powerwall && (t.material.aoMap = r.textures.getTexture("exterior_ao_onebed_solar_no_cables")), "no-solar" !== e.solar && "No Powerwall" === e.powerwall || (t.material.aoMap = r.textures.getTexture("exterior_ao_onebed_nosolar"))), t.material && ["Base Color Material_XL 10", "Color_Exterior_walls_XL 10", "Metal_details_XL 10"].includes(t.material.name) && (["solar-half", "solar-full"].includes(e.solar) && "No Powerwall" === e.powerwall && (t.material.aoMap = r.textures.getTexture("AO_XL10_1")), "no-solar" !== e.solar && "No Powerwall" === e.powerwall || (t.material.aoMap = r.textures.getTexture("AO_XL10"))), t.material && ["Base Color Material_XL 8", "Color_Exterior_walls_XL 8", "Metal_details_XL 8"].includes(t.material.name) && (["solar-half", "solar-full"].includes(e.solar) && "No Powerwall" === e.powerwall && (t.material.aoMap = r.textures.getTexture("AO_XL8_1")), "no-solar" !== e.solar && "No Powerwall" === e.powerwall || (t.material.aoMap = r.textures.getTexture("AO_XL8"))), t.material && ["Color_Exterior_walls_twobed", "Base Color Material_twobed", "Metal_details_twobed"].includes(t.material.name) && (["solar-half", "solar-full"].includes(e.solar) && "No Powerwall" === e.powerwall && (t.material.aoMap = r.textures.getTexture("exterior_ao_twobed_solar_no_cables")), "no-solar" !== e.solar && "No Powerwall" === e.powerwall || (t.material.aoMap = r.textures.getTexture("exterior_ao_twobed_nosolar"))), t.material && ["Color_Exterior_walls_studio", "Base Color Material_studio", "Metal_details_studio"].includes(t.material.name) && ("double doors" === e.right && (["solar-half", "solar-full"].includes(e.solar) && "No Powerwall" === e.powerwall && (t.material.aoMap = r.textures.getTexture("exterior_ao_studio_no_cables")), "no-solar" !== e.solar && "No Powerwall" === e.powerwall || (t.material.aoMap = r.textures.getTexture("exterior_ao_studio_nosolar"))), "window" === e.right && (["solar-half", "solar-full"].includes(e.solar) && "No Powerwall" === e.powerwall && (t.material.aoMap = r.textures.getTexture("studio_exterior_ao_stairs_solar_no_cables")), "no-solar" !== e.solar && "No Powerwall" === e.powerwall || (t.material.aoMap = r.textures.getTexture("studio_exterior_ao_stairs_no_solar")))), t.material && "Roof Material_studio" === t.material.name) {
                                        var i;
                                        if ("no-solar" === e.solar) i = "roof_solar_none_ao_studio";
                                        else {
                                            var o = "solar-full" === e.solar ? "full" : "half";
                                            i = "roof_solar_".concat(o, "_ao_studio_no_cables")
                                        }
                                        t.material.aoMap = r.textures.getTexture(i)
                                    }
                                    if (t.material && "Roof Material_onebed" === t.material.name) {
                                        var a;
                                        if ("no-solar" === e.solar) a = "roof_solar_none_ao_onebed";
                                        else {
                                            var s = "solar-full" === e.solar ? "full" : "half";
                                            a = "roof_solar_".concat(s, "_ao_onebed_no_cables")
                                        }
                                        t.material.aoMap = r.textures.getTexture(a)
                                    }
                                    if (t.material && "Roof Material_twobed" === t.material.name) {
                                        var l;
                                        if ("no-solar" === e.solar) l = "roof_solar_none_ao_twobed";
                                        else {
                                            var c = "solar-full" === e.solar ? "full" : "half";
                                            l = "roof_solar_".concat(c, "_ao_twobed_no_cables")
                                        }
                                        t.material.aoMap = r.textures.getTexture(l)
                                    }
                                    t.material && "Roof Material_XL 8" === t.material.name && ("solar-full" === e.solar && (t.material.aoMap = r.textures.getTexture("Roof_2BA_Full")), "solar-half" === e.solar && (t.material.aoMap = r.textures.getTexture("Roof_2BA_One")), "no-solar" === e.solar && (t.material.aoMap = r.textures.getTexture("Roof_2BA_Clear"))), t.material && "Roof Material_XL 10" === t.material.name && ("solar-full" === e.solar && (t.material.aoMap = r.textures.getTexture("XL10-solar-full")), "solar-half" === e.solar && (t.material.aoMap = r.textures.getTexture("XL10-solar-half")), "no-solar" === e.solar && (t.material.aoMap = r.textures.getTexture("XL10-no-solar"))), "studio_shadow" === t.name && ("window" === e.front && "window" === e.left && "double doors" === e.right ? t.material.map = r.textures.getTexture("1_S") : "double doors" === e.front && "window" === e.left && "double doors" === e.right ? t.material.map = r.textures.getTexture("2_S") : "double doors" === e.front && "double doors" === e.left && "double doors" === e.right ? t.material.map = r.textures.getTexture("3_S") : "window" === e.front && "double doors" === e.left && "window" === e.right ? t.material.map = r.textures.getTexture("4_S") : "double doors" === e.front && "window" === e.left && "window" === e.right ? t.material.map = r.textures.getTexture("5_S") : "window" === e.front && "window" === e.left && "double doors" === e.right || "double doors" === e.front && "double doors" === e.left && "window" === e.right ? t.material.map = r.textures.getTexture("6_S") : "window" === e.front && "double doors" === e.left && "double doors" === e.right && (t.material.map = r.textures.getTexture("4_S"))), "onebed_shadow" === t.name && ("window" === e.front && "window" === e.left ? t.material.map = r.textures.getTexture("1_1B") : "double doors" === e.front && "window" === e.left ? t.material.map = r.textures.getTexture("2_1B") : "double doors" === e.left && "double doors" === e.front ? t.material.map = r.textures.getTexture("3_1B") : "double doors" === e.left && "window" === e.front && (t.material.map = r.textures.getTexture("4_1B"))), "twobed_shadow" === t.name && ("window" === e.front && "window" === e.left ? t.material.map = r.textures.getTexture("4_2B") : "double doors" === e.front && "window" === e.left ? t.material.map = r.textures.getTexture("1_2B") : "double doors" === e.left && "double doors" === e.front ? t.material.map = r.textures.getTexture("2_2B") : "double doors" === e.left && "window" === e.front && (t.material.map = r.textures.getTexture("3_2B"))), "XL 8_shadow" === t.name && ("window" === e["primary bedroom"] && ("window" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("1_2BA")), "double doors" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("2_2BA")), "window" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("3_2BA")), "double doors" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("4_2BA"))), "double doors" === e["primary bedroom"] && ("window" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("5_2BA")), "double doors" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("6_2BA")), "window" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("7_2BA")), "double doors" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("8_2BA")))), "XL 10_shadow" === t.name && ("window" === e["primary bedroom"] && ("window" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("3_XL10")), "double doors" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("8_XL10")), "window" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("7_XL10")), "double doors" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("2_XL10"))), "double doors" === e["primary bedroom"] && ("window" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("4_XL10")), "double doors" === e["living room"] && "window" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("5_XL10")), "window" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("6_XL10")), "double doors" === e["living room"] && "double doors" === e["secondary bedroom"] && (t.material.map = r.textures.getTexture("1_XL10")))), ["DoubleDoor_Front_2BA", "DoubleDoor_Left_XL10"].includes(t.name) && (t.visible = "double doors" === e["primary bedroom"]), ["Window_Front_2BA", "Window_Left_XL10_3"].includes(t.name) && (t.visible = "window" === e["primary bedroom"]), ["DoubleDoor_Front_S", "DoubleDoor_Front_1B", "DoubleDoor_Front_2B"].includes(t.name) && (t.visible = "double doors" === e.front), ["Baseline_Front_1B", "Baseline_Front_S", "Baseline_Front_2B"].includes(t.name) && (t.visible = "window" === e.front), ["DoubleDoor_Left_S", "DoubleDoor_Left_1B", "DoubleDoor_Left_2B"].includes(t.name) && (t.visible = "double doors" === e.left), ["Baseline_Left_1B", "Baseline_Left_S", "Baseline_Left_2B"].includes(t.name) && (t.visible = "window" === e.left), ["DoubleDoor_Right_2BA", "DoubleDoor_Right_XL10"].includes(t.name) && (t.visible = "double doors" === e.front), ["Window_Right_2BA", "Window_Right_XL10"].includes(t.name) && (t.visible = "window" === e.front), ["Door_Right_S"].includes(t.name) && (t.visible = "double doors" === e.right), ["Window_Right_S"].includes(t.name) && (t.visible = "window" === e.right), ["Undersructure_Front_S", "Deck_Front_S"].includes(t.name) && (t.visible = "double doors" === e.right), ["SolarPanel_Right_1B", "SolarPanel_Right_S", "SolarPanel_Right_2B"].includes(t.name) && (t.visible = "solar-full" === e.solar), ["SolarPanel_Left_1B", "SolarPanel_Left_S", "SolarPanel_Left_2B"].includes(t.name) && (t.visible = ["solar-half", "solar-full"].includes(e.solar)), ["ElectricalPanel_Conduit_1B", "ElectricalPanel_Conduit_S", "ElectricalPanel_Conduit_2B", "ElectricalPanel_Conduit_2BA", "ElectricalPanel_Conduit_XL10"].includes(t.name) && (t.visible = "no-solar" !== e.solar && "No Powerwall" === e.powerwall), t.material && t.material.aoMap && (t.material.aoMap.channel = 1)
                                })), "front" === e.changedValue && "window" === e.right && "window" === e.front && this.options.setOption({
                                    right: "double doors"
                                }), "right" === e.changedValue && "window" === e.right && "window" === e.front && this.options.setOption({
                                    front: "double doors"
                                }), this.update(1);
                            case 14:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function () {
                    return e.apply(this, arguments)
                })
            }]), t
        }();
        window.exported = {
            CreateScene: d_,
            CameraGsap: mf
        };
        /**
         * @license
         * Copyright 2019 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
        const p_ = window,
            f_ = p_.ShadowRoot && (void 0 === p_.ShadyCSS || p_.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
            m_ = Symbol(),
            g_ = new WeakMap;
        class A_ {
            constructor(t, e, n) {
                if (this._$cssResult$ = !0, n !== m_) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
                this.cssText = t, this.t = e
            }
            get styleSheet() {
                let t = this.o;
                const e = this.t;
                if (f_ && void 0 === t) {
                    const n = void 0 !== e && 1 === e.length;
                    n && (t = g_.get(e)), void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText), n && g_.set(e, t))
                }
                return t
            }
            toString() {
                return this.cssText
            }
        }
        const v_ = (t, ...e) => {
                const n = 1 === t.length ? t[0] : e.reduce(((e, n, r) => e + (t => {
                    if (!0 === t._$cssResult$) return t.cssText;
                    if ("number" == typeof t) return t;
                    throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
                })(n) + t[r + 1]), t[0]);
                return new A_(n, t, m_)
            },
            __ = f_ ? t => t : t => t instanceof CSSStyleSheet ? (t => {
                let e = "";
                for (const n of t.cssRules) e += n.cssText;
                return (t => new A_("string" == typeof t ? t : t + "", void 0, m_))(e)
            })(t) : t
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
        ;
        var y_;
        const E_ = window,
            x_ = E_.trustedTypes,
            b_ = x_ ? x_.emptyScript : "",
            w_ = E_.reactiveElementPolyfillSupport,
            C_ = {
                toAttribute(t, e) {
                    switch (e) {
                        case Boolean:
                            t = t ? b_ : null;
                            break;
                        case Object:
                        case Array:
                            t = null == t ? t : JSON.stringify(t)
                    }
                    return t
                },
                fromAttribute(t, e) {
                    let n = t;
                    switch (e) {
                        case Boolean:
                            n = null !== t;
                            break;
                        case Number:
                            n = null === t ? null : Number(t);
                            break;
                        case Object:
                        case Array:
                            try {
                                n = JSON.parse(t)
                            } catch (t) {
                                n = null
                            }
                    }
                    return n
                }
            },
            S_ = (t, e) => e !== t && (e == e || t == t),
            I_ = {
                attribute: !0,
                type: String,
                converter: C_,
                reflect: !1,
                hasChanged: S_
            },
            M_ = "finalized";
        class T_ extends HTMLElement {
            constructor() {
                super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu()
            }
            static addInitializer(t) {
                var e;
                this.finalize(), (null !== (e = this.h) && void 0 !== e ? e : this.h = []).push(t)
            }
            static get observedAttributes() {
                this.finalize();
                const t = [];
                return this.elementProperties.forEach(((e, n) => {
                    const r = this._$Ep(n, e);
                    void 0 !== r && (this._$Ev.set(r, n), t.push(r))
                })), t
            }
            static createProperty(t, e = I_) {
                if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
                    const n = "symbol" == typeof t ? Symbol() : "__" + t,
                        r = this.getPropertyDescriptor(t, n, e);
                    void 0 !== r && Object.defineProperty(this.prototype, t, r)
                }
            }
            static getPropertyDescriptor(t, e, n) {
                return {
                    get() {
                        return this[e]
                    },
                    set(r) {
                        const i = this[t];
                        this[e] = r, this.requestUpdate(t, i, n)
                    },
                    configurable: !0,
                    enumerable: !0
                }
            }
            static getPropertyOptions(t) {
                return this.elementProperties.get(t) || I_
            }
            static finalize() {
                if (this.hasOwnProperty(M_)) return !1;
                this[M_] = !0;
                const t = Object.getPrototypeOf(this);
                if (t.finalize(), void 0 !== t.h && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) {
                    const t = this.properties,
                        e = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];
                    for (const n of e) this.createProperty(n, t[n])
                }
                return this.elementStyles = this.finalizeStyles(this.styles), !0
            }
            static finalizeStyles(t) {
                const e = [];
                if (Array.isArray(t)) {
                    const n = new Set(t.flat(1 / 0).reverse());
                    for (const t of n) e.unshift(__(t))
                } else void 0 !== t && e.push(__(t));
                return e
            }
            static _$Ep(t, e) {
                const n = e.attribute;
                return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof t ? t.toLowerCase() : void 0
            }
            _$Eu() {
                var t;
                this._$E_ = new Promise((t => this.enableUpdating = t)), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach((t => t(this)))
            }
            addController(t) {
                var e, n;
                (null !== (e = this._$ES) && void 0 !== e ? e : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (n = t.hostConnected) || void 0 === n || n.call(t))
            }
            removeController(t) {
                var e;
                null === (e = this._$ES) || void 0 === e || e.splice(this._$ES.indexOf(t) >>> 0, 1)
            }
            _$Eg() {
                this.constructor.elementProperties.forEach(((t, e) => {
                    this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e])
                }))
            }
            createRenderRoot() {
                var t;
                const e = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
                return ((t, e) => {
                    f_ ? t.adoptedStyleSheets = e.map((t => t instanceof CSSStyleSheet ? t : t.styleSheet)) : e.forEach((e => {
                        const n = document.createElement("style"),
                            r = p_.litNonce;
                        void 0 !== r && n.setAttribute("nonce", r), n.textContent = e.cssText, t.appendChild(n)
                    }))
                })(e, this.constructor.elementStyles), e
            }
            connectedCallback() {
                var t;
                void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach((t => {
                    var e;
                    return null === (e = t.hostConnected) || void 0 === e ? void 0 : e.call(t)
                }))
            }
            enableUpdating(t) {}
            disconnectedCallback() {
                var t;
                null === (t = this._$ES) || void 0 === t || t.forEach((t => {
                    var e;
                    return null === (e = t.hostDisconnected) || void 0 === e ? void 0 : e.call(t)
                }))
            }
            attributeChangedCallback(t, e, n) {
                this._$AK(t, n)
            }
            _$EO(t, e, n = I_) {
                var r;
                const i = this.constructor._$Ep(t, n);
                if (void 0 !== i && !0 === n.reflect) {
                    const o = (void 0 !== (null === (r = n.converter) || void 0 === r ? void 0 : r.toAttribute) ? n.converter : C_).toAttribute(e, n.type);
                    this._$El = t, null == o ? this.removeAttribute(i) : this.setAttribute(i, o), this._$El = null
                }
            }
            _$AK(t, e) {
                var n;
                const r = this.constructor,
                    i = r._$Ev.get(t);
                if (void 0 !== i && this._$El !== i) {
                    const t = r.getPropertyOptions(i),
                        o = "function" == typeof t.converter ? {
                            fromAttribute: t.converter
                        } : void 0 !== (null === (n = t.converter) || void 0 === n ? void 0 : n.fromAttribute) ? t.converter : C_;
                    this._$El = i, this[i] = o.fromAttribute(e, t.type), this._$El = null
                }
            }
            requestUpdate(t, e, n) {
                let r = !0;
                void 0 !== t && (((n = n || this.constructor.getPropertyOptions(t)).hasChanged || S_)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), !0 === n.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t, n))) : r = !1), !this.isUpdatePending && r && (this._$E_ = this._$Ej())
            }
            async _$Ej() {
                this.isUpdatePending = !0;
                try {
                    await this._$E_
                } catch (t) {
                    Promise.reject(t)
                }
                const t = this.scheduleUpdate();
                return null != t && await t, !this.isUpdatePending
            }
            scheduleUpdate() {
                return this.performUpdate()
            }
            performUpdate() {
                var t;
                if (!this.isUpdatePending) return;
                this.hasUpdated, this._$Ei && (this._$Ei.forEach(((t, e) => this[e] = t)), this._$Ei = void 0);
                let e = !1;
                const n = this._$AL;
                try {
                    e = this.shouldUpdate(n), e ? (this.willUpdate(n), null === (t = this._$ES) || void 0 === t || t.forEach((t => {
                        var e;
                        return null === (e = t.hostUpdate) || void 0 === e ? void 0 : e.call(t)
                    })), this.update(n)) : this._$Ek()
                } catch (t) {
                    throw e = !1, this._$Ek(), t
                }
                e && this._$AE(n)
            }
            willUpdate(t) {}
            _$AE(t) {
                var e;
                null === (e = this._$ES) || void 0 === e || e.forEach((t => {
                    var e;
                    return null === (e = t.hostUpdated) || void 0 === e ? void 0 : e.call(t)
                })), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t)
            }
            _$Ek() {
                this._$AL = new Map, this.isUpdatePending = !1
            }
            get updateComplete() {
                return this.getUpdateComplete()
            }
            getUpdateComplete() {
                return this._$E_
            }
            shouldUpdate(t) {
                return !0
            }
            update(t) {
                void 0 !== this._$EC && (this._$EC.forEach(((t, e) => this._$EO(e, this[e], t))), this._$EC = void 0), this._$Ek()
            }
            updated(t) {}
            firstUpdated(t) {}
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
        var B_;
        T_[M_] = !0, T_.elementProperties = new Map, T_.elementStyles = [], T_.shadowRootOptions = {
            mode: "open"
        }, null == w_ || w_({
            ReactiveElement: T_
        }), (null !== (y_ = E_.reactiveElementVersions) && void 0 !== y_ ? y_ : E_.reactiveElementVersions = []).push("1.6.3");
        const R_ = window,
            L_ = R_.trustedTypes,
            D_ = L_ ? L_.createPolicy("lit-html", {
                createHTML: t => t
            }) : void 0,
            P_ = "$lit$",
            O_ = `lit$${(Math.random()+"").slice(9)}$`,
            k_ = "?" + O_,
            U_ = `<${k_}>`,
            N_ = document,
            F_ = () => N_.createComment(""),
            Q_ = t => null === t || "object" != typeof t && "function" != typeof t,
            $_ = Array.isArray,
            G_ = "[ \t\n\f\r]",
            H_ = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
            z_ = /-->/g,
            V_ = />/g,
            W_ = RegExp(`>|${G_}(?:([^\\s"'>=/]+)(${G_}*=${G_}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`, "g"),
            j_ = /'/g,
            X_ = /"/g,
            q_ = /^(?:script|style|textarea|title)$/i,
            Y_ = (ey = 1, (t, ...e) => ({
                _$litType$: ey,
                strings: t,
                values: e
            })),
            K_ = Symbol.for("lit-noChange"),
            J_ = Symbol.for("lit-nothing"),
            Z_ = new WeakMap,
            ty = N_.createTreeWalker(N_, 129, null, !1);
        var ey;

        function ny(t, e) {
            if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
            return void 0 !== D_ ? D_.createHTML(e) : e
        }
        class ry {
            constructor({
                strings: t,
                _$litType$: e
            }, n) {
                let r;
                this.parts = [];
                let i = 0,
                    o = 0;
                const a = t.length - 1,
                    s = this.parts,
                    [l, c] = ((t, e) => {
                        const n = t.length - 1,
                            r = [];
                        let i, o = 2 === e ? "<svg>" : "",
                            a = H_;
                        for (let e = 0; e < n; e++) {
                            const n = t[e];
                            let s, l, c = -1,
                                u = 0;
                            for (; u < n.length && (a.lastIndex = u, l = a.exec(n), null !== l);) u = a.lastIndex, a === H_ ? "!--" === l[1] ? a = z_ : void 0 !== l[1] ? a = V_ : void 0 !== l[2] ? (q_.test(l[2]) && (i = RegExp("</" + l[2], "g")), a = W_) : void 0 !== l[3] && (a = W_) : a === W_ ? ">" === l[0] ? (a = null != i ? i : H_, c = -1) : void 0 === l[1] ? c = -2 : (c = a.lastIndex - l[2].length, s = l[1], a = void 0 === l[3] ? W_ : '"' === l[3] ? X_ : j_) : a === X_ || a === j_ ? a = W_ : a === z_ || a === V_ ? a = H_ : (a = W_, i = void 0);
                            const h = a === W_ && t[e + 1].startsWith("/>") ? " " : "";
                            o += a === H_ ? n + U_ : c >= 0 ? (r.push(s), n.slice(0, c) + P_ + n.slice(c) + O_ + h) : n + O_ + (-2 === c ? (r.push(void 0), e) : h)
                        }
                        return [ny(t, o + (t[n] || "<?>") + (2 === e ? "</svg>" : "")), r]
                    })(t, e);
                if (this.el = ry.createElement(l, n), ty.currentNode = this.el.content, 2 === e) {
                    const t = this.el.content,
                        e = t.firstChild;
                    e.remove(), t.append(...e.childNodes)
                }
                for (; null !== (r = ty.nextNode()) && s.length < a;) {
                    if (1 === r.nodeType) {
                        if (r.hasAttributes()) {
                            const t = [];
                            for (const e of r.getAttributeNames())
                                if (e.endsWith(P_) || e.startsWith(O_)) {
                                    const n = c[o++];
                                    if (t.push(e), void 0 !== n) {
                                        const t = r.getAttribute(n.toLowerCase() + P_).split(O_),
                                            e = /([.?@])?(.*)/.exec(n);
                                        s.push({
                                            type: 1,
                                            index: i,
                                            name: e[2],
                                            strings: t,
                                            ctor: "." === e[1] ? ly : "?" === e[1] ? uy : "@" === e[1] ? hy : sy
                                        })
                                    } else s.push({
                                        type: 6,
                                        index: i
                                    })
                                } for (const e of t) r.removeAttribute(e)
                        }
                        if (q_.test(r.tagName)) {
                            const t = r.textContent.split(O_),
                                e = t.length - 1;
                            if (e > 0) {
                                r.textContent = L_ ? L_.emptyScript : "";
                                for (let n = 0; n < e; n++) r.append(t[n], F_()), ty.nextNode(), s.push({
                                    type: 2,
                                    index: ++i
                                });
                                r.append(t[e], F_())
                            }
                        }
                    } else if (8 === r.nodeType)
                        if (r.data === k_) s.push({
                            type: 2,
                            index: i
                        });
                        else {
                            let t = -1;
                            for (; - 1 !== (t = r.data.indexOf(O_, t + 1));) s.push({
                                type: 7,
                                index: i
                            }), t += O_.length - 1
                        } i++
                }
            }
            static createElement(t, e) {
                const n = N_.createElement("template");
                return n.innerHTML = t, n
            }
        }

        function iy(t, e, n = t, r) {
            var i, o, a, s;
            if (e === K_) return e;
            let l = void 0 !== r ? null === (i = n._$Co) || void 0 === i ? void 0 : i[r] : n._$Cl;
            const c = Q_(e) ? void 0 : e._$litDirective$;
            return (null == l ? void 0 : l.constructor) !== c && (null === (o = null == l ? void 0 : l._$AO) || void 0 === o || o.call(l, !1), void 0 === c ? l = void 0 : (l = new c(t), l._$AT(t, n, r)), void 0 !== r ? (null !== (a = (s = n)._$Co) && void 0 !== a ? a : s._$Co = [])[r] = l : n._$Cl = l), void 0 !== l && (e = iy(t, l._$AS(t, e.values), l, r)), e
        }
        class oy {
            constructor(t, e) {
                this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e
            }
            get parentNode() {
                return this._$AM.parentNode
            }
            get _$AU() {
                return this._$AM._$AU
            }
            u(t) {
                var e;
                const {
                    el: {
                        content: n
                    },
                    parts: r
                } = this._$AD, i = (null !== (e = null == t ? void 0 : t.creationScope) && void 0 !== e ? e : N_).importNode(n, !0);
                ty.currentNode = i;
                let o = ty.nextNode(),
                    a = 0,
                    s = 0,
                    l = r[0];
                for (; void 0 !== l;) {
                    if (a === l.index) {
                        let e;
                        2 === l.type ? e = new ay(o, o.nextSibling, this, t) : 1 === l.type ? e = new l.ctor(o, l.name, l.strings, this, t) : 6 === l.type && (e = new dy(o, this, t)), this._$AV.push(e), l = r[++s]
                    }
                    a !== (null == l ? void 0 : l.index) && (o = ty.nextNode(), a++)
                }
                return ty.currentNode = N_, i
            }
            v(t) {
                let e = 0;
                for (const n of this._$AV) void 0 !== n && (void 0 !== n.strings ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++
            }
        }
        class ay {
            constructor(t, e, n, r) {
                var i;
                this.type = 2, this._$AH = J_, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = r, this._$Cp = null === (i = null == r ? void 0 : r.isConnected) || void 0 === i || i
            }
            get _$AU() {
                var t, e;
                return null !== (e = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== e ? e : this._$Cp
            }
            get parentNode() {
                let t = this._$AA.parentNode;
                const e = this._$AM;
                return void 0 !== e && 11 === (null == t ? void 0 : t.nodeType) && (t = e.parentNode), t
            }
            get startNode() {
                return this._$AA
            }
            get endNode() {
                return this._$AB
            }
            _$AI(t, e = this) {
                t = iy(this, t, e), Q_(t) ? t === J_ || null == t || "" === t ? (this._$AH !== J_ && this._$AR(), this._$AH = J_) : t !== this._$AH && t !== K_ && this._(t) : void 0 !== t._$litType$ ? this.g(t) : void 0 !== t.nodeType ? this.$(t) : (t => $_(t) || "function" == typeof (null == t ? void 0 : t[Symbol.iterator]))(t) ? this.T(t) : this._(t)
            }
            k(t) {
                return this._$AA.parentNode.insertBefore(t, this._$AB)
            }
            $(t) {
                this._$AH !== t && (this._$AR(), this._$AH = this.k(t))
            }
            _(t) {
                this._$AH !== J_ && Q_(this._$AH) ? this._$AA.nextSibling.data = t : this.$(N_.createTextNode(t)), this._$AH = t
            }
            g(t) {
                var e;
                const {
                    values: n,
                    _$litType$: r
                } = t, i = "number" == typeof r ? this._$AC(t) : (void 0 === r.el && (r.el = ry.createElement(ny(r.h, r.h[0]), this.options)), r);
                if ((null === (e = this._$AH) || void 0 === e ? void 0 : e._$AD) === i) this._$AH.v(n);
                else {
                    const t = new oy(i, this),
                        e = t.u(this.options);
                    t.v(n), this.$(e), this._$AH = t
                }
            }
            _$AC(t) {
                let e = Z_.get(t.strings);
                return void 0 === e && Z_.set(t.strings, e = new ry(t)), e
            }
            T(t) {
                $_(this._$AH) || (this._$AH = [], this._$AR());
                const e = this._$AH;
                let n, r = 0;
                for (const i of t) r === e.length ? e.push(n = new ay(this.k(F_()), this.k(F_()), this, this.options)) : n = e[r], n._$AI(i), r++;
                r < e.length && (this._$AR(n && n._$AB.nextSibling, r), e.length = r)
            }
            _$AR(t = this._$AA.nextSibling, e) {
                var n;
                for (null === (n = this._$AP) || void 0 === n || n.call(this, !1, !0, e); t && t !== this._$AB;) {
                    const e = t.nextSibling;
                    t.remove(), t = e
                }
            }
            setConnected(t) {
                var e;
                void 0 === this._$AM && (this._$Cp = t, null === (e = this._$AP) || void 0 === e || e.call(this, t))
            }
        }
        class sy {
            constructor(t, e, n, r, i) {
                this.type = 1, this._$AH = J_, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = i, n.length > 2 || "" !== n[0] || "" !== n[1] ? (this._$AH = Array(n.length - 1).fill(new String), this.strings = n) : this._$AH = J_
            }
            get tagName() {
                return this.element.tagName
            }
            get _$AU() {
                return this._$AM._$AU
            }
            _$AI(t, e = this, n, r) {
                const i = this.strings;
                let o = !1;
                if (void 0 === i) t = iy(this, t, e, 0), o = !Q_(t) || t !== this._$AH && t !== K_, o && (this._$AH = t);
                else {
                    const r = t;
                    let a, s;
                    for (t = i[0], a = 0; a < i.length - 1; a++) s = iy(this, r[n + a], e, a), s === K_ && (s = this._$AH[a]), o || (o = !Q_(s) || s !== this._$AH[a]), s === J_ ? t = J_ : t !== J_ && (t += (null != s ? s : "") + i[a + 1]), this._$AH[a] = s
                }
                o && !r && this.j(t)
            }
            j(t) {
                t === J_ ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "")
            }
        }
        class ly extends sy {
            constructor() {
                super(...arguments), this.type = 3
            }
            j(t) {
                this.element[this.name] = t === J_ ? void 0 : t
            }
        }
        const cy = L_ ? L_.emptyScript : "";
        class uy extends sy {
            constructor() {
                super(...arguments), this.type = 4
            }
            j(t) {
                t && t !== J_ ? this.element.setAttribute(this.name, cy) : this.element.removeAttribute(this.name)
            }
        }
        class hy extends sy {
            constructor(t, e, n, r, i) {
                super(t, e, n, r, i), this.type = 5
            }
            _$AI(t, e = this) {
                var n;
                if ((t = null !== (n = iy(this, t, e, 0)) && void 0 !== n ? n : J_) === K_) return;
                const r = this._$AH,
                    i = t === J_ && r !== J_ || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive,
                    o = t !== J_ && (r === J_ || i);
                i && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t
            }
            handleEvent(t) {
                var e, n;
                "function" == typeof this._$AH ? this._$AH.call(null !== (n = null === (e = this.options) || void 0 === e ? void 0 : e.host) && void 0 !== n ? n : this.element, t) : this._$AH.handleEvent(t)
            }
        }
        class dy {
            constructor(t, e, n) {
                this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n
            }
            get _$AU() {
                return this._$AM._$AU
            }
            _$AI(t) {
                iy(this, t)
            }
        }
        const py = R_.litHtmlPolyfillSupport;
        null == py || py(ry, ay), (null !== (B_ = R_.litHtmlVersions) && void 0 !== B_ ? B_ : R_.litHtmlVersions = []).push("2.8.0");
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
        var fy, my;
        class gy extends T_ {
            constructor() {
                super(...arguments), this.renderOptions = {
                    host: this
                }, this._$Do = void 0
            }
            createRenderRoot() {
                var t, e;
                const n = super.createRenderRoot();
                return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = n.firstChild), n
            }
            update(t) {
                const e = this.render();
                this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = ((t, e, n) => {
                    var r, i;
                    const o = null !== (r = null == n ? void 0 : n.renderBefore) && void 0 !== r ? r : e;
                    let a = o._$litPart$;
                    if (void 0 === a) {
                        const t = null !== (i = null == n ? void 0 : n.renderBefore) && void 0 !== i ? i : null;
                        o._$litPart$ = a = new ay(e.insertBefore(F_(), t), t, void 0, null != n ? n : {})
                    }
                    return a._$AI(t), a
                })(e, this.renderRoot, this.renderOptions)
            }
            connectedCallback() {
                var t;
                super.connectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!0)
            }
            disconnectedCallback() {
                var t;
                super.disconnectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!1)
            }
            render() {
                return K_
            }
        }
        gy.finalized = !0, gy._$litElement$ = !0, null === (fy = globalThis.litElementHydrateSupport) || void 0 === fy || fy.call(globalThis, {
            LitElement: gy
        });
        const Ay = globalThis.litElementPolyfillSupport;
        null == Ay || Ay({
            LitElement: gy
        }), (null !== (my = globalThis.litElementVersions) && void 0 !== my ? my : globalThis.litElementVersions = []).push("3.3.3");
        /**
         * @license
         * Copyright 2020 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
        const vy = 2;
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
        class _y {
            constructor(t) {}
            get _$AU() {
                return this._$AM._$AU
            }
            _$AT(t, e, n) {
                this._$Ct = t, this._$AM = e, this._$Ci = n
            }
            _$AS(t, e) {
                return this.update(t, e)
            }
            update(t, e) {
                return this.render(...e)
            }
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
        const yy = (t, e) => {
                var n, r;
                const i = t._$AN;
                if (void 0 === i) return !1;
                for (const t of i) null === (r = (n = t)._$AO) || void 0 === r || r.call(n, e, !1), yy(t, e);
                return !0
            },
            Ey = t => {
                let e, n;
                do {
                    if (void 0 === (e = t._$AM)) break;
                    n = e._$AN, n.delete(t), t = e
                } while (0 === (null == n ? void 0 : n.size))
            },
            xy = t => {
                for (let e; e = t._$AM; t = e) {
                    let n = e._$AN;
                    if (void 0 === n) e._$AN = n = new Set;
                    else if (n.has(t)) break;
                    n.add(t), Cy(e)
                }
            };

        function by(t) {
            void 0 !== this._$AN ? (Ey(this), this._$AM = t, xy(this)) : this._$AM = t
        }

        function wy(t, e = !1, n = 0) {
            const r = this._$AH,
                i = this._$AN;
            if (void 0 !== i && 0 !== i.size)
                if (e)
                    if (Array.isArray(r))
                        for (let t = n; t < r.length; t++) yy(r[t], !1), Ey(r[t]);
                    else null != r && (yy(r, !1), Ey(r));
            else yy(this, t)
        }
        const Cy = t => {
            var e, n, r, i;
            t.type == vy && (null !== (e = (r = t)._$AP) && void 0 !== e || (r._$AP = wy), null !== (n = (i = t)._$AQ) && void 0 !== n || (i._$AQ = by))
        };
        class Sy extends _y {
            constructor() {
                super(...arguments), this._$AN = void 0
            }
            _$AT(t, e, n) {
                super._$AT(t, e, n), xy(this), this.isConnected = t._$AU
            }
            _$AO(t, e = !0) {
                var n, r;
                t !== this.isConnected && (this.isConnected = t, t ? null === (n = this.reconnected) || void 0 === n || n.call(this) : null === (r = this.disconnected) || void 0 === r || r.call(this)), e && (yy(this, t), Ey(this))
            }
            setValue(t) {
                if (void 0 === this._$Ct.strings) this._$Ct._$AI(t, this);
                else {
                    const e = [...this._$Ct._$AH];
                    e[this._$Ci] = t, this._$Ct._$AI(e, this, 0)
                }
            }
            disconnected() {}
            reconnected() {}
        }
        const Iy = new WeakMap,
            My = (t => (...e) => ({
                _$litDirective$: t,
                values: e
            }))(class extends Sy {
                render(t) {
                    return J_
                }
                update(t, [e]) {
                    var n;
                    const r = e !== this.G;
                    return r && void 0 !== this.G && this.ot(void 0), (r || this.rt !== this.lt) && (this.G = e, this.dt = null === (n = t.options) || void 0 === n ? void 0 : n.host, this.ot(this.lt = t.element)), J_
                }
                ot(t) {
                    var e;
                    if ("function" == typeof this.G) {
                        const n = null !== (e = this.dt) && void 0 !== e ? e : globalThis;
                        let r = Iy.get(n);
                        void 0 === r && (r = new WeakMap, Iy.set(n, r)), void 0 !== r.get(this.G) && this.G.call(this.dt, void 0), r.set(this.G, t), void 0 !== t && this.G.call(this.dt, t)
                    } else this.G.value = t
                }
                get rt() {
                    var t, e, n;
                    return "function" == typeof this.G ? null === (e = Iy.get(null !== (t = this.dt) && void 0 !== t ? t : globalThis)) || void 0 === e ? void 0 : e.get(this.G) : null === (n = this.G) || void 0 === n ? void 0 : n.value
                }
                disconnected() {
                    this.rt === this.lt && this.ot(void 0)
                }
                reconnected() {
                    this.ot(this.lt)
                }
            });

        function Ty(t) {
            return Ty = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Ty(t)
        }
        var By, Ry, Ly, Dy, Py;

        function Oy(t, e) {
            return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, {
                raw: {
                    value: Object.freeze(e)
                }
            }))
        }

        function ky(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Uy(r.key), r)
            }
        }

        function Uy(t) {
            var e = function (t, e) {
                if ("object" != Ty(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != Ty(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == Ty(e) ? e : String(e)
        }

        function Ny(t, e, n) {
            return e = $y(e),
                function (t, e) {
                    if (e && ("object" === Ty(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, Fy() ? Reflect.construct(e, [], $y(t).constructor) : e.apply(t, n))
        }

        function Fy() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {})))
            } catch (t) {}
            return (Fy = function () {
                return !!t
            })()
        }

        function Qy() {
            return Qy = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {
                var r = function (t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = $y(t)););
                    return t
                }(t, e);
                if (r) {
                    var i = Object.getOwnPropertyDescriptor(r, e);
                    return i.get ? i.get.call(arguments.length < 3 ? t : n) : i.value
                }
            }, Qy.apply(this, arguments)
        }

        function $y(t) {
            return $y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, $y(t)
        }

        function Gy(t, e) {
            return Gy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, Gy(t, e)
        }
        var Hy = function (t) {
            function e() {
                var t;
                return function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), (t = Ny(this, e)).loading = {
                    isLoading: !0,
                    percent: null
                }, t.errors = {
                    isError: !1,
                    message: null
                }, t
            }
            var n, r, i;
            return function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && Gy(t, e)
            }(e, t), n = e, i = [{
                key: "styles",
                get: function () {
                    return v_(Py || (Py = Oy(["\n      :host {\n        width: 100%;\n        height: 100%;\n        display: block;\n        -webkit-tap-highlight-color: rgba(255, 255, 255, 0) !important;\n        -webkit-focus-ring-color: rgba(255, 255, 255, 0) !important;\n        outline: none !important;\n        box-sizing: border-box;\n        --white: rgb(255, 255, 255);\n        --black: rgb(0, 0, 0);\n        --transparent: rgba(0, 0, 0, 0);\n        --samara-primary: #000000;\n        --samara-secondary: #e0ded4;\n        --progress-bar-size: 15em;\n        --grey5: rgba(169, 169, 169, 0.5);\n      }\n\n      .loading-overlay,\n      .errors-overlay {\n        width: 100%;\n        height: 100%;\n        z-index: 2;\n        background-color: var(--samara-bgcolor);\n        justify-content: center;\n        align-items: center;\n        display: flex;\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n\n      .loading-overlay {\n        flex-direction: column;\n      }\n\n      .errors-overlay {\n        z-index: 3;\n      }\n\n      .progress-bar {\n        height: 0.55em;\n        width: 0;\n        max-width: var(--progress-bar-size);\n        background: var(--samara-primary);\n        border-radius: 2em;\n        position: absolute;\n        bottom: 0;\n      }\n\n      .progress-bar-wrapper {\n        width: var(--progress-bar-size);\n        height: 0.55em;\n        margin-top: 2.5em;\n        margin-bottom: 2.5em;\n        position: relative;\n      }\n\n      .progress-bar-wrapper:before {\n        content: '';\n        width: 100%;\n        height: 100%;\n        background-color: var(--grey5);\n        border-radius: 2em;\n        position: absolute;\n      }\n\n      .scene {\n        width: 100%;\n        height: 100%;\n        background-color: var(--samara-bgcolor);\n        display: flex;\n        position: relative;\n      }\n\n      .scene-wrapper {\n        height: 100%;\n        width: 100%;\n        outline: none;\n        flex-direction: row;\n        justify-content: space-between;\n        display: flex;\n        position: relative;\n        overflow: hidden;\n        font-family: sans-serif;\n      }\n\n      .scene canvas {\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n\n      .icon {\n        overflow: hidden;\n        max-width: 1em;\n        width: 1em;\n        min-width: 1em;\n        height: 1em;\n        max-height: 1em;\n        cursor: pointer;\n        padding: 0.5em;\n        position: relative;\n        border-radius: 50%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n\n        svg {\n          vertical-align: middle;\n          width: 100%;\n          height: 100%;\n        }\n      }\n    "])))
                }
            }, {
                key: "properties",
                get: function () {
                    return {
                        loading: {
                            state: !0
                        },
                        errors: {
                            state: !0
                        },
                        initialState: {}
                    }
                }
            }], (r = [{
                key: "firstUpdated",
                value: function () {}
            }, {
                key: "onRef",
                value: function (t) {
                    cf.container = t
                }
            }, {
                key: "connectedCallback",
                value: function () {
                    var t = this;
                    Qy($y(e.prototype), "connectedCallback", this).call(this);
                    var n = JSON.parse(this.initialState);
                    this.devMode = "on" === n.devMode;
                    var r = {
                        layout: n.layout,
                        color: n.color || cf.models.samara.complectationVars.Color.variants[0].name,
                        roof: n.roof || cf.models.samara.complectationVars.Roof.variants[0].name,
                        front: n.front,
                        left: n.left,
                        right: n.right,
                        solar: n.solar,
                        trim: n.trim || cf.models.samara.complectationVars.Trim.variants[1].name,
                        "primary bedroom": cf.models.samara.complectationVars["Primary bedroom"].variants[1].name,
                        "living room": "window",
                        "secondary bedroom": "double doors",
                        support: "Dark bronze base",
                        powerwall: n.powerwall
                    };
                    tf.complectation = new Jp(r), this.sub = tf.loading.subscribe((function (e) {
                        t.loading = e
                    })), this.sub.add(tf.errors.subscribe((function (e) {
                        t.errors = e
                    })))
                }
            }, {
                key: "disconnectedCallback",
                value: function () {
                    Qy($y(e.prototype), "disconnectedCallback", this).call(this), this.sub.unsubscribe()
                }
            }, {
                key: "render",
                value: function () {
                    return Y_(By || (By = Oy(['\n      <div class="scene-wrapper">\n        <div class="scene" ', "></div>\n\n        ", "\n        ", "\n        ", "\n      </div>\n    "])), My(this.onRef), this.errors.isError ? Y_(Ry || (Ry = Oy(['<div class="errors-overlay">\n              ', '\n              <div class="icon">\n                <svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">\n                  <path\n                    fill="black"\n                    d="M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z"\n                  >\n                    <animateTransform\n                      attributeType="xml"\n                      attributeName="transform"\n                      type="rotate"\n                      from="0 25 25"\n                      to="360 25 25"\n                      dur="1s"\n                      repeatCount="indefinite"\n                    />\n                  </path>\n                </svg>\n              </div>\n            </div>'])), this.errors.message) : J_, this.loading.isLoading && this.devMode ? Y_(Ly || (Ly = Oy(['<div class="loading-overlay">\n              <div class="progress-bar-wrapper">\n                <div\n                  class="progress-bar"\n                  style="width:', '%"\n                ></div>\n              </div>\n            </div>'])), this.loading.percent) : J_, !this.loading.isLoading && this.devMode ? Y_(Dy || (Dy = Oy(["<gui-component></gui-component>"]))) : J_)
                }
            }]) && ky(n.prototype, r), i && ky(n, i), Object.defineProperty(n, "prototype", {
                writable: !1
            }), e
        }(gy);
        customElements.define("samara-scene", Hy);
        var zy = function () {
            var t = 0,
                e = document.createElement("div");

            function n(t) {
                return e.appendChild(t.dom), t
            }

            function r(n) {
                for (var r = 0; r < e.children.length; r++) e.children[r].style.display = r === n ? "block" : "none";
                t = n
            }
            e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", (function (n) {
                n.preventDefault(), r(++t % e.children.length)
            }), !1);
            var i = (performance || Date).now(),
                o = i,
                a = 0,
                s = n(new zy.Panel("FPS", "#0ff", "#002")),
                l = n(new zy.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory) var c = n(new zy.Panel("MB", "#f08", "#201"));
            return r(0), {
                REVISION: 16,
                dom: e,
                addPanel: n,
                showPanel: r,
                begin: function () {
                    i = (performance || Date).now()
                },
                end: function () {
                    a++;
                    var t = (performance || Date).now();
                    if (l.update(t - i, 200), t >= o + 1e3 && (s.update(1e3 * a / (t - o), 100), o = t, a = 0, c)) {
                        var e = performance.memory;
                        c.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576)
                    }
                    return t
                },
                update: function () {
                    i = this.end()
                },
                domElement: e,
                setMode: r
            }
        };
        zy.Panel = function (t, e, n) {
            var r = 1 / 0,
                i = 0,
                o = Math.round,
                a = o(window.devicePixelRatio || 1),
                s = 80 * a,
                l = 48 * a,
                c = 3 * a,
                u = 2 * a,
                h = 3 * a,
                d = 15 * a,
                p = 74 * a,
                f = 30 * a,
                m = document.createElement("canvas");
            m.width = s, m.height = l, m.style.cssText = "width:80px;height:48px";
            var g = m.getContext("2d");
            return g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, s, l), g.fillStyle = e, g.fillText(t, c, u), g.fillRect(h, d, p, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h, d, p, f), {
                dom: m,
                update: function (l, A) {
                    r = Math.min(r, l), i = Math.max(i, l), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, s, d), g.fillStyle = e, g.fillText(o(l) + " " + t + " (" + o(r) + "-" + o(i) + ")", c, u), g.drawImage(m, h + a, d, p - a, f, h, d, p - a, f), g.fillRect(h + p - a, d, a, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h + p - a, d, a, o((1 - l / A) * f))
                }
            }
        };
        const Vy = zy;

        function Wy(t, e) {
            return function (t) {
                if (Array.isArray(t)) return t
            }(t) || function (t, e) {
                var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != n) {
                    var r, i, o, a, s = [],
                        l = !0,
                        c = !1;
                    try {
                        if (o = (n = n.call(t)).next, 0 === e);
                        else
                            for (; !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                    } catch (t) {
                        c = !0, i = t
                    } finally {
                        try {
                            if (!l && null != n.return && (a = n.return(), Object(a) !== a)) return
                        } finally {
                            if (c) throw i
                        }
                    }
                    return s
                }
            }(t, e) || function (t, e) {
                if (!t) return;
                if ("string" == typeof t) return jy(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jy(t, e)
            }(t, e) || function () {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function jy(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r
        }

        function Xy(t, e, n) {
            return e = Yy(e),
                function (t, e) {
                    if (e && ("object" === Zy(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, qy() ? Reflect.construct(e, n || [], Yy(t).constructor) : e.apply(t, n))
        }

        function qy() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {})))
            } catch (t) {}
            return (qy = function () {
                return !!t
            })()
        }

        function Yy(t) {
            return Yy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, Yy(t)
        }

        function Ky(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && Jy(t, e)
        }

        function Jy(t, e) {
            return Jy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, Jy(t, e)
        }

        function Zy(t) {
            return Zy = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Zy(t)
        }

        function tE(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function eE(t, e, n) {
            return e && function (t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, nE(r.key), r)
                }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function nE(t) {
            var e = function (t, e) {
                if ("object" != Zy(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != Zy(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }
            /**
             * lil-gui
             * https://lil-gui.georgealways.com
             * @version 0.16.0
             * @author George Michael Brower
             * @license MIT
             */
            (t, "string");
            return "symbol" == Zy(e) ? e : String(e)
        }
        var rE = function () {
                function t(e, n, r, i) {
                    var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "div";
                    tE(this, t), this.parent = e, this.object = n, this.property = r, this._disabled = !1, this.initialValue = this.getValue(), this.domElement = document.createElement("div"), this.domElement.classList.add("controller"), this.domElement.classList.add(i), this.$name = document.createElement("div"), this.$name.classList.add("name"), t.nextNameID = t.nextNameID || 0, this.$name.id = "lil-gui-name-" + ++t.nextNameID, this.$widget = document.createElement(o), this.$widget.classList.add("widget"), this.$disable = this.$widget, this.domElement.appendChild(this.$name), this.domElement.appendChild(this.$widget), this.parent.children.push(this), this.parent.controllers.push(this), this.parent.$children.appendChild(this.domElement), this._listenCallback = this._listenCallback.bind(this), this.name(r)
                }
                return eE(t, [{
                    key: "name",
                    value: function (t) {
                        return this._name = t, this.$name.innerHTML = t, this
                    }
                }, {
                    key: "onChange",
                    value: function (t) {
                        return this._onChange = t, this
                    }
                }, {
                    key: "_callOnChange",
                    value: function () {
                        this.parent._callOnChange(this), void 0 !== this._onChange && this._onChange.call(this, this.getValue()), this._changed = !0
                    }
                }, {
                    key: "onFinishChange",
                    value: function (t) {
                        return this._onFinishChange = t, this
                    }
                }, {
                    key: "_callOnFinishChange",
                    value: function () {
                        this._changed && (this.parent._callOnFinishChange(this), void 0 !== this._onFinishChange && this._onFinishChange.call(this, this.getValue())), this._changed = !1
                    }
                }, {
                    key: "reset",
                    value: function () {
                        return this.setValue(this.initialValue), this._callOnFinishChange(), this
                    }
                }, {
                    key: "enable",
                    value: function () {
                        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        return this.disable(!t)
                    }
                }, {
                    key: "disable",
                    value: function () {
                        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        return t === this._disabled || (this._disabled = t, this.domElement.classList.toggle("disabled", t), this.$disable.toggleAttribute("disabled", t)), this
                    }
                }, {
                    key: "options",
                    value: function (t) {
                        var e = this.parent.add(this.object, this.property, t);
                        return e.name(this._name), this.destroy(), e
                    }
                }, {
                    key: "min",
                    value: function (t) {
                        return this
                    }
                }, {
                    key: "max",
                    value: function (t) {
                        return this
                    }
                }, {
                    key: "step",
                    value: function (t) {
                        return this
                    }
                }, {
                    key: "listen",
                    value: function () {
                        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        return this._listening = t, void 0 !== this._listenCallbackID && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this
                    }
                }, {
                    key: "_listenCallback",
                    value: function () {
                        this._listenCallbackID = requestAnimationFrame(this._listenCallback), this.updateDisplay()
                    }
                }, {
                    key: "getValue",
                    value: function () {
                        return this.object[this.property]
                    }
                }, {
                    key: "setValue",
                    value: function (t) {
                        return this.object[this.property] = t, this._callOnChange(), this.updateDisplay(), this
                    }
                }, {
                    key: "updateDisplay",
                    value: function () {
                        return this
                    }
                }, {
                    key: "load",
                    value: function (t) {
                        return this.setValue(t), this._callOnFinishChange(), this
                    }
                }, {
                    key: "save",
                    value: function () {
                        return this.getValue()
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1), this.parent.$children.removeChild(this.domElement)
                    }
                }]), t
            }(),
            iE = function (t) {
                function e(t, n, r) {
                    var i;
                    return tE(this, e), (i = Xy(this, e, [t, n, r, "boolean", "label"])).$input = document.createElement("input"), i.$input.setAttribute("type", "checkbox"), i.$input.setAttribute("aria-labelledby", i.$name.id), i.$widget.appendChild(i.$input), i.$input.addEventListener("change", (function () {
                        i.setValue(i.$input.checked), i._callOnFinishChange()
                    })), i.$disable = i.$input, i.updateDisplay(), i
                }
                return Ky(e, t), eE(e, [{
                    key: "updateDisplay",
                    value: function () {
                        return this.$input.checked = this.getValue(), this
                    }
                }]), e
            }(rE);

        function oE(t) {
            var e, n;
            return (e = t.match(/(#|0x)?([a-f0-9]{6})/i)) ? n = e[2] : (e = t.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? n = parseInt(e[1]).toString(16).padStart(2, 0) + parseInt(e[2]).toString(16).padStart(2, 0) + parseInt(e[3]).toString(16).padStart(2, 0) : (e = t.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (n = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), !!n && "#" + n
        }
        var aE, sE, lE, cE, uE, hE, dE, pE = {
                isPrimitive: !0,
                match: function (t) {
                    return "string" == typeof t
                },
                fromHexString: oE,
                toHexString: oE
            },
            fE = {
                isPrimitive: !0,
                match: function (t) {
                    return "number" == typeof t
                },
                fromHexString: function (t) {
                    return parseInt(t.substring(1), 16)
                },
                toHexString: function (t) {
                    return "#" + t.toString(16).padStart(6, 0)
                }
            },
            mE = {
                isPrimitive: !1,
                match: Array.isArray,
                fromHexString: function (t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        r = fE.fromHexString(t);
                    e[0] = (r >> 16 & 255) / 255 * n, e[1] = (r >> 8 & 255) / 255 * n, e[2] = (255 & r) / 255 * n
                },
                toHexString: function (t) {
                    var e = Wy(t, 3),
                        n = e[0],
                        r = e[1],
                        i = e[2],
                        o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    return fE.toHexString(n * (o = 255 / o) << 16 ^ r * o << 8 ^ i * o << 0)
                }
            },
            gE = {
                isPrimitive: !1,
                match: function (t) {
                    return Object(t) === t
                },
                fromHexString: function (t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        r = fE.fromHexString(t);
                    e.r = (r >> 16 & 255) / 255 * n, e.g = (r >> 8 & 255) / 255 * n, e.b = (255 & r) / 255 * n
                },
                toHexString: function (t) {
                    var e = t.r,
                        n = t.g,
                        r = t.b,
                        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    return fE.toHexString(e * (i = 255 / i) << 16 ^ n * i << 8 ^ r * i << 0)
                }
            },
            AE = [pE, fE, mE, gE],
            vE = function (t) {
                function e(t, n, r, i) {
                    var o, a;
                    return tE(this, e), (o = Xy(this, e, [t, n, r, "color"])).$input = document.createElement("input"), o.$input.setAttribute("type", "color"), o.$input.setAttribute("tabindex", -1), o.$input.setAttribute("aria-labelledby", o.$name.id), o.$text = document.createElement("input"), o.$text.setAttribute("type", "text"), o.$text.setAttribute("spellcheck", "false"), o.$text.setAttribute("aria-labelledby", o.$name.id), o.$display = document.createElement("div"), o.$display.classList.add("display"), o.$display.appendChild(o.$input), o.$widget.appendChild(o.$display), o.$widget.appendChild(o.$text), o._format = (a = o.initialValue, AE.find((function (t) {
                        return t.match(a)
                    }))), o._rgbScale = i, o._initialValueHexString = o.save(), o._textFocused = !1, o.$input.addEventListener("input", (function () {
                        o._setValueFromHexString(o.$input.value)
                    })), o.$input.addEventListener("blur", (function () {
                        o._callOnFinishChange()
                    })), o.$text.addEventListener("input", (function () {
                        var t = oE(o.$text.value);
                        t && o._setValueFromHexString(t)
                    })), o.$text.addEventListener("focus", (function () {
                        o._textFocused = !0, o.$text.select()
                    })), o.$text.addEventListener("blur", (function () {
                        o._textFocused = !1, o.updateDisplay(), o._callOnFinishChange()
                    })), o.$disable = o.$text, o.updateDisplay(), o
                }
                return Ky(e, t), eE(e, [{
                    key: "reset",
                    value: function () {
                        return this._setValueFromHexString(this._initialValueHexString), this
                    }
                }, {
                    key: "_setValueFromHexString",
                    value: function (t) {
                        if (this._format.isPrimitive) {
                            var e = this._format.fromHexString(t);
                            this.setValue(e)
                        } else this._format.fromHexString(t, this.getValue(), this._rgbScale), this._callOnChange(), this.updateDisplay()
                    }
                }, {
                    key: "save",
                    value: function () {
                        return this._format.toHexString(this.getValue(), this._rgbScale)
                    }
                }, {
                    key: "load",
                    value: function (t) {
                        return this._setValueFromHexString(t), this._callOnFinishChange(), this
                    }
                }, {
                    key: "updateDisplay",
                    value: function () {
                        return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this
                    }
                }]), e
            }(rE),
            _E = function (t) {
                function e(t, n, r) {
                    var i;
                    return tE(this, e), (i = Xy(this, e, [t, n, r, "function"])).$button = document.createElement("button"), i.$button.appendChild(i.$name), i.$widget.appendChild(i.$button), i.$button.addEventListener("click", (function (t) {
                        t.preventDefault(), i.getValue().call(i.object)
                    })), i.$button.addEventListener("touchstart", (function () {})), i.$disable = i.$button, i
                }
                return Ky(e, t), eE(e)
            }(rE),
            yE = function (t) {
                function e(t, n, r, i, o, a) {
                    var s;
                    tE(this, e), (s = Xy(this, e, [t, n, r, "number"]))._initInput(), s.min(i), s.max(o);
                    var l = void 0 !== a;
                    return s.step(l ? a : s._getImplicitStep(), l), s.updateDisplay(), s
                }
                return Ky(e, t), eE(e, [{
                    key: "min",
                    value: function (t) {
                        return this._min = t, this._onUpdateMinMax(), this
                    }
                }, {
                    key: "max",
                    value: function (t) {
                        return this._max = t, this._onUpdateMinMax(), this
                    }
                }, {
                    key: "step",
                    value: function (t) {
                        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        return this._step = t, this._stepExplicit = e, this
                    }
                }, {
                    key: "updateDisplay",
                    value: function () {
                        var t = this.getValue();
                        if (this._hasSlider) {
                            var e = (t - this._min) / (this._max - this._min);
                            e = Math.max(0, Math.min(e, 1)), this.$fill.style.width = 100 * e + "%"
                        }
                        return this._inputFocused || (this.$input.value = t), this
                    }
                }, {
                    key: "_initInput",
                    value: function () {
                        var t = this;
                        this.$input = document.createElement("input"), this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$disable = this.$input;
                        var e, n, r, i, o, a = function (e) {
                                var n = parseFloat(t.$input.value);
                                isNaN(n) || (t._snapClampSetValue(n + e), t.$input.value = t.getValue())
                            },
                            s = !1,
                            l = function (a) {
                                if (s) {
                                    var l = a.clientX - e,
                                        u = a.clientY - n;
                                    Math.abs(u) > 5 ? (a.preventDefault(), t.$input.blur(), s = !1, t._setDraggingStyle(!0, "vertical")) : Math.abs(l) > 5 && c()
                                }
                                if (!s) {
                                    var h = a.clientY - r;
                                    o -= h * t._step * t._arrowKeyMultiplier(a), i + o > t._max ? o = t._max - i : i + o < t._min && (o = t._min - i), t._snapClampSetValue(i + o)
                                }
                                r = a.clientY
                            },
                            c = function e() {
                                t._setDraggingStyle(!1, "vertical"), t._callOnFinishChange(), window.removeEventListener("mousemove", l), window.removeEventListener("mouseup", e)
                            };
                        this.$input.addEventListener("input", (function () {
                            var e = parseFloat(t.$input.value);
                            isNaN(e) || t.setValue(t._clamp(e))
                        })), this.$input.addEventListener("keydown", (function (e) {
                            "Enter" === e.code && t.$input.blur(), "ArrowUp" === e.code && (e.preventDefault(), a(t._step * t._arrowKeyMultiplier(e))), "ArrowDown" === e.code && (e.preventDefault(), a(t._step * t._arrowKeyMultiplier(e) * -1))
                        })), this.$input.addEventListener("wheel", (function (e) {
                            t._inputFocused && (e.preventDefault(), a(t._step * t._normalizeMouseWheel(e)))
                        })), this.$input.addEventListener("mousedown", (function (a) {
                            e = a.clientX, n = r = a.clientY, s = !0, i = t.getValue(), o = 0, window.addEventListener("mousemove", l), window.addEventListener("mouseup", c)
                        })), this.$input.addEventListener("focus", (function () {
                            t._inputFocused = !0
                        })), this.$input.addEventListener("blur", (function () {
                            t._inputFocused = !1, t.updateDisplay(), t._callOnFinishChange()
                        }))
                    }
                }, {
                    key: "_initSlider",
                    value: function () {
                        var t = this;
                        this._hasSlider = !0, this.$slider = document.createElement("div"), this.$slider.classList.add("slider"), this.$fill = document.createElement("div"), this.$fill.classList.add("fill"), this.$slider.appendChild(this.$fill), this.$widget.insertBefore(this.$slider, this.$input), this.domElement.classList.add("hasSlider");
                        var e, n, r, i = function (e) {
                                var n, r, i, o, a = t.$slider.getBoundingClientRect(),
                                    s = (n = e, r = a.left, i = a.right, o = t._min, (n - r) / (i - r) * (t._max - o) + o);
                                t._snapClampSetValue(s)
                            },
                            o = function (t) {
                                i(t.clientX)
                            },
                            a = function e() {
                                t._callOnFinishChange(), t._setDraggingStyle(!1), window.removeEventListener("mousemove", o), window.removeEventListener("mouseup", e)
                            },
                            s = !1,
                            l = function (e) {
                                e.preventDefault(), t._setDraggingStyle(!0), i(e.touches[0].clientX), s = !1
                            },
                            c = function t(r) {
                                if (s) {
                                    var o = r.touches[0].clientX - e,
                                        a = r.touches[0].clientY - n;
                                    Math.abs(o) > Math.abs(a) ? l(r) : (window.removeEventListener("touchmove", t), window.removeEventListener("touchend", u))
                                } else r.preventDefault(), i(r.touches[0].clientX)
                            },
                            u = function e() {
                                t._callOnFinishChange(), t._setDraggingStyle(!1), window.removeEventListener("touchmove", c), window.removeEventListener("touchend", e)
                            },
                            h = this._callOnFinishChange.bind(this);
                        this.$slider.addEventListener("mousedown", (function (e) {
                            t._setDraggingStyle(!0), i(e.clientX), window.addEventListener("mousemove", o), window.addEventListener("mouseup", a)
                        })), this.$slider.addEventListener("touchstart", (function (r) {
                            r.touches.length > 1 || (t._hasScrollBar ? (e = r.touches[0].clientX, n = r.touches[0].clientY, s = !0) : l(r), window.addEventListener("touchmove", c), window.addEventListener("touchend", u))
                        })), this.$slider.addEventListener("wheel", (function (e) {
                            if (!(Math.abs(e.deltaX) < Math.abs(e.deltaY) && t._hasScrollBar)) {
                                e.preventDefault();
                                var n = t._normalizeMouseWheel(e) * t._step;
                                t._snapClampSetValue(t.getValue() + n), t.$input.value = t.getValue(), clearTimeout(r), r = setTimeout(h, 400)
                            }
                        }))
                    }
                }, {
                    key: "_setDraggingStyle",
                    value: function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "horizontal";
                        this.$slider && this.$slider.classList.toggle("active", t), document.body.classList.toggle("lil-gui-dragging", t), document.body.classList.toggle("lil-gui-" + e, t)
                    }
                }, {
                    key: "_getImplicitStep",
                    value: function () {
                        return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : .1
                    }
                }, {
                    key: "_onUpdateMinMax",
                    value: function () {
                        !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), !1), this._initSlider(), this.updateDisplay())
                    }
                }, {
                    key: "_normalizeMouseWheel",
                    value: function (t) {
                        var e = t.deltaX,
                            n = t.deltaY;
                        return Math.floor(t.deltaY) !== t.deltaY && t.wheelDelta && (e = 0, n = -t.wheelDelta / 120, n *= this._stepExplicit ? 1 : 10), e + -n
                    }
                }, {
                    key: "_arrowKeyMultiplier",
                    value: function (t) {
                        var e = this._stepExplicit ? 1 : 10;
                        return t.shiftKey ? e *= 10 : t.altKey && (e /= 10), e
                    }
                }, {
                    key: "_snap",
                    value: function (t) {
                        var e = Math.round(t / this._step) * this._step;
                        return parseFloat(e.toPrecision(15))
                    }
                }, {
                    key: "_clamp",
                    value: function (t) {
                        return t < this._min && (t = this._min), t > this._max && (t = this._max), t
                    }
                }, {
                    key: "_snapClampSetValue",
                    value: function (t) {
                        this.setValue(this._clamp(this._snap(t)))
                    }
                }, {
                    key: "_hasScrollBar",
                    get: function () {
                        var t = this.parent.root.$children;
                        return t.scrollHeight > t.clientHeight
                    }
                }, {
                    key: "_hasMin",
                    get: function () {
                        return void 0 !== this._min
                    }
                }, {
                    key: "_hasMax",
                    get: function () {
                        return void 0 !== this._max
                    }
                }]), e
            }(rE),
            EE = function (t) {
                function e(t, n, r, i) {
                    var o;
                    return tE(this, e), (o = Xy(this, e, [t, n, r, "option"])).$select = document.createElement("select"), o.$select.setAttribute("aria-labelledby", o.$name.id), o.$display = document.createElement("div"), o.$display.classList.add("display"), o._values = Array.isArray(i) ? i : Object.values(i), o._names = Array.isArray(i) ? i : Object.keys(i), o._names.forEach((function (t) {
                        var e = document.createElement("option");
                        e.innerHTML = t, o.$select.appendChild(e)
                    })), o.$select.addEventListener("change", (function () {
                        o.setValue(o._values[o.$select.selectedIndex]), o._callOnFinishChange()
                    })), o.$select.addEventListener("focus", (function () {
                        o.$display.classList.add("focus")
                    })), o.$select.addEventListener("blur", (function () {
                        o.$display.classList.remove("focus")
                    })), o.$widget.appendChild(o.$select), o.$widget.appendChild(o.$display), o.$disable = o.$select, o.updateDisplay(), o
                }
                return Ky(e, t), eE(e, [{
                    key: "updateDisplay",
                    value: function () {
                        var t = this.getValue(),
                            e = this._values.indexOf(t);
                        return this.$select.selectedIndex = e, this.$display.innerHTML = -1 === e ? t : this._names[e], this
                    }
                }]), e
            }(rE),
            xE = function (t) {
                function e(t, n, r) {
                    var i;
                    return tE(this, e), (i = Xy(this, e, [t, n, r, "string"])).$input = document.createElement("input"), i.$input.setAttribute("type", "text"), i.$input.setAttribute("aria-labelledby", i.$name.id), i.$input.addEventListener("input", (function () {
                        i.setValue(i.$input.value)
                    })), i.$input.addEventListener("keydown", (function (t) {
                        "Enter" === t.code && i.$input.blur()
                    })), i.$input.addEventListener("blur", (function () {
                        i._callOnFinishChange()
                    })), i.$widget.appendChild(i.$input), i.$disable = i.$input, i.updateDisplay(), i
                }
                return Ky(e, t), eE(e, [{
                    key: "updateDisplay",
                    value: function () {
                        return this.$input.value = this.getValue(), this
                    }
                }]), e
            }(rE),
            bE = function () {
                function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        r = n.parent,
                        i = n.autoPlace,
                        o = void 0 === i ? void 0 === r : i,
                        a = n.container,
                        s = n.width,
                        l = n.title,
                        c = void 0 === l ? "3D" : l;
                    n.injectStyles;
                    var u = n.touchStyles,
                        h = void 0 === u || u;
                    if (tE(this, t), this.parent = r, this.root = r ? r.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = !1, this._hidden = !1, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", !0), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", (function () {
                            return e.openAnimated(e._closed)
                        })), this.$title.addEventListener("keydown", (function (t) {
                            "Enter" !== t.code && "Space" !== t.code || (t.preventDefault(), e.$title.click())
                        })), this.$title.addEventListener("touchstart", (function () {})), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(c), h && this.domElement.classList.add("allow-touch-styles"), this.parent) return this.parent.children.push(this), this.parent.folders.push(this), void this.parent.$children.appendChild(this.domElement);
                    this.domElement.classList.add("root"), a ? a.appendChild(this.domElement) : o && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)), s && this.domElement.style.setProperty("--width", s + "px"), this.domElement.addEventListener("keydown", (function (t) {
                        return t.stopPropagation()
                    })), this.domElement.addEventListener("keyup", (function (t) {
                        return t.stopPropagation()
                    }))
                }
                return eE(t, [{
                    key: "add",
                    value: function (t, e, n, r, i) {
                        if (Object(n) === n) return new EE(this, t, e, n);
                        var o = t[e];
                        switch (Zy(o)) {
                            case "number":
                                return new yE(this, t, e, n, r, i);
                            case "boolean":
                                return new iE(this, t, e);
                            case "string":
                                return new xE(this, t, e);
                            case "function":
                                return new _E(this, t, e)
                        }
                        console.error("gui.add failed\n\tproperty:", e, "\n\tobject:", t, "\n\tvalue:", o)
                    }
                }, {
                    key: "addColor",
                    value: function (t, e) {
                        return new vE(this, t, e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1)
                    }
                }, {
                    key: "addFolder",
                    value: function (e) {
                        return new t({
                            parent: this,
                            title: e
                        })
                    }
                }, {
                    key: "load",
                    value: function (t) {
                        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        return t.controllers && this.controllers.forEach((function (e) {
                            e instanceof _E || e._name in t.controllers && e.load(t.controllers[e._name])
                        })), e && t.folders && this.folders.forEach((function (e) {
                            e._title in t.folders && e.load(t.folders[e._title])
                        })), this
                    }
                }, {
                    key: "save",
                    value: function () {
                        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                            e = {
                                controllers: {},
                                folders: {}
                            };
                        return this.controllers.forEach((function (t) {
                            if (!(t instanceof _E)) {
                                if (t._name in e.controllers) throw new Error('Cannot save GUI with duplicate property "'.concat(t._name, '"'));
                                e.controllers[t._name] = t.save()
                            }
                        })), t && this.folders.forEach((function (t) {
                            if (t._title in e.folders) throw new Error('Cannot save GUI with duplicate folder "'.concat(t._title, '"'));
                            e.folders[t._title] = t.save()
                        })), e
                    }
                }, {
                    key: "open",
                    value: function () {
                        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        return this._closed = !t, this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this
                    }
                }, {
                    key: "close",
                    value: function () {
                        return this.open(!1)
                    }
                }, {
                    key: "show",
                    value: function () {
                        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        return this._hidden = !t, this.domElement.style.display = this._hidden ? "none" : "", this
                    }
                }, {
                    key: "hide",
                    value: function () {
                        return this.show(!1)
                    }
                }, {
                    key: "openAnimated",
                    value: function () {
                        var t = this,
                            e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        return this._closed = !e, this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame((function () {
                            var n = t.$children.clientHeight;
                            t.$children.style.height = n + "px", t.domElement.classList.add("transition");
                            t.$children.addEventListener("transitionend", (function e(n) {
                                n.target === t.$children && (t.$children.style.height = "", t.domElement.classList.remove("transition"), t.$children.removeEventListener("transitionend", e))
                            }));
                            var r = e ? t.$children.scrollHeight : 0;
                            t.domElement.classList.toggle("closed", !e), requestAnimationFrame((function () {
                                t.$children.style.height = r + "px"
                            }))
                        })), this
                    }
                }, {
                    key: "title",
                    value: function (t) {
                        return this._title = t, this.$title.innerHTML = t, this
                    }
                }, {
                    key: "reset",
                    value: function () {
                        return (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0] ? this.controllersRecursive() : this.controllers).forEach((function (t) {
                            return t.reset()
                        })), this
                    }
                }, {
                    key: "onChange",
                    value: function (t) {
                        return this._onChange = t, this
                    }
                }, {
                    key: "_callOnChange",
                    value: function (t) {
                        this.parent && this.parent._callOnChange(t), void 0 !== this._onChange && this._onChange.call(this, {
                            object: t.object,
                            property: t.property,
                            value: t.getValue(),
                            controller: t
                        })
                    }
                }, {
                    key: "onFinishChange",
                    value: function (t) {
                        return this._onFinishChange = t, this
                    }
                }, {
                    key: "_callOnFinishChange",
                    value: function (t) {
                        this.parent && this.parent._callOnFinishChange(t), void 0 !== this._onFinishChange && this._onFinishChange.call(this, {
                            object: t.object,
                            property: t.property,
                            value: t.getValue(),
                            controller: t
                        })
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)), this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement), Array.from(this.children).forEach((function (t) {
                            return t.destroy()
                        }))
                    }
                }, {
                    key: "controllersRecursive",
                    value: function () {
                        var t = Array.from(this.controllers);
                        return this.folders.forEach((function (e) {
                            t = t.concat(e.controllersRecursive())
                        })), t
                    }
                }, {
                    key: "foldersRecursive",
                    value: function () {
                        var t = Array.from(this.folders);
                        return this.folders.forEach((function (e) {
                            t = t.concat(e.foldersRecursive())
                        })), t
                    }
                }]), t
            }();

        function wE(t, e) {
            return void 0 === e && (e = Sv), n = function () {
                return Tv(t, e)
            }, av((function (t, e) {
                var r = !1,
                    i = null,
                    o = null,
                    a = !1,
                    s = function () {
                        if (null == o || o.unsubscribe(), o = null, r) {
                            r = !1;
                            var t = i;
                            i = null, e.next(t)
                        }
                        a && e.complete()
                    },
                    l = function () {
                        o = null, a && e.complete()
                    };
                t.subscribe(sv(e, (function (t) {
                    r = !0, i = t, o || iv(n(t)).subscribe(o = sv(e, s, l))
                }), (function () {
                    a = !0, (!r || !o || o.closed) && e.complete()
                })))
            }));
            var n
        }

        function CE(t) {
            return CE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, CE(t)
        }

        function SE(t, e) {
            return function (t) {
                if (Array.isArray(t)) return t
            }(t) || function (t, e) {
                var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != n) {
                    var r, i, o, a, s = [],
                        l = !0,
                        c = !1;
                    try {
                        if (o = (n = n.call(t)).next, 0 === e);
                        else
                            for (; !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                    } catch (t) {
                        c = !0, i = t
                    } finally {
                        try {
                            if (!l && null != n.return && (a = n.return(), Object(a) !== a)) return
                        } finally {
                            if (c) throw i
                        }
                    }
                    return s
                }
            }(t, e) || function (t, e) {
                if (!t) return;
                if ("string" == typeof t) return IE(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return IE(t, e)
            }(t, e) || function () {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function IE(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r
        }

        function ME(t, e) {
            return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, {
                raw: {
                    value: Object.freeze(e)
                }
            }))
        }

        function TE() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            TE = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == CE(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError(CE(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function BE(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function RE(t) {
            return function () {
                var e = this,
                    n = arguments;
                return new Promise((function (r, i) {
                    var o = t.apply(e, n);

                    function a(t) {
                        BE(o, r, i, a, s, "next", t)
                    }

                    function s(t) {
                        BE(o, r, i, a, s, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }

        function LE(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function DE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, OE(r.key), r)
            }
        }

        function PE(t, e, n) {
            return e && DE(t.prototype, e), n && DE(t, n), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function OE(t) {
            var e = function (t, e) {
                if ("object" != CE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != CE(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == CE(e) ? e : String(e)
        }

        function kE(t, e, n) {
            return e = FE(e),
                function (t, e) {
                    if (e && ("object" === CE(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, UE() ? Reflect.construct(e, [], FE(t).constructor) : e.apply(t, n))
        }

        function UE() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {})))
            } catch (t) {}
            return (UE = function () {
                return !!t
            })()
        }

        function NE() {
            return NE = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {
                var r = function (t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = FE(t)););
                    return t
                }(t, e);
                if (r) {
                    var i = Object.getOwnPropertyDescriptor(r, e);
                    return i.get ? i.get.call(arguments.length < 3 ? t : n) : i.value
                }
            }, NE.apply(this, arguments)
        }

        function FE(t) {
            return FE = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, FE(t)
        }

        function QE(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && $E(t, e)
        }

        function $E(t, e) {
            return $E = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, $E(t, e)
        }
        var GE = function (t) {
            function e() {
                return LE(this, e), kE(this, e)
            }
            return QE(e, t), PE(e, [{
                key: "connectedCallback",
                value: function () {
                    NE(FE(e.prototype), "connectedCallback", this).call(this)
                }
            }, {
                key: "getImagesFromMaterials",
                value: function (t) {
                    var e = this,
                        n = {
                            material: t
                        },
                        r = ["map", "normalMap", "aoMap", "roughnessMap", "metalnessMap", "emissiveMap", "alphaMap"];
                    return window.engine.scene.getObjectByName(this.parent).traverse((function (t) {
                        t.material && t.material.name === e.material && r.forEach((function (e) {
                            t.material[e] && (n[e] = t.material[e].image)
                        }))
                    })), n
                }
            }, {
                key: "disconnectedCallback",
                value: function () {
                    NE(FE(e.prototype), "disconnectedCallback", this).call(this)
                }
            }, {
                key: "handleClick",
                value: function (t) {
                    var e = this,
                        n = document.createElement("input");
                    n.setAttribute("type", "file"), n.setAttribute("accept", ".png, .jpg"), n.addEventListener("change", function () {
                        var n = RE(TE().mark((function n(r) {
                            var i, o, a;
                            return TE().wrap((function (n) {
                                for (;;) switch (n.prev = n.next) {
                                    case 0:
                                        return i = r.target.files[0], o = URL.createObjectURL(i), n.next = 4, (new $d).loadAsync(o);
                                    case 4:
                                        (a = n.sent).colorSpace = Yi, a.flipY = !1, window.engine.scene.traverse((function (n) {
                                            n.material && n.material.name === e.material && ("ao" === t && (n.material.aoMap = a, n.material.aoMap.channel = 1), "map" === t && (n.material.map = a), "normal" === t && (n.material.normalMap = a), "roughness" === t && (n.material.roughnessMap = a), "metalness" === t && (n.material.metalnessMap = a), "emissive" === t && (n.material.emissiveMap = a), n.material.needsUpdate = !0)
                                        })), e.getImagesFromMaterials(), e.requestUpdate(), window.engine.update();
                                    case 11:
                                    case "end":
                                        return n.stop()
                                }
                            }), n)
                        })));
                        return function (t) {
                            return n.apply(this, arguments)
                        }
                    }()), n.style.display = "none", document.body.appendChild(n), n.click(), document.body.removeChild(n)
                }
            }, {
                key: "handleDelete",
                value: function (t) {
                    var e = this;
                    window.engine.scene.traverse((function (n) {
                        n.material && n.material.name === e.material && ("ao" === t && (n.material.aoMap = null), "map" === t && (n.material.map = null), "normal" === t && (n.material.normalMap = null), "roughness" === t && (n.material.roughnessMap = null), "metalness" === t && (n.material.metalnessMap = null), "emissive" === t && (n.material.emissiveMap = null), n.material.needsUpdate = !0)
                    })), this.getImagesFromMaterials(), this.requestUpdate(), window.engine.update()
                }
            }, {
                key: "firstUpdated",
                value: function () {}
            }, {
                key: "render",
                value: function () {
                    var t = this;
                    this.images = this.getImagesFromMaterials(this.material);
                    var e = function (e, n) {
                        return Y_(aE || (aE = ME(['\n      <div class="picker-el__wrapper inline">\n        <div\n          @click="', '"\n          class="picker-el"\n        >\n          ', "\n          ", '\n        </div>\n\n        <div\n          @click="', '"\n          class="picker-el"\n        >\n          x\n        </div>\n      </div>\n    '])), (function () {
                            t.handleClick(n)
                        }), e && e.currentSrc && !e.currentSrc.includes("blob") ? Y_(sE || (sE = ME(['<img src="', '" /> '])), e.currentSrc) : Y_(lE || (lE = ME(["", ""])), e), n.charAt(0).toUpperCase() + n.slice(1), (function () {
                            t.handleDelete(n)
                        }))
                    };
                    return Y_(cE || (cE = ME(["\n      ", "\n      ", "\n      ", "\n      ", "\n      ", "\n      ", "\n      ", "\n    "])), e(this.images.map, "map"), e(this.images.aoMap, "ao"), e(this.images.normalMap, "normal"), e(this.images.roughnessMap, "roughness"), e(this.images.metalnessMap, "metalness"), e(this.images.emissiveMap, "emissive"), e(this.images.alphaMap, "alpha"))
                }
            }], [{
                key: "styles",
                get: function () {
                    return [v_(uE || (uE = ME(["\n        .picker-el {\n          color: #fff;\n          cursor: pointer;\n          display: flex;\n          padding: 0.5em 1.5em 0.5em 1.5em;\n          margin: 0.875em 0 0.875em 0;\n          justify-content: center;\n          align-items: center;\n          border-radius: 0.5em;\n        }\n        .picker-el img {\n          width: 3em;\n          height: 3em;\n        }\n        .picker-el:hover {\n          opacity: 0.8;\n        }\n        .picker-el__wrapper {\n          margin-left: 0.5em;\n          margin-right: 0.5em;\n        }\n        .picker-el__active {\n          box-shadow: #00b0f0 0 0 0.5em;\n        }\n        .picker-el__disabled {\n          opacity: 0.3;\n          pointer-events: none;\n        }\n        .inline {\n          display: inline-flex;\n        }\n      "])))]
                }
            }, {
                key: "properties",
                get: function () {
                    return {
                        material: "",
                        parent: ""
                    }
                }
            }]), e
        }(gy);
        customElements.define("button-component", GE);
        var HE, zE, VE, WE, jE = function (t) {
            function e() {
                var t;
                return LE(this, e), (t = kE(this, e)).engine = window.engine, t
            }
            var n;
            return QE(e, t), PE(e, [{
                key: "connectedCallback",
                value: function () {
                    var t = this;
                    NE(FE(e.prototype), "connectedCallback", this).call(this), this.sub = tf.complectation.pipe(wE(100)).subscribe((function (e) {
                        t.lastLayout !== e.layout && (t.createMaterialsFolder(e.layout), t.lastLayout = e.layout)
                    }))
                }
            }, {
                key: "disconnectedCallback",
                value: function () {
                    this.sub && this.sub.unsubscribe(), this.cleanUpControllers()
                }
            }, {
                key: "createMaterialsFolder",
                value: (n = RE(TE().mark((function t() {
                    var e, n, r, i, o, a, s, l = this,
                        c = arguments;
                    return TE().wrap((function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if (e = c.length > 0 && void 0 !== c[0] ? c[0] : tf.complectation.value.layout, this.gui) {
                                    t.next = 3;
                                    break
                                }
                                return t.abrupt("return");
                            case 3:
                                return n = cf.models.samara.assetsArray.find((function (t) {
                                    return t.name === tf.complectation.value.layout
                                })), t.next = 6, Promise.resolve(n.loadedModel);
                            case 6:
                                (r = this.gui.folders.find((function (t) {
                                    return "Materials" === t._title
                                }))) ? (r.controllersRecursive().forEach((function (t) {
                                    t.listen(!1), t.destroy()
                                })), r.destroy(), r = this.gui.addFolder("Materials")) : r = this.gui.addFolder("Materials"), r.close(), i = new Set, o = function (t, e, n) {
                                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                        i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                                        o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .01;
                                    void 0 !== e[t] && "MeshTransmissionMaterial" !== e.materialType && ("color" === t ? n.addColor(e, "color").onChange((function () {
                                        l.engine.update()
                                    })).listen() : n.add(e, t, r, i, o).onChange((function () {
                                        l.engine.update()
                                    })).listen())
                                }, a = ["color", "depthWrite", "visible", "transmission", "metalness", "roughness", "ior", "thickness", "reflectivity", "aoMapIntensity", "emissiveIntensity"], (s = this.engine.scene.getObjectByName(e)) && s.traverse((function (t) {
                                    if (t.material && !i.has(t.material.name)) {
                                        i.add(t.material.name);
                                        var e = r.addFolder(t.material.name).close();
                                        e.$children.innerHTML = "<br/> ".concat(t.material.materialType || t.material.type), a.forEach((function (n) {
                                            o(n, t.material, e)
                                        }));
                                        var n = e.addFolder("Textures").close();
                                        n.$children.innerHTML = '<button-component material="'.concat(t.material.name, '" parent="').concat(s.name, '"></button-component>');
                                        var c = n.addFolder("Offset");
                                        t.material.normalMap && (n.add(t.material.normalScale, "x", -10, 10, .001).onChange((function (e) {
                                            t.material.normalScale = new Co(e, e), l.engine.update()
                                        })).name("normalScale").listen(), n.add(t.material.normalMap.repeat, "x", 1, 200, .01).onChange((function (e) {
                                            t.material.normalMap.repeat.set(e, e), t.material.map.repeat.set(e, e), l.engine.update()
                                        })).name("repeat").listen(), n.add(t.material, "normalMapType", {
                                            TangentSpace: 0,
                                            ObjectSpace: 1
                                        }).onChange((function (e) {
                                            t.material.normalMap.needsUpdate = !0, l.engine.update()
                                        })).name("normalMapType"), n.add(t.material.normalMap, "colorSpace", {
                                            SRGB: Yi,
                                            LinearSRGB: Ki
                                        }).onChange((function (e) {
                                            t.material.normalMap.needsUpdate = !0, l.engine.update()
                                        })).name("normalMapColorSpace"), c.add(t.material.normalMap.offset, "x", 0, 1, .001).onChange((function () {
                                            t.material.normalMap.needsUpdate = !0, l.engine.update(1)
                                        })).name("Normal offset X"), c.add(t.material.normalMap.offset, "y", 0, 1, .001).onChange((function () {
                                            t.material.normalMap.needsUpdate = !0, l.engine.update(1)
                                        })).name("Normal offset Y")), t.material.map && (c.add(t.material.map.offset, "x", 0, 1, .001).onChange((function () {
                                            t.material.map.needsUpdate = !0, l.engine.update(1)
                                        })).name("Base color offset X").listen(), c.add(t.material.map.offset, "y", 0, 1, .001).onChange((function () {
                                            t.material.map.needsUpdate = !0, l.engine.update(1)
                                        })).name("Base color offset Y").listen())
                                    }
                                }));
                            case 14:
                            case "end":
                                return t.stop()
                        }
                    }), t, this)
                }))), function () {
                    return n.apply(this, arguments)
                })
            }, {
                key: "cleanUpControllers",
                value: function () {
                    this.gui && (this.gui.controllersRecursive().forEach((function (t) {
                        t.listen(!1), t.destroy()
                    })), this.gui.destroy())
                }
            }, {
                key: "onRef",
                value: function (t) {
                    t && (this.guiDomEl = t, this.initGui())
                }
            }, {
                key: "render",
                value: function () {
                    return Y_(hE || (hE = ME(['<div class="gui" ', "></div>"])), My(this.onRef))
                }
            }, {
                key: "initGui",
                value: function () {
                    var t = this;
                    this.textures = new hg, this.gui = new bE({
                        load: JSON,
                        autoPlace: !1,
                        container: this.guiDomEl
                    }), this.gui.close(), this.guiDomEl.appendChild(this.gui.domElement);
                    for (var e = this.gui.addFolder("Complectation"), n = 0, r = Object.entries(cf.models.samara.complectationVars); n < r.length; n++) {
                        var i = SE(r[n], 2),
                            o = i[0];
                        i[1];
                        var a = e.addFolder(o);
                        a.$children.innerHTML = '<options-component parent="'.concat(o, '"></options-component>'), a.close()
                    }
                    var s = this.gui.addFolder("Envmap");
                    s.add(cf.envMap, "intensity", 0, 5).step(.01).onChange((function (e) {
                        t.engine.scene.traverse((function (t) {
                            t.material && t.material.envMap && (t.material.envMapIntensity = e)
                        })), t.engine.update()
                    })).listen(), cf.environment.assetsArray.forEach((function (e) {
                        e.click = RE(TE().mark((function n() {
                            var r;
                            return TE().wrap((function (n) {
                                for (;;) switch (n.prev = n.next) {
                                    case 0:
                                        if (cf.envMap.intensity = e.defaultHdrIntensity, r = cf.environment.assetsArray.find((function (t) {
                                                return t.id === e.id
                                            })), n.t0 = !r.loadedHDRTexture, !n.t0) {
                                            n.next = 6;
                                            break
                                        }
                                        return n.next = 6, t.engine.textures.loadTexture(r, "pmrem");
                                    case 6:
                                        t.engine.scene.traverse((function (n) {
                                            n.material && n.material.envMap && (n.material.envMap = t.textures.getHdrTexture(e.name), n.material.envMapIntensity = e.defaultHdrIntensity)
                                        })), t.engine.update();
                                    case 8:
                                    case "end":
                                        return n.stop()
                                }
                            }), n)
                        }))), s.add(e, "click").name(e.name)
                    })), s.close();
                    var l = this.gui.addFolder("Camera");
                    l.add(cf.camera, "fov", 5, 90).step(.1).onChange((function () {
                        t.engine.setupPerspectiveView()
                    })), l.add(cf.models.samara, "modelScaleAspectValue", 100, 150).step(10).onChange((function () {
                        t.engine.setupPerspectiveView()
                    }));
                    [{
                        name: "next",
                        value: 1
                    }, {
                        name: "prev",
                        value: -1
                    }].forEach((function (e) {
                        e.click = function () {
                            t.engine.CameraGsap.setPosition(e.value)
                        }, l.add(e, "click").name(e.name)
                    })), l.close();
                    var c = this.gui.addFolder("Shadow");
                    c.add(cf.shadowMesh, "opacity", .1, 1).step(.1).onChange((function (e) {
                        t.engine.scene.traverse((function (t) {
                            t.name.includes("_shadow") && (t.material.opacity = e)
                        })), t.engine.update()
                    })), c.close(), this.engine.stats = Vy();
                    var u = this.gui.addFolder("Performance");
                    this.engine.stats.dom.style.position = "relative", u.$children.appendChild(this.engine.stats.dom), u.close()
                }
            }], [{
                key: "styles",
                get: function () {
                    return v_(dE || (dE = ME(["\n      .gui {\n        position: absolute;\n        top: 0;\n        right: 1em;\n        max-height: 100vh;\n        overflow: auto;\n        z-index: 3;\n        border-bottom-left-radius: 1em;\n        border-bottom-right-radius: 1em;\n      }\n\n      .lil-gui {\n        --background-color: #1f1f1f;\n        --text-color: #ebebeb;\n        --title-background-color: #111;\n        --title-text-color: #ebebeb;\n        --widget-color: #424242;\n        --hover-color: #4f4f4f;\n        --focus-color: #595959;\n        --number-color: #2cc9ff;\n        --string-color: #a2db3c;\n        --font-size: 11px;\n        --input-font-size: 11px;\n        --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n          Arial, sans-serif;\n        --font-family-mono: Menlo, Monaco, Consolas, 'Droid Sans Mono',\n          monospace;\n        --padding: 4px;\n        --spacing: 4px;\n        --widget-height: 20px;\n        --name-width: 45%;\n        --slider-knob-width: 2px;\n        --slider-input-width: 27%;\n        --color-input-width: 27%;\n        --slider-input-min-width: 45px;\n        --color-input-min-width: 45px;\n        --folder-indent: 7px;\n        --widget-padding: 0 0 0 3px;\n        --widget-border-radius: 2px;\n        --checkbox-size: calc(var(--widget-height) * 0.75);\n        --scrollbar-width: 5px;\n        background-color: var(--background-color);\n        color: var(--text-color);\n        font-family: var(--font-family);\n        font-size: var(--font-size);\n        font-style: normal;\n        font-weight: 400;\n        line-height: 1;\n        text-align: left;\n        touch-action: manipulation;\n        user-select: none;\n        -webkit-user-select: none;\n      }\n      .lil-gui,\n      .lil-gui * {\n        box-sizing: border-box;\n        margin: 0;\n        padding: 0;\n      }\n      .lil-gui.root {\n        display: flex;\n        flex-direction: column;\n        width: var(--width, 245px);\n      }\n      .lil-gui.root > .title {\n        background: var(--title-background-color);\n        color: var(--title-text-color);\n      }\n      .lil-gui.root > .children {\n        overflow-x: hidden;\n        overflow-y: auto;\n      }\n      .lil-gui.root > .children::-webkit-scrollbar {\n        background: var(--background-color);\n        height: var(--scrollbar-width);\n        width: var(--scrollbar-width);\n      }\n      .lil-gui.root > .children::-webkit-scrollbar-thumb {\n        background: var(--focus-color);\n        border-radius: var(--scrollbar-width);\n      }\n      .lil-gui.force-touch-styles {\n        --widget-height: 28px;\n        --padding: 6px;\n        --spacing: 6px;\n        --font-size: 13px;\n        --input-font-size: 16px;\n        --folder-indent: 10px;\n        --scrollbar-width: 7px;\n        --slider-input-min-width: 50px;\n        --color-input-min-width: 65px;\n      }\n      .lil-gui.autoPlace {\n        max-height: 100%;\n        position: fixed;\n        right: 15px;\n        top: 0;\n        z-index: 1001;\n      }\n      .lil-gui .controller {\n        align-items: center;\n        display: flex;\n        margin: var(--spacing) 0;\n        padding: 0 var(--padding);\n      }\n      .lil-gui .controller.disabled {\n        opacity: 0.5;\n      }\n      .lil-gui .controller.disabled,\n      .lil-gui .controller.disabled * {\n        pointer-events: none !important;\n      }\n      .lil-gui .controller > .name {\n        flex-shrink: 0;\n        line-height: var(--widget-height);\n        min-width: var(--name-width);\n        padding-right: var(--spacing);\n        white-space: pre;\n      }\n      .lil-gui .controller .widget {\n        align-items: center;\n        display: flex;\n        min-height: var(--widget-height);\n        position: relative;\n        width: 100%;\n      }\n      .lil-gui .controller.string input {\n        color: var(--string-color);\n      }\n      .lil-gui .controller.boolean .widget {\n        cursor: pointer;\n      }\n      .lil-gui .controller.color .display {\n        border-radius: var(--widget-border-radius);\n        height: var(--widget-height);\n        position: relative;\n        width: 100%;\n      }\n      .lil-gui .controller.color input[type='color'] {\n        cursor: pointer;\n        height: 100%;\n        opacity: 0;\n        width: 100%;\n      }\n      .lil-gui .controller.color input[type='text'] {\n        flex-shrink: 0;\n        font-family: var(--font-family-mono);\n        margin-left: var(--spacing);\n        min-width: var(--color-input-min-width);\n        width: var(--color-input-width);\n      }\n      .lil-gui .controller.option select {\n        max-width: 100%;\n        opacity: 0;\n        position: absolute;\n        width: 100%;\n      }\n      .lil-gui .controller.option .display {\n        background: var(--widget-color);\n        border-radius: var(--widget-border-radius);\n        height: var(--widget-height);\n        line-height: var(--widget-height);\n        max-width: 100%;\n        overflow: hidden;\n        padding-left: 0.55em;\n        padding-right: 1.75em;\n        pointer-events: none;\n        position: relative;\n        word-break: break-all;\n      }\n      .lil-gui .controller.option .display.active {\n        background: var(--focus-color);\n      }\n      .lil-gui .controller.option .display:after {\n        bottom: 0;\n        content: '↕';\n        font-family: lil-gui;\n        padding-right: 0.375em;\n        position: absolute;\n        right: 0;\n        top: 0;\n      }\n      .lil-gui .controller.option .widget,\n      .lil-gui .controller.option select {\n        cursor: pointer;\n      }\n      .lil-gui .controller.number input {\n        color: var(--number-color);\n      }\n      .lil-gui .controller.number.hasSlider input {\n        flex-shrink: 0;\n        margin-left: var(--spacing);\n        min-width: var(--slider-input-min-width);\n        width: var(--slider-input-width);\n      }\n      .lil-gui .controller.number .slider {\n        background-color: var(--widget-color);\n        border-radius: var(--widget-border-radius);\n        cursor: ew-resize;\n        height: var(--widget-height);\n        overflow: hidden;\n        padding-right: var(--slider-knob-width);\n        touch-action: pan-y;\n        width: 100%;\n      }\n      .lil-gui .controller.number .slider.active {\n        background-color: var(--focus-color);\n      }\n      .lil-gui .controller.number .slider.active .fill {\n        opacity: 0.95;\n      }\n      .lil-gui .controller.number .fill {\n        border-right: var(--slider-knob-width) solid var(--number-color);\n        box-sizing: content-box;\n        height: 100%;\n      }\n      .lil-gui-dragging .lil-gui {\n        --hover-color: var(--widget-color);\n      }\n      .lil-gui-dragging * {\n        cursor: ew-resize !important;\n      }\n      .lil-gui-dragging.lil-gui-vertical * {\n        cursor: ns-resize !important;\n      }\n      .lil-gui .title {\n        --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n        -webkit-tap-highlight-color: transparent;\n        text-decoration-skip: objects;\n        cursor: pointer;\n        font-weight: 600;\n        height: var(--title-height);\n        line-height: calc(var(--title-height) - 4px);\n        outline: none;\n        padding: 0 var(--padding);\n      }\n      .lil-gui .title:before {\n        content: '▾';\n        display: inline-block;\n        font-family: lil-gui;\n        padding-right: 2px;\n      }\n      .lil-gui .title:active {\n        background: var(--title-background-color);\n        opacity: 0.75;\n      }\n      .lil-gui.root > .title:focus {\n        text-decoration: none !important;\n      }\n      .lil-gui.closed > .title:before {\n        content: '▸';\n      }\n      .lil-gui.closed > .children {\n        opacity: 0;\n        transform: translateY(-7px);\n      }\n      .lil-gui.closed:not(.transition) > .children {\n        display: none;\n      }\n      .lil-gui.transition > .children {\n        overflow: hidden;\n        pointer-events: none;\n        transition-duration: 0.3s;\n        transition-property: height, opacity, transform;\n        transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n      }\n      .lil-gui .children:empty:before {\n        content: 'Empty';\n        display: block;\n        font-style: italic;\n        height: var(--widget-height);\n        line-height: var(--widget-height);\n        margin: var(--spacing) 0;\n        opacity: 0.5;\n        padding: 0 var(--padding);\n      }\n      .lil-gui.root > .children > .lil-gui > .title {\n        border-width: 0;\n        border-bottom: 1px solid var(--widget-color);\n        border-left: 0 solid var(--widget-color);\n        border-right: 0 solid var(--widget-color);\n        border-top: 1px solid var(--widget-color);\n        transition: border-color 0.3s;\n      }\n      .lil-gui.root > .children > .lil-gui.closed > .title {\n        border-bottom-color: transparent;\n      }\n      .lil-gui + .controller {\n        border-top: 1px solid var(--widget-color);\n        margin-top: 0;\n        padding-top: var(--spacing);\n      }\n      .lil-gui .lil-gui .lil-gui > .title {\n        border: none;\n      }\n      .lil-gui .lil-gui .lil-gui > .children {\n        border: none;\n        border-left: 2px solid var(--widget-color);\n        margin-left: var(--folder-indent);\n      }\n      .lil-gui .lil-gui .controller {\n        border: none;\n      }\n      .lil-gui input {\n        -webkit-tap-highlight-color: transparent;\n        background: var(--widget-color);\n        border: 0;\n        border-radius: var(--widget-border-radius);\n        color: var(--text-color);\n        font-family: var(--font-family);\n        font-size: var(--input-font-size);\n        height: var(--widget-height);\n        outline: none;\n        width: 100%;\n      }\n      .lil-gui input:disabled {\n        opacity: 1;\n      }\n      .lil-gui input[type='number'],\n      .lil-gui input[type='text'] {\n        padding: var(--widget-padding);\n      }\n      .lil-gui input[type='number']:focus,\n      .lil-gui input[type='text']:focus {\n        background: var(--focus-color);\n      }\n      .lil-gui input::-webkit-inner-spin-button,\n      .lil-gui input::-webkit-outer-spin-button {\n        -webkit-appearance: none;\n        margin: 0;\n      }\n      .lil-gui input[type='number'] {\n        -moz-appearance: textfield;\n      }\n      .lil-gui input[type='checkbox'] {\n        appearance: none;\n        -webkit-appearance: none;\n        border-radius: var(--widget-border-radius);\n        cursor: pointer;\n        height: var(--checkbox-size);\n        text-align: center;\n        width: var(--checkbox-size);\n      }\n      .lil-gui input[type='checkbox']:checked:before {\n        content: '✓';\n        font-family: lil-gui;\n        font-size: var(--checkbox-size);\n        line-height: var(--checkbox-size);\n      }\n      .lil-gui button {\n        -webkit-tap-highlight-color: transparent;\n        background: var(--widget-color);\n        border: 1px solid var(--widget-color);\n        border-radius: var(--widget-border-radius);\n        color: var(--text-color);\n        cursor: pointer;\n        font-family: var(--font-family);\n        font-size: var(--font-size);\n        height: var(--widget-height);\n        line-height: calc(var(--widget-height) - 4px);\n        outline: none;\n        text-align: center;\n        text-transform: none;\n        width: 100%;\n      }\n      .lil-gui button:active {\n        background: var(--focus-color);\n      }\n      @font-face {\n        font-family: lil-gui;\n        src: url('data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==')\n          format('woff');\n      }\n      @media (pointer: coarse) {\n        .lil-gui.allow-touch-styles {\n          --widget-height: 28px;\n          --padding: 6px;\n          --spacing: 6px;\n          --font-size: 13px;\n          --input-font-size: 16px;\n          --folder-indent: 10px;\n          --scrollbar-width: 7px;\n          --slider-input-min-width: 50px;\n          --color-input-min-width: 65px;\n        }\n      }\n      @media (hover: hover) {\n        .lil-gui .controller.color .display:hover:before {\n          border: 1px solid #fff9;\n          border-radius: var(--widget-border-radius);\n          bottom: 0;\n          content: ' ';\n          display: block;\n          left: 0;\n          position: absolute;\n          right: 0;\n          top: 0;\n        }\n        .lil-gui .controller.option .display.focus {\n          background: var(--focus-color);\n        }\n        .lil-gui .controller.option .widget:hover .display {\n          background: var(--hover-color);\n        }\n        .lil-gui .controller.number .slider:hover {\n          background-color: var(--hover-color);\n        }\n        .lil-gui .title:hover {\n          background: var(--title-background-color);\n          opacity: 0.85;\n        }\n        .lil-gui .title:focus {\n          text-decoration: underline var(--focus-color);\n        }\n        .lil-gui input:hover {\n          background: var(--hover-color);\n        }\n        .lil-gui input:active {\n          background: var(--focus-color);\n        }\n        .lil-gui input[type='checkbox']:focus {\n          box-shadow: inset 0 0 0 1px var(--focus-color);\n        }\n        .lil-gui button:hover {\n          background: var(--hover-color);\n          border-color: var(--hover-color);\n        }\n        .lil-gui button:focus {\n          border-color: var(--focus-color);\n        }\n      }\n    "])))
                }
            }]), e
        }(gy);

        function XE(t) {
            return XE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, XE(t)
        }

        function qE() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            qE = function () {
                return e
            };
            var t, e = {},
                n = Object.prototype,
                r = n.hasOwnProperty,
                i = Object.defineProperty || function (t, e, n) {
                    t[e] = n.value
                },
                o = "function" == typeof Symbol ? Symbol : {},
                a = o.iterator || "@@iterator",
                s = o.asyncIterator || "@@asyncIterator",
                l = o.toStringTag || "@@toStringTag";

            function c(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                c({}, "")
            } catch (t) {
                c = function (t, e, n) {
                    return t[e] = n
                }
            }

            function u(t, e, n, r) {
                var o = e && e.prototype instanceof A ? e : A,
                    a = Object.create(o.prototype),
                    s = new B(r || []);
                return i(a, "_invoke", {
                    value: S(t, n, s)
                }), a
            }

            function h(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            e.wrap = u;
            var d = "suspendedStart",
                p = "suspendedYield",
                f = "executing",
                m = "completed",
                g = {};

            function A() {}

            function v() {}

            function _() {}
            var y = {};
            c(y, a, (function () {
                return this
            }));
            var E = Object.getPrototypeOf,
                x = E && E(E(R([])));
            x && x !== n && r.call(x, a) && (y = x);
            var b = _.prototype = A.prototype = Object.create(y);

            function w(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    c(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function C(t, e) {
                function n(i, o, a, s) {
                    var l = h(t[i], t, o);
                    if ("throw" !== l.type) {
                        var c = l.arg,
                            u = c.value;
                        return u && "object" == XE(u) && r.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                            n("next", t, a, s)
                        }), (function (t) {
                            n("throw", t, a, s)
                        })) : e.resolve(u).then((function (t) {
                            c.value = t, a(c)
                        }), (function (t) {
                            return n("throw", t, a, s)
                        }))
                    }
                    s(l.arg)
                }
                var o;
                i(this, "_invoke", {
                    value: function (t, r) {
                        function i() {
                            return new e((function (e, i) {
                                n(t, r, e, i)
                            }))
                        }
                        return o = o ? o.then(i, i) : i()
                    }
                })
            }

            function S(e, n, r) {
                var i = d;
                return function (o, a) {
                    if (i === f) throw new Error("Generator is already running");
                    if (i === m) {
                        if ("throw" === o) throw a;
                        return {
                            value: t,
                            done: !0
                        }
                    }
                    for (r.method = o, r.arg = a;;) {
                        var s = r.delegate;
                        if (s) {
                            var l = I(s, r);
                            if (l) {
                                if (l === g) continue;
                                return l
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === d) throw i = m, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        i = f;
                        var c = h(e, n, r);
                        if ("normal" === c.type) {
                            if (i = r.done ? m : p, c.arg === g) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            }
                        }
                        "throw" === c.type && (i = m, r.method = "throw", r.arg = c.arg)
                    }
                }
            }

            function I(e, n) {
                var r = n.method,
                    i = e.iterator[r];
                if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, I(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                var o = h(i, e.iterator, n.arg);
                if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, g;
                var a = o.arg;
                return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, g) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, g)
            }

            function M(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function T(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function B(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(M, this), this.reset(!0)
            }

            function R(e) {
                if (e || "" === e) {
                    var n = e[a];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var i = -1,
                            o = function n() {
                                for (; ++i < e.length;)
                                    if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                throw new TypeError(XE(e) + " is not iterable")
            }
            return v.prototype = _, i(b, "constructor", {
                value: _,
                configurable: !0
            }), i(_, "constructor", {
                value: v,
                configurable: !0
            }), v.displayName = c(_, l, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
            }, e.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, c(t, l, "GeneratorFunction")), t.prototype = Object.create(b), t
            }, e.awrap = function (t) {
                return {
                    __await: t
                }
            }, w(C.prototype), c(C.prototype, s, (function () {
                return this
            })), e.AsyncIterator = C, e.async = function (t, n, r, i, o) {
                void 0 === o && (o = Promise);
                var a = new C(u(t, n, r, i), o);
                return e.isGeneratorFunction(n) ? a : a.next().then((function (t) {
                    return t.done ? t.value : a.next()
                }))
            }, w(b), c(b, l, "Generator"), c(b, a, (function () {
                return this
            })), c(b, "toString", (function () {
                return "[object Generator]"
            })), e.keys = function (t) {
                var e = Object(t),
                    n = [];
                for (var r in e) n.push(r);
                return n.reverse(),
                    function t() {
                        for (; n.length;) {
                            var r = n.pop();
                            if (r in e) return t.value = r, t.done = !1, t
                        }
                        return t.done = !0, t
                    }
            }, e.values = R, B.prototype = {
                constructor: B,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var n = this;

                    function i(r, i) {
                        return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return i("end");
                        if (a.tryLoc <= this.prev) {
                            var l = r.call(a, "catchLoc"),
                                c = r.call(a, "finallyLoc");
                            if (l && c) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            } else if (l) {
                                if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var o = i;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(a)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), g
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), g
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                T(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), g
                }
            }, e
        }

        function YE(t, e, n) {
            return (e = ex(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function KE(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a),
                    l = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(l) : Promise.resolve(l).then(r, i)
        }

        function JE(t) {
            return function () {
                var e = this,
                    n = arguments;
                return new Promise((function (r, i) {
                    var o = t.apply(e, n);

                    function a(t) {
                        KE(o, r, i, a, s, "next", t)
                    }

                    function s(t) {
                        KE(o, r, i, a, s, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }

        function ZE(t, e) {
            return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, {
                raw: {
                    value: Object.freeze(e)
                }
            }))
        }

        function tx(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, ex(r.key), r)
            }
        }

        function ex(t) {
            var e = function (t, e) {
                if ("object" != XE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(t, e);
                    if ("object" != XE(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t, "string");
            return "symbol" == XE(e) ? e : String(e)
        }

        function nx(t, e, n) {
            return e = ox(e),
                function (t, e) {
                    if (e && ("object" === XE(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, rx() ? Reflect.construct(e, [], ox(t).constructor) : e.apply(t, n))
        }

        function rx() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {})))
            } catch (t) {}
            return (rx = function () {
                return !!t
            })()
        }

        function ix() {
            return ix = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {
                var r = function (t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = ox(t)););
                    return t
                }(t, e);
                if (r) {
                    var i = Object.getOwnPropertyDescriptor(r, e);
                    return i.get ? i.get.call(arguments.length < 3 ? t : n) : i.value
                }
            }, ix.apply(this, arguments)
        }

        function ox(t) {
            return ox = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, ox(t)
        }

        function ax(t, e) {
            return ax = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, ax(t, e)
        }
        customElements.define("gui-component", jE);
        var sx = function (t) {
            function e() {
                return function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), nx(this, e)
            }
            var n, r, i;
            return function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && ax(t, e)
            }(e, t), n = e, r = [{
                key: "connectedCallback",
                value: function () {
                    var t = this;
                    ix(ox(e.prototype), "connectedCallback", this).call(this), this.sub = tf.complectation.pipe(wE(50)).subscribe((function (e) {
                        t.requestUpdate()
                    })), this.sub.add(tf.modelLoadingIndicator.subscribe((function (e) {
                        t.modelLoadingIndicator = e
                    }))), this.engine = window.engine
                }
            }, {
                key: "disconnectedCallback",
                value: function () {
                    ix(ox(e.prototype), "disconnectedCallback", this).call(this), this.sub.unsubscribe()
                }
            }, {
                key: "firstUpdated",
                value: function () {}
            }, {
                key: "getClass",
                value: function (t, e) {
                    return this.engine.options.checkOptionAdded(t, e) && (t.include && this.engine.options.checkSomeOptionInIncludeAdded(t.include, e) || !t.include) ? "picker-el picker-el__active" : t.include && !this.engine.options.checkSomeOptionInIncludeAdded(t.include, e) ? "picker-el picker-el__disabled" : "picker-el"
                }
            }, {
                key: "render",
                value: function () {
                    var t = this;
                    return Y_(HE || (HE = ZE(['\n      <div class="menu-variant">\n        ', "\n      </div>\n    "])), cf.models.samara.complectationVars[this.parent].variants.map((function (e) {
                        return Y_(zE || (zE = ZE(['<div class="picker-el__wrapper">\n              <div\n                @click="', '"\n                class=', "\n              >\n                ", "\n                ", "\n              </div>\n            </div>"])), JE(qE().mark((function n() {
                            return qE().wrap((function (n) {
                                for (;;) switch (n.prev = n.next) {
                                    case 0:
                                        cf.models.samara.complectationVars[t.parent].camera, t.engine.options.setOption(YE({}, t.parent.toLowerCase(), e.name));
                                    case 2:
                                    case "end":
                                        return n.stop()
                                }
                            }), n)
                        }))), t.getClass(e, t.parent), e.name, t.modelLoadingIndicator.isLoading && t.modelLoadingIndicator.name === e.name ? Y_(VE || (VE = ZE([' <div class="icon">\n                      <svg\n                        viewBox="0 0 50 50"\n                        xmlns="http://www.w3.org/2000/svg"\n                      >\n                        <path\n                          fill="white"\n                          d="M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z"\n                        >\n                          <animateTransform\n                            attributeType="xml"\n                            attributeName="transform"\n                            type="rotate"\n                            from="0 25 25"\n                            to="360 25 25"\n                            dur="1s"\n                            repeatCount="indefinite"\n                          />\n                        </path>\n                      </svg>\n                    </div>']))) : J_)
                    })))
                }
            }], i = [{
                key: "styles",
                get: function () {
                    return v_(WE || (WE = ZE(["\n      .picker-el {\n        color: var(--white);\n        cursor: pointer;\n        background-color: #383838;\n        border-radius: 0.5em;\n        justify-content: center;\n        align-items: center;\n        margin: 0.875em 0;\n        padding: 0.5em 1.5em;\n        display: flex;\n      }\n\n      .picker-el:hover {\n        opacity: 0.8;\n      }\n\n      .picker-el__wrapper {\n        margin-left: 0.5em;\n        margin-right: 0.5em;\n      }\n\n      .picker-el__active {\n        box-shadow: 0 0 0.5em #00b0f0;\n      }\n\n      .picker-el__disabled {\n        opacity: 0.3;\n        pointer-events: none;\n      }\n\n      .icon {\n        overflow: hidden;\n        max-width: 1em;\n        width: 1em;\n        min-width: 1em;\n        height: 1em;\n        max-height: 1em;\n        cursor: pointer;\n        padding: 0.5em;\n        position: relative;\n        border-radius: 50%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n\n        svg {\n          vertical-align: middle;\n          width: 100%;\n          height: 100%;\n        }\n      }\n    "])))
                }
            }, {
                key: "properties",
                get: function () {
                    return {
                        parent: {},
                        modelLoadingIndicator: {
                            state: !0
                        }
                    }
                }
            }], r && tx(n.prototype, r), i && tx(n, i), Object.defineProperty(n, "prototype", {
                writable: !1
            }), e
        }(gy);
        customElements.define("options-component", sx)
    })()
})();
class $t extends Dt {
    constructor(t) {
        super(), Lt(this, t, Qt, Ft, a, {
            index: 0,
            isEnabled: 1,
            shouldControlGlobalScroll: 5
        })
    }
}
const Gt = [];

function Ht(e, n = t) {
    let r;
    const i = new Set;

    function o(t) {
        if (a(e, t) && (e = t, r)) {
            const t = !Gt.length;
            for (const t of i) t[1](), Gt.push(t, e);
            if (t) {
                for (let t = 0; t < Gt.length; t += 2) Gt[t][0](Gt[t + 1]);
                Gt.length = 0
            }
        }
    }

    function s(t) {
        o(t(e))
    }
    return {
        set: o,
        update: s,
        subscribe: function (a, l = t) {
            const c = [a, l];
            return i.add(c), 1 === i.size && (r = n(o, s) || t), a(e), () => {
                i.delete(c), 0 === i.size && r && (r(), r = null)
            }
        }
    }
}

function zt(e, n, r) {
    const a = !Array.isArray(e),
        s = a ? [e] : e;
    if (!s.every(Boolean)) throw new Error("derived() expects stores as input, got a falsy value");
    const l = n.length < 2;
    return u = (e, r) => {
        let u = !1;
        const h = [];
        let d = 0,
            p = t;
        const f = () => {
                if (d) return;
                p();
                const i = n(a ? h[0] : h, e, r);
                l ? e(i) : p = o(i) ? i : t
            },
            m = s.map(((t, e) => c(t, (t => {
                h[e] = t, d &= ~(1 << e), u && f()
            }), (() => {
                d |= 1 << e
            }))));
        return u = !0, f(),
            function () {
                i(m), p(), u = !1
            }
    }, {
        subscribe: Ht(r, u).subscribe
    };
    var u
}
var Vt = {
    installationCost: {
        studio: 115e3,
        onebed: 12e4,
        twobed: 125e3,
        xl8: 155e3,
        xl10: 16e4
    },
    deliveryCost: {
        studio: 12e3,
        onebed: 14e3,
        twobed: 14e3,
        xl8: 26e3,
        xl10: 32e3
    },
    options: [{
        key: "region",
        values: [{
            key: "socal",
            display: {
                title: "Southern California",
                alternativeTitle: "Southern<br>California",
                sf_field: "GEO_c",
                sf_value: "Southern California"
            }
        }, {
            key: "nocal",
            display: {
                title: "San&nbsp;Francisco Bay&nbsp;Area",
                alternativeTitle: "San&nbsp;Francisco<br>Bay&nbsp;Area",
                sf_field: "GEO_c",
                sf_value: "San Francisco Bay Area"
            }
        }, {
            key: "rest",
            display: {
                title: "Somewhere else",
                subtitle: "Coming soon",
                sf_field: "GEO_c",
                sf_value: "Other"
            }
        }],
        display: {
            label: "Region",
            title: "Where is your Backyard going?"
        }
    }, {
        key: "layout",
        sf_field: "Unit_Layout__c",
        values: [{
            key: "studio",
            sf_value: "Studio",
            cost: 152e3,
            display: {
                title: "Studio",
                subtitle: "420 gross sq. ft.",
                primarySubtitle: "1 bath"
            }
        }, {
            key: "onebed",
            sf_value: "One Bedroom",
            cost: 17e4,
            display: {
                title: "One bedroom",
                subtitle: "540 gross sq. ft.",
                primarySubtitle: "1 bedroom, 1 bath"
            }
        }, {
            key: "twobed",
            sf_value: "Two Bedroom",
            cost: 19e4,
            display: {
                title: "Two bedroom",
                subtitle: "690 gross sq. ft.",
                primarySubtitle: "2 bedrooms, 1 bath"
            }
        }, {
            key: "xl8",
            sf_value: "XL 8",
            cost: 249e3,
            display: {
                title: "Backyard XL 8",
                subtitle: "800 gross sq. ft.",
                primarySubtitle: "2 bedrooms, 2 baths"
            }
        }, {
            key: "xl10",
            sf_value: "XL 10",
            cost: 277e3,
            display: {
                title: "Backyard XL 10",
                subtitle: "950 gross sq. ft.",
                primarySubtitle: "2 bedrooms, 2 baths"
            }
        }],
        display: {
            label: "Layout",
            title: "Choose your layout"
        }
    }, {
        key: "cladding",
        sf_field: "Base_Material__c",
        values: [{
            key: "cement",
            sf_value: "Fiber Cement - Vertical",
            display: {
                title: "Fiber cement",
                subtitle: "Durable and weather resistant",
                list: ['Vertical 7" panels with V-groove', "Five standard colors or custom color", "Fire-, moisture-, and rot-resistant"]
            }
        }, {
            key: "metal",
            sf_value: "Insulated Metal Panel",
            cost: ({
                layout: t
            }) => ({
                studio: 23500,
                onebed: 27500,
                twobed: 32e3,
                xl8: 45e3,
                xl10: 5e4
            } [t]),
            display: {
                title: "Smooth-coated steel",
                subtitle: "Lustrous and maintenance-free",
                list: ['Horizontal 24" smooth-coated steel insulated panels', "Three standard colors plus two premium colors", "Easy to clean and never needs to be painted", "Fire-, moisture-, and rot-resistant"]
            }
        }],
        display: {
            label: "Exterior material",
            title: "Choose your cladding material"
        }
    }, {
        key: "color",
        sf_field: "Base_Color_Selection__c",
        values: [{
            key: "base-bonewhite",
            sf_value: "Bone White",
            display: {
                title: "Bone white",
                description: "A warm and simple white. Classic."
            }
        }, {
            key: "base-driftwood",
            sf_value: "Driftwood",
            display: {
                title: "Driftwood",
                description: "A flexible and serene gray with cool undertones."
            }
        }, {
            key: "base-parchment",
            sf_value: "Parchment",
            display: {
                title: "Parchment",
                description: "An inviting, earthy beige. Like stucco."
            }
        }, {
            key: "base-evergreen",
            sf_value: "Evergreen",
            cost: ({
                cladding: t
            }) => ({
                cement: 0,
                metal: 5e3
            } [t]),
            display: {
                title: "Evergreen",
                description: "A deep and vibrant green with a hint of earthiness."
            }
        }, {
            key: "base-dark-bronze",
            sf_value: "Dark Bronze",
            cost: ({
                cladding: t
            }) => ({
                cement: 0,
                metal: 5e3
            } [t]),
            display: {
                title: "Dark bronze",
                description: "Rich and warm. Most definitely not black."
            }
        }, {
            key: "custom",
            sf_value: "Custom (Fiber Cement Only)",
            cost: ({
                layout: t
            }) => t?.startsWith("xl") ? 4e3 : 3e3,
            conditions: {
                cladding: t => "cement" === t
            },
            display: {
                title: "Custom color",
                subtitle: "Not shown and specified later"
            }
        }],
        display: {
            label: "Cladding color",
            title: "Choose your cladding color"
        }
    }, {
        key: "roof",
        sf_field: "Roof_Color__c",
        values: [{
            key: "roof-dark-bronze",
            sf_value: "Dark Bronze",
            display: {
                title: "Dark bronze",
                description: "Extremely versatile, deep and muted."
            }
        }, {
            key: "roof-metallic-silver",
            sf_value: "Silver",
            cost: 2500,
            display: {
                title: "Metallic silver",
                description: "Slightly warm with a subtle fleck."
            }
        }],
        display: {
            label: "Roof",
            title: "Choose your roof color"
        }
    }, {
        key: "floor",
        sf_field: "Floor_Option__c",
        values: [{
            key: "floor-natural-oak",
            sf_value: "Natural oak",
            display: {
                title: "Natural oak",
                description: "Waterproof stone composite flooring with a warm, honest character and visible grain."
            }
        }, {
            key: "floor-dark-oak",
            sf_value: "Dark oak",
            cost: 1e3,
            display: {
                title: "Dark oak",
                description: "Waterproof stone composite flooring with a rich depth that anchors the space."
            }
        }],
        display: {
            label: "Flooring",
            title: "Choose your floor color"
        }
    }, {
        key: "kitchen-cabinet-finish",
        sf_field: "Kitchen_Cabinet_Finish__c",
        values: [{
            key: "kitchen-cabinet-bone-white",
            sf_value: "Bone white",
            display: {
                title: "Bone white",
                description: "Clean and unobtrusive. Emphasizes depth."
            }
        }, {
            key: "kitchen-cabinet-natural-oak",
            sf_value: "Natural oak",
            cost: 5e3,
            display: {
                title: "Natural oak",
                description: "Brings tactile warmth. Intentionally unfussy."
            }
        }],
        display: {
            label: "Kitchen cabinet finish",
            title: "Choose your kitchen cabinet finish"
        }
    }, {
        key: "entry",
        sf_field: "Studio_Entry__c",
        conditions: {
            layout: t => "studio" === t
        },
        values: [{
            key: "entry-side",
            sf_value: "Side Entry",
            display: {
                title: "Side entry",
                summaryLabel: "Side entry",
                subtitle: "Enter through the hallway"
            }
        }, {
            key: "entry-front",
            sf_value: "Front Entry",
            cost: 3e3,
            display: {
                title: "Front entry",
                summaryLabel: "Front entry",
                subtitle: "Enter directly into the living area"
            }
        }],
        display: {
            label: "Entry",
            title: "Choose your entrance location",
            camera: "right-angle"
        }
    }, {
        key: "front",
        sf_field: "Front_Option__c",
        conditions: {
            entry: t => void 0 === t || "entry-side" === t
        },
        values: [{
            key: "front-window",
            sf_value: "Casement Window",
            display: {
                title: "Casement window",
                summaryLabel: "Front casement window",
                subtitle: "3'&thinsp;×&thinsp;5'"
            }
        }, {
            key: "front-doors",
            sf_value: "Double Doors",
            cost: 7e3,
            installationCost: 4e3,
            display: {
                title: "Double doors",
                summaryLabel: "Front double doors",
                subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
            }
        }],
        display: {
            label: "Front",
            title: "Choose your front window&nbsp;or&nbsp;doors",
            camera: "right-angle"
        }
    }, {
        key: "left",
        sf_field: "Side_Option__c",
        conditions: {
            layout: t => !1 === t?.startsWith("xl")
        },
        values: [{
            key: "side-window",
            sf_value: "Casement Window",
            display: {
                title: "Casement Window",
                summaryLabel: "Left side casement window",
                subtitle: "3'&thinsp;×&thinsp;5'"
            }
        }, {
            key: "side-doors",
            sf_value: "Double Doors",
            cost: 7e3,
            installationCost: 4e3,
            display: {
                title: "Double doors",
                summaryLabel: "Left side double doors",
                subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
            }
        }],
        display: {
            label: "Left side",
            title: ({
                layout: t
            }) => "twobed" === t ? "Choose your secondary bedroom window&nbsp;or&nbsp;doors" : "Choose your living room window&nbsp;or&nbsp;doors",
            camera: "left-angle"
        }
    }, {
        key: "xl-living-room-side",
        sf_field: "Side_Option__c",
        conditions: {
            layout: t => !0 === t?.startsWith("xl")
        },
        values: [{
            key: "window",
            sf_value: "Casement Window",
            display: {
                title: "Casement window",
                summaryLabel: "Living room casement window",
                subtitle: "3'&thinsp;×&thinsp;5'"
            }
        }, {
            key: "doors",
            sf_value: "Double Doors",
            cost: 7e3,
            installationCost: 4e3,
            display: {
                title: "Double doors",
                summaryLabel: "Living room double doors",
                subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
            }
        }],
        display: {
            label: "Living room side",
            title: "Choose your living room window&nbsp;or&nbsp;doors",
            camera: "right-angle"
        }
    }, {
        key: "xl-primary-bedroom-side",
        sf_field: "Primary_Bedroom_Option__c",
        conditions: {
            layout: t => !0 === t?.startsWith("xl")
        },
        values: [{
            key: "window",
            sf_value: "Casement Window",
            display: {
                title: "Casement window",
                summaryLabel: "Primary bedroom casement window",
                subtitle: "3'&thinsp;×&thinsp;5'"
            }
        }, {
            key: "doors",
            sf_value: "Double Doors",
            cost: 7e3,
            installationCost: 4e3,
            display: {
                title: "Double doors",
                summaryLabel: "Primary bedroom double doors",
                subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
            }
        }],
        display: {
            label: "Primary bedroom room side",
            title: "Choose your primary bedroom window&nbsp;or&nbsp;doors",
            camera: ({
                layout: t
            }) => "xl8" === t ? "left-angle" : "right-angle-back"
        }
    }, {
        key: "xl-secondary-bedroom-side",
        sf_field: "Secondary_Bedroom_Option__c",
        conditions: {
            layout: t => t?.startsWith("xl")
        },
        values: [{
            key: "window",
            sf_value: "Casement Window",
            display: {
                title: "Casement window",
                summaryLabel: "Secondary bedroom casement window",
                subtitle: "3'&thinsp;×&thinsp;5'"
            }
        }, {
            key: "doors",
            sf_value: "Double Doors",
            cost: 7e3,
            installationCost: 4e3,
            display: {
                title: "Double doors",
                summaryLabel: "Secondary bedroom double doors",
                subtitle: "<nobr>3'&thinsp;×&thinsp;6'8\"</nobr> glass doors"
            }
        }],
        display: {
            label: "Secondary bedroom room side",
            title: "Choose your secondary bedroom window&nbsp;or&nbsp;doors",
            camera: ({
                layout: t
            }) => "xl8" === t ? "right-angle" : "right-angle-back"
        }
    }, {
        key: "solar",
        sf_field: "Solar_Option__c",
        values: [{
            key: "solar-no",
            sf_value: "No Solar",
            display: {
                title: "No solar",
                summaryLabel: "None",
                subtitle: "Power with the grid",
                description: "No solar"
            }
        }, {
            key: "solar-half",
            sf_value: "Half Solar",
            cost: ({
                layout: t
            }) => ({
                studio: 8100,
                onebed: 10200,
                twobed: 13500,
                xl8: 11e3,
                xl10: 13e3
            } [t]),
            display: {
                title: ({
                    layout: t
                }) => t?.startsWith("xl") ? "Half solar array" : "Solar array",
                subtitle: ({
                    layout: t
                }) => t?.startsWith("xl") ? "Offset your energy usage" : "Go net zero&thinsp;¹",
                summaryLabel: "Half solar array",
                description: ({
                    layout: t
                }) => "studio" === t ? "7-panel, 2.5 kW DC photovoltaic system" : "onebed" === t ? "9-panel, 3.4 kW DC photovoltaic system" : "12-panel, 4.5 kW DC photovoltaic system"
            }
        }, {
            key: "solar-full",
            sf_value: "Full Solar",
            cost: ({
                layout: t
            }) => ({
                studio: 16200,
                onebed: 20400,
                twobed: 27e3,
                xl8: 22e3,
                xl10: 26500
            } [t]),
            conditions: {
                layout: t => t?.startsWith("xl")
            },
            display: {
                title: "Full solar array",
                subtitle: ({
                    layout: t
                }) => t?.startsWith("xl") ? "Go net zero&thinsp;¹" : "Offset even more energy usage",
                summaryLabel: "Full solar array",
                description: ({
                    layout: t
                }) => "studio" === t ? "14-panel, 5.3 kW DC photovoltaic system" : "onebed" === t ? "18-panel, 6.8 kW DC photovoltaic system" : "24-panel, 9.1 kW DC photovoltaic system"
            }
        }],
        display: {
            label: "Solar",
            title: "Add solar panels",
            camera: "roof"
        }
    }, {
        key: "powerwall",
        sf_field: "Powerwall__c",
        conditions: {
            solar: t => "solar-no" !== t
        },
        values: [{
            key: "standard",
            sf_value: "Standard",
            display: {
                title: "Standard"
            }
        }, {
            key: "powerwall",
            sf_value: "Tesla Powerwall 3",
            cost: 2e4,
            display: {
                title: "Tesla Powerwall 3",
                subtitle: t => "solar-no" === t.solar ? "Available with solar array" : "Use your clean energy 24/7"
            }
        }],
        display: {
            label: "Tesla Powerwall 3",
            title: "Tesla Powerwall 3",
            camera: ({
                layout: t
            }) => "xl10" === t ? "left-back" : "left-angle-back"
        }
    }, {
        key: "kitchen-layout",
        sf_field: "Kitchen_Layout__c",
        conditions: {
            layout: t => "xl10" === t
        },
        values: [{
            key: "standard",
            sf_value: "Standard",
            display: {
                title: "Standard kitchen layout",
                subtitle: "Bring your own dining table"
            }
        }, {
            key: "island",
            sf_value: "Kitchen island",
            cost: 5e3,
            display: {
                title: "Kitchen with island",
                subtitle: "Add counter and storage space"
            }
        }],
        display: {
            label: "Kitchen layout",
            title: "Choose your kitchen layout"
        }
    }, {
        key: "kitchen-cooler",
        sf_field: "Kitchen_Cooler__c",
        conditions: {
            layout: t => "xl10" === t,
            "kitchen-layout": t => "island" === t
        },
        values: [{
            key: "standard",
            sf_value: "Standard"
        }, {
            key: "island",
            sf_value: "Wine and beverage cooler",
            cost: 2500,
            display: {
                title: "Wine and beverage cooler",
                subtitle: t => "island" === t["kitchen-layout"] ? "Chill your Barolo perfectly" : "Available with kitchen island"
            }
        }],
        display: {
            title: "Wine and beverage cooler",
            label: "Wine and beverage cooler"
        }
    }, {
        key: "primary-bedroom-wardrobe",
        sf_field: "Primary_Bedroom_Wardrobe__c",
        conditions: {
            layout: t => "onebed" === t || "twobed" === t
        },
        values: [{
            key: "standard",
            sf_value: "Standard",
            display: {
                title: "Standard wardrobe"
            }
        }, {
            key: "full",
            sf_value: "Full Width",
            cost: 1750,
            display: {
                title: "Full-width wardrobe",
                summaryLabel: "Primary bedroom full wardrobe",
                subtitle: "Spans the entire wall"
            }
        }],
        display: {
            title: "Choose storage for this bedroom"
        }
    }, {
        key: "secondary-bedroom-wardrobe",
        sf_field: "Secondary_Bedroom_Wardrobe__c",
        conditions: {
            layout: t => "twobed" === t
        },
        values: [{
            key: "standard",
            sf_value: "Standard",
            display: {
                title: "Standard wardrobe"
            }
        }, {
            key: "full",
            sf_value: "Full Width",
            cost: 1750,
            display: {
                title: "Full-width wardrobe",
                summaryLabel: "Secondary bedroom full wardrobe",
                subtitle: "Spans the entire wall"
            }
        }],
        display: {
            title: "Choose storage for this bedroom"
        }
    }, {
        key: "bathroom-accessibility-kit",
        sf_field: "Bathroom_Accessibility_Kit__c",
        values: [{
            key: "standard",
            sf_value: "Standard",
            display: {
                title: "Standard"
            }
        }, {
            key: "bathroom-accessibility-kit",
            sf_value: "Bathroom accessibility kit",
            display: {
                title: "Bathroom accessibility kit",
                subtitle: "Enhance safety and ease of use",
                cost: "Free"
            }
        }],
        display: {
            title: "Bathroom accessibility kit"
        }
    }, {
        key: "interior-blinds",
        sf_field: "Blinds__c",
        values: [{
            key: "standard",
            sf_value: "No blinds",
            display: {
                title: "Standard"
            }
        }, {
            key: "blinds-roller",
            sf_value: "Rolling blinds",
            installationCost: t => ({
                studio: 1500,
                onebed: 1750,
                twobed: 2e3,
                xl8: 2250,
                xl10: 2500
            } [t.layout] + ("side-doors" === t.left ? 300 : 0) + ("entry-front" === t.entry || "front-doors" === t.front ? 300 : 0) + ("doors" === t["xl-living-room-side"] ? 300 : 0) + ("doors" === t["xl-primary-bedroom-side"] ? 300 : 0) + ("doors" === t["xl-secondary-bedroom-side"] ? 300 : 0)),
            display: {
                title: "Roller blinds",
                subtitle: "More privacy without losing light"
            }
        }],
        display: {
            title: "Blinds"
        }
    }]
};
const Wt = ["interior-blinds", "kitchen-pantry", "kitchen-cooler", "bathroom-accessibility-kit"],
    jt = {
        ...Vt.options.reduce(((t, e) => Wt.includes(e.key) ? t : {
            ...t,
            [e.key]: e.values.length > 1 ? e.values[0].key : void 0
        }), {}),
        layout: "onebed",
        solar: "solar-no"
    },
    Xt = {
        "base-bonewhite": {
            name: "Bone white base",
            hex: 16580093
        },
        "base-parchment": {
            name: "Parchment base",
            hex: 14736851
        },
        "base-driftwood": {
            name: "Driftwood base",
            hex: 14475231
        },
        "base-evergreen": {
            name: "Evergreen base",
            hex: 3426105
        },
        "base-dark-bronze": {
            name: "Dark bronze base",
            hex: 4341304
        },
        "roof-metallic-silver": {
            name: "Metallic Silver Roof",
            hex: 15527148
        },
        "roof-dark-bronze": {
            name: "Dark Bronze Roof",
            hex: 3091755
        },
        "floor-natural-oak": {
            name: "Natural oak",
            hex: 13873533
        },
        "floor-dark-oak": {
            name: "Dark oak",
            hex: 4404780
        },
        "kitchen-cabinet-bone-white": {
            name: "Bone white kitchen cabinet finish",
            hex: 16580093
        },
        "kitchen-cabinet-natural-oak": {
            name: "Natural oak kitchen cabinet finish",
            hex: 13873533
        }
    },
    qt = Vt;

function Yt(t) {
    const e = qt.options.find((e => e.key === t));
    return void 0 === e && "undefined" != typeof Sentry && Sentry.captureException(`can't find option with key "${t}"`), e
}

function Kt(t, e) {
    return e ? e.values.find((e => e.key === t)) : null
}

function Jt(t, e) {
    return Kt(e, Yt(t))
}

function Zt(t) {
    return qt.options.filter((e => !e.conditions || Object.entries(e.conditions).every((([e, n]) => n(t[e]))))).map((e => ({
        ...e,
        values: e.values.filter((e => !e.conditions || Object.entries(e.conditions).every((([e, n]) => n(t[e])))))
    })))
}

function te(t) {
    const e = {
        ...jt,
        ...t
    };
    return Zt(e).reduce(((n, r) => {
        if (Wt.includes(r.key) && void 0 === e[r.key]) return n;
        const i = r.values.some((e => e.key === t[r.key])) ? t[r.key] : jt[r.key];
        return {
            ...n,
            [r.key]: i,
            region: e.region
        }
    }), {})
}

function ee(t) {
    const e = Zt({
        ...jt,
        ...t
    }).map((({
        key: t
    }) => t));
    return Object.fromEntries(Object.entries(t).filter((([t, n]) => n && e.includes(t))).map((([e, n]) => {
        const r = Yt(e).display.title || "Add-on",
            i = Jt(e, n).display.title;
        return [("function" == typeof r ? r(t) : r).replace("Choose your ", ""), ("function" == typeof i ? i(t) : i).replace(/<[^>]*>/g, "")]
    })).map((([t, e]) => [t.slice(0, 1).toUpperCase() + t.slice(1), e])))
}
const ne = function () {
    const {
        set: t,
        update: e,
        subscribe: n
    } = Ht({});
    return {
        subscribe: n,
        set(e) {
            t({
                ...e
            })
        },
        reset() {
            t({})
        },
        select(t, n) {
            gtag("event", `configurator_option_${t}_${n}`), e((e => te({
                ...jt,
                ...e,
                [t]: n
            })))
        }
    }
}();

function re(t, e, n, r) {
    let i = 0;
    const o = Jt(n, e);
    if (!o) return i;
    if (Number.isFinite(o[t])) i += o[t];
    else if (o[t]) {
        const e = o[t](te(r));
        e && (i += e)
    }
    return i
}

function ie(t) {
    const e = te(t),
        n = Object.entries(e).reduce(((t, [n, r]) => t + function (t, e, n) {
            return re("cost", t, e, n)
        }(r, n, e)), 0),
        r = Vt.installationCost[e.layout] + Vt.deliveryCost[e.layout] + Object.entries(e).reduce(((t, [n, r]) => t + function (t, e, n) {
            return re("installationCost", t, e, n)
        }(r, n, e)), 0);
    return {
        total: n + r,
        installation: r,
        base: n
    }
}
const oe = zt([ne], (([t]) => ie(t))),
    ae = (() => {
        try {
            const t = "__storage_test";
            return window.localStorage.setItem(t, null), window.localStorage.removeItem(t), !0
        } catch (t) {
            return !1
        }
    })();
var se = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function le(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var ce, ue, he, de = {
    exports: {}
};
ce = de, ue = "undefined" != typeof self ? self : se, he = function () {
    const t = new Uint8Array([0, 0, 0, 0, 0, 34, 53, 53, 54, 53, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 39, 39, 31, 31, 31, 31, 31, 31, 31, 31, 31, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 46, 46, 46, 46, 46, 19, 46, 46, 46, 46, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 55, 55, 55, 55, 55, 55, 55, 55, 55, 0, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 8, 8, 8, 51, 45, 51, 51, 51, 20, 20, 20, 20, 20, 20, 20, 20, 0, 20, 20, 20, 20, 20, 20, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 0, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 56, 9, 9, 0, 9, 0, 9, 9, 0, 9, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 10, 10, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 48, 48, 48, 0, 48, 48, 0, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 23, 23, 0, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 0, 51, 41, 41, 41, 41, 41, 41, 41, 41, 0, 0, 28, 28, 28, 28, 28, 28, 28, 28, 28, 0, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 0, 14, 14, 14, 14, 14, 14, 14, 14, 24, 24, 0, 24, 24, 24, 24, 24, 24, 24, 24, 24, 0, 0, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 0, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 29, 29, 0, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 0, 0, 0, 0, 0, 0, 18, 18, 0, 18, 18, 18, 18, 18, 18, 0, 18, 18, 18, 18, 18, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 36, 36, 0, 43, 36, 36, 36, 36, 36, 36, 36, 36, 0, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 13, 13, 13, 13, 13, 13, 13, 0, 44, 44, 44, 44, 44, 44, 44, 44, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 0, 0, 0, 0, 33, 33, 0, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 43, 0, 0, 0, 30, 30, 30, 0, 30, 30, 30, 0, 30, 30, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 57, 57, 57, 57, 57, 11, 11, 52, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 47, 47, 47, 47, 47, 47, 47, 0, 47, 47, 47, 47, 47, 47, 47, 1, 1, 1, 1, 1]),
        e = [null, "AK", "AL", "AR", "AZ", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "IA", "ID", "IL", "IN", "KS", "KY", "LA", "MA", "MD", "ME", "MI", "MN", "MO", "MS", "MT", "NC", "ND", "NE", "NV", "NH", "NJ", "NM", "NY", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VA", "VT", "WA", "WI", "WV", "WY", "DC", "GU", "PR", "VI", "AE", "AA", "AP", "AS", "PW", "FM", "MP", "MH"],
        n = {
            20500: 51,
            20501: 51,
            20502: 51,
            20503: 51,
            20504: 51,
            20505: 51,
            20506: 51,
            20507: 51,
            20508: 51,
            20509: 51,
            20510: 51,
            20511: 51,
            20515: 51,
            20520: 51,
            20521: 51,
            20522: 51,
            20523: 51,
            20524: 51,
            20525: 51,
            20526: 51,
            20527: 51,
            20528: 51,
            20529: 51,
            20530: 51,
            20531: 51,
            20532: 51,
            20533: 51,
            20534: 51,
            20535: 51,
            20536: 51,
            20537: 51,
            20538: 51,
            20539: 51,
            20540: 51,
            20541: 51,
            20542: 51,
            20543: 51,
            20544: 51,
            20546: 51,
            20547: 51,
            20548: 51,
            20549: 51,
            20551: 51,
            20552: 51,
            20553: 51,
            20554: 51,
            20555: 51,
            20557: 51,
            20558: 51,
            20559: 51,
            20560: 51,
            20565: 51,
            20566: 51,
            20570: 51,
            20571: 51,
            20572: 51,
            20573: 51,
            20575: 51,
            20576: 51,
            20577: 51,
            20578: 51,
            20579: 51,
            20580: 51,
            20581: 51,
            20585: 51,
            20586: 51,
            20590: 51,
            20591: 51,
            20593: 51,
            20594: 51,
            20597: 51,
            20598: 45,
            20599: 51,
            72643: 24,
            73960: 43,
            83414: 50,
            96799: 58,
            96939: 59,
            96940: 59,
            96941: 60,
            96942: 60,
            96943: 60,
            96944: 60,
            96950: 61,
            96951: 61,
            96952: 61,
            96960: 62,
            96970: 62,
            "06390": 34
        };
    return function (r) {
        let i;
        if (r = r.slice(0, 5), n[r]) i = n[r];
        else {
            const e = parseInt(r.slice(0, 3));
            i = t[e]
        }
        return e[i] || null
    }
}, ce.exports ? (ce.exports = he(), ce.exports.default = ce.exports) : ue.zipState = he();
var pe = le(de.exports);
const fe = {
    AL: "Alabama",
    AK: "Alaska",
    AS: "American Samoa",
    AZ: "Arizona",
    AR: "Arkansas",
    CA: "California",
    CO: "Colorado",
    CT: "Connecticut",
    DE: "Delaware",
    DC: "District Of Columbia",
    FM: "Federated States Of Micronesia",
    FL: "Florida",
    GA: "Georgia",
    GU: "Guam",
    HI: "Hawaii",
    ID: "Idaho",
    IL: "Illinois",
    IN: "Indiana",
    IA: "Iowa",
    KS: "Kansas",
    KY: "Kentucky",
    LA: "Louisiana",
    ME: "Maine",
    MH: "Marshall Islands",
    MD: "Maryland",
    MA: "Massachusetts",
    MI: "Michigan",
    MN: "Minnesota",
    MS: "Mississippi",
    MO: "Missouri",
    MT: "Montana",
    NE: "Nebraska",
    NV: "Nevada",
    NH: "New Hampshire",
    NJ: "New Jersey",
    NM: "New Mexico",
    NY: "New York",
    NC: "North Carolina",
    ND: "North Dakota",
    MP: "Northern Mariana Islands",
    OH: "Ohio",
    OK: "Oklahoma",
    OR: "Oregon",
    PW: "Palau",
    PA: "Pennsylvania",
    PR: "Puerto Rico",
    RI: "Rhode Island",
    SC: "South Carolina",
    SD: "South Dakota",
    TN: "Tennessee",
    TX: "Texas",
    UT: "Utah",
    VT: "Vermont",
    VI: "Virgin Islands",
    VA: "Virginia",
    WA: "Washington",
    WV: "West Virginia",
    WI: "Wisconsin",
    WY: "Wyoming"
};

function me() {
    return Math.random().toString(32).substr(2, 5)
}
const ge = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|.(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    Ae = /(^\d{5}$)|(^\d{5}-\d{4}$)/,
    ve = /^(\+\d{1,2}\s)?\(?\d{3}\)?[\s.-]\d{3}[\s.-]\d{4}$/;

function _e() {
    window.dispatchEvent(new Event("modal:did-change-content"))
}
const ye = {
    page: "home",
    variant: 40,
    messageStep: 10,
    scheduleStep: 20,
    helloStep: 10,
    expandStep: 50,
    showroomStep: 10,
    isLoading: !1,
    data: {}
};
const Ee = function (t, e, n = (t => t)) {
    if (!ae) return e;
    let r, i = Date.now();

    function o() {
        const n = JSON.stringify(u(e));
        n && (localStorage.setItem("v7:" + t, n), i = Date.now())
    }
    window.addEventListener("visibilitychange", o), window.addEventListener("pagehide", o), e.subscribe((() => {
        clearTimeout(r), Date.now() - i > 0 ? o() : r = setTimeout(o, 0)
    }));
    const a = localStorage.getItem("v7:" + t);
    if (a) {
        const t = a;
        let r;
        try {
            r = n(JSON.parse(t))
        } catch (t) {
            console.warn("failed to load store", t.message)
        }
        r && e.set(r)
    }
    return e
}("contact:v5", function (t, e, n = (t => t)) {
    const r = me();
    let i = me();
    return window.addEventListener(`store:sync:${t}`, (function (t) {
        t.detail.id !== r && t.detail.version !== i && (i = t.detail.version, e.update((e => ({
            ...e,
            ...n(t.detail.state)
        })), !0))
    })), {
        ...e,
        update(n, o) {
            e.update((e => {
                const a = n(e);
                if (!0 !== o) {
                    i = me();
                    const e = new CustomEvent(`store:sync:${t}`, {
                        detail: {
                            state: a,
                            id: r,
                            version: i
                        }
                    });
                    setTimeout((() => {
                        window.dispatchEvent(e)
                    }), 0)
                }
                return a
            }))
        }
    }
}("contact", function () {
    const t = new URLSearchParams(location.search);
    Object.entries({
        utm_campaign: "utmCampaign",
        utm_source: "utmSource",
        utm_term: "utmTerm",
        gclid: "gclid"
    }).forEach((([e, n]) => {
        t.has(e) && (ye.data[n] = t.get(e))
    }));
    const {
        update: e,
        subscribe: n,
        set: r
    } = Ht(ye);
    return {
        subscribe: n,
        update: e,
        set: r,
        variant(t, n = {}) {
            e((e => ({
                ...e,
                variant: t,
                data: {
                    ...e.data,
                    ...n
                }
            })))
        },
        openPage(t) {
            e((e => ({
                ...e,
                page: t,
                isLoading: !1
            }))), _e(), gtag("event", `contact_page_${t}`)
        },
        openStep(t) {
            e((e => ({
                ...e,
                [`${e.page}Step`]: t,
                [`${e.page}StepChangedAt`]: Date.now(),
                isLoading: !1
            }))), _e()
        },
        openMessageStep(t) {
            this.openStep(t)
        },
        openScheduleStep(t) {
            this.openStep(t)
        },
        openHelloStep(t) {
            this.openStep(t)
        },
        openExpandStep(t) {
            this.openStep(t)
        },
        openShowroomStep(t) {
            this.openStep(t)
        },
        loading() {
            e((t => ({
                ...t,
                isLoading: !0
            })))
        },
        resetData() {
            e((t => ({
                ...t,
                data: {}
            })))
        }
    }
}(), xe), xe);

function xe(t) {
    return {
        ...t,
        messageStep: ye.messageStep,
        scheduleStep: ye.scheduleStep,
        helloStep: ye.helloStep,
        expandStep: ye.expandStep,
        showroomStep: ye.showroomStep,
        data: {
            ...t.data,
            slot: void 0,
            message: void 0
        }
    }
}
Ee.updateData = function (t, e) {
    Ee.update((n => {
        const r = {
            ...n.data,
            [t]: e
        };
        if ("address" === t || "zip" === t || "street" === t || "city" === t) {
            let {
                street: t,
                city: e,
                zip: n
            } = r;
            if (t && e && n) {
                const i = function (t) {
                    return fe[pe(t)]
                }(n.toString());
                t = t.replace(new RegExp(i, "ig"), "").replace(new RegExp(e, "ig"), "").replace(new RegExp(n, "ig"), "").replace(/ {2,}/g, " ").replace(/ ,/g, ","), r.address = i ? `${t}, ${e}, ${i} ${n}` : `${t}, ${e}, ${n}`
            }
        }
        return {
            ...n,
            data: r
        }
    }))
};
const be = 1e3;
let we = 0;
async function Ce(t) {
    let e;
    we = Date.now();
    try {
        e = await API.orderUpdate(t, JSON.stringify({
            configuration: u(ne),
            ...u(Ee).data
        }))
    } catch (t) {
        if (t instanceof TypeError && "Load failed" === t.message) return void console.log("Order update failed due to network issue");
        console.error("failed to update order", t)
    }
}

function Se(t) {
    Date.now() - we < be ? setTimeout(Ce, be, t) : Ce(t)
}
async function Ie(t) {
    try {
        const e = await API.orderBegin(),
            {
                session_id: n
            } = await e.json();
        t((t => ({
            ...t,
            id: n,
            isLoading: !1
        })))
    } catch (e) {
        t((t => ({
            ...t,
            isLoading: !1
        })))
    }
}

function Me(t) {
    t((t => ({
        ...t,
        isLoading: !0
    })));
    const [, e] = location.pathname.match(/\/backyard\/configure\/([a-z]{8})/) || [];
    if (e) return async function (t, e) {
        const n = await API.orderFetchBySessionId(t);
        if (200 !== n.status) return Ie(e); {
            const r = await n.json();
            ne.set({
                ...jt,
                ...r.configuration
            }), e((e => ({
                ...e,
                id: t,
                isLoading: !1
            })))
        }
    }(e, t);
    if (ne.set({
            ...jt
        }), document.location.hash) {
        let [t, e] = document.location.hash.slice(1).split("+");
        e = e.replace("-", ""), "xl" === e && (e = "xl8"), ne.select("layout", e), ne.select("color", `base-${t}`)
    }
    return Ie(t)
}
const Te = function () {
    const t = {
            isLoading: !0
        },
        e = Ht({
            ...t
        }),
        {
            update: n,
            subscribe: r,
            set: i
        } = e,
        o = [];
    return {
        subscribe: r,
        reset() {
            i({
                ...t
            })
        },
        async start() {
            try {
                await Me(n)
            } catch (t) {
                console.warn("failed to start session", t)
            }
            if (!0 !== location.pathname.startsWith("/backyard/configure")) return;
            const {
                id: t
            } = u(e);
            void 0 !== t && (o.push(ne.subscribe((() => {
                Se(t)
            }))), o.push(Ee.subscribe((() => {
                Se(t)
            }))), history.replaceState(null, null, `/backyard/configure/${t}`))
        },
        finalize(t) {
            n((e => ({
                ...e,
                slug: t
            }))), history.replaceState(null, null, "/backyard/configure"), o.forEach((t => {
                t()
            }))
        }
    }
}();

function Be(t) {
    let e = t;
    !1 === Number.isFinite(e) && (e = 0);
    return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
    }).format(e)
}

function Re(t) {
    let e, n, r, i, o, a, s, l = t[3][0] + "",
        c = t[3].length > 1 && De(t);
    return {
        c() {
            e = L("span"), n = P(t[4]), r = O(), i = L("span"), o = P(l), a = O(), c && c.c(), s = k(), N(e, "class", "configurator-variant-cost-sign svelte-1yt8uwp"), N(i, "class", "configurator-variant-cost-component svelte-1yt8uwp")
        },
        m(t, l) {
            T(t, e, l), S(e, n), T(t, r, l), T(t, i, l), S(i, o), T(t, a, l), c && c.m(t, l), T(t, s, l)
        },
        p(t, e) {
            16 & e && F(n, t[4]), 8 & e && l !== (l = t[3][0] + "") && F(o, l), t[3].length > 1 ? c ? c.p(t, e) : (c = De(t), c.c(), c.m(s.parentNode, s)) : c && (c.d(1), c = null)
        },
        d(t) {
            t && (B(e), B(r), B(i), B(a), B(s)), c && c.d(t)
        }
    }
}

function Le(t) {
    let e, n = t[0].display.cost + "";
    return {
        c() {
            e = P(n)
        },
        m(t, n) {
            T(t, e, n)
        },
        p(t, r) {
            1 & r && n !== (n = t[0].display.cost + "") && F(e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function De(t) {
    let e, n, r, i, o, a, s, l = t[3][1] + "",
        c = t[1] && Pe(),
        u = t[1] && Oe(t);
    return {
        c() {
            e = L("span"), e.textContent = ",", n = O(), c && c.c(), r = O(), i = L("span"), o = P(l), a = O(), u && u.c(), s = k(), N(e, "class", "configurator-variant-cost-delimiter configurator-variant-cost-delimiter-full svelte-1yt8uwp"), N(i, "class", "configurator-variant-cost-component configurator-variant-cost-component-full svelte-1yt8uwp")
        },
        m(t, l) {
            T(t, e, l), T(t, n, l), c && c.m(t, l), T(t, r, l), T(t, i, l), S(i, o), T(t, a, l), u && u.m(t, l), T(t, s, l)
        },
        p(t, e) {
            t[1] ? c || (c = Pe(), c.c(), c.m(r.parentNode, r)) : c && (c.d(1), c = null), 8 & e && l !== (l = t[3][1] + "") && F(o, l), t[1] ? u ? u.p(t, e) : (u = Oe(t), u.c(), u.m(s.parentNode, s)) : u && (u.d(1), u = null)
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(a), B(s)), c && c.d(t), u && u.d(t)
        }
    }
}

function Pe(t) {
    let e;
    return {
        c() {
            e = L("span"), e.textContent = ".", N(e, "class", "configurator-variant-cost-delimiter configurator-variant-cost-delimiter-short svelte-1yt8uwp")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Oe(t) {
    let e, n, r = t[3][1].replace(/00$/, "k") + "";
    return {
        c() {
            e = L("span"), n = P(r), N(e, "class", "configurator-variant-cost-component configurator-variant-cost-component-short svelte-1yt8uwp")
        },
        m(t, r) {
            T(t, e, r), S(e, n)
        },
        p(t, e) {
            8 & e && r !== (r = t[3][1].replace(/00$/, "k") + "") && F(n, r)
        },
        d(t) {
            t && B(e)
        }
    }
}

function ke(e) {
    let n;

    function r(t, e) {
        return t[0].display.cost ? Le : t[3] ? Re : void 0
    }
    let i = r(e),
        o = i && i(e);
    return {
        c() {
            n = L("div"), o && o.c(), N(n, "class", "configurator-variant-cost type-12 color-text-60 svelte-1yt8uwp"), H(n, "configurator-variant-cost-visible", !e[2]), H(n, "configurator-variant-cost-hidden", e[2]), H(n, "configurator-variant-cost-short", e[1])
        },
        m(t, e) {
            T(t, n, e), o && o.m(n, null)
        },
        p(t, [e]) {
            i === (i = r(t)) && o ? o.p(t, e) : (o && o.d(1), o = i && i(t), o && (o.c(), o.m(n, null))), 4 & e && H(n, "configurator-variant-cost-visible", !t[2]), 4 & e && H(n, "configurator-variant-cost-hidden", t[2]), 2 & e && H(n, "configurator-variant-cost-short", t[1])
        },
        i: t,
        o: t,
        d(t) {
            t && B(n), o && o.d()
        }
    }
}

function Ue(t, e, n) {
    let r, i, o, a, s, l, c;
    h(t, Te, (t => n(9, l = t))), h(t, ne, (t => n(10, c = t)));
    let {
        option: u
    } = e, {
        variant: d
    } = e, {
        shouldShortenOnMobile: p = !1
    } = e, f = "";
    return t.$$set = t => {
        "option" in t && n(5, u = t.option), "variant" in t && n(0, d = t.variant), "shouldShortenOnMobile" in t && n(1, p = t.shouldShortenOnMobile)
    }, t.$$.update = () => {
        1057 & t.$$.dirty && n(7, r = ie({
            ...c,
            [u.key]: d.key
        }).total - ie(c).total), 128 & t.$$.dirty && n(4, i = r < 0 ? "–" : "+"), 384 & t.$$.dirty && n(8, (n(6, f = o), o = Be(Math.abs(r)))), 448 & t.$$.dirty && n(3, a = (0 === r ? f : o)?.split(",")), 641 & t.$$.dirty && n(2, s = l.isLoading || void 0 === d.display.cost && 0 === r)
    }, [d, p, s, a, i, u, f, r, o, l, c]
}
class Ne extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ue, ke, a, {
            option: 5,
            variant: 0,
            shouldShortenOnMobile: 1
        })
    }
}

function Fe(e) {
    let n;
    return {
        c() {
            n = L("div"), n.innerHTML = '<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" class="svelte-v5u9h4"><path d="M3.74805 9.58936C3.53678 9.58936 3.35059 9.48551 3.18945 9.27783L0.401855 5.72754C0.348145 5.66309 0.308757 5.59863 0.283691 5.53418C0.258626 5.46615 0.246094 5.3999 0.246094 5.33545C0.246094 5.18864 0.294434 5.06868 0.391113 4.97559C0.487793 4.87891 0.611328 4.83057 0.761719 4.83057C0.940755 4.83057 1.09473 4.91829 1.22363 5.09375L3.72656 8.37012L8.5498 0.684082C8.61426 0.583822 8.6805 0.513997 8.74854 0.474609C8.81657 0.431641 8.9043 0.410156 9.01172 0.410156C9.15853 0.410156 9.27669 0.454915 9.36621 0.544434C9.45573 0.633952 9.50049 0.752116 9.50049 0.898926C9.50049 0.963379 9.48975 1.02783 9.46826 1.09229C9.44678 1.15316 9.41276 1.22119 9.36621 1.29639L4.29053 9.28857C4.15804 9.4891 3.97721 9.58936 3.74805 9.58936Z" fill="white"></path></svg>\n\tAdded', N(n, "class", "configurator-variant-indicator type-12 svelte-v5u9h4")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        i: t,
        o: t,
        d(t) {
            t && B(n)
        }
    }
}
class Qe extends Dt {
    constructor(t) {
        super(), Lt(this, t, null, Fe, a, {})
    }
}
const $e = Symbol("modal");

function Ge(t) {
    let e, n, r, i;
    const o = t[2].default,
        a = d(o, t, t[1], null);
    return {
        c() {
            e = L("button"), a && a.c(), N(e, "class", "modal-control type-18 m-type-15 color-text-40 svelte-r0nedy")
        },
        m(o, s) {
            T(o, e, s), a && a.m(e, null), n = !0, r || (i = U(e, "click", t[0]), r = !0)
        },
        p(t, [e]) {
            a && a.p && (!n || 2 & e) && m(a, o, t, t[1], n ? f(o, t[1], e, null) : g(t[1]), null)
        },
        i(t) {
            n || (bt(a, t), n = !0)
        },
        o(t) {
            wt(a, t), n = !1
        },
        d(t) {
            t && B(e), a && a.d(t), r = !1, i()
        }
    }
}

function He(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e;
    const o = nt();
    return t.$$set = t => {
        "$$scope" in t && n(1, i = t.$$scope)
    }, [function () {
        o("click")
    }, i, r]
}
class ze extends Dt {
    constructor(t) {
        super(), Lt(this, t, He, Ge, a, {})
    }
}
const {
    window: Ve
} = C;

function We(t) {
    let e, n;
    return e = new ze({
        props: {
            $$slots: {
                default: [je]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("click", t[8]), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            4096 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function je(e) {
    let n, r, i;
    return {
        c() {
            n = D("svg"), r = D("path"), i = P("\n\t\t\t\t\t\t\tBack"), N(r, "d", "m7.26894 16.6823c.37684.4038 1.00963.4256 1.41338.0488.40375-.3769.42557-1.0097.04874-1.4134zm-6.268941-8.1823-.731055-.68232c-.3585929.38421-.3585929.98043 0 1.36464zm7.731051-6.81768c.37684-.40375.35502-1.03654-.04873-1.413374-.40375-.376835-1.03654-.3550151-1.41338.048736zm.00001 13.63538-7.00001-7.50002-1.462106 1.36464 6.999996 7.49998zm-7.00001-6.13538 7-7.5-1.46211-1.364638-6.999996 7.499998z"), N(r, "fill", "#000"), N(r, "fill-opacity", ".4"), N(n, "fill", "none"), N(n, "height", "17"), N(n, "viewBox", "0 0 9 17"), N(n, "width", "9"), N(n, "xmlns", "http://www.w3.org/2000/svg"), N(n, "class", "svelte-gu11dh")
        },
        m(t, e) {
            T(t, n, e), S(n, r), T(t, i, e)
        },
        p: t,
        d(t) {
            t && (B(n), B(i))
        }
    }
}

function Xe(e) {
    let n, r;
    return {
        c() {
            n = D("svg"), r = D("path"), N(r, "d", "m13.3007.709971c-.39-.39-1.02-.39-1.41 0l-4.89 4.879999-4.89-4.889999c-.39-.39-1.02-.39-1.409997 0-.39.389999-.39 1.019999 0 1.409999l4.889997 4.89-4.889997 4.89003c-.39.39-.39 1.02 0 1.41.389997.39 1.019997.39 1.409997 0l4.89-4.89003 4.89 4.89003c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41l-4.89-4.89003 4.89-4.89c.38-.38.38-1.02 0-1.399999z"), N(r, "fill", "#000"), N(r, "fill-opacity", ".4"), N(n, "fill", "none"), N(n, "height", "14"), N(n, "viewBox", "0 0 14 14"), N(n, "width", "14"), N(n, "xmlns", "http://www.w3.org/2000/svg"), N(n, "class", "svelte-gu11dh")
        },
        m(t, e) {
            T(t, n, e), S(n, r)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function qe(t) {
    let e, n, r, o, a, s, l, c, u, h, p, v, _, y = t[4] && We(t);
    c = new ze({
        props: {
            $$slots: {
                default: [Xe]
            },
            $$scope: {
                ctx: t
            }
        }
    }), c.$on("click", t[9]);
    const E = t[10].default,
        x = d(E, t, t[12], null);
    return {
        c() {
            e = L("div"), n = L("div"), r = L("div"), o = L("div"), a = L("div"), y && y.c(), s = O(), l = L("div"), Mt(c.$$.fragment), u = O(), x && x.c(), N(a, "class", "common-modal-back-button"), N(l, "class", "common-modal-close-button"), N(o, "class", "common-modal-controls svelte-gu11dh"), N(r, "class", "content svelte-gu11dh"), N(n, "class", "common-modal-scroll svelte-gu11dh"), N(e, "class", h = A(`common-modal common-modal-variant-${t[0]} ${t[1]}`) + " svelte-gu11dh"), H(e, "common-modal-without-appear-animation", t[2]), H(e, "common-modal-dismissing", t[5])
        },
        m(i, h) {
            T(i, e, h), S(e, n), S(n, r), S(r, o), S(o, a), y && y.m(a, null), S(o, s), S(o, l), Tt(c, l, null), S(r, u), x && x.m(r, null), t[11](n), p = !0, v || (_ = [U(Ve, "keydown", t[7]), U(r, "click", Ye), U(n, "mousedown", t[6]), U(n, "mousemove", Ke), U(n, "touchstart", Je), U(n, "touchmove", Ze), U(n, "touchend", tn), U(n, "scroll", en)], v = !0)
        },
        p(t, [n]) {
            t[4] ? y ? (y.p(t, n), 16 & n && bt(y, 1)) : (y = We(t), y.c(), bt(y, 1), y.m(a, null)) : y && (Et(), wt(y, 1, 1, (() => {
                y = null
            })), xt());
            const r = {};
            4096 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), c.$set(r), x && x.p && (!p || 4096 & n) && m(x, E, t, t[12], p ? f(E, t[12], n, null) : g(t[12]), null), (!p || 3 & n && h !== (h = A(`common-modal common-modal-variant-${t[0]} ${t[1]}`) + " svelte-gu11dh")) && N(e, "class", h), (!p || 7 & n) && H(e, "common-modal-without-appear-animation", t[2]), (!p || 35 & n) && H(e, "common-modal-dismissing", t[5])
        },
        i(t) {
            p || (bt(y), bt(c.$$.fragment, t), bt(x, t), p = !0)
        },
        o(t) {
            wt(y), wt(c.$$.fragment, t), wt(x, t), p = !1
        },
        d(n) {
            n && B(e), y && y.d(), Bt(c), x && x.d(n), t[11](null), v = !1, i(_)
        }
    }
}

function Ye(t) {
    t.stopPropagation()
}

function Ke(t) {
    t.stopPropagation()
}

function Je(t) {
    t.stopPropagation()
}

function Ze(t) {
    t.stopPropagation()
}

function tn(t) {
    t.stopPropagation()
}

function en() {}

function nn(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e, {
        variant: o = "default"
    } = e, {
        extraClassNames: a = ""
    } = e, {
        shouldSkipAnimation: s = !1
    } = e;
    rt($e, {
        setCanGoBack: function (t) {
            n(4, u = t)
        },
        setBackgroundClickable: function (t) {
            h = t
        }
    });
    const l = nt();
    let c, u = !1,
        h = !0,
        d = !1;

    function p(t) {
        n(5, d = !0), l("will-dismiss"), setTimeout(l, 400, "dismiss")
    }

    function f() {
        c.scrollTo(0, 0)
    }
    return Z((() => {
        document.body.classList.add("common-modal-presented"), window.addEventListener("router:will-change-url", p), window.addEventListener("modal:did-change-content", f), window.addEventListener("modal:dismiss", p)
    })), et((() => {
        document.body.classList.remove("common-modal-presented"), window.removeEventListener("router:will-change-url", p), window.removeEventListener("modal:did-change-content", f), window.removeEventListener("modal:dismiss", p)
    })), t.$$set = t => {
        "variant" in t && n(0, o = t.variant), "extraClassNames" in t && n(1, a = t.extraClassNames), "shouldSkipAnimation" in t && n(2, s = t.shouldSkipAnimation), "$$scope" in t && n(12, i = t.$$scope)
    }, [o, a, s, c, u, d, function (t) {
        !0 === h && t.target === c && p()
    }, function (t) {
        c.matches(":focus-within") || "Escape" === t.key && p()
    }, function () {
        l("back"), window.dispatchEvent(new Event("modal:did-click-back-button"))
    }, function () {
        p()
    }, r, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            c = t, n(3, c)
        }))
    }, i]
}
class rn extends Dt {
    constructor(t) {
        super(), Lt(this, t, nn, qe, a, {
            variant: 0,
            extraClassNames: 1,
            shouldSkipAnimation: 2
        })
    }
}

function on(t) {
    let e, n;
    const r = t[1].default,
        i = d(r, t, t[0], null);
    return {
        c() {
            e = L("div"), i && i.c(), N(e, "class", "configurator-modal-content svelte-1ztemd")
        },
        m(t, r) {
            T(t, e, r), i && i.m(e, null), n = !0
        },
        p(t, [e]) {
            i && i.p && (!n || 1 & e) && m(i, r, t, t[0], n ? f(r, t[0], e, null) : g(t[0]), null)
        },
        i(t) {
            n || (bt(i, t), n = !0)
        },
        o(t) {
            wt(i, t), n = !1
        },
        d(t) {
            t && B(e), i && i.d(t)
        }
    }
}

function an(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e;
    return t.$$set = t => {
        "$$scope" in t && n(0, i = t.$$scope)
    }, [i, r]
}
class sn extends Dt {
    constructor(t) {
        super(), Lt(this, t, an, on, a, {})
    }
}

function ln(e) {
    let n, r, i, o, a, s, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C;
    return {
        c() {
            n = L("h1"), n.textContent = "What’s included in the roller blinds add-on?", r = O(), i = L("div"), o = O(), a = L("p"), a.textContent = "This package, dynamically priced to reflect your layout and customizations, includes a\n\t\t\tcustom-fit light-filtering blind for each window, plus a set for each pair of double\n\t\t\tdoors. The beautiful, translucent, and subtly textured fabric ensures full privacy\n\t\t\twithout blocking natural light.", s = O(), c = L("div"), u = O(), h = L("img"), p = O(), f = L("div"), m = O(), g = L("div"), g.textContent = "Kitchen window with roller blind", A = O(), v = L("div"), _ = O(), y = L("img"), x = O(), b = L("div"), w = O(), C = L("div"), C.textContent = "Kitchen window without roller blind", N(n, "class", "type-30-light m-type-24-light"), N(i, "class", "spacer-16"), N(a, "class", "type-18 m-type-15 color-text-60"), N(c, "class", "spacer-50 spacer-36"), l(h.src, d = "/assets/images/configure/interior/roller-blinds.webp") || N(h, "src", "/assets/images/configure/interior/roller-blinds.webp"), N(h, "width", "1600"), N(h, "height", "1200"), N(h, "alt", "Standard wardrobe"), N(h, "class", "svelte-1nx099j"), N(f, "class", "spacer-12 spacer-8"), N(g, "class", "type-center type-15 m-type-14 color-text-60"), N(v, "class", "spacer-50 spacer-36"), l(y.src, E = "/assets/images/configure/interior/no-blinds.webp") || N(y, "src", "/assets/images/configure/interior/no-blinds.webp"), N(y, "width", "1600"), N(y, "height", "1200"), N(y, "alt", "Full-width wardrobe"), N(y, "class", "svelte-1nx099j"), N(b, "class", "spacer-12 spacer-8"), N(C, "class", "type-center type-15 m-type-14 color-text-60")
        },
        m(t, e) {
            T(t, n, e), T(t, r, e), T(t, i, e), T(t, o, e), T(t, a, e), T(t, s, e), T(t, c, e), T(t, u, e), T(t, h, e), T(t, p, e), T(t, f, e), T(t, m, e), T(t, g, e), T(t, A, e), T(t, v, e), T(t, _, e), T(t, y, e), T(t, x, e), T(t, b, e), T(t, w, e), T(t, C, e)
        },
        p: t,
        d(t) {
            t && (B(n), B(r), B(i), B(o), B(a), B(s), B(c), B(u), B(h), B(p), B(f), B(m), B(g), B(A), B(v), B(_), B(y), B(x), B(b), B(w), B(C))
        }
    }
}

function cn(t) {
    let e, n;
    return e = new sn({
        props: {
            $$slots: {
                default: [ln]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            4 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function un(t) {
    let e, n;
    return e = new rn({
        props: {
            $$slots: {
                default: [cn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("dismiss", t[0]), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, [n]) {
            const r = {};
            4 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function hn(t) {
    const e = nt();
    return [function () {
        e("dismiss")
    }]
}
class dn extends Dt {
    constructor(t) {
        super(), Lt(this, t, hn, un, a, {})
    }
}

function pn(e) {
    let n, r, i, o, a, s, c, u, h, d, p, f, m, g;
    return {
        c() {
            n = L("h1"), n.textContent = "What can you store in the freestanding kitchen pantry?", r = O(), i = L("div"), o = O(), a = L("p"), a.textContent = "The freestanding pantry complements the design of our signature kitchen perfectly.\n\t\t\tDesigned to fit snugly in the corner, it measures 26 inches in width, 18.5 inches in\n\t\t\tdepth, and stands 77.5 inches tall. Built-in electrical outlets, adjustable shelves, and\n\t\t\tpull-out drawers make it ideal for tucking appliances, cookware, bulk goods, and other\n\t\t\tsupplies out of sight.", s = O(), c = L("div"), u = O(), h = L("img"), p = O(), f = L("div"), m = O(), g = L("div"), g.textContent = "Freestanding kitchen pantry", N(n, "class", "type-30-light m-type-24-light"), N(i, "class", "spacer-16"), N(a, "class", "type-18 m-type-15 color-text-60"), N(c, "class", "spacer-50 spacer-36"), l(h.src, d = "/assets/images/configure/interior/pantry.jpeg") || N(h, "src", "/assets/images/configure/interior/pantry.jpeg"), N(h, "width", "1200"), N(h, "height", "1600"), N(h, "alt", "Freestanding kitchen pantry"), N(h, "class", "svelte-vm36f6"), N(f, "class", "spacer-12 spacer-8"), N(g, "class", "type-center type-15 m-type-14 color-text-60")
        },
        m(t, e) {
            T(t, n, e), T(t, r, e), T(t, i, e), T(t, o, e), T(t, a, e), T(t, s, e), T(t, c, e), T(t, u, e), T(t, h, e), T(t, p, e), T(t, f, e), T(t, m, e), T(t, g, e)
        },
        p: t,
        d(t) {
            t && (B(n), B(r), B(i), B(o), B(a), B(s), B(c), B(u), B(h), B(p), B(f), B(m), B(g))
        }
    }
}

function fn(t) {
    let e, n;
    return e = new sn({
        props: {
            $$slots: {
                default: [pn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            4 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function mn(t) {
    let e, n;
    return e = new rn({
        props: {
            $$slots: {
                default: [fn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("dismiss", t[0]), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, [n]) {
            const r = {};
            4 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function gn(t) {
    const e = nt();
    return [function () {
        e("dismiss")
    }]
}
class An extends Dt {
    constructor(t) {
        super(), Lt(this, t, gn, mn, a, {})
    }
}

function vn(e) {
    let n, r, i, o, a;
    return {
        c() {
            n = L("h1"), n.textContent = "What’s included in the bathroom accessibility kit?", r = O(), i = L("div"), o = O(), a = L("p"), a.textContent = "Our bathroom accessibility kit adds grab bars to the shower and toilet areas, a shower bench, and a roll-in\n            shower. Combined with existing 32” threshold clearances, the kit enhances Backyard’s safety and ease of use\n            for those with mobility needs.", N(n, "class", "type-30-light m-type-24-light"), N(i, "class", "spacer-16"), N(a, "class", "type-18 m-type-15 color-text-60")
        },
        m(t, e) {
            T(t, n, e), T(t, r, e), T(t, i, e), T(t, o, e), T(t, a, e)
        },
        p: t,
        d(t) {
            t && (B(n), B(r), B(i), B(o), B(a))
        }
    }
}

function _n(t) {
    let e, n;
    return e = new sn({
        props: {
            $$slots: {
                default: [vn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            4 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function yn(t) {
    let e, n;
    return e = new rn({
        props: {
            $$slots: {
                default: [_n]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("dismiss", t[0]), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, [n]) {
            const r = {};
            4 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function En(t) {
    const e = nt();
    return [function () {
        e("dismiss")
    }]
}
class xn extends Dt {
    constructor(t) {
        super(), Lt(this, t, En, yn, a, {})
    }
}
const {
    window: bn
} = C;

function wn(t, e, n) {
    const r = t.slice();
    return r[31] = e[n], r
}

function Cn(t) {
    let e, n = t[1].display.primarySubtitle + "";
    return {
        c() {
            e = L("span"), N(e, "class", "type-14 color-text-40 svelte-1yfmfhl")
        },
        m(t, r) {
            T(t, e, r), e.innerHTML = n
        },
        p(t, r) {
            2 & r[0] && n !== (n = t[1].display.primarySubtitle + "") && (e.innerHTML = n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Sn(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "•", N(n, "class", "type-14 color-text-40 svelte-1yfmfhl")
        },
        m(t, r) {
            T(t, n, r), e[22](n)
        },
        p: t,
        d(t) {
            t && B(n), e[22](null)
        }
    }
}

function In(t) {
    let e;
    return {
        c() {
            e = L("span"), N(e, "class", "type-14 color-text-40 svelte-1yfmfhl")
        },
        m(n, r) {
            T(n, e, r), e.innerHTML = t[9]
        },
        p(t, n) {
            512 & n[0] && (e.innerHTML = t[9])
        },
        d(t) {
            t && B(e)
        }
    }
}

function Mn(t) {
    let e, n = St(t[1].display.list),
        r = [];
    for (let e = 0; e < n.length; e += 1) r[e] = Tn(wn(t, n, e));
    return {
        c() {
            e = L("ul");
            for (let t = 0; t < r.length; t += 1) r[t].c();
            N(e, "class", "configurator-variant-list type-15 m-type-14 type-light color-text-40 svelte-1yfmfhl"), H(e, "configurator-variant-list-visible", t[5] && t[1].display.list), H(e, "configurator-variant-list-safari", t[15])
        },
        m(n, i) {
            T(n, e, i);
            for (let t = 0; t < r.length; t += 1) r[t] && r[t].m(e, null);
            t[23](e)
        },
        p(t, i) {
            if (2 & i[0]) {
                let o;
                for (n = St(t[1].display.list), o = 0; o < n.length; o += 1) {
                    const a = wn(t, n, o);
                    r[o] ? r[o].p(a, i) : (r[o] = Tn(a), r[o].c(), r[o].m(e, null))
                }
                for (; o < r.length; o += 1) r[o].d(1);
                r.length = n.length
            }
            34 & i[0] && H(e, "configurator-variant-list-visible", t[5] && t[1].display.list)
        },
        d(n) {
            n && B(e), R(r, n), t[23](null)
        }
    }
}

function Tn(t) {
    let e, n = t[31] + "";
    return {
        c() {
            e = L("li"), N(e, "class", "svelte-1yfmfhl")
        },
        m(t, r) {
            T(t, e, r), e.innerHTML = n
        },
        p(t, r) {
            2 & r[0] && n !== (n = t[31] + "") && (e.innerHTML = n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Bn(t) {
    let e, n, r;
    return n = new Ne({
        props: {
            option: t[0],
            variant: t[1]
        }
    }), {
        c() {
            e = L("div"), Mt(n.$$.fragment), N(e, "class", "configurator-variant-cost-container svelte-1yfmfhl")
        },
        m(t, i) {
            T(t, e, i), Tt(n, e, null), r = !0
        },
        p(t, e) {
            const r = {};
            1 & e[0] && (r.option = t[0]), 2 & e[0] && (r.variant = t[1]), n.$set(r)
        },
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            t && B(e), Bt(n)
        }
    }
}

function Rn(t) {
    let e, n;
    return e = new Qe({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Ln(t) {
    let e, n, r, i;
    const o = [On, Pn, Dn],
        a = [];

    function s(t, e) {
        return "interior-blinds" === t[0].key ? 0 : "kitchen-pantry" === t[0].key ? 1 : "bathroom-accessibility-kit" === t[0].key ? 2 : -1
    }
    return ~(e = s(t)) && (n = a[e] = o[e](t)), {
        c() {
            n && n.c(), r = k()
        },
        m(t, n) {
            ~e && a[e].m(t, n), T(t, r, n), i = !0
        },
        p(t, i) {
            let l = e;
            e = s(t), e === l ? ~e && a[e].p(t, i) : (n && (Et(), wt(a[l], 1, 1, (() => {
                a[l] = null
            })), xt()), ~e ? (n = a[e], n ? n.p(t, i) : (n = a[e] = o[e](t), n.c()), bt(n, 1), n.m(r.parentNode, r)) : n = null)
        },
        i(t) {
            i || (bt(n), i = !0)
        },
        o(t) {
            wt(n), i = !1
        },
        d(t) {
            t && B(r), ~e && a[e].d(t)
        }
    }
}

function Dn(e) {
    let n, r;
    return n = new xn({}), n.$on("dismiss", e[19]), {
        c() {
            Mt(n.$$.fragment)
        },
        m(t, e) {
            Tt(n, t, e), r = !0
        },
        p: t,
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            Bt(n, t)
        }
    }
}

function Pn(e) {
    let n, r;
    return n = new An({}), n.$on("dismiss", e[19]), {
        c() {
            Mt(n.$$.fragment)
        },
        m(t, e) {
            Tt(n, t, e), r = !0
        },
        p: t,
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            Bt(n, t)
        }
    }
}

function On(e) {
    let n, r;
    return n = new dn({}), n.$on("dismiss", e[19]), {
        c() {
            Mt(n.$$.fragment)
        },
        m(t, e) {
            Tt(n, t, e), r = !0
        },
        p: t,
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            Bt(n, t)
        }
    }
}

function kn(e) {
    let n, r, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x = e[1].display.primarySubtitle && Cn(e),
        b = e[1].display.primarySubtitle && e[9] && Sn(e),
        w = e[9] && In(e),
        C = e[1].display.list && Mn(e),
        I = e[3] && Bn(e),
        M = e[12] && Rn(),
        R = e[14] && function (e) {
            let n, r, i, o, a;
            return {
                c() {
                    n = L("div"), r = O(), i = L("a"), i.textContent = "Learn more", N(n, "class", "spacer-16 m-spacer-12"), N(i, "class", "configurator-variant-learn-more type-15 m-type-12 svelte-1yfmfhl")
                },
                m(t, s) {
                    T(t, n, s), T(t, r, s), T(t, i, s), o || (a = U(i, "click", e[18]), o = !0)
                },
                p: t,
                d(t) {
                    t && (B(n), B(r), B(i)), o = !1, a()
                }
            }
        }(e),
        D = e[7] && Ln(e);
    return {
        c() {
            n = L("li"), r = L("label"), o = L("h3"), a = O(), x && x.c(), s = O(), b && b.c(), l = O(), w && w.c(), c = O(), C && C.c(), u = O(), I && I.c(), h = O(), M && M.c(), d = O(), R && R.c(), p = O(), f = L("input"), A = O(), D && D.c(), v = k(), N(o, "class", "type-18 m-type-15"), H(o, "alt", e[1].key.startsWith("xl")), N(f, "type", m = e[2] ? "checkbox" : "radio"), N(f, "name", e[13]), f.value = g = e[1].key, f.checked = e[5], N(f, "class", "svelte-1yfmfhl"), N(r, "class", "svelte-1yfmfhl"), N(n, "class", "configurator-variant svelte-1yfmfhl"), N(n, "style", e[11])
        },
        m(t, i) {
            T(t, n, i), S(n, r), S(r, o), o.innerHTML = e[10], S(r, a), x && x.m(r, null), S(r, s), b && b.m(r, null), S(r, l), w && w.m(r, null), S(r, c), C && C.m(r, null), S(r, u), I && I.m(r, null), S(r, h), M && M.m(r, null), S(r, d), R && R.m(r, null), S(r, p), S(r, f), e[24](n), T(t, A, i), D && D.m(t, i), T(t, v, i), _ = !0, y || (E = [U(bn, "resize", e[17]), U(f, "input", e[16])], y = !0)
        },
        p(t, e) {
            (!_ || 1024 & e[0]) && (o.innerHTML = t[10]), (!_ || 2 & e[0]) && H(o, "alt", t[1].key.startsWith("xl")), t[1].display.primarySubtitle ? x ? x.p(t, e) : (x = Cn(t), x.c(), x.m(r, s)) : x && (x.d(1), x = null), t[1].display.primarySubtitle && t[9] ? b ? b.p(t, e) : (b = Sn(t), b.c(), b.m(r, l)) : b && (b.d(1), b = null), t[9] ? w ? w.p(t, e) : (w = In(t), w.c(), w.m(r, c)) : w && (w.d(1), w = null), t[1].display.list ? C ? C.p(t, e) : (C = Mn(t), C.c(), C.m(r, u)) : C && (C.d(1), C = null), t[3] ? I ? (I.p(t, e), 8 & e[0] && bt(I, 1)) : (I = Bn(t), I.c(), bt(I, 1), I.m(r, h)) : I && (Et(), wt(I, 1, 1, (() => {
                I = null
            })), xt()), t[12] ? M ? 4096 & e[0] && bt(M, 1) : (M = Rn(), M.c(), bt(M, 1), M.m(r, d)) : M && (Et(), wt(M, 1, 1, (() => {
                M = null
            })), xt()), t[14] && R.p(t, e), (!_ || 4 & e[0] && m !== (m = t[2] ? "checkbox" : "radio")) && N(f, "type", m), (!_ || 2 & e[0] && g !== (g = t[1].key) && f.value !== g) && (f.value = g), (!_ || 32 & e[0]) && (f.checked = t[5]), (!_ || 2048 & e[0]) && N(n, "style", t[11]), t[7] ? D ? (D.p(t, e), 128 & e[0] && bt(D, 1)) : (D = Ln(t), D.c(), bt(D, 1), D.m(v.parentNode, v)) : D && (Et(), wt(D, 1, 1, (() => {
                D = null
            })), xt())
        },
        i(t) {
            _ || (bt(I), bt(M), bt(D), _ = !0)
        },
        o(t) {
            wt(I), wt(M), wt(D), _ = !1
        },
        d(t) {
            t && (B(n), B(A), B(v)), x && x.d(), b && b.d(), w && w.d(), C && C.d(), I && I.d(), M && M.d(), R && R.d(), e[24](null), D && D.d(t), y = !1, i(E)
        }
    }
}

function Un(t, e, n) {
    let r, i, o, a, s, l;
    h(t, ne, (t => n(21, l = t)));
    let {
        option: c
    } = e, {
        variant: u
    } = e, {
        isToggle: d = !1
    } = e, {
        minimumHeight: p
    } = e, {
        shouldDisplayCost: f = !0
    } = e;
    const m = `configurator-option-${c.key}`;
    ! function (t) {
        J().$$.context.get(t)
    }(`${c.key}_variantHeights`);
    const g = "interior-blinds" === c.key || "bathroom-accessibility-kit" === c.key || "kitchen-pantry" === c.key;
    let A, v, _, y, E, x = !1,
        b = void 0 !== globalThis.safari;

    function w() {}

    function C() {
        if (void 0 === y) return;
        const t = y.getBoundingClientRect(),
            e = y.nextElementSibling?.getBoundingClientRect();
        y.classList.toggle("configurator-variant-middot-hidden", void 0 === e || e.left < t.left)
    }
    return Z((() => (void 0 !== y && (E = new ResizeObserver(C), E.observe(A)), () => {
        void 0 !== E && E.unobserve(A)
    }))), t.$$set = t => {
        "option" in t && n(0, c = t.option), "variant" in t && n(1, u = t.variant), "isToggle" in t && n(2, d = t.isToggle), "minimumHeight" in t && n(20, p = t.minimumHeight), "shouldDisplayCost" in t && n(3, f = t.shouldDisplayCost)
    }, t.$$.update = () => {
        2097155 & t.$$.dirty[0] && n(5, r = l[c.key] === u.key), 36 & t.$$.dirty[0] && n(12, i = d && r), 1048624 & t.$$.dirty[0] && n(11, o = false), 2097154 & t.$$.dirty[0] && n(10, a = u.display.title && "function" == typeof u.display.title ? u.display.title(l) : u.display.title), 2097154 & t.$$.dirty[0] && n(9, s = u.display.subtitle && "function" == typeof u.display.subtitle ? u.display.subtitle(l) : u.display.subtitle)
    }, [c, u, d, f, v, r, A, x, y, s, a, o, i, m, g, b, function (t) {
        window.dispatchEvent(new CustomEvent("variant", {
            detail: {
                option: c,
                variant: u
            }
        })), ne.select(c.key, t.target.checked && u.key)
    }, function () {
        clearTimeout(_), _ = setTimeout(w, 100), C()
    }, function (t) {
        t.stopPropagation(), t.preventDefault(), n(7, x = !0)
    }, function () {
        n(7, x = !1)
    }, p, l, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            y = t, n(8, y)
        }))
    }, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            v = t, n(4, v)
        }))
    }, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            A = t, n(6, A)
        }))
    }]
}
class Nn extends Dt {
    constructor(t) {
        super(), Lt(this, t, Un, kn, a, {
            option: 0,
            variant: 1,
            isToggle: 2,
            minimumHeight: 20,
            shouldDisplayCost: 3
        }, null, [-1, -1])
    }
}

function Fn(t) {
    let e, n, r, i, o, a, s, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C, S, I, M;
    return {
        c() {
            e = L("h1"), e.textContent = "Do you need extra bedroom storage?", n = O(), r = L("div"), i = O(), o = L("p"), o.textContent = "The standard wardrobe measures 66.25 inches in width, 24 inches in\n\t\t\tdepth, and 80 inches in height. It includes hanging space, a shoe\n\t\t\track, open shelves, and soft-close drawers.", a = O(), s = L("div"), c = O(), u = L("p"), u.textContent = "The full-width wardrobe spans 112 inches in width, 24 inches in\n\t\t\tdepth, and 80 inches in height, covering the entire bedroom wall\n\t\t\twith storage. It includes all features of the standard wardrobe,\n\t\t\tplus an additional closed module with adjustable shelves and hanging\n\t\t\tracks.", h = O(), d = L("div"), p = O(), f = L("img"), g = O(), A = L("div"), v = O(), _ = L("div"), _.textContent = "Standard wardrobe", y = O(), E = L("div"), x = O(), b = L("img"), C = O(), S = L("div"), I = O(), M = L("div"), M.textContent = "Full-width wardrobe", N(e, "class", "type-30-light m-type-24-light"), N(r, "class", "spacer-16"), N(o, "class", "type-18 m-type-15 color-text-60"), N(s, "class", "spacer-16"), N(u, "class", "type-18 m-type-15 color-text-60"), N(d, "class", "spacer-50 spacer-36"), l(f.src, m = t[1]) || N(f, "src", m), N(f, "width", "1600"), N(f, "height", "1200"), N(f, "alt", "Standard wardrobe"), N(f, "class", "svelte-vm36f6"), N(A, "class", "spacer-12 spacer-8"), N(_, "class", "type-center type-15 m-type-14 color-text-60"), N(E, "class", "spacer-50 spacer-36"), l(b.src, w = t[0]) || N(b, "src", w), N(b, "width", "1600"), N(b, "height", "1200"), N(b, "alt", "Full-width wardrobe"), N(b, "class", "svelte-vm36f6"), N(S, "class", "spacer-12 spacer-8"), N(M, "class", "type-center type-15 m-type-14 color-text-60")
        },
        m(t, l) {
            T(t, e, l), T(t, n, l), T(t, r, l), T(t, i, l), T(t, o, l), T(t, a, l), T(t, s, l), T(t, c, l), T(t, u, l), T(t, h, l), T(t, d, l), T(t, p, l), T(t, f, l), T(t, g, l), T(t, A, l), T(t, v, l), T(t, _, l), T(t, y, l), T(t, E, l), T(t, x, l), T(t, b, l), T(t, C, l), T(t, S, l), T(t, I, l), T(t, M, l)
        },
        p(t, e) {
            2 & e && !l(f.src, m = t[1]) && N(f, "src", m), 1 & e && !l(b.src, w = t[0]) && N(b, "src", w)
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(o), B(a), B(s), B(c), B(u), B(h), B(d), B(p), B(f), B(g), B(A), B(v), B(_), B(y), B(E), B(x), B(b), B(C), B(S), B(I), B(M))
        }
    }
}

function Qn(t) {
    let e, n;
    return e = new sn({
        props: {
            $$slots: {
                default: [Fn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            259 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function $n(t) {
    let e, n;
    return e = new rn({
        props: {
            $$slots: {
                default: [Qn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("dismiss", t[2]), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, [n]) {
            const r = {};
            259 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Gn(t, e, n) {
    let r, i, o, a, s;
    h(t, ne, (t => n(6, s = t)));
    let {
        option: l
    } = e;
    const c = nt();
    return t.$$set = t => {
        "option" in t && n(3, l = t.option)
    }, t.$$.update = () => {
        8 & t.$$.dirty && n(5, r = l.key.startsWith("primary") ? "bedroom1" : "bedroom2"), 64 & t.$$.dirty && n(4, i = "floor-natural-oak" === s.floor ? "nat" : "dark"), 48 & t.$$.dirty && n(1, o = `/assets/images/configure/1505/${r}_${i}_standard.jpg`), 48 & t.$$.dirty && n(0, a = `/assets/images/configure/1505/${r}_${i}_full.jpg`)
    }, [a, o, function () {
        c("dismiss")
    }, l, i, r, s]
}
class Hn extends Dt {
    constructor(t) {
        super(), Lt(this, t, Gn, $n, a, {
            option: 3
        })
    }
}

function zn(e) {
    let n, r;
    return {
        c() {
            n = D("svg"), r = D("path"), N(r, "d", "M0.739258 6.13037C0.739258 5.90576 0.819824 5.71289 0.980957 5.55176C1.14209 5.38574 1.33496 5.30273 1.55957 5.30273H6.04932V0.820312C6.04932 0.595703 6.12988 0.402832 6.29102 0.241699C6.45215 0.0805664 6.64502 0 6.86963 0C7.09912 0 7.29443 0.0805664 7.45557 0.241699C7.6167 0.402832 7.69727 0.595703 7.69727 0.820312V5.30273H12.1797C12.4043 5.30273 12.5972 5.38574 12.7583 5.55176C12.9194 5.71289 13 5.90576 13 6.13037C13 6.35986 12.9194 6.55518 12.7583 6.71631C12.5972 6.87256 12.4043 6.95068 12.1797 6.95068H7.69727V11.4478C7.69727 11.6675 7.6167 11.8579 7.45557 12.019C7.29443 12.1802 7.09912 12.2607 6.86963 12.2607C6.64502 12.2607 6.45215 12.1802 6.29102 12.019C6.12988 11.8579 6.04932 11.6675 6.04932 11.4478V6.95068H1.55957C1.33496 6.95068 1.14209 6.87256 0.980957 6.71631C0.819824 6.55518 0.739258 6.35986 0.739258 6.13037Z"), N(r, "fill", "#0096F7"), N(n, "width", "13"), N(n, "height", "13"), N(n, "viewBox", "0 0 13 13"), N(n, "fill", "none"), N(n, "xmlns", "http://www.w3.org/2000/svg")
        },
        m(t, e) {
            T(t, n, e), S(n, r)
        },
        p: t,
        i: t,
        o: t,
        d(t) {
            t && B(n)
        }
    }
}
class Vn extends Dt {
    constructor(t) {
        super(), Lt(this, t, null, zn, a, {})
    }
}

function Wn(t) {
    let e, n, r, i, o, a, s, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C, S, I, M;
    return {
        c() {
            e = L("h1"), e.textContent = "Which kitchen layout is right for you?", n = O(), r = L("div"), i = O(), o = L("p"), o.textContent = 'Backyard XL 10\'s standard kitchen layout includes 13.65 linear feet\n\t\t\tof counter space and plenty of storage, plus our standard suite of\n\t\t\tfull-size appliances. This suite includes a 30" wide four-burner\n\t\t\tinduction cooktop, 30" wide single wall oven, 29" wide stainless\n\t\t\tsteel sink with garbage disposal, 24" wide panelized dishwasher, and\n\t\t\ta 33" wide French door refrigerator.', a = O(), s = L("div"), c = O(), u = L("p"), u.textContent = 'The kitchen island adds 2.5 linear feet of counter space, plus\n\t\t\tadditional storage, electric outlets, and room for counter-height\n\t\t\tseating. It can be configured to include a 24" wine and beverage\n\t\t\tcooler.', h = O(), d = L("div"), p = O(), f = L("img"), g = O(), A = L("div"), v = O(), _ = L("div"), _.textContent = "Standard kitchen layout", y = O(), E = L("div"), x = O(), b = L("img"), C = O(), S = L("div"), I = O(), M = L("div"), M.textContent = "Kitchen with island", N(e, "class", "type-30-light m-type-24-light"), N(r, "class", "spacer-16"), N(o, "class", "type-18 m-type-15 color-text-60"), N(s, "class", "spacer-16"), N(u, "class", "type-18 m-type-15 color-text-60"), N(d, "class", "spacer-50 spacer-36"), l(f.src, m = t[1]) || N(f, "src", m), N(f, "width", "1600"), N(f, "height", "1200"), N(f, "alt", "Standard kitchen"), N(f, "class", "svelte-2qes36"), N(A, "class", "spacer-12 spacer-8"), N(_, "class", "type-center type-15 m-type-14 color-text-60"), N(E, "class", "spacer-50 spacer-36"), l(b.src, w = t[0]) || N(b, "src", w), N(b, "width", "1600"), N(b, "height", "1200"), N(b, "alt", "Kitchen with island"), N(b, "class", "svelte-2qes36"), N(S, "class", "spacer-12 spacer-8"), N(M, "class", "type-center type-15 m-type-14 color-text-60")
        },
        m(t, l) {
            T(t, e, l), T(t, n, l), T(t, r, l), T(t, i, l), T(t, o, l), T(t, a, l), T(t, s, l), T(t, c, l), T(t, u, l), T(t, h, l), T(t, d, l), T(t, p, l), T(t, f, l), T(t, g, l), T(t, A, l), T(t, v, l), T(t, _, l), T(t, y, l), T(t, E, l), T(t, x, l), T(t, b, l), T(t, C, l), T(t, S, l), T(t, I, l), T(t, M, l)
        },
        p(t, e) {
            2 & e && !l(f.src, m = t[1]) && N(f, "src", m), 1 & e && !l(b.src, w = t[0]) && N(b, "src", w)
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(o), B(a), B(s), B(c), B(u), B(h), B(d), B(p), B(f), B(g), B(A), B(v), B(_), B(y), B(E), B(x), B(b), B(C), B(S), B(I), B(M))
        }
    }
}

function jn(t) {
    let e, n;
    return e = new sn({
        props: {
            $$slots: {
                default: [Wn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            131 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Xn(t) {
    let e, n;
    return e = new rn({
        props: {
            $$slots: {
                default: [jn]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("dismiss", t[2]), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, [n]) {
            const r = {};
            131 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function qn(t, e, n) {
    let r, i, o, a, s;
    h(t, ne, (t => n(5, s = t)));
    const l = nt();
    return t.$$.update = () => {
        32 & t.$$.dirty && n(4, r = "floor-natural-oak" === s.floor ? "nat" : "dark"), 32 & t.$$.dirty && n(3, i = "kitchen-cabinet-natural-oak" === s["kitchen-cabinet-finish"] ? "nat" : "white"), 24 & t.$$.dirty && n(1, o = `/assets/images/configure/1505/kitchen_xl10_${r}_${i}_table.jpg`), 24 & t.$$.dirty && n(0, a = `/assets/images/configure/1505/kitchen_xl10_${r}_${i}_island.jpg`)
    }, [a, o, function () {
        l("dismiss")
    }, i, r, s]
}
class Yn extends Dt {
    constructor(t) {
        super(), Lt(this, t, qn, Xn, a, {})
    }
}

function Kn(t, e, n) {
    const r = t.slice();
    return r[14] = e[n], r
}

function Jn(t) {
    let e;
    return {
        c() {
            e = L("h2"), N(e, "class", "type-24-light m-type-18")
        },
        m(n, r) {
            T(n, e, r), e.innerHTML = t[3]
        },
        p(t, n) {
            8 & n && (e.innerHTML = t[3])
        },
        d(t) {
            t && B(e)
        }
    }
}

function Zn(t) {
    let e, n;
    return e = new Nn({
        props: {
            option: t[6],
            variant: t[14],
            minimumHeight: t[5],
            shouldDisplayCost: t[0]
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            16 & n && (r.variant = t[14]), 32 & n && (r.minimumHeight = t[5]), 1 & n && (r.shouldDisplayCost = t[0]), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function tr(e) {
    let n, r;
    return n = new Hn({
        props: {
            option: e[6]
        }
    }), n.$on("dismiss", e[10]), {
        c() {
            Mt(n.$$.fragment)
        },
        m(t, e) {
            Tt(n, t, e), r = !0
        },
        p: t,
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            Bt(n, t)
        }
    }
}

function er(e) {
    let n, r;
    return n = new Yn({}), n.$on("dismiss", e[10]), {
        c() {
            Mt(n.$$.fragment)
        },
        m(t, e) {
            Tt(n, t, e), r = !0
        },
        p: t,
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            Bt(n, t)
        }
    }
}

function nr(e) {
    let n, r, i, o, a, s, l, c, u, h, d, p = e[6].key.endsWith("bedroom-wardrobe"),
        f = e[6].key.endsWith("kitchen-layout"),
        m = e[3] && Jn(e),
        g = St(e[4]),
        A = [];
    for (let t = 0; t < g.length; t += 1) A[t] = Zn(Kn(e, g, t));
    const v = t => wt(A[t], 1, 1, (() => {
        A[t] = null
    }));
    let _ = p && function (e) {
            let n, r, i, o, a, s, l, c, u;
            return s = new Vn({}), {
                c() {
                    n = L("div"), r = O(), i = L("div"), o = L("button"), a = P("Compare wardrobe options\n\t\t\t\t"), Mt(s.$$.fragment), N(n, "class", "spacer-32"), N(o, "class", "button-rounded button-configurator type-15 m-type-14 type-regola-regular svelte-1kt5zd3"), N(i, "class", "configurator-option-wardrobe svelte-1kt5zd3")
                },
                m(t, h) {
                    T(t, n, h), T(t, r, h), T(t, i, h), S(i, o), S(o, a), Tt(s, o, null), l = !0, c || (u = U(o, "click", e[8]), c = !0)
                },
                p: t,
                i(t) {
                    l || (bt(s.$$.fragment, t), l = !0)
                },
                o(t) {
                    wt(s.$$.fragment, t), l = !1
                },
                d(t) {
                    t && (B(n), B(r), B(i)), Bt(s), c = !1, u()
                }
            }
        }(e),
        y = f && function (e) {
            let n, r, i, o, a, s, l, c, u;
            return s = new Vn({}), {
                c() {
                    n = L("div"), r = O(), i = L("div"), o = L("button"), a = P("Compare kitchen layouts\n\t\t\t\t"), Mt(s.$$.fragment), N(n, "class", "spacer-32"), N(o, "class", "button-rounded button-configurator type-15 m-type-14 type-regola-regular svelte-1kt5zd3"), N(i, "class", "configurator-option-wardrobe svelte-1kt5zd3")
                },
                m(t, h) {
                    T(t, n, h), T(t, r, h), T(t, i, h), S(i, o), S(o, a), Tt(s, o, null), l = !0, c || (u = U(o, "click", e[9]), c = !0)
                },
                p: t,
                i(t) {
                    l || (bt(s.$$.fragment, t), l = !0)
                },
                o(t) {
                    wt(s.$$.fragment, t), l = !1
                },
                d(t) {
                    t && (B(n), B(r), B(i)), Bt(s), c = !1, u()
                }
            }
        }(e),
        E = e[1] && tr(e),
        x = e[2] && er(e);
    return {
        c() {
            n = L("div"), m && m.c(), r = O(), i = L("div"), o = O(), a = L("ul");
            for (let t = 0; t < A.length; t += 1) A[t].c();
            s = O(), _ && _.c(), l = O(), y && y.c(), c = O(), E && E.c(), u = O(), x && x.c(), h = k(), N(i, "class", "spacer-24"), N(a, "class", "configurator-option-variants svelte-1kt5zd3"), N(n, "class", "configurator-option")
        },
        m(t, e) {
            T(t, n, e), m && m.m(n, null), S(n, r), S(n, i), S(n, o), S(n, a);
            for (let t = 0; t < A.length; t += 1) A[t] && A[t].m(a, null);
            S(n, s), _ && _.m(n, null), S(n, l), y && y.m(n, null), T(t, c, e), E && E.m(t, e), T(t, u, e), x && x.m(t, e), T(t, h, e), d = !0
        },
        p(t, [e]) {
            if (t[3] ? m ? m.p(t, e) : (m = Jn(t), m.c(), m.m(n, r)) : m && (m.d(1), m = null), 113 & e) {
                let n;
                for (g = St(t[4]), n = 0; n < g.length; n += 1) {
                    const r = Kn(t, g, n);
                    A[n] ? (A[n].p(r, e), bt(A[n], 1)) : (A[n] = Zn(r), A[n].c(), bt(A[n], 1), A[n].m(a, null))
                }
                for (Et(), n = g.length; n < A.length; n += 1) v(n);
                xt()
            }
            p && _.p(t, e), f && y.p(t, e), t[1] ? E ? (E.p(t, e), 2 & e && bt(E, 1)) : (E = tr(t), E.c(), bt(E, 1), E.m(u.parentNode, u)) : E && (Et(), wt(E, 1, 1, (() => {
                E = null
            })), xt()), t[2] ? x ? (x.p(t, e), 4 & e && bt(x, 1)) : (x = er(t), x.c(), bt(x, 1), x.m(h.parentNode, h)) : x && (Et(), wt(x, 1, 1, (() => {
                x = null
            })), xt())
        },
        i(t) {
            if (!d) {
                for (let t = 0; t < g.length; t += 1) bt(A[t]);
                bt(_), bt(y), bt(E), bt(x), d = !0
            }
        },
        o(t) {
            A = A.filter(Boolean);
            for (let t = 0; t < A.length; t += 1) wt(A[t]);
            wt(_), wt(y), wt(E), wt(x), d = !1
        },
        d(t) {
            t && (B(n), B(c), B(u), B(h)), m && m.d(), R(A, t), _ && _.d(), y && y.d(), E && E.d(t), x && x.d(t)
        }
    }
}

function rr(t, e, n) {
    let r, i, o, a;
    h(t, ne, (t => n(12, o = t)));
    let {
        key: s
    } = e, {
        shouldDisplayCost: l = !0
    } = e;
    const c = Yt(s),
        u = Ht({}),
        d = zt(u, (t => Math.max(...Object.values(t))));
    h(t, d, (t => n(5, a = t)));
    let p = !1,
        f = !1;
    return rt(`${c.key}_variantHeights`, u), t.$$set = t => {
        "key" in t && n(11, s = t.key), "shouldDisplayCost" in t && n(0, l = t.shouldDisplayCost)
    }, t.$$.update = () => {
        4096 & t.$$.dirty && n(4, r = Zt(o).find((({
            key: t
        }) => t === c.key))?.values || []), 4096 & t.$$.dirty && n(3, i = c.display.title && "function" == typeof c.display.title ? c.display.title(o) : c.display.title)
    }, [l, p, f, i, r, a, c, d, function () {
        n(1, p = !0)
    }, function () {
        n(2, f = !0)
    }, function () {
        n(1, p = !1), n(2, f = !1)
    }, s, o]
}
class ir extends Dt {
    constructor(t) {
        super(), Lt(this, t, rr, nr, a, {
            key: 11,
            shouldDisplayCost: 0
        })
    }
}

function or(t, e, n) {
    const r = t.slice();
    return r[4] = e[n], r
}

function ar(t) {
    let e, n, r, i;
    return {
        c() {
            e = L("h2"), n = P(t[0]), r = O(), i = L("div"), N(e, "class", "type-24-light m-type-18"), N(i, "class", "spacer-16")
        },
        m(t, o) {
            T(t, e, o), S(e, n), T(t, r, o), T(t, i, o)
        },
        p(t, e) {
            1 & e && F(n, t[0])
        },
        d(t) {
            t && (B(e), B(r), B(i))
        }
    }
}

function sr(t) {
    let e, n;
    return e = new Nn({
        props: {
            option: t[3](t[4]).option,
            variant: t[3](t[4]).variant,
            isToggle: !0
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            2 & n && (r.option = t[3](t[4]).option), 2 & n && (r.variant = t[3](t[4]).variant), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function lr(t) {
    let e, n, r, i, o = void 0 !== t[0] && ar(t),
        a = St(t[1]),
        s = [];
    for (let e = 0; e < a.length; e += 1) s[e] = sr(or(t, a, e));
    const l = t => wt(s[t], 1, 1, (() => {
        s[t] = null
    }));
    return {
        c() {
            e = L("div"), o && o.c(), n = O(), r = L("ul");
            for (let t = 0; t < s.length; t += 1) s[t].c();
            N(r, "class", "configurator-option-variants svelte-144ugib"), N(e, "class", "configurator-option svelte-144ugib"), H(e, "configurator-option-disabled", t[2])
        },
        m(t, a) {
            T(t, e, a), o && o.m(e, null), S(e, n), S(e, r);
            for (let t = 0; t < s.length; t += 1) s[t] && s[t].m(r, null);
            i = !0
        },
        p(t, [c]) {
            if (void 0 !== t[0] ? o ? o.p(t, c) : (o = ar(t), o.c(), o.m(e, n)) : o && (o.d(1), o = null), 10 & c) {
                let e;
                for (a = St(t[1]), e = 0; e < a.length; e += 1) {
                    const n = or(t, a, e);
                    s[e] ? (s[e].p(n, c), bt(s[e], 1)) : (s[e] = sr(n), s[e].c(), bt(s[e], 1), s[e].m(r, null))
                }
                for (Et(), e = a.length; e < s.length; e += 1) l(e);
                xt()
            }(!i || 4 & c) && H(e, "configurator-option-disabled", t[2])
        },
        i(t) {
            if (!i) {
                for (let t = 0; t < a.length; t += 1) bt(s[t]);
                i = !0
            }
        },
        o(t) {
            s = s.filter(Boolean);
            for (let t = 0; t < s.length; t += 1) wt(s[t]);
            i = !1
        },
        d(t) {
            t && B(e), o && o.d(), R(s, t)
        }
    }
}

function cr(t, e, n) {
    let {
        title: r
    } = e, {
        keys: i
    } = e, {
        disabled: o = !1
    } = e;
    return t.$$set = t => {
        "title" in t && n(0, r = t.title), "keys" in t && n(1, i = t.keys), "disabled" in t && n(2, o = t.disabled)
    }, [r, i, o, function (t) {
        const e = Yt(t);
        if (!e) throw new Error(`can't find option with key '${t}'`);
        if (!e.values || 0 === e.values.length) throw new Error(`no values for option with key '${t}'`);
        const n = e.values.at(-1);
        return {
            option: e,
            variant: n
        }
    }]
}
class ur extends Dt {
    constructor(t) {
        super(), Lt(this, t, cr, lr, a, {
            title: 0,
            keys: 1,
            disabled: 2
        })
    }
}

function hr(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = "/assets/images/configure/kitchen-cabinet-finish-natural-oak.jpg") || N(n, "src", "/assets/images/configure/kitchen-cabinet-finish-natural-oak.jpg"), N(n, "width", "100%"), N(n, "height", "100%"), N(n, "alt", "Natural oak"), N(n, "class", "svelte-71frzl")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function dr(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = "/assets/images/configure/kitchen-cabinet-finish-bone-white.jpg") || N(n, "src", "/assets/images/configure/kitchen-cabinet-finish-bone-white.jpg"), N(n, "width", "100%"), N(n, "height", "100%"), N(n, "alt", "Bone white"), N(n, "class", "svelte-71frzl")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function pr(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = "/assets/images/configure/floor-dark-stained-oak.jpg") || N(n, "src", "/assets/images/configure/floor-dark-stained-oak.jpg"), N(n, "width", "100%"), N(n, "height", "100%"), N(n, "alt", "Dark oak"), N(n, "class", "svelte-71frzl")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function fr(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = "/assets/images/configure/floor-natural-oak.jpg") || N(n, "src", "/assets/images/configure/floor-natural-oak.jpg"), N(n, "width", "100%"), N(n, "height", "100%"), N(n, "alt", "Natural oak"), N(n, "class", "svelte-71frzl")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function mr(e) {
    let n, r, i, o;
    return {
        c() {
            n = L("img"), i = O(), o = L("div"), N(n, "class", "configurator-variant-color-swatch-silver-coarse svelte-71frzl"), l(n.src, r = "/assets/images/configure/silver-coarse.png") || N(n, "src", "/assets/images/configure/silver-coarse.png"), N(n, "width", "100%"), N(n, "height", "100%"), N(n, "alt", "Sliver texture"), N(o, "class", "configurator-variant-color-swatch-glare svelte-71frzl"), N(o, "style", e[5])
        },
        m(t, e) {
            T(t, n, e), T(t, i, e), T(t, o, e)
        },
        p: t,
        d(t) {
            t && (B(n), B(i), B(o))
        }
    }
}

function gr(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d;

    function p(t, e) {
        return "roof-metallic-silver" === t[1].key ? mr : "floor-natural-oak" === t[1].key ? fr : "floor-dark-oak" === t[1].key ? pr : "kitchen-cabinet-bone-white" === t[1].key ? dr : "kitchen-cabinet-natural-oak" === t[1].key ? hr : void 0
    }
    let f = p(t),
        m = f && f(t);
    return c = new Ne({
        props: {
            option: t[0],
            variant: t[1],
            shouldShortenOnMobile: !0
        }
    }), {
        c() {
            e = L("li"), n = L("input"), o = O(), a = L("div"), m && m.c(), l = O(), Mt(c.$$.fragment), N(n, "type", "radio"), N(n, "name", t[4]), n.value = r = t[1].key, n.checked = t[2], N(n, "aria-label", i = t[1].display.title), N(n, "class", "svelte-71frzl"), N(a, "class", s = A(`configurator-variant-color-swatch configurator-variant-color-swatch-${t[1].key}`) + " svelte-71frzl"), N(a, "style", t[3]), N(e, "class", "configurator-variant-color svelte-71frzl")
        },
        m(r, i) {
            T(r, e, i), S(e, n), S(e, o), S(e, a), m && m.m(a, null), S(e, l), Tt(c, e, null), u = !0, h || (d = U(n, "input", t[6]), h = !0)
        },
        p(t, [e]) {
            (!u || 2 & e && r !== (r = t[1].key) && n.value !== r) && (n.value = r), (!u || 4 & e) && (n.checked = t[2]), (!u || 2 & e && i !== (i = t[1].display.title)) && N(n, "aria-label", i), f === (f = p(t)) && m ? m.p(t, e) : (m && m.d(1), m = f && f(t), m && (m.c(), m.m(a, null))), (!u || 2 & e && s !== (s = A(`configurator-variant-color-swatch configurator-variant-color-swatch-${t[1].key}`) + " svelte-71frzl")) && N(a, "class", s);
            const o = {};
            1 & e && (o.option = t[0]), 2 & e && (o.variant = t[1]), c.$set(o)
        },
        i(t) {
            u || (bt(c.$$.fragment, t), u = !0)
        },
        o(t) {
            wt(c.$$.fragment, t), u = !1
        },
        d(t) {
            t && B(e), m && m.d(), Bt(c), h = !1, d()
        }
    }
}

function Ar(t, e, n) {
    let r, i;
    h(t, ne, (t => n(7, i = t)));
    let {
        option: o
    } = e, {
        variant: a
    } = e;
    const s = `background-color: #${Xt[a.key].hex.toString(16)}`,
        l = `configurator-option-${o.key}`;
    return t.$$set = t => {
        "option" in t && n(0, o = t.option), "variant" in t && n(1, a = t.variant)
    }, t.$$.update = () => {
        131 & t.$$.dirty && n(2, r = i[o.key] === a.key)
    }, [o, a, r, s, l, undefined, function (t) {
        window.dispatchEvent(new CustomEvent("variant", {
            detail: {
                option: o,
                variant: a
            }
        })), ne.select(o.key, t.target.checked && a.key)
    }, i]
}
class vr extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ar, gr, a, {
            option: 0,
            variant: 1
        })
    }
}

function _r(t, e, n) {
    const r = t.slice();
    return r[6] = e[n], r
}

function yr(t, e, n) {
    const r = t.slice();
    return r[6] = e[n], r
}

function Er(t) {
    let e;
    return {
        c() {
            e = L("div"), e.textContent = "New", N(e, "class", "configurator-section-header-badge type-caps type-12 svelte-rzpqdb")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function xr(e) {
    let n, r, i = "custom" !== e[6].key && function (e) {
        let n, r;
        return n = new vr({
            props: {
                option: e[3],
                variant: e[6]
            }
        }), {
            c() {
                Mt(n.$$.fragment)
            },
            m(t, e) {
                Tt(n, t, e), r = !0
            },
            p: t,
            i(t) {
                r || (bt(n.$$.fragment, t), r = !0)
            },
            o(t) {
                wt(n.$$.fragment, t), r = !1
            },
            d(t) {
                Bt(n, t)
            }
        }
    }(e);
    return {
        c() {
            i && i.c(), n = k()
        },
        m(t, e) {
            i && i.m(t, e), T(t, n, e), r = !0
        },
        p(t, e) {
            "custom" !== t[6].key && i.p(t, e)
        },
        i(t) {
            r || (bt(i), r = !0)
        },
        o(t) {
            wt(i), r = !1
        },
        d(t) {
            t && B(n), i && i.d(t)
        }
    }
}

function br(t) {
    let e, n, r, i, o = St(t[3].values),
        a = [];
    for (let e = 0; e < o.length; e += 1) a[e] = wr(_r(t, o, e));
    const s = t => wt(a[t], 1, 1, (() => {
        a[t] = null
    }));
    return {
        c() {
            e = L("div"), n = O(), r = L("ul");
            for (let t = 0; t < a.length; t += 1) a[t].c();
            N(e, "class", "spacer-32"), N(r, "class", "configurator-option-variants svelte-rzpqdb")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), T(t, r, o);
            for (let t = 0; t < a.length; t += 1) a[t] && a[t].m(r, null);
            i = !0
        },
        p(t, e) {
            if (8 & e) {
                let n;
                for (o = St(t[3].values), n = 0; n < o.length; n += 1) {
                    const i = _r(t, o, n);
                    a[n] ? (a[n].p(i, e), bt(a[n], 1)) : (a[n] = wr(i), a[n].c(), bt(a[n], 1), a[n].m(r, null))
                }
                for (Et(), n = o.length; n < a.length; n += 1) s(n);
                xt()
            }
        },
        i(t) {
            if (!i) {
                for (let t = 0; t < o.length; t += 1) bt(a[t]);
                i = !0
            }
        },
        o(t) {
            a = a.filter(Boolean);
            for (let t = 0; t < a.length; t += 1) wt(a[t]);
            i = !1
        },
        d(t) {
            t && (B(e), B(n), B(r)), R(a, t)
        }
    }
}

function wr(e) {
    let n, r, i = "custom" === e[6].key && function (e) {
        let n, r;
        return n = new Nn({
            props: {
                option: e[3],
                variant: e[6]
            }
        }), {
            c() {
                Mt(n.$$.fragment)
            },
            m(t, e) {
                Tt(n, t, e), r = !0
            },
            p: t,
            i(t) {
                r || (bt(n.$$.fragment, t), r = !0)
            },
            o(t) {
                wt(n.$$.fragment, t), r = !1
            },
            d(t) {
                Bt(n, t)
            }
        }
    }(e);
    return {
        c() {
            i && i.c(), n = k()
        },
        m(t, e) {
            i && i.m(t, e), T(t, n, e), r = !0
        },
        p(t, e) {
            "custom" === t[6].key && i.p(t, e)
        },
        i(t) {
            r || (bt(i), r = !0)
        },
        o(t) {
            wt(i), r = !1
        },
        d(t) {
            t && B(n), i && i.d(t)
        }
    }
}

function Cr(t) {
    let e, n, r, i, o, a, s, l, c = t[1].display.description + "",
        u = "custom" !== t[1].key && Sr(t);
    return {
        c() {
            e = L("div"), n = O(), r = L("hr"), i = O(), o = L("div"), u && u.c(), a = O(), s = L("div"), l = P(c), N(e, "class", "spacer-24 m-spacer-18"), N(r, "class", "divider"), N(s, "class", "type-14 color-text-40 configurator-option-color-description-text svelte-rzpqdb"), N(o, "class", "configurator-option-color-description svelte-rzpqdb")
        },
        m(t, c) {
            T(t, e, c), T(t, n, c), T(t, r, c), T(t, i, c), T(t, o, c), u && u.m(o, null), S(o, a), S(o, s), S(s, l)
        },
        p(t, e) {
            "custom" !== t[1].key ? u ? u.p(t, e) : (u = Sr(t), u.c(), u.m(o, a)) : u && (u.d(1), u = null), 2 & e && c !== (c = t[1].display.description + "") && F(l, c)
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(o)), u && u.d()
        }
    }
}

function Sr(t) {
    let e, n, r = t[1].display.title + "";
    return {
        c() {
            e = L("div"), n = P(r), N(e, "class", "type-18 m-type-15")
        },
        m(t, r) {
            T(t, e, r), S(e, n)
        },
        p(t, e) {
            2 & e && r !== (r = t[1].display.title + "") && F(n, r)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Ir(t) {
    let e, n, r, i, o, a, s, l, c, u, h = !0 === t[0] && Er(),
        d = St(t[3].values),
        p = [];
    for (let e = 0; e < d.length; e += 1) p[e] = xr(yr(t, d, e));
    const f = t => wt(p[t], 1, 1, (() => {
        p[t] = null
    }));
    let m = t[2] && br(t),
        g = t[1] && t[1].display.description && Cr(t);
    return {
        c() {
            e = L("div"), h && h.c(), n = O(), r = L("h2"), r.textContent = `${t[3].display.title}`, i = O(), o = L("div"), a = O(), s = L("ul");
            for (let t = 0; t < p.length; t += 1) p[t].c();
            l = O(), m && m.c(), c = O(), g && g.c(), N(r, "class", "type-24-light m-type-18"), N(o, "class", "spacer-32"), N(s, "class", "configurator-option-variants svelte-rzpqdb"), N(e, "class", "configurator-option")
        },
        m(t, d) {
            T(t, e, d), h && h.m(e, null), S(e, n), S(e, r), S(e, i), S(e, o), S(e, a), S(e, s);
            for (let t = 0; t < p.length; t += 1) p[t] && p[t].m(s, null);
            S(e, l), m && m.m(e, null), S(e, c), g && g.m(e, null), u = !0
        },
        p(t, [r]) {
            if (!0 === t[0] ? h || (h = Er(), h.c(), h.m(e, n)) : h && (h.d(1), h = null), 8 & r) {
                let e;
                for (d = St(t[3].values), e = 0; e < d.length; e += 1) {
                    const n = yr(t, d, e);
                    p[e] ? (p[e].p(n, r), bt(p[e], 1)) : (p[e] = xr(n), p[e].c(), bt(p[e], 1), p[e].m(s, null))
                }
                for (Et(), e = d.length; e < p.length; e += 1) f(e);
                xt()
            }
            t[2] ? m ? (m.p(t, r), 4 & r && bt(m, 1)) : (m = br(t), m.c(), bt(m, 1), m.m(e, c)) : m && (Et(), wt(m, 1, 1, (() => {
                m = null
            })), xt()), t[1] && t[1].display.description ? g ? g.p(t, r) : (g = Cr(t), g.c(), g.m(e, null)) : g && (g.d(1), g = null)
        },
        i(t) {
            if (!u) {
                for (let t = 0; t < d.length; t += 1) bt(p[t]);
                bt(m), u = !0
            }
        },
        o(t) {
            p = p.filter(Boolean);
            for (let t = 0; t < p.length; t += 1) wt(p[t]);
            wt(m), u = !1
        },
        d(t) {
            t && B(e), h && h.d(), R(p, t), m && m.d(), g && g.d()
        }
    }
}

function Mr(t, e, n) {
    let r, i, o;
    h(t, ne, (t => n(5, o = t)));
    let {
        key: a
    } = e, {
        isNew: s = !1
    } = e;
    const l = Yt(a);
    return t.$$set = t => {
        "key" in t && n(4, a = t.key), "isNew" in t && n(0, s = t.isNew)
    }, t.$$.update = () => {
        32 & t.$$.dirty && n(2, r = Kt("custom", l) && "cement" === o.cladding), 48 & t.$$.dirty && n(1, i = o[a] && Kt(o[a], l))
    }, [s, i, r, l, a, o]
}
class Tr extends Dt {
    constructor(t) {
        super(), Lt(this, t, Mr, Ir, a, {
            key: 4,
            isNew: 0
        })
    }
}
const Br = t => ({}),
    Rr = t => ({}),
    Lr = t => ({}),
    Dr = t => ({}),
    Pr = t => ({}),
    Or = t => ({});

function kr(t) {
    let e;
    return {
        c() {
            e = L("div"), e.textContent = "New", N(e, "class", "configurator-section-header-badge type-caps type-12 svelte-u0udsm")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Ur(t) {
    let e, n, r, i, o, a, s, l, c, u = !0 === t[0] && kr();
    const h = t[2].title,
        p = d(h, t, t[1], Or),
        A = t[2].description,
        v = d(A, t, t[1], Dr),
        _ = t[2].extra,
        y = d(_, t, t[1], Rr);
    return {
        c() {
            e = L("div"), u && u.c(), n = O(), r = L("h1"), p && p.c(), i = O(), o = L("div"), a = O(), s = L("p"), v && v.c(), l = O(), y && y.c(), N(r, "class", "type-30-light m-type-24-light"), N(o, "class", "spacer-12 m-spacer-8"), N(s, "class", "type-24-light m-type-18-light color-text-40"), N(e, "class", "configurator-section-header")
        },
        m(t, h) {
            T(t, e, h), u && u.m(e, null), S(e, n), S(e, r), p && p.m(r, null), S(e, i), S(e, o), S(e, a), S(e, s), v && v.m(s, null), S(e, l), y && y.m(e, null), c = !0
        },
        p(t, [r]) {
            !0 === t[0] ? u || (u = kr(), u.c(), u.m(e, n)) : u && (u.d(1), u = null), p && p.p && (!c || 2 & r) && m(p, h, t, t[1], c ? f(h, t[1], r, Pr) : g(t[1]), Or), v && v.p && (!c || 2 & r) && m(v, A, t, t[1], c ? f(A, t[1], r, Lr) : g(t[1]), Dr), y && y.p && (!c || 2 & r) && m(y, _, t, t[1], c ? f(_, t[1], r, Br) : g(t[1]), Rr)
        },
        i(t) {
            c || (bt(p, t), bt(v, t), bt(y, t), c = !0)
        },
        o(t) {
            wt(p, t), wt(v, t), wt(y, t), c = !1
        },
        d(t) {
            t && B(e), u && u.d(), p && p.d(t), v && v.d(t), y && y.d(t)
        }
    }
}

function Nr(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e, {
        isNew: o = !1
    } = e;
    return t.$$set = t => {
        "isNew" in t && n(0, o = t.isNew), "$$scope" in t && n(1, i = t.$$scope)
    }, [o, i, r]
}
class Fr extends Dt {
    constructor(t) {
        super(), Lt(this, t, Nr, Ur, a, {
            isNew: 0
        })
    }
}
const {
    window: Qr
} = C;

function $r(t) {
    let e, n, r, o, a;
    const s = t[13].default,
        l = d(s, t, t[12], null);
    return {
        c() {
            e = L("div"), n = L("div"), l && l.c(), N(n, "class", "configurator-section-preview-sticker svelte-1hl8vd7"), N(n, "style", t[7]), H(n, "configurator-section-preview-sticker-photo", "auto" !== t[0]), N(e, "class", "configurator-section-preview svelte-1hl8vd7"), N(e, "style", t[6]), H(e, "configurator-section-preview-visible", t[5]), H(e, "configurator-section-preview-first", t[1]), H(e, "configurator-section-preview-last", t[2]), H(e, "configurator-section-preview-sticky", !0 === t[3] || "auto" === t[0])
        },
        m(i, s) {
            T(i, e, s), S(e, n), l && l.m(n, null), t[14](e), r = !0, o || (a = [U(Qr, "resize", t[8]), U(Qr, "scroll", t[8])], o = !0)
        },
        p(t, [i]) {
            l && l.p && (!r || 4096 & i) && m(l, s, t, t[12], r ? f(s, t[12], i, null) : g(t[12]), null), (!r || 1 & i) && H(n, "configurator-section-preview-sticker-photo", "auto" !== t[0]), (!r || 64 & i) && N(e, "style", t[6]), (!r || 32 & i) && H(e, "configurator-section-preview-visible", t[5]), (!r || 2 & i) && H(e, "configurator-section-preview-first", t[1]), (!r || 4 & i) && H(e, "configurator-section-preview-last", t[2]), (!r || 9 & i) && H(e, "configurator-section-preview-sticky", !0 === t[3] || "auto" === t[0])
        },
        i(t) {
            r || (bt(l, t), r = !0)
        },
        o(t) {
            wt(l, t), r = !1
        },
        d(n) {
            n && B(e), l && l.d(n), t[14](null), o = !1, i(a)
        }
    }
}

function Gr(t, e, n) {
    let r, i, o, {
            $$slots: a = {},
            $$scope: s
        } = e,
        {
            aspectRatio: l = "auto"
        } = e,
        {
            isFirst: c = !1
        } = e,
        {
            isLast: u = !1
        } = e,
        {
            isFullPage: h = !1
        } = e,
        {
            isSticky: d = !1
        } = e,
        p = document.body.clientHeight,
        f = !0;
    const m = `aspect-ratio: ${l}; height: ${"auto"===l?"100vh":"auto"}; top: ${"auto"===l?"0":`calc((100vh - (50vw / ${l})) / 2)`}; max-width: 100%;`;

    function g() {
        if (n(10, p = document.body.clientHeight), h) return;
        if (window.innerWidth <= 768) return void n(5, f = !0);
        const t = o.getBoundingClientRect(),
            e = .5 * window.innerHeight;
        n(5, f = t.top <= e && t.bottom > e)
    }
    return Z(g), t.$$set = t => {
        "aspectRatio" in t && n(0, l = t.aspectRatio), "isFirst" in t && n(1, c = t.isFirst), "isLast" in t && n(2, u = t.isLast), "isFullPage" in t && n(9, h = t.isFullPage), "isSticky" in t && n(3, d = t.isSticky), "$$scope" in t && n(12, s = t.$$scope)
    }, t.$$.update = () => {
        1536 & t.$$.dirty && n(11, r = h ? `${p}px` : "100%"), 2048 & t.$$.dirty && n(6, i = `height: ${r}`)
    }, [l, c, u, d, o, f, i, m, g, h, p, r, s, a, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            o = t, n(4, o)
        }))
    }]
}
class Hr extends Dt {
    constructor(t) {
        super(), Lt(this, t, Gr, $r, a, {
            aspectRatio: 0,
            isFirst: 1,
            isLast: 2,
            isFullPage: 9,
            isSticky: 3
        })
    }
}

function zr(t) {
    let e;
    return {
        c() {
            e = L("div"), e.textContent = "Unit as configured", N(e, "class", "type-14 m-type-12 color-text-60")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Vr(e) {
    let n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A = Be(e[1].base) + "",
        v = e[0].layout && zr();
    return {
        c() {
            n = L("hr"), r = O(), i = L("div"), o = O(), a = L("div"), s = L("div"), v && v.c(), l = O(), c = L("div"), u = O(), h = L("div"), d = P(A), p = O(), f = L("span"), f.textContent = "plus installation", m = O(), g = L("div"), N(n, "class", "divider"), N(i, "class", "spacer-24 m-spacer-16"), N(c, "class", "spacer-4"), N(f, "class", "type-18-light color-text-60"), N(h, "class", "type-18 m-type-15"), N(g, "class", "spacer-0 m-spacer-16"), N(s, "class", "column-12 m-column-6"), N(a, "class", "modern-grid modern-grid-full")
        },
        m(t, e) {
            T(t, n, e), T(t, r, e), T(t, i, e), T(t, o, e), T(t, a, e), S(a, s), v && v.m(s, null), S(s, l), S(s, c), S(s, u), S(s, h), S(h, d), S(h, p), S(h, f), S(s, m), S(s, g)
        },
        p(t, [e]) {
            t[0].layout ? v || (v = zr(), v.c(), v.m(s, l)) : v && (v.d(1), v = null), 2 & e && A !== (A = Be(t[1].base) + "") && F(d, A)
        },
        i: t,
        o: t,
        d(t) {
            t && (B(n), B(r), B(i), B(o), B(a)), v && v.d()
        }
    }
}

function Wr(t, e, n) {
    let r, i;
    return h(t, ne, (t => n(0, r = t))), h(t, oe, (t => n(1, i = t))), [r, i]
}
class jr extends Dt {
    constructor(t) {
        super(), Lt(this, t, Wr, Vr, a, {})
    }
}

function Xr(t) {
    let e, n, r;
    return {
        c() {
            e = L("div"), n = O(), r = L("div"), r.innerHTML = '<span class="svelte-1fg7p2e">¹</span>\n\t\tNet zero may change for build sites with significant shading.', N(e, "class", "spacer-12"), N(r, "class", "type-12 type-light color-text-40 configurator-footnote svelte-1fg7p2e")
        },
        m(t, i) {
            T(t, e, i), T(t, n, i), T(t, r, i)
        },
        d(t) {
            t && (B(e), B(n), B(r))
        }
    }
}

function qr(e) {
    let n, r, i, o, a, s = e[0] && Xr();
    return {
        c() {
            n = L("hr"), r = O(), i = L("div"), o = O(), s && s.c(), a = k(), N(n, "class", "divider"), N(i, "class", "spacer-24")
        },
        m(t, e) {
            T(t, n, e), T(t, r, e), T(t, i, e), T(t, o, e), s && s.m(t, e), T(t, a, e)
        },
        p(t, [e]) {
            t[0] ? s || (s = Xr(), s.c(), s.m(a.parentNode, a)) : s && (s.d(1), s = null)
        },
        i: t,
        o: t,
        d(t) {
            t && (B(n), B(r), B(i), B(o), B(a)), s && s.d(t)
        }
    }
}

function Yr(t, e, n) {
    let {
        isNetZeroFootnoteVisible: r = !0
    } = e;
    return t.$$set = t => {
        "isNetZeroFootnoteVisible" in t && n(0, r = t.isNetZeroFootnoteVisible)
    }, [r]
}
class Kr extends Dt {
    constructor(t) {
        super(), Lt(this, t, Yr, qr, a, {
            isNetZeroFootnoteVisible: 0
        })
    }
}

function Jr(t) {
    let e, n, r, i, o, a, s, l, c, u, h, p, A, v, _, y, E, x, b, w, C, I, M, R, D, k, F, Q, $, G, z, V, W, j, X, q, Y, K, J, Z, tt;
    o = new jr({});
    const et = t[3].default,
        nt = d(et, t, t[2], null);
    return K = new Kr({}), {
        c() {
            e = L("h2"), e.textContent = "Price breakdown for your Backyard", n = O(), r = L("div"), i = O(), Mt(o.$$.fragment), a = O(), s = L("div"), l = O(), c = L("hr"), u = O(), h = L("div"), p = O(), A = L("div"), v = L("div"), _ = L("div"), _.textContent = "Need a break?", y = O(), E = L("div"), x = O(), b = L("div"), b.textContent = "Save your configuration link and come back at any time.", w = O(), C = L("div"), I = O(), M = L("a"), R = L("div"), R.textContent = "Link copied", D = P("\n\t\t\tCopy\n\t\t\t"), k = L("span"), k.textContent = "configuration", F = P(" link"), Q = O(), $ = L("div"), G = O(), z = L("div"), z.innerHTML = '<div class="type-14 m-type-12 type-regola-regular">Have questions?</div> <div class="spacer-4"></div> <div class="type-14 m-type-12 color-text-60">Talk to one of our experts to get answers or support.</div> <div class="spacer-12 m-spacer-4"></div> <a onclick="Contact.show()" class="type-14 m-type-12 type-regola-regular">Talk to us</a>', V = O(), W = L("div"), j = O(), nt && nt.c(), X = O(), q = L("div"), Y = O(), Mt(K.$$.fragment), N(e, "class", "type-24-light m-type-18-light"), N(r, "class", "spacer-24 m-spacer-16"), N(s, "class", "spacer-50"), N(c, "class", "divider"), N(h, "class", "spacer-24 m-spacer-16"), N(_, "class", "type-14 m-type-12 type-regola-regular"), N(E, "class", "spacer-4"), N(b, "class", "type-14 m-type-12 color-text-60"), N(C, "class", "spacer-12 m-spacer-4"), N(R, "class", "configurator-link-copied-toast type-12 svelte-io64vq"), H(R, "configurator-link-copied-toast-visible", t[0]), N(k, "class", "mobile-hidden"), N(M, "class", "type-14 m-type-12 type-regola-regular configurator-link svelte-io64vq"), N($, "class", "spacer-0 m-spacer-16"), N(v, "class", "column-6 m-column-3"), N(z, "class", "column-6 m-column-3"), N(A, "class", "modern-grid modern-grid-full"), N(W, "class", "spacer-64 m-spacer-50"), N(q, "class", "spacer-64 m-spacer-50")
        },
        m(d, f) {
            T(d, e, f), T(d, n, f), T(d, r, f), T(d, i, f), Tt(o, d, f), T(d, a, f), T(d, s, f), T(d, l, f), T(d, c, f), T(d, u, f), T(d, h, f), T(d, p, f), T(d, A, f), S(A, v), S(v, _), S(v, y), S(v, E), S(v, x), S(v, b), S(v, w), S(v, C), S(v, I), S(v, M), S(M, R), S(M, D), S(M, k), S(M, F), S(v, Q), S(v, $), S(A, G), S(A, z), T(d, V, f), T(d, W, f), T(d, j, f), nt && nt.m(d, f), T(d, X, f), T(d, q, f), T(d, Y, f), Tt(K, d, f), J = !0, Z || (tt = U(M, "click", t[1]), Z = !0)
        },
        p(t, [e]) {
            (!J || 1 & e) && H(R, "configurator-link-copied-toast-visible", t[0]), nt && nt.p && (!J || 4 & e) && m(nt, et, t, t[2], J ? f(et, t[2], e, null) : g(t[2]), null)
        },
        i(t) {
            J || (bt(o.$$.fragment, t), bt(nt, t), bt(K.$$.fragment, t), J = !0)
        },
        o(t) {
            wt(o.$$.fragment, t), wt(nt, t), wt(K.$$.fragment, t), J = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(a), B(s), B(l), B(c), B(u), B(h), B(p), B(A), B(V), B(W), B(j), B(X), B(q), B(Y)), Bt(o, t), nt && nt.d(t), Bt(K, t), Z = !1, tt()
        }
    }
}

function Zr(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e, o = !1;
    return t.$$set = t => {
        "$$scope" in t && n(2, i = t.$$scope)
    }, [o, function () {
        n(0, o = !0), navigator.clipboard.writeText(location.href), setTimeout((() => {
            n(0, o = !1)
        }), 2e3)
    }, i, r]
}
class ti extends Dt {
    constructor(t) {
        super(), Lt(this, t, Zr, Jr, a, {})
    }
}
const ei = {
        paths: {
            models_path: "/assets/ddd/models/",
            textures_path: "/assets/ddd/textures/",
            decoders_path: "/assets/ddd/decoders/"
        },
        camera: {
            initPos: {
                x: 5,
                y: 1.5,
                z: 13
            }
        },
        environment: {
            assetsArray: [{
                id: 2,
                hdrTexturePath: "hdr/hdr-2",
                name: "hdr-2",
                isDefault: !0,
                defaultHdrIntensity: 1.5
            }]
        },
        controls: {
            defaultRightClick: !0
        },
        loadOnDemand: {
            enabled: !0
        }
    },
    ni = {
        left: () => [-12, .5, 4],
        "left-angle": () => [-7, .5, 10],
        "left-angle-back": () => [-7, .5, -10],
        "left-back": () => [-12, .5, -4],
        front: () => [0, .5, 12],
        back: () => [0, .5, -12],
        right: () => [12, .5, 4],
        "right-angle": () => [7, .5, 10],
        "right-angle-back": () => [7, .5, -10],
        "right-back": () => [12, .5, -4],
        roof: t => void 0 !== t && (t.startsWith("left") || t.startsWith("front")) ? [-11.75, 5.45, 5.3] : [11.75, 5.45, 5.3]
    },
    ri = ["front", "left-angle", "left", "roof", "front", "right-angle", "roof"];

function ii(t, e) {
    function n(t, e) {
        return "layout" === t ? "xl8" === e ? {
            layout: "XL 8"
        } : "xl10" === e ? {
            layout: "XL 10"
        } : {
            layout: e
        } : "cladding" === t ? {
            trim: "cement" === e ? "wood" : "metal"
        } : "color" === t ? "custom" === e ? {
            color: "Bone white base"
        } : {
            color: Xt[e].name
        } : "front" === t ? {
            front: "front-window" === e ? "window" : "double doors"
        } : "left" === t ? {
            left: "side-doors" === e ? "double doors" : "window"
        } : "roof" === t ? {
            roof: Xt[e]
        } : "solar" === t ? {
            solar: "solar-no" === e ? "no-solar" : e
        } : "xl-living-room-side" === t ? {
            "living room": "window" === e ? "window" : "double doors"
        } : "xl-primary-bedroom-side" === t ? {
            "primary bedroom": "window" === e ? "window" : "double doors"
        } : "xl-secondary-bedroom-side" === t ? {
            "secondary bedroom": "window" === e ? "window" : "double doors"
        } : "powerwall" === t ? {
            powerwall: "powerwall" === e ? "Tesla Powerwall 3" : "No Powerwall"
        } : {
            [t]: e
        }
    }
    const r = Object.entries(t).reduce(((t, [e, r]) => ({
        ...t,
        ...n(e, r)
    })), {});
    return e.entry && ("entry-front" === e.entry && (r.front = "double doors"), r.right = "entry-side" === e.entry ? "double doors" : "window"), r.cables = "no-cables", Object.entries(r).forEach((([t, e]) => {
        void 0 === e && delete r[t]
    })), r
}

function oi() {
    const t = document.createElement("samara-scene"),
        e = u(ne);
    if (document.location.hash) {
        let [t, n] = document.location.hash.slice(1).split("+");
        n = n.replace("-", ""), "xl" === n && (n = "xl8"), e.layout = n, e.color = `base-${t}`
    }
    const n = {
        ...ii({
            ...jt,
            ...e
        }, e),
        devMode: "off"
    };
    return t.setAttribute("initialstate", JSON.stringify(n)), t
}

function ai() {
    return {
        element: oi(),
        isLoading: !1,
        isCameraControlDiscovered: !1,
        progress: 0,
        camera: "front"
    }
}
const si = function () {
    let t = !1;
    const e = Ht(ai()),
        {
            update: n,
            subscribe: r,
            set: i
        } = e;
    async function o() {
        if (t) return;
        t = !0;
        const e = new globalThis.exported.CreateScene(ei);
        "development" === process.env.NODE_ENV && (window.scene = e), e.status().subscribe((({
            isLoading: t,
            percent: r
        }) => {
            n((n => ({
                ...n,
                scene: e,
                progress: t ? r / 100 : 1,
                isLoading: t
            })))
        }));
        try {
            await e.init(), a()
        } catch (e) {
            console.error(e), n((t => ({
                ...t,
                scene: null,
                isLoading: !1
            }))), t = !1
        }
    }

    function a() {
        const {
            element: t,
            isLoading: n,
            scene: r
        } = u(e);
        if (!0 === n || !r || !r.CameraGsap) return;
        const i = t.parentElement.clientHeight < window.innerHeight,
            o = r.CameraGsap.getControls();
        o.azimuthRotateSpeed = i ? .33 : 1, o.polarRotateSpeed = i ? .15 : 1, o.smoothTime = i ? .1 : .3, r.setupPerspectiveView(15, i ? 140 : 220), r.onResize()
    }

    function s() {
        const {
            scene: t
        } = u(e);
        if (null == t) return;
        const n = u(ne),
            r = ii(te({
                ...jt,
                ...n
            }), n);
        ["layout", "trim", "color", "roof", "left", "right", "front", "living room", "primary bedroom", "secondary bedroom", "solar", "powerwall"].forEach((e => {
            t.setOption({
                [e]: r[e]
            })
        })), t.onComplectationChange(), t.renderOnce()
    }
    let l, c, h, d = !1;
    return Te.subscribe((({
        isLoading: t
    }) => {
        !1 === t && s()
    })), r((({
        isLoading: t,
        scene: e,
        camera: r
    }) => {
        if (l) return;
        if (t || null == e || void 0 === e.CameraGsap) return;
        let [i, o, a] = ni[r](c);
        const s = e.CameraGsap.getControls().camera.position,
            u = Math.abs(s.x - ei.camera.initPos.x) < 1 && Math.abs(s.y - ei.camera.initPos.y) < 1 && Math.abs(s.z - ei.camera.initPos.z) < 1;
        if (!1 === u && !1 === d) return;
        if (!1 === u && c === r) return;
        const p = u ? 2400 : 600;
        u && (d = !0, l = !0, setTimeout((() => {
            l = !1
        }), p));
        const f = u ? "power2.out" : void 0;
        c = r;
        const {
            start: m,
            cancel: g
        } = e.CameraGsap.setPositionSpherical(i, o, a, p / 1e3, f);
        m(), h = g, !1 === u && "front" !== r && n((t => ({
            ...t,
            isCameraControlDiscovered: !0
        })))
    })), window.addEventListener("variant", (function (t) {
        const r = u(ne),
            i = t.detail.option.display;
        let o = 0;
        if ("layout" !== t.detail.option.key) {
            const t = "function" == typeof i.camera ? i.camera(r) : i.camera;
            if (t) {
                const {
                    camera: r
                } = u(e);
                r !== t && (o = 798), n((e => ({
                    ...e,
                    camera: t
                })))
            }
        }
        setTimeout(s, o)
    })), window.addEventListener("resize", (function () {
        a()
    })), {
        subscribe: r,
        reset() {
            const {
                element: n
            } = u(e);
            n && n.parentElement && n.parentElement.removeChild(n), i(ai()), t = !1
        },
        resetCamera() {
            n((t => (t.scene?.CameraGsap && t.scene.CameraGsap.setPositionSpherical(ei.camera.initPos.x, ei.camera.initPos.y, ei.camera.initPos.z, 1).start(), {
                ...t,
                camera: "front"
            })))
        },
        changeCamera(t) {
            n((e => ({
                ...e,
                camera: t
            })))
        },
        cancelCameraAnimation() {
            h && (h(), h = void 0)
        },
        markCameraControlsDiscovered() {
            n((t => ({
                ...t,
                isCameraControlDiscovered: !0
            })))
        },
        take: () => (setTimeout(o, 0), setTimeout(a, 0), u(e).element)
    }
}();
const li = function () {
    const {
        update: t,
        subscribe: e
    } = Ht({
        isVisible: !1
    });
    return {
        subscribe: e,
        show() {
            t((t => ({
                ...t,
                isVisible: !0
            })))
        },
        hide() {
            t((t => ({
                ...t,
                isVisible: !1
            })))
        }
    }
}();

function ci(e) {
    let n, r, i;
    return {
        c() {
            n = L("a"), n.innerHTML = 'Financing options available. <svg width="13" height="12" viewBox="0 0 13 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.49609 12C5.69141 12 4.93555 11.8457 4.22852 11.5371C3.52148 11.2324 2.89648 10.8105 2.35352 10.2715C1.81445 9.73242 1.39062 9.10938 1.08203 8.40234C0.777344 7.69141 0.625 6.93359 0.625 6.12891C0.625 5.32422 0.777344 4.56836 1.08203 3.86133C1.39062 3.15039 1.81445 2.52539 2.35352 1.98633C2.89258 1.44727 3.51562 1.02539 4.22266 0.720703C4.93359 0.412109 5.68945 0.257812 6.49023 0.257812C7.29883 0.257812 8.05664 0.412109 8.76367 0.720703C9.47461 1.02539 10.0996 1.44727 10.6387 1.98633C11.1816 2.52539 11.6055 3.15039 11.9102 3.86133C12.2188 4.56836 12.373 5.32422 12.373 6.12891C12.373 6.93359 12.2188 7.69141 11.9102 8.40234C11.6055 9.10938 11.1816 9.73242 10.6387 10.2715C10.0996 10.8105 9.47461 11.2324 8.76367 11.5371C8.05664 11.8457 7.30078 12 6.49609 12ZM6.49609 11.25C7.20703 11.25 7.87109 11.1172 8.48828 10.8516C9.10938 10.5859 9.6543 10.2207 10.123 9.75586C10.5957 9.28711 10.9629 8.74414 11.2246 8.12695C11.4902 7.50586 11.623 6.83984 11.623 6.12891C11.623 5.41797 11.4902 4.75391 11.2246 4.13672C10.959 3.51562 10.5918 2.9707 10.123 2.50195C9.6543 2.0332 9.10938 1.66602 8.48828 1.40039C7.86719 1.13477 7.20117 1.00195 6.49023 1.00195C5.7832 1.00195 5.11914 1.13477 4.49805 1.40039C3.88086 1.66602 3.33789 2.0332 2.86914 2.50195C2.4043 2.9707 2.03906 3.51562 1.77344 4.13672C1.50781 4.75391 1.375 5.41797 1.375 6.12891C1.375 6.83984 1.50781 7.50586 1.77344 8.12695C2.03906 8.74414 2.40625 9.28711 2.875 9.75586C3.34375 10.2207 3.88672 10.5859 4.50391 10.8516C5.125 11.1172 5.78906 11.25 6.49609 11.25ZM5.44727 9.35156C5.35352 9.35156 5.27539 9.32227 5.21289 9.26367C5.15039 9.20117 5.11914 9.125 5.11914 9.03516C5.11914 8.94531 5.15039 8.86914 5.21289 8.80664C5.27539 8.74414 5.35352 8.71289 5.44727 8.71289H6.29688V5.66016H5.52344C5.42969 5.66016 5.35156 5.62891 5.28906 5.56641C5.22656 5.50391 5.19531 5.42773 5.19531 5.33789C5.19531 5.24805 5.22656 5.17383 5.28906 5.11523C5.35156 5.05273 5.42969 5.02148 5.52344 5.02148H6.6543C6.76758 5.02148 6.85352 5.05859 6.91211 5.13281C6.97461 5.20312 7.00586 5.29688 7.00586 5.41406V8.71289H7.84961C7.94336 8.71289 8.02148 8.74414 8.08398 8.80664C8.14648 8.86914 8.17773 8.94531 8.17773 9.03516C8.17773 9.125 8.14648 9.20117 8.08398 9.26367C8.02148 9.32227 7.94336 9.35156 7.84961 9.35156H5.44727ZM6.4668 3.94336C6.29102 3.94336 6.14062 3.88281 6.01562 3.76172C5.89062 3.63672 5.82812 3.48633 5.82812 3.31055C5.82812 3.13086 5.89062 2.98047 6.01562 2.85938C6.14062 2.73438 6.29102 2.67188 6.4668 2.67188C6.64258 2.67188 6.79102 2.73438 6.91211 2.85938C7.03711 2.98047 7.09961 3.13086 7.09961 3.31055C7.09961 3.48633 7.03711 3.63672 6.91211 3.76172C6.79102 3.88281 6.64258 3.94336 6.4668 3.94336Z" fill="black" fill-opacity="0.4" style="fill:black;fill-opacity:0.4;"></path></svg>', N(n, "class", "ctype-14 type-light color-text-40 svelte-yvnp44")
        },
        m(t, o) {
            T(t, n, o), r || (i = U(n, "click", e[0]), r = !0)
        },
        p: t,
        i: t,
        o: t,
        d(t) {
            t && B(n), r = !1, i()
        }
    }
}

function ui(t) {
    return [function () {
        li.show()
    }]
}
class hi extends Dt {
    constructor(t) {
        super(), Lt(this, t, ui, ci, a, {})
    }
}

function di(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g = Be(t[3].base) + "";
    return d = new hi({}), {
        c() {
            e = L("div"), n = L("div"), r = O(), i = L("div"), o = P(g), a = O(), s = L("span"), s.textContent = " plus installation", l = O(), c = L("div"), u = O(), h = L("div"), Mt(d.$$.fragment), p = O(), f = L("div"), N(n, "class", "spacer-0 m-spacer-12"), N(s, "class", "color-text-40"), N(i, "class", "configurator-cost-pill-content svelte-2y5uap"), N(c, "class", "spacer-12 m-spacer-flexible"), N(h, "class", "configurator-cost-pill-hint svelte-2y5uap"), N(f, "class", "spacer-24"), N(e, "class", "configurator-cost-pill type-18 m-type-15 type-light svelte-2y5uap"), H(e, "configurator-cost-pill-light", t[0]), H(e, "configurator-cost-pill-hint-visible", t[1]), H(e, "configurator-cost-pill-loading", t[2])
        },
        m(t, g) {
            T(t, e, g), S(e, n), S(e, r), S(e, i), S(i, o), S(i, a), S(i, s), S(e, l), S(e, c), S(e, u), S(e, h), Tt(d, h, null), S(e, p), S(e, f), m = !0
        },
        p(t, [n]) {
            (!m || 8 & n) && g !== (g = Be(t[3].base) + "") && F(o, g), (!m || 1 & n) && H(e, "configurator-cost-pill-light", t[0]), (!m || 2 & n) && H(e, "configurator-cost-pill-hint-visible", t[1]), (!m || 4 & n) && H(e, "configurator-cost-pill-loading", t[2])
        },
        i(t) {
            m || (bt(d.$$.fragment, t), m = !0)
        },
        o(t) {
            wt(d.$$.fragment, t), m = !1
        },
        d(t) {
            t && B(e), Bt(d)
        }
    }
}

function pi(t, e, n) {
    let r, i, o, a;
    h(t, si, (t => n(4, i = t))), h(t, Te, (t => n(5, o = t))), h(t, oe, (t => n(3, a = t)));
    let {
        isLightMaterial: s = !1
    } = e, {
        isInstallationEstimateHintVisible: l = !0
    } = e;
    return t.$$set = t => {
        "isLightMaterial" in t && n(0, s = t.isLightMaterial), "isInstallationEstimateHintVisible" in t && n(1, l = t.isInstallationEstimateHintVisible)
    }, t.$$.update = () => {
        48 & t.$$.dirty && n(2, r = o.isLoading || i.isLoading)
    }, [s, l, r, a, i, o]
}
class fi extends Dt {
    constructor(t) {
        super(), Lt(this, t, pi, di, a, {
            isLightMaterial: 0,
            isInstallationEstimateHintVisible: 1
        })
    }
}

function mi(t) {
    let e, n, r, i;
    return r = new fi({}), {
        c() {
            e = L("div"), n = L("div"), Mt(r.$$.fragment), N(n, "class", "configurator-mobile-cost-pill-sticker svelte-md2p9k"), N(e, "class", "desktop-hidden configurator-mobile-cost-pill svelte-md2p9k"), N(e, "style", t[0])
        },
        m(t, o) {
            T(t, e, o), S(e, n), Tt(r, n, null), i = !0
        },
        p(t, [n]) {
            (!i || 1 & n) && N(e, "style", t[0])
        },
        i(t) {
            i || (bt(r.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), i = !1
        },
        d(t) {
            t && B(e), Bt(r)
        }
    }
}

function gi(t, e, n) {
    let r, {
        offsetTop: i = 0
    } = e;
    return t.$$set = t => {
        "offsetTop" in t && n(1, i = t.offsetTop)
    }, t.$$.update = () => {
        2 & t.$$.dirty && n(0, r = `top: ${i}px; height: calc(100% - ${i}px)`)
    }, [r, i]
}
class Ai extends Dt {
    constructor(t) {
        super(), Lt(this, t, gi, mi, a, {
            offsetTop: 1
        })
    }
}

function vi(t) {
    let e, n, r, i, o;
    const a = t[4].default,
        s = d(a, t, t[3], null);
    return {
        c() {
            e = L("div"), s && s.c(), N(e, "class", "configurator-section svelte-k1qvu3"), N(e, "data-is-dark-content", n = t[0] || null), H(e, "configurator-section-last", t[1])
        },
        m(n, a) {
            T(n, e, a), s && s.m(e, null), t[5](e), r = !0, i || (o = U(window, "resize", _i), i = !0)
        },
        p(t, [i]) {
            s && s.p && (!r || 8 & i) && m(s, a, t, t[3], r ? f(a, t[3], i, null) : g(t[3]), null), (!r || 1 & i && n !== (n = t[0] || null)) && N(e, "data-is-dark-content", n), (!r || 2 & i) && H(e, "configurator-section-last", t[1])
        },
        i(t) {
            r || (bt(s, t), r = !0)
        },
        o(t) {
            wt(s, t), r = !1
        },
        d(n) {
            n && B(e), s && s.d(n), t[5](null), i = !1, o()
        }
    }
}

function _i() {}

function yi(t, e, n) {
    let r, {
            $$slots: i = {},
            $$scope: o
        } = e,
        {
            isDarkContent: a = !1
        } = e,
        {
            isLastSection: s = !1
        } = e;
    return Z((() => {
        setTimeout(_i, 0)
    })), et(ne.subscribe((() => {
        setTimeout(_i, 0)
    }))), t.$$set = t => {
        "isDarkContent" in t && n(0, a = t.isDarkContent), "isLastSection" in t && n(1, s = t.isLastSection), "$$scope" in t && n(3, o = t.$$scope)
    }, [a, s, r, o, i, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            r = t, n(2, r)
        }))
    }]
}
class Ei extends Dt {
    constructor(t) {
        super(), Lt(this, t, yi, vi, a, {
            isDarkContent: 0,
            isLastSection: 1
        })
    }
}
const xi = {
    options: 0,
    address: 1,
    reservation: 2,
    confirmation: 3
};
const bi = function () {
    const t = {
            page: xi.options
        },
        {
            update: e,
            subscribe: n,
            set: r
        } = Ht({
            ...t
        });
    return {
        subscribe: n,
        reset() {
            r({
                ...t
            })
        },
        previous() {
            e((t => ({
                ...t,
                page: t.page - 1
            })))
        },
        next() {
            e((t => ({
                ...t,
                page: t.page + 1
            })))
        },
        open(t) {
            gtag("event", `checkout_step_${function(t){return Object.keys(xi).find((e=>xi[e]===t))}(t)}`), e((e => ({
                ...e,
                page: t
            })))
        }
    }
}();

function wi(e) {
    let n, r, o, a, s, l, c, u, h, d, p, f, m, g;
    return {
        c() {
            n = L("div"), r = L("button"), o = D("svg"), a = D("path"), c = O(), u = L("button"), h = D("svg"), d = D("use"), N(a, "id", "chevron-icon"), N(a, "d", "M0.271484 6.99658C0.271484 6.86963 0.293457 6.75244 0.337402 6.64502C0.38623 6.5376 0.459473 6.43506 0.557129 6.3374L6.2627 0.756348C6.42871 0.595215 6.62891 0.514648 6.86328 0.514648C7.02441 0.514648 7.16846 0.553711 7.29541 0.631836C7.42725 0.705078 7.53223 0.805176 7.61035 0.932129C7.68848 1.05908 7.72754 1.20312 7.72754 1.36426C7.72754 1.59375 7.63721 1.79883 7.45654 1.97949L2.31494 6.99658L7.45654 12.0137C7.63721 12.1943 7.72754 12.4019 7.72754 12.6362C7.72754 12.7925 7.68848 12.9341 7.61035 13.061C7.53223 13.1929 7.42725 13.2954 7.29541 13.3687C7.16846 13.4468 7.02441 13.4858 6.86328 13.4858C6.62891 13.4858 6.42871 13.4028 6.2627 13.2368L0.557129 7.65576C0.459473 7.55811 0.38623 7.45557 0.337402 7.34814C0.293457 7.24072 0.271484 7.12354 0.271484 6.99658Z"), N(o, "width", "8"), N(o, "height", "14"), N(o, "viewBox", "0 0 8 14"), N(o, "fill", s = e[0] ? "white" : "black"), N(o, "fill-opacity", l = e[0] ? "1.0" : "0.6"), N(o, "xmlns", "http://www.w3.org/2000/svg"), N(o, "class", "svelte-1hhtgmf"), N(r, "title", "Previous"), N(r, "class", "button-rounded button-configurator configurator-paging-controls-previous svelte-1hhtgmf"), N(d, "href", "#chevron-icon"), N(h, "width", "8"), N(h, "height", "14"), N(h, "viewBox", "0 0 8 14"), N(h, "fill", p = e[0] ? "white" : "black"), N(h, "fill-opacity", f = e[0] ? "1.0" : "0.6"), N(h, "xmlns", "http://www.w3.org/2000/svg"), N(h, "class", "svelte-1hhtgmf"), N(u, "title", "Next"), N(u, "class", "button-rounded button-configurator configurator-paging-controls-next svelte-1hhtgmf"), N(n, "class", "configurator-paging-controls svelte-1hhtgmf"), H(n, "configurator-paging-controls-dark-content", e[0])
        },
        m(t, i) {
            T(t, n, i), S(n, r), S(r, o), S(o, a), S(n, c), S(n, u), S(u, h), S(h, d), m || (g = [U(r, "click", e[1]), U(u, "click", e[2])], m = !0)
        },
        p(t, [e]) {
            1 & e && s !== (s = t[0] ? "white" : "black") && N(o, "fill", s), 1 & e && l !== (l = t[0] ? "1.0" : "0.6") && N(o, "fill-opacity", l), 1 & e && p !== (p = t[0] ? "white" : "black") && N(h, "fill", p), 1 & e && f !== (f = t[0] ? "1.0" : "0.6") && N(h, "fill-opacity", f), 1 & e && H(n, "configurator-paging-controls-dark-content", t[0])
        },
        i: t,
        o: t,
        d(t) {
            t && B(n), m = !1, i(g)
        }
    }
}

function Ci(t, e, n) {
    let {
        isOverDarkContent: r = !1
    } = e;
    const i = nt();
    return t.$$set = t => {
        "isOverDarkContent" in t && n(0, r = t.isOverDarkContent)
    }, [r, function () {
        i("previous")
    }, function () {
        i("next")
    }]
}
class Si extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ci, wi, a, {
            isOverDarkContent: 0
        })
    }
}

function Ii(t) {
    let e;
    return {
        c() {
            e = L("div"), e.innerHTML = '<img src="/assets/images/configure/drag.svg" width="14" height="14" alt="Drag"/>\n\t\t\tDrag the model to rotate<br/>your configuration', N(e, "class", "configurator-model-view-control-hint type-15 color-text-40 svelte-43obea"), H(e, "configurator-model-view-control-hint-hidden", t[2].isCameraControlDiscovered), H(e, "configurator-model-view-control-hint-loading", t[1])
        },
        m(t, n) {
            T(t, e, n)
        },
        p(t, n) {
            4 & n && H(e, "configurator-model-view-control-hint-hidden", t[2].isCameraControlDiscovered), 2 & n && H(e, "configurator-model-view-control-hint-loading", t[1])
        },
        d(t) {
            t && B(e)
        }
    }
}

function Mi(t) {
    let e, n, r, o, a, s, l, c, u, h, d, p, f, m;
    r = new Si({}), r.$on("previous", t[4]), r.$on("next", t[5]);
    let g = t[0] && Ii(t);
    return {
        c() {
            e = L("div"), n = L("div"), Mt(r.$$.fragment), o = O(), a = L("div"), s = L("div"), l = L("div"), u = O(), h = L("div"), h.innerHTML = "", d = O(), g && g.c(), N(n, "class", "configurator-model-view-paging-controls svelte-43obea"), H(n, "configurator-model-view-paging-controls-loading", t[1]), N(l, "class", "configurator-model-view-progress-bar svelte-43obea"), N(l, "style", c = `width: ${100*t[2].progress}%`), N(s, "class", "configurator-model-view-progress-track svelte-43obea"), N(a, "class", "configurator-model-view-progress svelte-43obea"), H(a, "configurator-model-view-progress-visible", t[1]), N(h, "class", "configurator-model-view-scene-container svelte-43obea"), H(h, "configurator-model-view-scene-container-loading", t[1]), N(e, "class", "configurator-model-view svelte-43obea")
        },
        m(i, c) {
            T(i, e, c), S(e, n), Tt(r, n, null), S(e, o), S(e, a), S(a, s), S(s, l), S(e, u), S(e, h), t[10](h), S(e, d), g && g.m(e, null), p = !0, f || (m = [U(h, "mousedown", t[6]), U(h, "mousemove", t[7]), U(h, "mouseup", t[8])], f = !0)
        },
        p(t, [r]) {
            (!p || 2 & r) && H(n, "configurator-model-view-paging-controls-loading", t[1]), (!p || 4 & r && c !== (c = `width: ${100*t[2].progress}%`)) && N(l, "style", c), (!p || 2 & r) && H(a, "configurator-model-view-progress-visible", t[1]), (!p || 2 & r) && H(h, "configurator-model-view-scene-container-loading", t[1]), t[0] ? g ? g.p(t, r) : (g = Ii(t), g.c(), g.m(e, null)) : g && (g.d(1), g = null)
        },
        i(t) {
            p || (bt(r.$$.fragment, t), p = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), p = !1
        },
        d(n) {
            n && B(e), Bt(r), t[10](null), g && g.d(), f = !1, i(m)
        }
    }
}

function Ti(t, e, n) {
    let r, i, o;
    h(t, si, (t => n(2, i = t))), h(t, Te, (t => n(9, o = t)));
    let a, {
            shouldDisplayControlHint: s = !0
        } = e,
        l = 0,
        c = !1;

    function u() {
        si.changeCamera(ri[l])
    }
    const d = new IntersectionObserver((t => {
        const [{
            isIntersecting: e,
            target: n
        }] = t;
        e && n.appendChild(si.take())
    }), {
        rootMargin: "-15%"
    });
    return Z((() => {
        d.observe(a)
    })), et((() => {
        d.disconnect()
    })), t.$$set = t => {
        "shouldDisplayControlHint" in t && n(0, s = t.shouldDisplayControlHint)
    }, t.$$.update = () => {
        516 & t.$$.dirty && n(1, r = i.isLoading || o.isLoading), 3 & t.$$.dirty && !1 === window.once && s && !1 === r && (window.once = !0, si.changeCamera("front"))
    }, [s, r, i, a, function () {
        l -= 1, l < 0 && (l = ri.length - 1), u()
    }, function () {
        l += 1, l > ri.length - 1 && (l = 0), u()
    }, function () {
        c = !0, si.cancelCameraAnimation()
    }, function () {
        i.isCameraControlDiscovered || c && si.markCameraControlsDiscovered()
    }, function () {
        c = !1
    }, o, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            a = t, n(3, a)
        }))
    }]
}
class Bi extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ti, Mi, a, {
            shouldDisplayControlHint: 0
        })
    }
}
const {
    window: Ri
} = C;

function Li(t) {
    let e, n, r, o, a, s;
    const l = t[5].default,
        c = d(l, t, t[4], null);
    return {
        c() {
            e = L("div"), n = L("div"), r = O(), c && c.c(), N(n, "class", "configurator-blinds-text svelte-hebmdq"), N(e, "class", "configurator-blinds svelte-hebmdq"), H(e, "configurator-blinds-full-height", t[0]), H(e, "configurator-blinds-visible", t[2])
        },
        m(i, l) {
            T(i, e, l), S(e, n), S(e, r), c && c.m(e, null), t[6](e), o = !0, a || (s = [U(Ri, "resize", t[3]), U(Ri, "scroll", t[3])], a = !0)
        },
        p(t, [n]) {
            c && c.p && (!o || 16 & n) && m(c, l, t, t[4], o ? f(l, t[4], n, null) : g(t[4]), null), (!o || 1 & n) && H(e, "configurator-blinds-full-height", t[0]), (!o || 4 & n) && H(e, "configurator-blinds-visible", t[2])
        },
        i(t) {
            o || (bt(c, t), o = !0)
        },
        o(t) {
            wt(c, t), o = !1
        },
        d(n) {
            n && B(e), c && c.d(n), t[6](null), a = !1, i(s)
        }
    }
}

function Di(t, e, n) {
    let r, {
            $$slots: i = {},
            $$scope: o
        } = e,
        {
            isFullHeight: a = !0
        } = e,
        s = !0;

    function l() {
        if (null == r) return;
        if (window.innerWidth <= 768) return void n(2, s = !0);
        const t = r.getBoundingClientRect(),
            e = .5 * window.innerHeight;
        n(2, s = t.top <= e && t.bottom > e)
    }
    return Z((() => {
        setTimeout(l, 1e3)
    })), t.$$set = t => {
        "isFullHeight" in t && n(0, a = t.isFullHeight), "$$scope" in t && n(4, o = t.$$scope)
    }, [a, r, s, l, o, i, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            r = t, n(1, r)
        }))
    }]
}
class Pi extends Dt {
    constructor(t) {
        super(), Lt(this, t, Di, Li, a, {
            isFullHeight: 0
        })
    }
}

function Oi(t) {
    let e, n, r, i;
    const o = t[5].default,
        a = d(o, t, t[4], null);
    return {
        c() {
            e = L("div"), a && a.c(), N(e, "class", "configurator-option-photos svelte-iigbbw"), H(e, "configurator-option-photos-disabled", t[0])
        },
        m(o, s) {
            T(o, e, s), a && a.m(e, null), t[6](e), n = !0, r || (i = U(e, "click", t[2]), r = !0)
        },
        p(t, [r]) {
            a && a.p && (!n || 16 & r) && m(a, o, t, t[4], n ? f(o, t[4], r, null) : g(t[4]), null), (!n || 1 & r) && H(e, "configurator-option-photos-disabled", t[0])
        },
        i(t) {
            n || (bt(a, t), n = !0)
        },
        o(t) {
            wt(a, t), n = !1
        },
        d(n) {
            n && B(e), a && a.d(n), t[6](null), r = !1, i()
        }
    }
}

function ki(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e, {
        photoIndex: o = 0
    } = e, {
        isDisabled: a = !1
    } = e;
    const s = nt();
    let l, c = -1;
    return tt((() => {
        if (void 0 === l) return;
        const t = l.querySelectorAll("img");
        if (0 === t.length) return;
        t.forEach((t => {
            t.style.zIndex = "0", t.classList.remove("appear-active")
        }));
        !0 === (c >= 0 && c < t.length) && c !== o && (t[c].style.zIndex = "1");
        !0 === (o >= 0 && o < t.length) && (t[o].style.zIndex = "2", o !== c && t[o].classList.add("appear-active")), c = o
    })), t.$$set = t => {
        "photoIndex" in t && n(3, o = t.photoIndex), "isDisabled" in t && n(0, a = t.isDisabled), "$$scope" in t && n(4, i = t.$$scope)
    }, [a, l, function () {
        !1 === a && s("click")
    }, o, i, r, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            l = t, n(1, l)
        }))
    }]
}
class Ui extends Dt {
    constructor(t) {
        super(), Lt(this, t, ki, Oi, a, {
            photoIndex: 3,
            isDisabled: 0
        })
    }
}
const {
    window: Ni
} = C;

function Fi(t) {
    t[26] = ["kitchen_xl10_nat_nat_table.jpg", "kitchen_xl10_nat_white_table.jpg", "kitchen_xl10_dark_nat_table.jpg", "kitchen_xl10_dark_white_table.jpg", "kitchen_xl10_nat_nat_island.jpg", "kitchen_xl10_nat_white_island.jpg", "kitchen_xl10_dark_nat_island.jpg", "kitchen_xl10_dark_white_island.jpg"]
}

function Qi(t, e, n) {
    const r = t.slice();
    return r[27] = e[n], r
}

function $i(t) {
    t[26] = ["bedroom2_nat_standard.jpg", "bedroom2_nat_full.jpg", "bedroom2_dark_standard.jpg", "bedroom2_dark_full.jpg"]
}

function Gi(t, e, n) {
    const r = t.slice();
    return r[27] = e[n], r
}

function Hi(t) {
    t[26] = ["bedroom1_nat_standard.jpg", "bedroom1_nat_full.jpg", "bedroom1_dark_standard.jpg", "bedroom1_dark_full.jpg"]
}

function zi(t, e, n) {
    const r = t.slice();
    return r[27] = e[n], r
}

function Vi(t) {
    t[26] = ["kitchen_studio_nat_nat.jpg", "kitchen_studio_nat_white.jpg", "kitchen_studio_dark_nat.jpg", "kitchen_studio_dark_white.jpg", "kitchen_12bed_nat_nat.jpg", "kitchen_12bed_dark_white.jpg", "kitchen_12bed_dark_nat.jpg", "kitchen_12bed_nat_white.jpg", "kitchen_xl8_nat_nat.jpg", "kitchen_xl8_nat_white.jpg", "kitchen_xl8_dark_nat.jpg", "kitchen_xl8_dark_white.jpg"]
}

function Wi(t, e, n) {
    const r = t.slice();
    return r[27] = e[n], r
}

function ji(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Design your Backyard️", N(n, "slot", "title")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Xi(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Make it yours. From layout to cladding and solar to\n\t\t\t\t\t\t\tfinishes, every detail is up to you.", N(n, "slot", "description")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function qi(e) {
    let n, r, i, o, a, s, l, c;
    return {
        c() {
            n = L("span"), r = L("div"), i = O(), o = L("div"), o.textContent = "Don’t want to start with a design?", a = O(), s = L("a"), s.textContent = "Check availability for your property", N(r, "class", "spacer-24 m-spacer-16"), N(o, "class", "type-18-light m-type-15-light color-text-40"), N(s, "class", "type-18 m-type-15-light"), N(n, "slot", "extra")
        },
        m(t, e) {
            T(t, n, e), S(n, r), S(n, i), S(n, o), S(n, a), S(n, s), l || (c = U(s, "click", ra), l = !0)
        },
        p: t,
        d(t) {
            t && B(n), l = !1, c()
        }
    }
}

function Yi(t) {
    let e, n, r, i, o, a, s, l, c, u;
    return o = new hi({}), c = new Bi({}), {
        c() {
            e = L("div"), n = L("div"), r = O(), i = L("div"), Mt(o.$$.fragment), a = O(), s = L("div"), l = O(), Mt(c.$$.fragment), N(n, "class", "m-spacer-flexible"), N(i, "class", "configurator-cost-pill-hint type-14 color-text-40"), N(s, "class", "spacer-16"), N(e, "class", "configurator-mobile-installation-estimate-hint svelte-1a6sgdt"), H(e, "configurator-mobile-installation-estimate-hint-visible", !t[15])
        },
        m(t, h) {
            T(t, e, h), S(e, n), S(e, r), S(e, i), Tt(o, i, null), S(e, a), S(e, s), T(t, l, h), Tt(c, t, h), u = !0
        },
        p(t, n) {
            (!u || 32768 & n[0]) && H(e, "configurator-mobile-installation-estimate-hint-visible", !t[15])
        },
        i(t) {
            u || (bt(o.$$.fragment, t), bt(c.$$.fragment, t), u = !0)
        },
        o(t) {
            wt(o.$$.fragment, t), wt(c.$$.fragment, t), u = !1
        },
        d(t) {
            t && (B(e), B(l)), Bt(o), Bt(c, t)
        }
    }
}

function Ki(t) {
    let e, n, r, i;
    return r = new ir({
        props: {
            key: "entry"
        }
    }), {
        c() {
            e = L("div"), n = O(), Mt(r.$$.fragment), N(e, "class", "spacer-80 m-spacer-50")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), Tt(r, t, o), i = !0
        },
        i(t) {
            i || (bt(r.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(e), B(n)), Bt(r, t)
        }
    }
}

function Ji(t) {
    let e, n, r, i;
    return r = new ir({
        props: {
            key: "front"
        }
    }), {
        c() {
            e = L("div"), n = O(), Mt(r.$$.fragment), N(e, "class", "spacer-80 m-spacer-50")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), Tt(r, t, o), i = !0
        },
        i(t) {
            i || (bt(r.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(e), B(n)), Bt(r, t)
        }
    }
}

function Zi(t) {
    let e, n, r, i;
    return r = new ir({
        props: {
            key: "left"
        }
    }), {
        c() {
            e = L("div"), n = O(), Mt(r.$$.fragment), N(e, "class", "spacer-80 m-spacer-50")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), Tt(r, t, o), i = !0
        },
        i(t) {
            i || (bt(r.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(e), B(n)), Bt(r, t)
        }
    }
}

function to(t) {
    let e, n, r, i;
    return r = new ir({
        props: {
            key: "xl-living-room-side"
        }
    }), {
        c() {
            e = L("div"), n = O(), Mt(r.$$.fragment), N(e, "class", "spacer-80 m-spacer-50")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), Tt(r, t, o), i = !0
        },
        i(t) {
            i || (bt(r.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(e), B(n)), Bt(r, t)
        }
    }
}

function eo(t) {
    let e, n, r, i;
    return r = new ir({
        props: {
            key: "xl-secondary-bedroom-side"
        }
    }), {
        c() {
            e = L("div"), n = O(), Mt(r.$$.fragment), N(e, "class", "spacer-80 m-spacer-50")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), Tt(r, t, o), i = !0
        },
        i(t) {
            i || (bt(r.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(e), B(n)), Bt(r, t)
        }
    }
}

function no(t) {
    let e, n, r, i;
    return r = new ir({
        props: {
            key: "xl-primary-bedroom-side"
        }
    }), {
        c() {
            e = L("div"), n = O(), Mt(r.$$.fragment), N(e, "class", "spacer-80 m-spacer-50")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), Tt(r, t, o), i = !0
        },
        i(t) {
            i || (bt(r.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(r.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(e), B(n)), Bt(r, t)
        }
    }
}

function ro(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C, I, M, R, D, P, k, U, F, Q, $, G, H, z, V, W, j, X, q, Y, K, J, Z = t[16]("entry"),
        tt = t[16]("front"),
        et = t[16]("left"),
        nt = t[16]("xl-living-room-side"),
        rt = t[16]("xl-secondary-bedroom-side"),
        it = t[16]("xl-primary-bedroom-side");
    a = new Fr({
        props: {
            $$slots: {
                extra: [qi],
                description: [Xi],
                title: [ji]
            },
            $$scope: {
                ctx: t
            }
        }
    }), d = new Hr({
        props: {
            isFirst: !0,
            isFullPage: na,
            $$slots: {
                default: [Yi]
            },
            $$scope: {
                ctx: t
            }
        }
    }), A = new ir({
        props: {
            key: "layout",
            shouldDisplayCost: !1
        }
    }), E = new ir({
        props: {
            key: "cladding"
        }
    }), C = new Tr({
        props: {
            key: "color"
        }
    }), D = new Tr({
        props: {
            key: "roof"
        }
    });
    let ot = Z && Ki(),
        at = tt && Ji(),
        st = et && Zi(),
        lt = nt && to(),
        ct = rt && eo(),
        ut = it && no();
    return V = new ir({
        props: {
            key: "solar"
        }
    }), q = new ur({
        props: {
            title: "Optional energy upgrades",
            keys: ["powerwall"],
            disabled: "solar-no" === t[0].solar
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), i = L("div"), o = O(), Mt(a.$$.fragment), s = O(), l = L("div"), c = O(), u = L("div"), h = O(), Mt(d.$$.fragment), p = O(), f = L("div"), m = L("div"), g = O(), Mt(A.$$.fragment), v = O(), _ = L("div"), y = O(), Mt(E.$$.fragment), x = O(), b = L("div"), w = O(), Mt(C.$$.fragment), I = O(), M = L("div"), R = O(), Mt(D.$$.fragment), P = O(), ot && ot.c(), k = O(), at && at.c(), U = O(), st && st.c(), F = O(), lt && lt.c(), Q = O(), ct && ct.c(), $ = O(), ut && ut.c(), G = O(), H = L("div"), z = O(), Mt(V.$$.fragment), W = O(), j = L("div"), X = O(), Mt(q.$$.fragment), Y = O(), K = L("div"), N(e, "class", "spacer-80 m-spacer-36"), N(i, "class", "spacer-36 m-spacer-24"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(l, "class", "spacer-0 m-spacer-50"), N(m, "class", "spacer-80 m-spacer-50"), N(_, "class", "spacer-80 m-spacer-50"), N(b, "class", "spacer-80 m-spacer-50"), N(M, "class", "spacer-80 m-spacer-50"), N(H, "class", "spacer-80 m-spacer-50"), N(j, "class", "spacer-80 m-spacer-36"), N(f, "class", "configurator-section-column svelte-1a6sgdt"), N(K, "class", "spacer-120 m-spacer-36")
        },
        m(B, L) {
            T(B, e, L), T(B, n, L), T(B, r, L), S(r, i), S(r, o), Tt(a, r, null), T(B, s, L), T(B, l, L), T(B, c, L), T(B, u, L), t[21](u), T(B, h, L), Tt(d, B, L), T(B, p, L), T(B, f, L), S(f, m), S(f, g), Tt(A, f, null), S(f, v), S(f, _), S(f, y), Tt(E, f, null), S(f, x), S(f, b), S(f, w), Tt(C, f, null), S(f, I), S(f, M), S(f, R), Tt(D, f, null), S(f, P), ot && ot.m(f, null), S(f, k), at && at.m(f, null), S(f, U), st && st.m(f, null), S(f, F), lt && lt.m(f, null), S(f, Q), ct && ct.m(f, null), S(f, $), ut && ut.m(f, null), S(f, G), S(f, H), S(f, z), Tt(V, f, null), S(f, W), S(f, j), S(f, X), Tt(q, f, null), T(B, Y, L), T(B, K, L), J = !0
        },
        p(t, e) {
            const n = {};
            32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), a.$set(n);
            const r = {};
            32768 & e[0] | 32 & e[1] && (r.$$scope = {
                dirty: e,
                ctx: t
            }), d.$set(r), 65536 & e[0] && (Z = t[16]("entry")), Z ? ot ? 65536 & e[0] && bt(ot, 1) : (ot = Ki(), ot.c(), bt(ot, 1), ot.m(f, k)) : ot && (Et(), wt(ot, 1, 1, (() => {
                ot = null
            })), xt()), 65536 & e[0] && (tt = t[16]("front")), tt ? at ? 65536 & e[0] && bt(at, 1) : (at = Ji(), at.c(), bt(at, 1), at.m(f, U)) : at && (Et(), wt(at, 1, 1, (() => {
                at = null
            })), xt()), 65536 & e[0] && (et = t[16]("left")), et ? st ? 65536 & e[0] && bt(st, 1) : (st = Zi(), st.c(), bt(st, 1), st.m(f, F)) : st && (Et(), wt(st, 1, 1, (() => {
                st = null
            })), xt()), 65536 & e[0] && (nt = t[16]("xl-living-room-side")), nt ? lt ? 65536 & e[0] && bt(lt, 1) : (lt = to(), lt.c(), bt(lt, 1), lt.m(f, Q)) : lt && (Et(), wt(lt, 1, 1, (() => {
                lt = null
            })), xt()), 65536 & e[0] && (rt = t[16]("xl-secondary-bedroom-side")), rt ? ct ? 65536 & e[0] && bt(ct, 1) : (ct = eo(), ct.c(), bt(ct, 1), ct.m(f, $)) : ct && (Et(), wt(ct, 1, 1, (() => {
                ct = null
            })), xt()), 65536 & e[0] && (it = t[16]("xl-primary-bedroom-side")), it ? ut ? 65536 & e[0] && bt(ut, 1) : (ut = no(), ut.c(), bt(ut, 1), ut.m(f, G)) : ut && (Et(), wt(ut, 1, 1, (() => {
                ut = null
            })), xt());
            const i = {};
            1 & e[0] && (i.disabled = "solar-no" === t[0].solar), q.$set(i)
        },
        i(t) {
            J || (bt(a.$$.fragment, t), bt(d.$$.fragment, t), bt(A.$$.fragment, t), bt(E.$$.fragment, t), bt(C.$$.fragment, t), bt(D.$$.fragment, t), bt(ot), bt(at), bt(st), bt(lt), bt(ct), bt(ut), bt(V.$$.fragment, t), bt(q.$$.fragment, t), J = !0)
        },
        o(t) {
            wt(a.$$.fragment, t), wt(d.$$.fragment, t), wt(A.$$.fragment, t), wt(E.$$.fragment, t), wt(C.$$.fragment, t), wt(D.$$.fragment, t), wt(ot), wt(at), wt(st), wt(lt), wt(ct), wt(ut), wt(V.$$.fragment, t), wt(q.$$.fragment, t), J = !1
        },
        d(i) {
            i && (B(e), B(n), B(r), B(s), B(l), B(c), B(u), B(h), B(p), B(f), B(Y), B(K)), Bt(a), t[21](null), Bt(d, i), Bt(A), Bt(E), Bt(C), Bt(D), ot && ot.d(), at && at.d(), st && st.d(), lt && lt.d(), ct && ct.d(), ut && ut.d(), Bt(V), Bt(q)
        }
    }
}

function io(t) {
    let e, n;
    return e = new Pi({
        props: {
            $$slots: {
                default: [ro]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            98321 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function oo(e) {
    let n, r, i, o, a;
    return {
        c() {
            n = L("img"), i = O(), o = L("img"), l(n.src, r = "/assets/images/configure/interior/floor-natural-oak.jpg") || N(n, "src", "/assets/images/configure/interior/floor-natural-oak.jpg"), N(n, "width", "1600"), N(n, "height", "1200"), N(n, "alt", ""), N(n, "loading", "lazy"), l(o.src, a = "/assets/images/configure/interior/floor-dark-stained-oak.jpg") || N(o, "src", "/assets/images/configure/interior/floor-dark-stained-oak.jpg"), N(o, "width", "1600"), N(o, "height", "1200"), N(o, "alt", ""), N(o, "loading", "lazy")
        },
        m(t, e) {
            T(t, n, e), T(t, i, e), T(t, o, e)
        },
        p: t,
        d(t) {
            t && (B(n), B(i), B(o))
        }
    }
}

function ao(t) {
    let e, n;
    return e = new Ui({
        props: {
            photoIndex: "floor-natural-oak" === t[0].floor ? 0 : 1,
            $$slots: {
                default: [oo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("click", (function () {
        o(t[10]) && t[10].apply(this, arguments)
    })), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(n, r) {
            t = n;
            const i = {};
            1 & r[0] && (i.photoIndex = "floor-natural-oak" === t[0].floor ? 0 : 1), 32 & r[1] && (i.$$scope = {
                dirty: r,
                ctx: t
            }), e.$set(i)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function so(t) {
    let e, n, r, i, o, a, s, l, c, u, h;
    return o = new Hr({
        props: {
            aspectRatio: 1600 / 1200,
            isSticky: !0,
            $$slots: {
                default: [ao]
            },
            $$scope: {
                ctx: t
            }
        }
    }), u = new Tr({
        props: {
            key: "floor",
            isNew: !0
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), r.innerHTML = '<h1 class="type-48 m-type-32">Interior options</h1> <div class="spacer-12"></div> <hr class="divider"/> <div class="spacer-150 m-spacer-36"></div>', i = O(), Mt(o.$$.fragment), a = O(), s = L("div"), l = O(), c = L("div"), Mt(u.$$.fragment), N(e, "class", "spacer-80 m-spacer-50"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(s, "class", "spacer-0 m-spacer-36"), N(c, "class", "configurator-section-column svelte-1a6sgdt")
        },
        m(t, d) {
            T(t, e, d), T(t, n, d), T(t, r, d), T(t, i, d), Tt(o, t, d), T(t, a, d), T(t, s, d), T(t, l, d), T(t, c, d), Tt(u, c, null), h = !0
        },
        p(t, e) {
            const n = {};
            1025 & e[0] | 32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), o.$set(n)
        },
        i(t) {
            h || (bt(o.$$.fragment, t), bt(u.$$.fragment, t), h = !0)
        },
        o(t) {
            wt(o.$$.fragment, t), wt(u.$$.fragment, t), h = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(a), B(s), B(l), B(c)), Bt(o, t), Bt(u)
        }
    }
}

function lo(t) {
    let e, n;
    return e = new Pi({
        props: {
            $$slots: {
                default: [so]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            1025 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function co(t) {
    let e, n;
    return e = new Ei({
        props: {
            isDarkContent: !0,
            $$slots: {
                default: [_o]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            2561 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function uo(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Kitchen 2.0", N(n, "slot", "title")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function ho(t) {
    let e;
    return {
        c() {
            e = P("Our redesigned kitchen with more storage,\n\t\t\t\t\t\t\t\t\tplus a built-in pantry. Now standard in your\n\t\t\t\t\t\t\t\t\tchoice of color.")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function po(t) {
    let e;
    return {
        c() {
            e = P("Our signature XL kitchen. Same generous\n\t\t\t\t\t\t\t\t\tlayout, now finished in natural oak or bone\n\t\t\t\t\t\t\t\t\twhite.")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function fo(t) {
    let e;

    function n(t, e) {
        return "xl8" === t[0].layout ? po : ho
    }
    let r = n(t),
        i = r(t);
    return {
        c() {
            e = L("span"), i.c(), N(e, "slot", "description")
        },
        m(t, n) {
            T(t, e, n), i.m(e, null)
        },
        p(t, o) {
            r !== (r = n(t)) && (i.d(1), i = r(t), i && (i.c(), i.m(e, null)))
        },
        d(t) {
            t && B(e), i.d()
        }
    }
}

function mo(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = `/assets/images/configure/1505/${e[27]}`) || N(n, "src", r), N(n, "width", "1600"), N(n, "height", "1200"), N(n, "alt", ""), N(n, "loading", "lazy")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function go(t) {
    let e;
    Vi(t);
    let n = St(t[26]),
        r = [];
    for (let e = 0; e < n.length; e += 1) r[e] = mo(Wi(t, n, e));
    return {
        c() {
            for (let t = 0; t < r.length; t += 1) r[t].c();
            e = k()
        },
        m(t, n) {
            for (let e = 0; e < r.length; e += 1) r[e] && r[e].m(t, n);
            T(t, e, n)
        },
        p(t, e) {
            Vi(t)
        },
        d(t) {
            t && B(e), R(r, t)
        }
    }
}

function Ao(t) {
    let e, n;
    return e = new Ui({
        props: {
            photoIndex: t[9],
            $$slots: {
                default: [go]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("click", (function () {
        o(t[11]) && t[11].apply(this, arguments)
    })), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(n, r) {
            t = n;
            const i = {};
            512 & r[0] && (i.photoIndex = t[9]), 32 & r[1] && (i.$$scope = {
                dirty: r,
                ctx: t
            }), e.$set(i)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function vo(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g;
    return i = new Fr({
        props: {
            isNew: !0,
            $$slots: {
                description: [fo],
                title: [uo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), l = new Hr({
        props: {
            aspectRatio: 1600 / 1200,
            isSticky: !0,
            $$slots: {
                default: [Ao]
            },
            $$scope: {
                ctx: t
            }
        }
    }), p = new Tr({
        props: {
            key: "kitchen-cabinet-finish"
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), Mt(i.$$.fragment), o = O(), a = L("div"), s = O(), Mt(l.$$.fragment), c = O(), u = L("div"), h = L("div"), d = O(), Mt(p.$$.fragment), f = O(), m = L("div"), N(e, "class", "spacer-80 m-spacer-36"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(a, "class", "spacer-0 m-spacer-36"), N(h, "class", "spacer-80 m-spacer-36"), N(u, "class", "configurator-section-column svelte-1a6sgdt"), N(m, "class", "spacer-80 m-spacer-36")
        },
        m(t, A) {
            T(t, e, A), T(t, n, A), T(t, r, A), Tt(i, r, null), T(t, o, A), T(t, a, A), T(t, s, A), Tt(l, t, A), T(t, c, A), T(t, u, A), S(u, h), S(u, d), Tt(p, u, null), T(t, f, A), T(t, m, A), g = !0
        },
        p(t, e) {
            const n = {};
            1 & e[0] | 32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), i.$set(n);
            const r = {};
            2560 & e[0] | 32 & e[1] && (r.$$scope = {
                dirty: e,
                ctx: t
            }), l.$set(r)
        },
        i(t) {
            g || (bt(i.$$.fragment, t), bt(l.$$.fragment, t), bt(p.$$.fragment, t), g = !0)
        },
        o(t) {
            wt(i.$$.fragment, t), wt(l.$$.fragment, t), wt(p.$$.fragment, t), g = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(o), B(a), B(s), B(c), B(u), B(f), B(m)), Bt(i), Bt(l, t), Bt(p)
        }
    }
}

function _o(t) {
    let e, n;
    return e = new Pi({
        props: {
            $$slots: {
                default: [vo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            2561 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function yo(t) {
    let e, n;
    return e = new Ei({
        props: {
            isDarkContent: !0,
            $$slots: {
                default: [Ro]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            16641 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Eo(t) {
    let e;
    return {
        c() {
            e = P("Primary bedroom")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function xo(t) {
    let e;
    return {
        c() {
            e = P("Bedroom")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function bo(t) {
    let e;

    function n(t, e) {
        return "onebed" === t[0].layout ? xo : "twobed" === t[0].layout ? Eo : void 0
    }
    let r = n(t),
        i = r && r(t);
    return {
        c() {
            e = L("span"), i && i.c(), N(e, "slot", "title")
        },
        m(t, n) {
            T(t, e, n), i && i.m(e, null)
        },
        p(t, o) {
            r !== (r = n(t)) && (i && i.d(1), i = r && r(t), i && (i.c(), i.m(e, null)))
        },
        d(t) {
            t && B(e), i && i.d()
        }
    }
}

function wo(t) {
    let e;
    return {
        c() {
            e = P("Customize storage in the primary bedroom,\n\t\t\t\t\t\t\t\t\tlocated next to the entry area.")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Co(t) {
    let e;
    return {
        c() {
            e = P("Customize storage in the bedroom, located\n\t\t\t\t\t\t\t\t\tnext to the entry area.")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function So(t) {
    let e;

    function n(t, e) {
        return "onebed" === t[0].layout ? Co : "twobed" === t[0].layout ? wo : void 0
    }
    let r = n(t),
        i = r && r(t);
    return {
        c() {
            e = L("span"), i && i.c(), N(e, "slot", "description")
        },
        m(t, n) {
            T(t, e, n), i && i.m(e, null)
        },
        p(t, o) {
            r !== (r = n(t)) && (i && i.d(1), i = r && r(t), i && (i.c(), i.m(e, null)))
        },
        d(t) {
            t && B(e), i && i.d()
        }
    }
}

function Io(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = `/assets/images/configure/1505/${e[27]}`) || N(n, "src", r), N(n, "width", "1600"), N(n, "height", "1200"), N(n, "alt", ""), N(n, "loading", "lazy")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Mo(t) {
    let e;
    Hi(t);
    let n = St(t[26]),
        r = [];
    for (let e = 0; e < n.length; e += 1) r[e] = Io(zi(t, n, e));
    return {
        c() {
            for (let t = 0; t < r.length; t += 1) r[t].c();
            e = k()
        },
        m(t, n) {
            for (let e = 0; e < r.length; e += 1) r[e] && r[e].m(t, n);
            T(t, e, n)
        },
        p(t, e) {
            Hi(t)
        },
        d(t) {
            t && B(e), R(r, t)
        }
    }
}

function To(t) {
    let e, n;
    return e = new Ui({
        props: {
            photoIndex: t[8],
            $$slots: {
                default: [Mo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("click", (function () {
        o(t[14]) && t[14].apply(this, arguments)
    })), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(n, r) {
            t = n;
            const i = {};
            256 & r[0] && (i.photoIndex = t[8]), 32 & r[1] && (i.$$scope = {
                dirty: r,
                ctx: t
            }), e.$set(i)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Bo(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g;
    return i = new Fr({
        props: {
            $$slots: {
                description: [So],
                title: [bo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), l = new Hr({
        props: {
            aspectRatio: 1600 / 1200,
            isSticky: !0,
            $$slots: {
                default: [To]
            },
            $$scope: {
                ctx: t
            }
        }
    }), p = new ir({
        props: {
            key: "primary-bedroom-wardrobe"
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), Mt(i.$$.fragment), o = O(), a = L("div"), s = O(), Mt(l.$$.fragment), c = O(), u = L("div"), h = L("div"), d = O(), Mt(p.$$.fragment), f = O(), m = L("div"), N(e, "class", "spacer-80 m-spacer-36"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(a, "class", "spacer-0 m-spacer-36"), N(h, "class", "spacer-80 m-spacer-36"), N(u, "class", "configurator-section-column svelte-1a6sgdt"), N(m, "class", "spacer-80 m-spacer-36")
        },
        m(t, A) {
            T(t, e, A), T(t, n, A), T(t, r, A), Tt(i, r, null), T(t, o, A), T(t, a, A), T(t, s, A), Tt(l, t, A), T(t, c, A), T(t, u, A), S(u, h), S(u, d), Tt(p, u, null), T(t, f, A), T(t, m, A), g = !0
        },
        p(t, e) {
            const n = {};
            1 & e[0] | 32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), i.$set(n);
            const r = {};
            16640 & e[0] | 32 & e[1] && (r.$$scope = {
                dirty: e,
                ctx: t
            }), l.$set(r)
        },
        i(t) {
            g || (bt(i.$$.fragment, t), bt(l.$$.fragment, t), bt(p.$$.fragment, t), g = !0)
        },
        o(t) {
            wt(i.$$.fragment, t), wt(l.$$.fragment, t), wt(p.$$.fragment, t), g = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(o), B(a), B(s), B(c), B(u), B(f), B(m)), Bt(i), Bt(l, t), Bt(p)
        }
    }
}

function Ro(t) {
    let e, n;
    return e = new Pi({
        props: {
            $$slots: {
                default: [Bo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            16641 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Lo(t) {
    let e, n;
    return e = new Ei({
        props: {
            isDarkContent: !0,
            $$slots: {
                default: [Fo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            8320 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Do(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Secondary bedroom", N(n, "slot", "title")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Po(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Customize storage in the secondary bedroom,\n\t\t\t\t\t\t\t\tlocated next to the living area.", N(n, "slot", "description")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Oo(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = `/assets/images/configure/1505/${e[27]}`) || N(n, "src", r), N(n, "width", "1600"), N(n, "height", "1200"), N(n, "alt", ""), N(n, "loading", "lazy")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function ko(t) {
    let e;
    $i(t);
    let n = St(t[26]),
        r = [];
    for (let e = 0; e < n.length; e += 1) r[e] = Oo(Gi(t, n, e));
    return {
        c() {
            for (let t = 0; t < r.length; t += 1) r[t].c();
            e = k()
        },
        m(t, n) {
            for (let e = 0; e < r.length; e += 1) r[e] && r[e].m(t, n);
            T(t, e, n)
        },
        p(t, e) {
            $i(t)
        },
        d(t) {
            t && B(e), R(r, t)
        }
    }
}

function Uo(t) {
    let e, n;
    return e = new Ui({
        props: {
            photoIndex: t[7],
            $$slots: {
                default: [ko]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("click", (function () {
        o(t[13]) && t[13].apply(this, arguments)
    })), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(n, r) {
            t = n;
            const i = {};
            128 & r[0] && (i.photoIndex = t[7]), 32 & r[1] && (i.$$scope = {
                dirty: r,
                ctx: t
            }), e.$set(i)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function No(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g;
    return i = new Fr({
        props: {
            $$slots: {
                description: [Po],
                title: [Do]
            },
            $$scope: {
                ctx: t
            }
        }
    }), l = new Hr({
        props: {
            aspectRatio: 1600 / 1200,
            isSticky: !0,
            $$slots: {
                default: [Uo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), p = new ir({
        props: {
            key: "secondary-bedroom-wardrobe"
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), Mt(i.$$.fragment), o = O(), a = L("div"), s = O(), Mt(l.$$.fragment), c = O(), u = L("div"), h = L("div"), d = O(), Mt(p.$$.fragment), f = O(), m = L("div"), N(e, "class", "spacer-80 m-spacer-36"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(a, "class", "spacer-0 m-spacer-36"), N(h, "class", "spacer-80 m-spacer-36"), N(u, "class", "configurator-section-column svelte-1a6sgdt"), N(m, "class", "spacer-80 m-spacer-36")
        },
        m(t, A) {
            T(t, e, A), T(t, n, A), T(t, r, A), Tt(i, r, null), T(t, o, A), T(t, a, A), T(t, s, A), Tt(l, t, A), T(t, c, A), T(t, u, A), S(u, h), S(u, d), Tt(p, u, null), T(t, f, A), T(t, m, A), g = !0
        },
        p(t, e) {
            const n = {};
            32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), i.$set(n);
            const r = {};
            8320 & e[0] | 32 & e[1] && (r.$$scope = {
                dirty: e,
                ctx: t
            }), l.$set(r)
        },
        i(t) {
            g || (bt(i.$$.fragment, t), bt(l.$$.fragment, t), bt(p.$$.fragment, t), g = !0)
        },
        o(t) {
            wt(i.$$.fragment, t), wt(l.$$.fragment, t), wt(p.$$.fragment, t), g = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(o), B(a), B(s), B(c), B(u), B(f), B(m)), Bt(i), Bt(l, t), Bt(p)
        }
    }
}

function Fo(t) {
    let e, n;
    return e = new Pi({
        props: {
            $$slots: {
                default: [No]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            8320 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Qo(t) {
    let e, n;
    return e = new Ei({
        props: {
            isDarkContent: !0,
            $$slots: {
                default: [jo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            4161 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function $o(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Kitchen 2.0", N(n, "slot", "title")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Go(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Same flexible layout, now available in your\n\t\t\t\t\t\t\t\tchoice of color. Add an island for more prep\n\t\t\t\t\t\t\t\tspace and storage.", N(n, "slot", "description")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Ho(e) {
    let n, r;
    return {
        c() {
            n = L("img"), l(n.src, r = `/assets/images/configure/1505/${e[27]}`) || N(n, "src", r), N(n, "width", "1600"), N(n, "height", "1200"), N(n, "alt", ""), N(n, "loading", "lazy")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function zo(t) {
    let e;
    Fi(t);
    let n = St(t[26]),
        r = [];
    for (let e = 0; e < n.length; e += 1) r[e] = Ho(Qi(t, n, e));
    return {
        c() {
            for (let t = 0; t < r.length; t += 1) r[t].c();
            e = k()
        },
        m(t, n) {
            for (let e = 0; e < r.length; e += 1) r[e] && r[e].m(t, n);
            T(t, e, n)
        },
        p(t, e) {
            Fi(t)
        },
        d(t) {
            t && B(e), R(r, t)
        }
    }
}

function Vo(t) {
    let e, n;
    return e = new Ui({
        props: {
            photoIndex: t[6],
            $$slots: {
                default: [zo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("click", (function () {
        o(t[12]) && t[12].apply(this, arguments)
    })), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(n, r) {
            t = n;
            const i = {};
            64 & r[0] && (i.photoIndex = t[6]), 32 & r[1] && (i.$$scope = {
                dirty: r,
                ctx: t
            }), e.$set(i)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Wo(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w;
    return i = new Fr({
        props: {
            isNew: !0,
            $$slots: {
                description: [Go],
                title: [$o]
            },
            $$scope: {
                ctx: t
            }
        }
    }), l = new Hr({
        props: {
            aspectRatio: 1600 / 1200,
            isSticky: !0,
            $$slots: {
                default: [Vo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), p = new Tr({
        props: {
            key: "kitchen-cabinet-finish"
        }
    }), A = new ir({
        props: {
            key: "kitchen-layout"
        }
    }), E = new ur({
        props: {
            title: "Optional kitchen island upgrades",
            keys: ["kitchen-cooler"],
            disabled: "island" !== t[0]["kitchen-layout"]
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), Mt(i.$$.fragment), o = O(), a = L("div"), s = O(), Mt(l.$$.fragment), c = O(), u = L("div"), h = L("div"), d = O(), Mt(p.$$.fragment), f = O(), m = L("div"), g = O(), Mt(A.$$.fragment), v = O(), _ = L("div"), y = O(), Mt(E.$$.fragment), x = O(), b = L("div"), N(e, "class", "spacer-80 m-spacer-36"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(a, "class", "spacer-0 m-spacer-36"), N(h, "class", "spacer-80 m-spacer-36"), N(m, "class", "spacer-80 m-spacer-36"), N(_, "class", "spacer-80 m-spacer-36"), N(u, "class", "configurator-section-column svelte-1a6sgdt"), N(b, "class", "spacer-80 m-spacer-36")
        },
        m(t, C) {
            T(t, e, C), T(t, n, C), T(t, r, C), Tt(i, r, null), T(t, o, C), T(t, a, C), T(t, s, C), Tt(l, t, C), T(t, c, C), T(t, u, C), S(u, h), S(u, d), Tt(p, u, null), S(u, f), S(u, m), S(u, g), Tt(A, u, null), S(u, v), S(u, _), S(u, y), Tt(E, u, null), T(t, x, C), T(t, b, C), w = !0
        },
        p(t, e) {
            const n = {};
            32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), i.$set(n);
            const r = {};
            4160 & e[0] | 32 & e[1] && (r.$$scope = {
                dirty: e,
                ctx: t
            }), l.$set(r);
            const o = {};
            1 & e[0] && (o.disabled = "island" !== t[0]["kitchen-layout"]), E.$set(o)
        },
        i(t) {
            w || (bt(i.$$.fragment, t), bt(l.$$.fragment, t), bt(p.$$.fragment, t), bt(A.$$.fragment, t), bt(E.$$.fragment, t), w = !0)
        },
        o(t) {
            wt(i.$$.fragment, t), wt(l.$$.fragment, t), wt(p.$$.fragment, t), wt(A.$$.fragment, t), wt(E.$$.fragment, t), w = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(o), B(a), B(s), B(c), B(u), B(x), B(b)), Bt(i), Bt(l, t), Bt(p), Bt(A), Bt(E)
        }
    }
}

function jo(t) {
    let e, n;
    return e = new Pi({
        props: {
            $$slots: {
                default: [Wo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            4161 & n[0] | 32 & n[1] && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Xo(t) {
    let e, n;
    return e = new Bi({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function qo(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Optional upgrades", N(n, "slot", "title")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Yo(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Peace of mind. Quality of life. Additional ways to\n\t\t\t\t\t\t\tenhance your Backyard.", N(n, "slot", "description")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Ko(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g;
    return a = new Fr({
        props: {
            $$slots: {
                description: [Yo],
                title: [qo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), p = new ur({
        props: {
            keys: ["bathroom-accessibility-kit", "interior-blinds"]
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), i = L("div"), o = O(), Mt(a.$$.fragment), s = O(), l = L("div"), c = O(), u = L("div"), h = L("div"), d = O(), Mt(p.$$.fragment), f = O(), m = L("div"), N(e, "class", "spacer-80 m-spacer-0"), N(i, "class", "spacer-0 m-spacer-24"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(l, "class", "spacer-0 m-spacer-36"), N(h, "class", "spacer-80 m-spacer-0"), N(u, "class", "configurator-section-column svelte-1a6sgdt"), N(m, "class", "spacer-80 m-spacer-36")
        },
        m(t, A) {
            T(t, e, A), T(t, n, A), T(t, r, A), S(r, i), S(r, o), Tt(a, r, null), T(t, s, A), T(t, l, A), T(t, c, A), T(t, u, A), S(u, h), S(u, d), Tt(p, u, null), T(t, f, A), T(t, m, A), g = !0
        },
        p(t, e) {
            const n = {};
            32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), a.$set(n)
        },
        i(t) {
            g || (bt(a.$$.fragment, t), bt(p.$$.fragment, t), g = !0)
        },
        o(t) {
            wt(a.$$.fragment, t), wt(p.$$.fragment, t), g = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(s), B(l), B(c), B(u), B(f), B(m)), Bt(a), Bt(p)
        }
    }
}

function Jo(e) {
    let n, r, i;
    return {
        c() {
            n = L("button"), n.innerHTML = 'Continue\n\t\t\t\t\t\t\t<img src="/assets/images/icons/arrow-right-white.svg" width="17" height="12" alt="→"/>', N(n, "class", "button-rounded button-rounded-blue button-submit type-18 m-type-15")
        },
        m(t, o) {
            T(t, n, o), r || (i = U(n, "click", e[18]), r = !0)
        },
        p: t,
        d(t) {
            t && B(n), r = !1, i()
        }
    }
}

function Zo(t) {
    let e, n, r, i, o, a, s;
    return i = new ti({
        props: {
            $$slots: {
                default: [Jo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            e = L("div"), n = O(), r = L("div"), Mt(i.$$.fragment), o = O(), a = L("div"), N(e, "class", "spacer-80 m-spacer-36"), N(r, "class", "configurator-section-column svelte-1a6sgdt"), N(a, "class", "spacer-150 m-spacer-64")
        },
        m(t, l) {
            T(t, e, l), T(t, n, l), T(t, r, l), Tt(i, r, null), T(t, o, l), T(t, a, l), s = !0
        },
        p(t, e) {
            const n = {};
            32 & e[1] && (n.$$scope = {
                dirty: e,
                ctx: t
            }), i.$set(n)
        },
        i(t) {
            s || (bt(i.$$.fragment, t), s = !0)
        },
        o(t) {
            wt(i.$$.fragment, t), s = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(o), B(a)), Bt(i)
        }
    }
}

function ta(t) {
    let e, n, r, i, o, a = function (t) {
        let e, n, r;
        return n = new Hr({
            props: {
                isLast: !0,
                $$slots: {
                    default: [Xo]
                },
                $$scope: {
                    ctx: t
                }
            }
        }), {
            c() {
                e = L("div"), Mt(n.$$.fragment), N(e, "class", "mobile-hidden")
            },
            m(t, i) {
                T(t, e, i), Tt(n, e, null), r = !0
            },
            i(t) {
                r || (bt(n.$$.fragment, t), r = !0)
            },
            o(t) {
                wt(n.$$.fragment, t), r = !1
            },
            d(t) {
                t && B(e), Bt(n)
            }
        }
    }(t);
    return n = new Pi({
        props: {
            isFullHeight: !1,
            $$slots: {
                default: [Ko]
            },
            $$scope: {
                ctx: t
            }
        }
    }), i = new Pi({
        props: {
            isFullHeight: !1,
            $$slots: {
                default: [Zo]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            a && a.c(), e = O(), Mt(n.$$.fragment), r = O(), Mt(i.$$.fragment)
        },
        m(t, s) {
            a && a.m(t, s), T(t, e, s), Tt(n, t, s), T(t, r, s), Tt(i, t, s), o = !0
        },
        p(t, e) {
            const r = {};
            32 & e[1] && (r.$$scope = {
                dirty: e,
                ctx: t
            }), n.$set(r);
            const o = {};
            32 & e[1] && (o.$$scope = {
                dirty: e,
                ctx: t
            }), i.$set(o)
        },
        i(t) {
            o || (bt(a), bt(n.$$.fragment, t), bt(i.$$.fragment, t), o = !0)
        },
        o(t) {
            wt(a), wt(n.$$.fragment, t), wt(i.$$.fragment, t), o = !1
        },
        d(t) {
            t && (B(e), B(r)), a && a.d(t), Bt(n, t), Bt(i, t)
        }
    }
}

function ea(t) {
    let e, n, r, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x = t[16]("primary-bedroom-wardrobe"),
        b = t[16]("secondary-bedroom-wardrobe");
    o = new fi({
        props: {
            isLightMaterial: t[3],
            isInstallationEstimateHintVisible: t[2]
        }
    }), l = new Ai({
        props: {
            offsetTop: t[5]
        }
    }), u = new Ei({
        props: {
            $$slots: {
                default: [io]
            },
            $$scope: {
                ctx: t
            }
        }
    }), d = new Ei({
        props: {
            $$slots: {
                default: [lo]
            },
            $$scope: {
                ctx: t
            }
        }
    });
    let w = "xl10" !== t[0].layout && co(t),
        C = x && yo(t),
        I = b && Lo(t),
        M = "xl10" === t[0].layout && Qo(t);
    return v = new Ei({
        props: {
            isLastSection: !0,
            $$slots: {
                default: [ta]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            e = L("div"), n = L("div"), r = L("div"), Mt(o.$$.fragment), a = O(), s = L("div"), Mt(l.$$.fragment), c = O(), Mt(u.$$.fragment), h = O(), Mt(d.$$.fragment), p = O(), w && w.c(), f = O(), C && C.c(), m = O(), I && I.c(), g = O(), M && M.c(), A = O(), Mt(v.$$.fragment), N(r, "class", "configurator-desktop-cost-pill-sticker svelte-1a6sgdt"), N(n, "class", "mobile-hidden configurator-desktop-cost-pill-container svelte-1a6sgdt"), N(s, "class", "configurator-content svelte-1a6sgdt"), N(e, "class", "configurator-options svelte-1a6sgdt"), H(e, "configurator-options-loading", t[15])
        },
        m(i, x) {
            T(i, e, x), S(e, n), S(n, r), Tt(o, r, null), S(e, a), S(e, s), Tt(l, s, null), S(s, c), Tt(u, s, null), S(s, h), Tt(d, s, null), S(s, p), w && w.m(s, null), S(s, f), C && C.m(s, null), S(s, m), I && I.m(s, null), S(s, g), M && M.m(s, null), S(s, A), Tt(v, s, null), t[22](s), _ = !0, y || (E = [U(Ni, "resize", t[17]), U(Ni, "scroll", t[17])], y = !0)
        },
        p(t, n) {
            const r = {};
            8 & n[0] && (r.isLightMaterial = t[3]), 4 & n[0] && (r.isInstallationEstimateHintVisible = t[2]), o.$set(r);
            const i = {};
            32 & n[0] && (i.offsetTop = t[5]), l.$set(i);
            const a = {};
            98321 & n[0] | 32 & n[1] && (a.$$scope = {
                dirty: n,
                ctx: t
            }), u.$set(a);
            const c = {};
            1025 & n[0] | 32 & n[1] && (c.$$scope = {
                dirty: n,
                ctx: t
            }), d.$set(c), "xl10" !== t[0].layout ? w ? (w.p(t, n), 1 & n[0] && bt(w, 1)) : (w = co(t), w.c(), bt(w, 1), w.m(s, f)) : w && (Et(), wt(w, 1, 1, (() => {
                w = null
            })), xt()), 65536 & n[0] && (x = t[16]("primary-bedroom-wardrobe")), x ? C ? (C.p(t, n), 65536 & n[0] && bt(C, 1)) : (C = yo(t), C.c(), bt(C, 1), C.m(s, m)) : C && (Et(), wt(C, 1, 1, (() => {
                C = null
            })), xt()), 65536 & n[0] && (b = t[16]("secondary-bedroom-wardrobe")), b ? I ? (I.p(t, n), 65536 & n[0] && bt(I, 1)) : (I = Lo(t), I.c(), bt(I, 1), I.m(s, g)) : I && (Et(), wt(I, 1, 1, (() => {
                I = null
            })), xt()), "xl10" === t[0].layout ? M ? (M.p(t, n), 1 & n[0] && bt(M, 1)) : (M = Qo(t), M.c(), bt(M, 1), M.m(s, A)) : M && (Et(), wt(M, 1, 1, (() => {
                M = null
            })), xt());
            const h = {};
            32 & n[1] && (h.$$scope = {
                dirty: n,
                ctx: t
            }), v.$set(h), (!_ || 32768 & n[0]) && H(e, "configurator-options-loading", t[15])
        },
        i(t) {
            _ || (bt(o.$$.fragment, t), bt(l.$$.fragment, t), bt(u.$$.fragment, t), bt(d.$$.fragment, t), bt(w), bt(C), bt(I), bt(M), bt(v.$$.fragment, t), _ = !0)
        },
        o(t) {
            wt(o.$$.fragment, t), wt(l.$$.fragment, t), wt(u.$$.fragment, t), wt(d.$$.fragment, t), wt(w), wt(C), wt(I), wt(M), wt(v.$$.fragment, t), _ = !1
        },
        d(n) {
            n && B(e), Bt(o), Bt(l), Bt(u), Bt(d), w && w.d(), C && C.d(), I && I.d(), M && M.d(), Bt(v), t[22](null), y = !1, i(E)
        }
    }
}
const na = !1;

function ra() {
    gtag("event", "hello_get_quick_estimate_configurator"), Contact.show({
        page: "hello",
        data: {
            subject: 8
        }
    })
}

function ia(t, e, n) {
    let r, i, o, a, s, l, c, u, d, p, f, m, g, A, v;
    h(t, ne, (t => n(0, g = t))), h(t, Te, (t => n(20, A = t)));
    let _ = !0,
        y = !1,
        E = null,
        x = 0;

    function b(t) {
        ! function (t) {
            t && "scroll" === t.type || window.innerWidth > 768 || null !== E && n(5, x = E.offsetTop)
        }(t), window.innerWidth <= 768 || void 0 !== v && n(2, _ = !0),
            function () {
                if (null == v) return;
                const t = Array.from(v.querySelectorAll(".configurator-section")).find((t => {
                    const e = t.querySelector(".configurator-section-preview-sticker");
                    if (e) {
                        const t = e.getBoundingClientRect(),
                            n = window.innerHeight - 40;
                        return t.top <= n && t.bottom > n
                    }
                    return !1
                }));
                n(3, y = t && t.dataset.isDarkContent)
            }()
    }
    return Z((() => {
        setTimeout(b, 0)
    })), t.$$.update = () => {
        1 & t.$$.dirty[0] && n(19, r = Zt(g)), 524288 & t.$$.dirty[0] && n(16, i = t => r.some((({
            key: e
        }) => e === t))), 1048576 & t.$$.dirty[0] && n(15, o = A.isLoading), 1 & t.$$.dirty[0] && n(14, a = () => {
            ne.select("primary-bedroom-wardrobe", "standard" === g["primary-bedroom-wardrobe"] ? "full" : "standard")
        }), 1 & t.$$.dirty[0] && n(13, s = () => {
            ne.select("secondary-bedroom-wardrobe", "standard" === g["secondary-bedroom-wardrobe"] ? "full" : "standard")
        }), 1 & t.$$.dirty[0] && n(12, l = () => {
            ne.select("floor", "floor-natural-oak" === g.floor ? "floor-dark-oak" : "floor-natural-oak")
        }), 1 & t.$$.dirty[0] && n(11, c = () => {
            ne.select("kitchen-cabinet-finish", "kitchen-cabinet-natural-oak" === g["kitchen-cabinet-finish"] ? "kitchen-cabinet-bone-white" : "kitchen-cabinet-natural-oak")
        }), 1 & t.$$.dirty[0] && n(10, u = () => {
            ne.select("floor", "floor-natural-oak" === g.floor ? "floor-dark-oak" : "floor-natural-oak")
        }), 1 & t.$$.dirty[0] && n(9, d = function (t) {
            const e = t.layout;
            let n = 0;
            "onebed" === e || "twobed" === e ? n = 4 : "xl8" === e && (n = 8);
            const r = "kitchen-cabinet-natural-oak" === t["kitchen-cabinet-finish"],
                i = "floor-dark-oak" === t.floor;
            let o = 0;
            return "onebed" === e || "twobed" === e ? !1 === i && !0 === r ? o = 0 : !0 === i && !1 === r ? o = 1 : !0 === i && !0 === r ? o = 2 : !1 === i && !1 === r && (o = 3) : (!0 === i && (o += 2), !1 === r && (o += 1)), n + o
        }(g)), 1 & t.$$.dirty[0] && n(8, p = function (t) {
            let e = 0;
            return !0 == ("floor-dark-oak" === t.floor) && (e += 2), !0 == ("full" === t["primary-bedroom-wardrobe"]) && (e += 1), e
        }(g)), 1 & t.$$.dirty[0] && n(7, f = function (t) {
            const e = t.layout;
            let n = 0;
            "xl8" === e ? n = 4 : "xl10" === e && (n = 8);
            let r = 0;
            return !0 == ("floor-dark-oak" === t.floor) && (r += 2), !0 == ("full" === t["secondary-bedroom-wardrobe"]) && (r += 1), n + r
        }(g)), 1 & t.$$.dirty[0] && n(6, m = function (t) {
            let e = 0;
            return "island" === t["kitchen-layout"] && (e += 4), "floor-dark-oak" === t.floor && (e += 2), "kitchen-cabinet-bone-white" === t["kitchen-cabinet-finish"] && (e += 1), e
        }(g))
    }, [g, v, _, y, E, x, m, f, p, d, u, c, l, s, a, o, i, b, function () {
        bi.next()
    }, r, A, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            E = t, n(4, E)
        }))
    }, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            v = t, n(1, v)
        }))
    }]
}
class oa extends Dt {
    constructor(t) {
        super(), Lt(this, t, ia, ea, a, {}, null, [-1, -1])
    }
}
var aa = {
    network: ["90001", "90002", "90003", "90004", "90005", "90006", "90007", "90008", "90011", "90012", "90013", "90014", "90015", "90016", "90017", "90018", "90019", "90020", "90021", "90022", "90023", "90024", "90025", "90026", "90027", "90028", "90029", "90031", "90032", "90033", "90034", "90035", "90036", "90037", "90038", "90039", "90040", "90041", "90042", "90043", "90044", "90045", "90046", "90047", "90048", "90049", "90056", "90057", "90058", "90059", "90061", "90062", "90063", "90064", "90065", "90066", "90067", "90068", "90069", "90071", "90073", "90077", "90089", "90094", "90095", "90201", "90210", "90211", "90212", "90220", "90221", "90222", "90230", "90232", "90240", "90241", "90242", "90245", "90247", "90248", "90249", "90250", "90254", "90255", "90260", "90262", "90263", "90265", "90266", "90270", "90272", "90274", "90275", "90277", "90278", "90280", "90290", "90291", "90292", "90293", "90301", "90302", "90303", "90304", "90305", "90401", "90402", "90403", "90404", "90405", "90501", "90502", "90503", "90504", "90505", "90506", "90601", "90602", "90603", "90604", "90605", "90606", "90620", "90621", "90623", "90630", "90631", "90638", "90639", "90640", "90650", "90660", "90670", "90680", "90701", "90703", "90706", "90710", "90712", "90713", "90715", "90716", "90717", "90720", "90723", "90731", "90732", "90740", "90742", "90743", "90744", "90745", "90746", "90747", "90755", "90802", "90803", "90804", "90805", "90806", "90807", "90808", "90810", "90813", "90814", "90815", "90822", "90840", "91001", "91006", "91007", "91008", "91010", "91011", "91016", "91020", "91024", "91030", "91040", "91042", "91101", "91103", "91104", "91105", "91106", "91107", "91108", "91123", "91201", "91202", "91203", "91204", "91205", "91206", "91207", "91208", "91210", "91214", "91301", "91302", "91303", "91304", "91306", "91307", "91311", "91316", "91320", "91321", "91324", "91325", "91326", "91330", "91331", "91335", "91340", "91342", "91343", "91344", "91345", "91350", "91351", "91352", "91354", "91355", "91356", "91360", "91361", "91362", "91364", "91367", "91371", "91377", "91381", "91384", "91387", "91390", "91401", "91402", "91403", "91405", "91406", "91411", "91423", "91436", "91501", "91502", "91504", "91505", "91506", "91521", "91522", "91523", "91601", "91602", "91604", "91605", "91606", "91607", "91608", "91701", "91702", "91706", "91708", "91709", "91710", "91711", "91722", "91723", "91724", "91730", "91731", "91732", "91733", "91737", "91739", "91740", "91741", "91744", "91745", "91746", "91748", "91750", "91752", "91754", "91755", "91759", "91761", "91762", "91763", "91764", "91765", "91766", "91767", "91768", "91770", "91773", "91775", "91776", "91780", "91784", "91786", "91789", "91790", "91791", "91792", "91801", "91803", "91902", "91910", "91911", "91913", "91914", "91915", "91917", "91932", "91935", "91941", "91942", "91945", "91950", "91977", "91978", "91980", "92003", "92007", "92008", "92009", "92010", "92011", "92014", "92019", "92020", "92021", "92024", "92025", "92026", "92027", "92028", "92029", "92037", "92040", "92054", "92055", "92056", "92057", "92058", "92059", "92061", "92064", "92065", "92067", "92069", "92071", "92075", "92078", "92081", "92082", "92083", "92084", "92091", "92093", "92096", "92101", "92102", "92103", "92104", "92105", "92106", "92107", "92108", "92109", "92110", "92111", "92113", "92114", "92115", "92116", "92117", "92118", "92119", "92120", "92121", "92122", "92123", "92124", "92126", "92127", "92128", "92129", "92130", "92131", "92134", "92135", "92136", "92139", "92140", "92145", "92152", "92154", "92155", "92173", "92182", "92201", "92203", "92210", "92211", "92220", "92223", "92230", "92234", "92236", "92240", "92241", "92253", "92254", "92256", "92258", "92260", "92262", "92264", "92270", "92276", "92282", "92305", "92313", "92314", "92316", "92317", "92318", "92320", "92321", "92322", "92324", "92325", "92335", "92336", "92337", "92339", "92341", "92346", "92350", "92352", "92354", "92358", "92359", "92373", "92374", "92376", "92377", "92378", "92382", "92385", "92391", "92397", "92399", "92401", "92404", "92405", "92407", "92408", "92410", "92411", "92415", "92501", "92503", "92504", "92505", "92506", "92507", "92508", "92509", "92518", "92521", "92530", "92532", "92539", "92543", "92544", "92545", "92548", "92549", "92551", "92553", "92555", "92557", "92561", "92562", "92563", "92567", "92570", "92571", "92582", "92583", "92584", "92585", "92586", "92587", "92590", "92591", "92592", "92595", "92596", "92602", "92603", "92604", "92606", "92610", "92612", "92614", "92617", "92618", "92620", "92624", "92625", "92626", "92627", "92629", "92630", "92637", "92646", "92647", "92648", "92649", "92651", "92653", "92655", "92656", "92657", "92660", "92661", "92662", "92663", "92672", "92673", "92675", "92676", "92677", "92679", "92683", "92688", "92691", "92692", "92694", "92697", "92701", "92703", "92704", "92705", "92706", "92707", "92708", "92780", "92782", "92801", "92802", "92804", "92805", "92806", "92807", "92808", "92821", "92823", "92831", "92832", "92833", "92835", "92840", "92841", "92843", "92844", "92845", "92860", "92861", "92865", "92866", "92867", "92868", "92869", "92870", "92879", "92880", "92881", "92882", "92883", "92886", "92887", "93001", "93003", "93004", "93010", "93012", "93013", "93015", "93021", "93022", "93023", "93030", "93033", "93035", "93036", "93040", "93041", "93042", "93043", "93060", "93063", "93065", "93066", "93067", "93101", "93103", "93105", "93106", "93108", "93109", "93110", "93111", "93117", "93204", "93210", "93224", "93225", "93249", "93251", "93252", "93254", "93268", "93401", "93402", "93405", "93407", "93420", "93422", "93426", "93427", "93428", "93429", "93430", "93432", "93433", "93434", "93435", "93436", "93437", "93440", "93441", "93442", "93444", "93445", "93446", "93449", "93450", "93451", "93452", "93453", "93454", "93455", "93458", "93460", "93461", "93463", "93465", "93510", "93550", "93563", "93635", "93901", "93905", "93906", "93907", "93908", "93920", "93923", "93924", "93925", "93926", "93927", "93930", "93932", "93933", "93940", "93943", "93944", "93950", "93953", "93955", "93960", "93962", "94002", "94005", "94010", "94014", "94015", "94019", "94020", "94021", "94022", "94024", "94025", "94027", "94028", "94029", "94030", "94035", "94037", "94038", "94040", "94041", "94043", "94044", "94060", "94061", "94062", "94063", "94065", "94066", "94070", "94074", "94080", "94085", "94086", "94087", "94089", "94102", "94103", "94104", "94105", "94107", "94108", "94109", "94110", "94111", "94112", "94114", "94115", "94116", "94117", "94118", "94121", "94122", "94123", "94124", "94127", "94128", "94129", "94130", "94131", "94132", "94133", "94134", "94158", "94301", "94303", "94304", "94305", "94306", "94401", "94402", "94403", "94404", "94501", "94502", "94503", "94505", "94506", "94507", "94508", "94509", "94510", "94511", "94512", "94513", "94514", "94515", "94517", "94518", "94519", "94520", "94521", "94523", "94525", "94526", "94528", "94530", "94531", "94533", "94534", "94535", "94536", "94538", "94539", "94541", "94542", "94544", "94545", "94546", "94547", "94548", "94549", "94550", "94551", "94552", "94553", "94555", "94556", "94558", "94559", "94560", "94561", "94563", "94564", "94565", "94566", "94567", "94568", "94569", "94571", "94572", "94574", "94576", "94577", "94578", "94579", "94580", "94582", "94583", "94585", "94586", "94587", "94588", "94589", "94590", "94591", "94592", "94595", "94596", "94597", "94598", "94599", "94601", "94602", "94603", "94605", "94606", "94607", "94608", "94609", "94610", "94611", "94612", "94613", "94618", "94619", "94621", "94702", "94703", "94704", "94705", "94706", "94707", "94708", "94709", "94710", "94720", "94801", "94803", "94804", "94805", "94806", "94901", "94903", "94904", "94920", "94922", "94923", "94924", "94925", "94928", "94929", "94930", "94931", "94933", "94937", "94938", "94939", "94940", "94941", "94945", "94946", "94947", "94949", "94951", "94952", "94954", "94956", "94957", "94960", "94963", "94964", "94965", "94970", "94971", "94972", "94973", "95002", "95003", "95004", "95005", "95006", "95008", "95010", "95012", "95013", "95014", "95017", "95018", "95019", "95020", "95023", "95030", "95032", "95033", "95035", "95037", "95039", "95043", "95045", "95046", "95050", "95051", "95053", "95054", "95060", "95062", "95064", "95065", "95066", "95070", "95073", "95075", "95076", "95110", "95111", "95112", "95113", "95116", "95117", "95118", "95119", "95120", "95121", "95122", "95123", "95124", "95125", "95126", "95127", "95128", "95129", "95130", "95131", "95132", "95133", "95134", "95135", "95136", "95138", "95139", "95140", "95141", "95148", "95192", "95206", "95219", "95220", "95242", "95258", "95360", "95363", "95377", "95391", "95401", "95403", "95404", "95405", "95407", "95409", "95412", "95421", "95425", "95436", "95439", "95441", "95442", "95444", "95446", "95448", "95450", "95452", "95457", "95461", "95462", "95465", "95467", "95472", "95476", "95492", "95497", "95603", "95605", "95606", "95607", "95608", "95610", "95612", "95615", "95616", "95618", "95620", "95621", "95624", "95626", "95627", "95628", "95630", "95632", "95637", "95638", "95640", "95641", "95645", "95648", "95650", "95652", "95653", "95655", "95658", "95659", "95660", "95661", "95662", "95663", "95664", "95668", "95669", "95670", "95672", "95673", "95677", "95678", "95682", "95683", "95687", "95688", "95690", "95691", "95693", "95694", "95695", "95698", "95742", "95746", "95747", "95757", "95758", "95762", "95765", "95776", "95811", "95814", "95815", "95816", "95817", "95818", "95819", "95820", "95821", "95822", "95823", "95824", "95825", "95826", "95827", "95828", "95829", "95830", "95831", "95832", "95833", "95834", "95835", "95836", "95837", "95838", "95841", "95842", "95843", "95864", "95937"],
    highInstallationCost: ["94501", "94502", "94536", "94537", "94538", "94539", "94540", "94541", "94542", "94543", "94544", "94545", "94546", "94550", "94551", "94552", "94555", "94557", "94560", "94566", "94568", "94577", "94578", "94579", "94580", "94586", "94587", "94588", "94601", "94602", "94603", "94604", "94605", "94606", "94607", "94608", "94690", "94610", "94611", "94612", "94613", "94614", "94615", "94617", "94618", "94619", "94620", "94621", "94622", "94623", "94624", "94625", "94649", "94659", "94660", "94661", "94662", "94666", "94701", "94702", "94703", "94704", "94705", "94706", "94707", "94708", "94790", "94710", "94712", "94720", "94505", "94506", "94507", "94590", "94511", "94513", "94514", "94516", "94517", "94518", "94519", "94520", "94521", "94522", "94523", "94524", "94525", "94526", "94527", "94528", "94529", "94530", "94531", "94547", "94548", "94549", "94553", "94556", "94561", "94563", "94564", "94565", "94569", "94570", "94572", "94575", "94582", "94583", "94595", "94596", "94597", "94598", "94801", "94802", "94803", "94804", "94805", "94806", "94807", "94808", "94820", "94850", "94901", "94903", "94904", "94912", "94913", "94914", "94915", "94920", "94924", "94925", "94929", "94930", "94933", "94937", "94938", "94939", "94940", "94941", "94942", "94945", "94946", "94947", "94948", "94949", "94950", "94956", "94957", "94960", "94963", "94964", "94965", "94966", "94970", "94971", "94972", "94973", "94974", "94976", "94977", "94978", "94979", "94998", "93426", "93450", "93901", "93902", "93905", "93906", "93907", "93908", "93912", "93915", "93920", "93921", "93922", "93923", "93924", "93925", "93926", "93927", "93928", "93930", "93932", "93933", "93940", "93942", "93943", "93944", "93950", "93953", "93954", "93955", "93960", "93962", "95004", "95012", "95039", "94503", "94508", "94515", "94558", "94559", "94562", "94567", "94573", "94574", "94576", "94581", "94599", "94101", "94102", "94103", "94104", "94105", "94106", "94107", "94108", "94190", "94110", "94111", "94112", "94114", "94115", "94116", "94117", "94118", "94119", "94120", "94121", "94122", "94123", "94124", "94125", "94126", "94127", "94129", "94130", "94131", "94132", "94133", "94134", "94135", "94136", "94137", "94138", "94139", "94140", "94141", "94142", "94143", "94144", "94145", "94146", "94147", "94150", "94151", "94152", "94153", "94154", "94155", "94156", "94158", "94159", "94160", "94161", "94162", "94163", "94164", "94171", "94172", "94175", "94177", "94188", "94199", "94002", "94005", "94010", "94011", "94013", "94014", "94015", "94016", "94017", "94018", "94019", "94020", "94021", "94025", "94026", "94027", "94028", "94030", "94037", "94038", "94044", "94060", "94061", "94062", "94063", "94064", "94065", "94066", "94070", "94074", "94080", "94083", "94128", "94303", "94401", "94402", "94403", "94404", "94497", "94022", "94023", "94024", "94035", "94039", "94040", "94041", "94042", "94043", "94085", "94086", "94087", "94088", "94089", "94301", "94302", "94304", "94305", "94306", "94390", "95002", "95008", "95090", "95011", "95013", "95014", "95015", "95020", "95021", "95026", "95030", "95031", "95032", "95035", "95036", "95037", "95038", "95042", "95044", "95046", "95050", "95051", "95052", "95053", "95054", "95055", "95056", "95070", "95071", "95101", "95103", "95106", "95108", "95190", "95110", "95111", "95112", "95113", "95115", "95116", "95117", "95118", "95119", "95120", "95121", "95122", "95123", "95124", "95125", "95126", "95127", "95128", "95129", "95130", "95131", "95132", "95133", "95134", "95135", "95136", "95138", "95139", "95140", "95141", "95148", "95150", "95151", "95152", "95153", "95154", "95155", "95156", "95157", "95158", "95159", "95160", "95161", "95164", "95170", "95172", "95173", "95190", "95191", "95192", "95193", "95194", "95196", "95001", "95003", "95005", "95006", "95007", "95010", "95017", "95018", "95019", "95033", "95041", "95060", "95061", "95062", "95063", "95064", "95065", "95066", "95067", "95073", "95076", "95077", "94922", "94923", "94926", "94927", "94928", "94931", "94951", "94952", "94953", "94954", "94955", "94975", "94999", "95401", "95402", "95403", "95404", "95405", "95406", "95407", "95490", "95412", "95416", "95419", "95421", "95425", "95430", "95431", "95433", "95436", "95439", "95441", "95442", "95444", "95446", "95448", "95450", "95452", "95462", "95465", "95471", "95472", "95473", "95476", "95480", "95486", "95487", "95492", "95497"]
};

function sa(t, e, n) {
    const r = t.slice();
    return r[27] = e[n], r
}

function la(t) {
    let e, n, r;
    return {
        c() {
            e = L("label"), n = P(t[2]), N(e, "class", r = A({
                default: "type-15 color-text-40",
                financing: "type-18 color-text-40"
            } [t[8]]) + " svelte-1y2ze90"), N(e, "for", t[12]), H(e, "common-form-field-input-label-hidden", t[11])
        },
        m(t, r) {
            T(t, e, r), S(e, n)
        },
        p(t, i) {
            4 & i && F(n, t[2]), 256 & i && r !== (r = A({
                default: "type-15 color-text-40",
                financing: "type-18 color-text-40"
            } [t[8]]) + " svelte-1y2ze90") && N(e, "class", r), 2304 & i && H(e, "common-form-field-input-label-hidden", t[11])
        },
        d(t) {
            t && B(e)
        }
    }
}

function ca(t) {
    let e, n, r, o, a;
    return {
        c() {
            e = L("input"), N(e, "id", t[12]), N(e, "name", t[3]), N(e, "placeholder", t[9]), N(e, "inputmode", t[4]), N(e, "autocapitalize", n = "email" !== t[4]), N(e, "class", r = A({
                default: "type-15 m-type-16",
                hello: "type-15 m-type-16",
                financing: "type-18"
            } [t[8]]) + " svelte-1y2ze90")
        },
        m(n, r) {
            T(n, e, r), Q(e, t[10]), t[25](e), o || (a = [U(e, "input", t[24]), U(e, "focus", t[15]), U(e, "blur", t[16]), U(e, "input", t[17]), U(e, "change", t[17]), U(e, "keypress", t[14])], o = !0)
        },
        p(t, i) {
            8 & i && N(e, "name", t[3]), 512 & i && N(e, "placeholder", t[9]), 16 & i && N(e, "inputmode", t[4]), 16 & i && n !== (n = "email" !== t[4]) && N(e, "autocapitalize", n), 256 & i && r !== (r = A({
                default: "type-15 m-type-16",
                hello: "type-15 m-type-16",
                financing: "type-18"
            } [t[8]]) + " svelte-1y2ze90") && N(e, "class", r), 1056 & i && e.value !== t[10] && Q(e, t[10])
        },
        d(n) {
            n && B(e), t[25](null), o = !1, i(a)
        }
    }
}

function ua(t) {
    let e, n, r;
    return {
        c() {
            e = L("textarea"), N(e, "id", t[12]), N(e, "name", t[3]), N(e, "class", "type-18 m-type-16 svelte-1y2ze90")
        },
        m(i, o) {
            T(i, e, o), Q(e, t[10]), n || (r = [U(e, "input", t[23]), U(e, "scroll", t[18])], n = !0)
        },
        p(t, n) {
            8 & n && N(e, "name", t[3]), 1056 & n && Q(e, t[10])
        },
        d(t) {
            t && B(e), n = !1, i(r)
        }
    }
}

function ha(t) {
    let e, n, r, o, a, s, c, u = St(t[5]),
        h = [];
    for (let e = 0; e < u.length; e += 1) h[e] = da(sa(t, u, e));
    return {
        c() {
            e = L("select");
            for (let t = 0; t < h.length; t += 1) h[t].c();
            r = O(), o = L("img"), N(e, "id", t[12]), N(e, "name", t[3]), N(e, "class", n = A({
                default: "type-15 m-type-16",
                financing: "type-18 m-type-15"
            } [t[8]]) + " svelte-1y2ze90"), void 0 === t[10] && ut((() => t[21].call(e))), N(o, "class", "common-form-field-input-dropdown-arrow svelte-1y2ze90"), l(o.src, a = "/assets/images/backyard/arrow-mini-down.svg") || N(o, "src", "/assets/images/backyard/arrow-mini-down.svg"), N(o, "alt", "⋁")
        },
        m(n, i) {
            T(n, e, i);
            for (let t = 0; t < h.length; t += 1) h[t] && h[t].m(e, null);
            G(e, t[10], !0), T(n, r, i), T(n, o, i), s || (c = [U(e, "change", t[21]), U(e, "change", t[22])], s = !0)
        },
        p(t, r) {
            if (32 & r) {
                let n;
                for (u = St(t[5]), n = 0; n < u.length; n += 1) {
                    const i = sa(t, u, n);
                    h[n] ? h[n].p(i, r) : (h[n] = da(i), h[n].c(), h[n].m(e, null))
                }
                for (; n < h.length; n += 1) h[n].d(1);
                h.length = u.length
            }
            8 & r && N(e, "name", t[3]), 256 & r && n !== (n = A({
                default: "type-15 m-type-16",
                financing: "type-18 m-type-15"
            } [t[8]]) + " svelte-1y2ze90") && N(e, "class", n), 1056 & r && G(e, t[10])
        },
        d(t) {
            t && (B(e), B(r), B(o)), R(h, t), s = !1, i(c)
        }
    }
}

function da(t) {
    let e, n, r, i, o = t[27][1] + "";
    return {
        c() {
            e = L("option"), n = P(o), r = O(), e.__value = i = t[27][0], Q(e, e.__value)
        },
        m(t, i) {
            T(t, e, i), S(e, n), S(e, r)
        },
        p(t, r) {
            32 & r && o !== (o = t[27][1] + "") && F(n, o), 32 & r && i !== (i = t[27][0]) && (e.__value = i, Q(e, e.__value))
        },
        d(t) {
            t && B(e)
        }
    }
}

function pa(e) {
    let n, r, i, o = void 0 !== e[2] && la(e);

    function a(t, e) {
        return "select" === t[4] ? ha : "textarea" === t[4] ? ua : ca
    }
    let s = a(e),
        l = s(e);
    return {
        c() {
            n = L("div"), o && o.c(), r = O(), l.c(), N(n, "class", i = A([`common-form-field-input ${e[6]}`, `common-form-field-input-${e[4]}`, `common-form-field-input-${e[8]}`].join(" ")) + " svelte-1y2ze90"), H(n, "empty", !e[10] || 0 === e[10].length), H(n, "titleless", !e[2] || 0 === e[2].length), H(n, "focused", e[0]), H(n, "error", e[7])
        },
        m(t, e) {
            T(t, n, e), o && o.m(n, null), S(n, r), l.m(n, null)
        },
        p(t, [e]) {
            void 0 !== t[2] ? o ? o.p(t, e) : (o = la(t), o.c(), o.m(n, r)) : o && (o.d(1), o = null), s === (s = a(t)) && l ? l.p(t, e) : (l.d(1), l = s(t), l && (l.c(), l.m(n, null))), 336 & e && i !== (i = A([`common-form-field-input ${t[6]}`, `common-form-field-input-${t[4]}`, `common-form-field-input-${t[8]}`].join(" ")) + " svelte-1y2ze90") && N(n, "class", i), 1360 & e && H(n, "empty", !t[10] || 0 === t[10].length), 340 & e && H(n, "titleless", !t[2] || 0 === t[2].length), 337 & e && H(n, "focused", t[0]), 464 & e && H(n, "error", t[7])
        },
        i: t,
        o: t,
        d(t) {
            t && B(n), o && o.d(), l.d()
        }
    }
}

function fa(t, e, n) {
    let {
        title: r = ""
    } = e, {
        name: i
    } = e, {
        type: o = "text"
    } = e, {
        options: a = []
    } = e, {
        store: s
    } = e, {
        className: l = ""
    } = e, {
        isFocused: c = !1
    } = e, {
        isError: u = !1
    } = e, {
        variant: h = "default"
    } = e, {
        input: d
    } = e, {
        placeholder: p
    } = e;
    const f = `input-${Math.random().toString(32).substring(2,5)}`,
        m = nt();
    let g, A = "select" === o ? a[0][0] : "";
    void 0 !== s && s.subscribe((t => {
        g && t.data[i] === g || (n(10, A = t.data[i]), n(20, g = A), "select" !== o || A || n(10, A = a[0][0]))
    }));
    let v = "",
        _ = !1;
    return t.$$set = t => {
        "title" in t && n(2, r = t.title), "name" in t && n(3, i = t.name), "type" in t && n(4, o = t.type), "options" in t && n(5, a = t.options), "store" in t && n(19, s = t.store), "className" in t && n(6, l = t.className), "isFocused" in t && n(0, c = t.isFocused), "isError" in t && n(7, u = t.isError), "variant" in t && n(8, h = t.variant), "input" in t && n(1, d = t.input), "placeholder" in t && n(9, p = t.placeholder)
    }, t.$$.update = () => {
        1573896 & t.$$.dirty && A !== g && (void 0 !== s && s.updateData(i, A), n(20, g = A))
    }, [c, d, r, i, o, a, l, u, h, p, A, _, f, m, function (t) {
        m("input", {
            inputEvent: t,
            reset() {
                t.target.value = null, n(10, A = null)
            }
        })
    }, function () {
        n(0, c = !0), m("focus")
    }, function () {
        n(0, c = !1), m("blur")
    }, function (t) {
        if ("phone" !== o) return;
        const e = t.target,
            r = v.length > e.value.length;
        if ("deleteContentBackward" !== t.inputType || "+1" !== e.value && "1" !== e.value || (e.value = ""), v = e.value, r) return;
        const a = /^[\+|1]/.test(e.value),
            l = e.value.replace(/[^0-9.]/g, "").replace(/^\+?1|\|1|\D/, ""),
            c = l.substr(0, 3),
            u = l.substr(3, 3),
            h = l.substr(6, 4);
        let d = e.value,
            p = !1;
        h ? d = `(${c}) ${u}-${h}` : u ? d = `(${c}) ${u}` : c ? (d = `(${c}) `, p = !0) : d = l, a && (d = `+1 ${d}`), n(10, A = d), void 0 !== s && s.updateData(i, d), setTimeout((() => {
            e.value = d, p && e.setSelectionRange(d.length - 1, d.length - 1)
        }), 0)
    }, function (t) {
        n(11, _ = t.target.scrollTop > 0)
    }, s, g, function () {
        A = function (t) {
            const e = t.querySelector(":checked");
            return e && e.__value
        }(this), n(10, A), n(5, a)
    }, () => {
        m("change", {
            value: A
        })
    }, function () {
        A = this.value, n(10, A), n(5, a)
    }, function () {
        A = this.value, n(10, A), n(5, a)
    }, function (t) {
        ot[t ? "unshift" : "push"]((() => {
            d = t, n(1, d)
        }))
    }]
}
class ma extends Dt {
    constructor(t) {
        super(), Lt(this, t, fa, pa, a, {
            title: 2,
            name: 3,
            type: 4,
            options: 5,
            store: 19,
            className: 6,
            isFocused: 0,
            isError: 7,
            variant: 8,
            input: 1,
            placeholder: 9
        })
    }
}

function ga(e) {
    let n, r, i, o, a, s, l;
    return {
        c() {
            n = L("div"), r = L("div"), i = O(), o = L("div"), a = O(), s = L("div"), N(r, "class", "svelte-f9d7e9"), N(o, "class", "svelte-f9d7e9"), N(s, "class", "svelte-f9d7e9"), N(n, "class", l = A(`loader ${e[0]}`) + " svelte-f9d7e9")
        },
        m(t, e) {
            T(t, n, e), S(n, r), S(n, i), S(n, o), S(n, a), S(n, s)
        },
        p(t, [e]) {
            1 & e && l !== (l = A(`loader ${t[0]}`) + " svelte-f9d7e9") && N(n, "class", l)
        },
        i: t,
        o: t,
        d(t) {
            t && B(n)
        }
    }
}

function Aa(t, e, n) {
    let {
        variant: r = "default"
    } = e;
    return t.$$set = t => {
        "variant" in t && n(0, r = t.variant)
    }, [r]
}
class va extends Dt {
    constructor(t) {
        super(), Lt(this, t, Aa, ga, a, {
            variant: 0
        })
    }
}

function _a(t, e, n) {
    const r = t.slice();
    return r[22] = e[n], r[24] = n, r
}

function ya(t) {
    let e, n, r, o, a = t[22].address + "";

    function s() {
        return t[14](t[24])
    }
    return {
        c() {
            e = L("li"), n = P(a), N(e, "class", "type-15 m-type-14 svelte-18bga3j"), H(e, "selected", t[24] === t[3])
        },
        m(i, a) {
            T(i, e, a), S(e, n), r || (o = [U(e, "mouseover", s), U(e, "mousedown", t[7])], r = !0)
        },
        p(r, i) {
            t = r, 2 & i && a !== (a = t[22].address + "") && F(n, a), 8 & i && H(e, "selected", t[24] === t[3])
        },
        d(t) {
            t && B(e), r = !1, i(o)
        }
    }
}

function Ea(t) {
    let e, n, r;
    return n = new va({}), {
        c() {
            e = L("li"), Mt(n.$$.fragment), N(e, "class", "loader-container svelte-18bga3j")
        },
        m(t, i) {
            T(t, e, i), Tt(n, e, null), r = !0
        },
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            t && B(e), Bt(n)
        }
    }
}

function xa(t) {
    let e, n, r, i, o, a, s, l = St(t[1]),
        c = [];
    for (let e = 0; e < l.length; e += 1) c[e] = ya(_a(t, l, e));
    let u = t[2] && Ea();
    return {
        c() {
            e = L("div"), n = L("ul");
            for (let t = 0; t < c.length; t += 1) c[t].c();
            r = O(), u && u.c(), N(n, "class", "svelte-18bga3j"), H(n, "visible", t[4]), N(e, "class", i = A(`suggestions ${t[0]}`) + " svelte-18bga3j")
        },
        m(i, l) {
            T(i, e, l), S(e, n);
            for (let t = 0; t < c.length; t += 1) c[t] && c[t].m(n, null);
            S(n, r), u && u.m(n, null), o = !0, a || (s = U(window, "keydown", t[5]), a = !0)
        },
        p(t, [a]) {
            if (202 & a) {
                let e;
                for (l = St(t[1]), e = 0; e < l.length; e += 1) {
                    const i = _a(t, l, e);
                    c[e] ? c[e].p(i, a) : (c[e] = ya(i), c[e].c(), c[e].m(n, r))
                }
                for (; e < c.length; e += 1) c[e].d(1);
                c.length = l.length
            }
            t[2] ? u ? 4 & a && bt(u, 1) : (u = Ea(), u.c(), bt(u, 1), u.m(n, null)) : u && (Et(), wt(u, 1, 1, (() => {
                u = null
            })), xt()), (!o || 16 & a) && H(n, "visible", t[4]), (!o || 1 & a && i !== (i = A(`suggestions ${t[0]}`) + " svelte-18bga3j")) && N(e, "class", i)
        },
        i(t) {
            o || (bt(u), o = !0)
        },
        o(t) {
            wt(u), o = !1
        },
        d(t) {
            t && B(e), R(c, t), u && u.d(), a = !1, s()
        }
    }
}

function ba(t, e, n) {
    let r, i;
    let {
        query: o
    } = e, {
        isVisible: a
    } = e, {
        variant: s = "default"
    } = e;
    const l = nt();
    let c, u, h, d = [],
        p = -1,
        f = !1;

    function m() {
        const t = d[p] || d[0];
        void 0 !== t && l("select", {
            suggestion: t
        })
    }

    function g(t) {
        n(3, p = t)
    }
    return t.$$set = t => {
        "query" in t && n(8, o = t.query), "isVisible" in t && n(9, a = t.isVisible), "variant" in t && n(0, s = t.variant)
    }, t.$$.update = () => {
        16128 & t.$$.dirty && (async () => {
            const t = (o || "").split(" ").slice(0, 20).join(" ").slice(0, 256);
            if (t !== c && (n(10, c = t), n(3, p = -1), n(1, d = []), h && (h.abort(), n(12, h = null)), t && !(t.length < 3) && a)) {
                n(2, f = !0), n(12, h = new AbortController);
                try {
                    const e = await API.completeAddress(encodeURIComponent(t), u, r, h.signal),
                        i = await e.json();
                    n(11, u = i.session), n(13, r = i.bias), n(1, d = i.suggestions)
                } catch (t) {
                    if ("AbortError" === t.name) return;
                    l("error"), console.error("failed to load address suggestions", t)
                }
                n(2, f = !1)
            }
        })(), 518 & t.$$.dirty && n(4, i = a && void 0 !== d && (d.length > 0 || f))
    }, n(13, r = "-118,34"), [s, d, f, p, i, function (t) {
        switch (t.key) {
            case "ArrowUp":
                ! function (t) {
                    t.preventDefault(), n(3, p = Math.max(p - 1, 0))
                }(t);
                break;
            case "ArrowDown":
                ! function (t) {
                    t.preventDefault(), void 0 !== d && n(3, p = Math.min(p + 1, d.length - 1))
                }(t);
                break;
            case "Enter":
                ! function (t) {
                    a && d.length > 0 && (t.target.blur(), t.preventDefault(), m())
                }(t);
                break;
            case "Escape":
                ! function (t) {
                    t.preventDefault(), n(1, d = [])
                }(t)
        }
    }, g, function () {
        m()
    }, o, a, c, u, h, r, t => g(t)]
}
class wa extends Dt {
    constructor(t) {
        super(), Lt(this, t, ba, xa, a, {
            query: 8,
            isVisible: 9,
            variant: 0
        })
    }
}
const Ca = t => ({}),
    Sa = t => ({}),
    Ia = t => ({}),
    Ma = t => ({});

function Ta(t) {
    let e, n, r, i, o, a;
    const s = t[2].label,
        l = d(s, t, t[1], Ma),
        c = t[2].subtitle,
        u = d(c, t, t[1], Sa);
    return {
        c() {
            e = L("div"), n = L("h2"), l && l.c(), r = O(), i = L("p"), u && u.c(), N(n, "class", "type-24 m-type-18"), N(i, "class", "color-text-60 type-15 m-type-14"), N(e, "class", o = A(`common-form-field-label common-form-field-label-${t[0]}`) + " svelte-1lngd6v")
        },
        m(t, o) {
            T(t, e, o), S(e, n), l && l.m(n, null), S(e, r), S(e, i), u && u.m(i, null), a = !0
        },
        p(t, [n]) {
            l && l.p && (!a || 2 & n) && m(l, s, t, t[1], a ? f(s, t[1], n, Ia) : g(t[1]), Ma), u && u.p && (!a || 2 & n) && m(u, c, t, t[1], a ? f(c, t[1], n, Ca) : g(t[1]), Sa), (!a || 1 & n && o !== (o = A(`common-form-field-label common-form-field-label-${t[0]}`) + " svelte-1lngd6v")) && N(e, "class", o)
        },
        i(t) {
            a || (bt(l, t), bt(u, t), a = !0)
        },
        o(t) {
            wt(l, t), wt(u, t), a = !1
        },
        d(t) {
            t && B(e), l && l.d(t), u && u.d(t)
        }
    }
}

function Ba(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e, {
        variant: o = "default"
    } = e;
    return t.$$set = t => {
        "variant" in t && n(0, o = t.variant), "$$scope" in t && n(1, i = t.$$scope)
    }, [o, i, r]
}
class Ra extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ba, Ta, a, {
            variant: 0
        })
    }
}

function La(t) {
    let e, n, r;
    return n = new Ra({
        props: {
            variant: t[7],
            $$slots: {
                subtitle: [Pa],
                label: [Da]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            e = L("div"), Mt(n.$$.fragment), N(e, "class", "modal-grid-column-6 contact-page-header")
        },
        m(t, i) {
            T(t, e, i), Tt(n, e, null), r = !0
        },
        p(t, e) {
            const r = {};
            128 & e && (r.variant = t[7]), 262150 & e && (r.$$scope = {
                dirty: e,
                ctx: t
            }), n.$set(r)
        },
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            t && B(e), Bt(n)
        }
    }
}

function Da(t) {
    let e, n;
    return {
        c() {
            e = L("span"), n = P(t[1]), N(e, "slot", "label")
        },
        m(t, r) {
            T(t, e, r), S(e, n)
        },
        p(t, e) {
            2 & e && F(n, t[1])
        },
        d(t) {
            t && B(e)
        }
    }
}

function Pa(t) {
    let e, n;
    return {
        c() {
            e = L("span"), n = P(t[2]), N(e, "slot", "subtitle")
        },
        m(t, r) {
            T(t, e, r), S(e, n)
        },
        p(t, e) {
            4 & e && F(n, t[2])
        },
        d(t) {
            t && B(e)
        }
    }
}

function Oa(t) {
    let e, n, r, i, o, a, s, l, c, u;
    return i = new ma({
        props: {
            variant: t[7],
            title: "ZIP code",
            name: "zip",
            store: t[5],
            className: t[4]
        }
    }), c = new ma({
        props: {
            variant: t[7],
            title: "City",
            name: "city",
            store: t[5],
            className: t[4]
        }
    }), {
        c() {
            e = L("div"), n = L("div"), r = O(), Mt(i.$$.fragment), o = O(), a = L("div"), s = L("div"), l = O(), Mt(c.$$.fragment), N(n, "class", "spacer-12 m-spacer-8"), N(e, "class", "modal-grid-column-3"), N(s, "class", "spacer-12 m-spacer-8"), N(a, "class", "modal-grid-column-3")
        },
        m(t, h) {
            T(t, e, h), S(e, n), S(e, r), Tt(i, e, null), T(t, o, h), T(t, a, h), S(a, s), S(a, l), Tt(c, a, null), u = !0
        },
        p(t, e) {
            const n = {};
            128 & e && (n.variant = t[7]), 32 & e && (n.store = t[5]), 16 & e && (n.className = t[4]), i.$set(n);
            const r = {};
            128 & e && (r.variant = t[7]), 32 & e && (r.store = t[5]), 16 & e && (r.className = t[4]), c.$set(r)
        },
        i(t) {
            u || (bt(i.$$.fragment, t), bt(c.$$.fragment, t), u = !0)
        },
        o(t) {
            wt(i.$$.fragment, t), wt(c.$$.fragment, t), u = !1
        },
        d(t) {
            t && (B(e), B(o), B(a)), Bt(i), Bt(c)
        }
    }
}

function ka(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f = void 0 !== t[1] && La(t);

    function m(e) {
        t[14](e)
    }

    function g(e) {
        t[15](e)
    }
    let A = {
        variant: t[7],
        title: t[3],
        name: t[8] ? "street" : "address",
        store: t[5],
        className: t[4],
        isError: t[6]
    };
    void 0 !== t[9] && (A.isFocused = t[9]), void 0 !== t[0] && (A.input = t[0]), a = new ma({
        props: A
    }), ot.push((() => It(a, "isFocused", m))), ot.push((() => It(a, "input", g))), a.$on("blur", t[12]), u = new wa({
        props: {
            variant: "contact",
            query: t[8] ? t[10].data.street : t[10].data.address,
            isVisible: t[9]
        }
    }), u.$on("select", t[11]);
    let v = !0 === t[8] && Oa(t);
    return {
        c() {
            e = L("div"), f && f.c(), n = O(), r = L("div"), i = L("div"), o = O(), Mt(a.$$.fragment), c = O(), Mt(u.$$.fragment), h = O(), v && v.c(), N(i, "class", "spacer-16 m-spacer-8"), N(r, "class", "modal-grid-column-6"), N(e, "class", d = `modal-grid modal-grid-half-gap form-field-address-${t[7]}`)
        },
        m(t, s) {
            T(t, e, s), f && f.m(e, null), S(e, n), S(e, r), S(r, i), S(r, o), Tt(a, r, null), S(r, c), Tt(u, r, null), S(e, h), v && v.m(e, null), p = !0
        },
        p(t, [r]) {
            void 0 !== t[1] ? f ? (f.p(t, r), 2 & r && bt(f, 1)) : (f = La(t), f.c(), bt(f, 1), f.m(e, n)) : f && (Et(), wt(f, 1, 1, (() => {
                f = null
            })), xt());
            const i = {};
            128 & r && (i.variant = t[7]), 8 & r && (i.title = t[3]), 256 & r && (i.name = t[8] ? "street" : "address"), 32 & r && (i.store = t[5]), 16 & r && (i.className = t[4]), 64 & r && (i.isError = t[6]), !s && 512 & r && (s = !0, i.isFocused = t[9], ht((() => s = !1))), !l && 1 & r && (l = !0, i.input = t[0], ht((() => l = !1))), a.$set(i);
            const o = {};
            1280 & r && (o.query = t[8] ? t[10].data.street : t[10].data.address), 512 & r && (o.isVisible = t[9]), u.$set(o), !0 === t[8] ? v ? (v.p(t, r), 256 & r && bt(v, 1)) : (v = Oa(t), v.c(), bt(v, 1), v.m(e, null)) : v && (Et(), wt(v, 1, 1, (() => {
                v = null
            })), xt()), (!p || 128 & r && d !== (d = `modal-grid modal-grid-half-gap form-field-address-${t[7]}`)) && N(e, "class", d)
        },
        i(t) {
            p || (bt(f), bt(a.$$.fragment, t), bt(u.$$.fragment, t), bt(v), p = !0)
        },
        o(t) {
            wt(f), wt(a.$$.fragment, t), wt(u.$$.fragment, t), wt(v), p = !1
        },
        d(t) {
            t && B(e), f && f.d(), Bt(a), Bt(u), v && v.d()
        }
    }
}

function Ua(e, n, r) {
    let i, o = t,
        a = () => (o(), o = c(d, (t => r(10, i = t))), d);
    e.$$.on_destroy.push((() => o()));
    let {
        title: s
    } = n, {
        subtitle: l = ""
    } = n, {
        fieldTitle: u
    } = n, {
        fieldClassName: h = ""
    } = n, {
        store: d
    } = n;
    a();
    let p, {
            isError: f = !1
        } = n,
        {
            variant: m = "default"
        } = n,
        {
            shouldDisplayExtraFields: g = !0
        } = n,
        {
            streetInputElement: A
        } = n,
        {
            shouldAllowArbitraryInput: v = !1
        } = n,
        _ = !1;

    function y(t) {
        p = t;
        const {
            address: e,
            coordinates: n
        } = p, [r, i, o, a, s] = e.match(/^(.*), (.*), (.*) (\d+)$/);
        !1 === g && d.updateData("address", e), d.updateData("street", i), d.updateData("zip", s), d.updateData("city", o), d.updateData("state", a), d.updateData("latitude", n[1]), d.updateData("longitude", n[0])
    }
    return e.$$set = t => {
        "title" in t && r(1, s = t.title), "subtitle" in t && r(2, l = t.subtitle), "fieldTitle" in t && r(3, u = t.fieldTitle), "fieldClassName" in t && r(4, h = t.fieldClassName), "store" in t && a(r(5, d = t.store)), "isError" in t && r(6, f = t.isError), "variant" in t && r(7, m = t.variant), "shouldDisplayExtraFields" in t && r(8, g = t.shouldDisplayExtraFields), "streetInputElement" in t && r(0, A = t.streetInputElement), "shouldAllowArbitraryInput" in t && r(13, v = t.shouldAllowArbitraryInput)
    }, [A, s, l, u, h, d, f, m, g, _, i, function (t) {
        y(t.detail.suggestion)
    }, function () {
        !0 !== v && !0 !== g && void 0 !== p && y(p)
    }, v, function (t) {
        _ = t, r(9, _)
    }, function (t) {
        A = t, r(0, A)
    }]
}
class Na extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ua, ka, a, {
            title: 1,
            subtitle: 2,
            fieldTitle: 3,
            fieldClassName: 4,
            store: 5,
            isError: 6,
            variant: 7,
            shouldDisplayExtraFields: 8,
            streetInputElement: 0,
            shouldAllowArbitraryInput: 13
        })
    }
}

function Fa(e) {
    let n, r, i, o, a, s, c, u, h, d, p, f;
    return {
        c() {
            n = L("div"), r = L("div"), i = L("input"), o = O(), a = L("img"), c = O(), u = L("label"), h = P(e[0]), N(i, "id", e[4]), N(i, "name", e[1]), N(i, "type", "checkbox"), i.__value = e[1], Q(i, i.__value), N(i, "class", "svelte-1d7a6bp"), l(a.src, s = "/assets/images/icons/checkmark-grey.svg") || N(a, "src", "/assets/images/icons/checkmark-grey.svg"), N(a, "width", "17"), N(a, "height", "16"), N(a, "alt", "Check mark"), N(a, "class", "svelte-1d7a6bp"), N(r, "class", "common-form-field-checkbox-box svelte-1d7a6bp"), N(u, "class", "type-15 m-type-14 color-text-60"), N(u, "for", e[4]), N(n, "class", d = A(`common-form-field-checkbox common-form-field-checkbox-${e[2]}`) + " svelte-1d7a6bp")
        },
        m(t, s) {
            T(t, n, s), S(n, r), S(r, i), i.checked = e[3], S(r, o), S(r, a), S(n, c), S(n, u), S(u, h), p || (f = U(i, "change", e[7]), p = !0)
        },
        p(t, [e]) {
            2 & e && N(i, "name", t[1]), 2 & e && (i.__value = t[1], Q(i, i.__value)), 8 & e && (i.checked = t[3]), 1 & e && F(h, t[0]), 4 & e && d !== (d = A(`common-form-field-checkbox common-form-field-checkbox-${t[2]}`) + " svelte-1d7a6bp") && N(n, "class", d)
        },
        i: t,
        o: t,
        d(t) {
            t && B(n), p = !1, f()
        }
    }
}

function Qa(t, e, n) {
    let {
        title: r
    } = e, {
        name: i
    } = e, {
        store: o
    } = e, {
        variant: a = "default"
    } = e;
    const s = `checkbox-${Math.random().toString(32).substring(2,5)}`;
    let l, c = !1;
    return o.subscribe((t => {
        t.data[i] !== l && (n(3, c = t.data[i]), n(6, l = c))
    })), t.$$set = t => {
        "title" in t && n(0, r = t.title), "name" in t && n(1, i = t.name), "store" in t && n(5, o = t.store), "variant" in t && n(2, a = t.variant)
    }, t.$$.update = () => {
        106 & t.$$.dirty && c !== l && (o.updateData(i, c), n(6, l = c))
    }, [r, i, a, c, s, o, l, function () {
        c = this.checked, n(3, c)
    }]
}
class $a extends Dt {
    constructor(t) {
        super(), Lt(this, t, Qa, Fa, a, {
            title: 0,
            name: 1,
            store: 5,
            variant: 2
        })
    }
}

function Ga(t, e) {
    return `mailto:customercare@samara.com?subject=${t}&body=Feel free to replace this line with a message, but please leave the information below so we can help you.%0A%0A--------------- Please do not modify the information below this line ---------------%0A%0A${e.map((([t,e])=>e&&`${t}: ${e}`)).filter((t=>!!t)).join("%0A")}`
}

function Ha(t) {
    let e, n, r, i;
    const o = t[2].default,
        a = d(o, t, t[1], null);
    return {
        c() {
            e = L("div"), e.textContent = "Something went wrong.", n = O(), r = L("div"), a && a.c(), N(e, "class", "type-15 m-type-15"), N(r, "class", "type-15 m-type-15")
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), T(t, r, o), a && a.m(r, null), i = !0
        },
        p(t, e) {
            a && a.p && (!i || 2 & e) && m(a, o, t, t[1], i ? f(o, t[1], e, null) : g(t[1]), null)
        },
        i(t) {
            i || (bt(a, t), i = !0)
        },
        o(t) {
            wt(a, t), i = !1
        },
        d(t) {
            t && (B(e), B(n), B(r)), a && a.d(t)
        }
    }
}

function za(t) {
    let e, n, r;
    const i = t[2].default,
        o = d(i, t, t[1], null);
    return {
        c() {
            e = L("div"), n = P("Something went wrong. "), o && o.c(), N(e, "class", "type-15 m-type-15")
        },
        m(t, i) {
            T(t, e, i), S(e, n), o && o.m(e, null), r = !0
        },
        p(t, e) {
            o && o.p && (!r || 2 & e) && m(o, i, t, t[1], r ? f(i, t[1], e, null) : g(t[1]), null)
        },
        i(t) {
            r || (bt(o, t), r = !0)
        },
        o(t) {
            wt(o, t), r = !1
        },
        d(t) {
            t && B(e), o && o.d(t)
        }
    }
}

function Va(t) {
    let e, n, r, i, o, a;
    const s = [za, Ha],
        l = [];

    function c(t, e) {
        return t[0] ? 0 : 1
    }
    return i = c(t), o = l[i] = s[i](t), {
        c() {
            e = L("div"), n = L("div"), r = O(), o.c(), N(n, "class", "spacer-16"), N(e, "class", "error-message color-text-60 type-center")
        },
        m(t, o) {
            T(t, e, o), S(e, n), S(e, r), l[i].m(e, null), a = !0
        },
        p(t, [n]) {
            let r = i;
            i = c(t), i === r ? l[i].p(t, n) : (Et(), wt(l[r], 1, 1, (() => {
                l[r] = null
            })), xt(), o = l[i], o ? o.p(t, n) : (o = l[i] = s[i](t), o.c()), bt(o, 1), o.m(e, null))
        },
        i(t) {
            a || (bt(o), a = !0)
        },
        o(t) {
            wt(o), a = !1
        },
        d(t) {
            t && B(e), l[i].d()
        }
    }
}

function Wa(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e, {
        isSingleLine: o = !1
    } = e;
    return t.$$set = t => {
        "isSingleLine" in t && n(0, o = t.isSingleLine), "$$scope" in t && n(1, i = t.$$scope)
    }, [o, i, r]
}
let ja = class extends Dt {
    constructor(t) {
        super(), Lt(this, t, Wa, Va, a, {
            isSingleLine: 0
        })
    }
};
const Xa = t => ({}),
    qa = t => ({}),
    Ya = t => ({}),
    Ka = t => ({});

function Ja(t) {
    let e, n, r, i, o, a;
    const s = t[3].top,
        l = d(s, t, t[2], Ka),
        c = t[3].bottom,
        u = d(c, t, t[2], qa);
    return {
        c() {
            e = L("div"), l && l.c(), n = O(), r = L("div"), i = O(), o = L("div"), u && u.c(), N(e, "class", "configurator-side-section svelte-16t9dx5"), N(r, "class", "spacer-12"), N(o, "class", "configurator-side-section svelte-16t9dx5")
        },
        m(t, s) {
            T(t, e, s), l && l.m(e, null), T(t, n, s), T(t, r, s), T(t, i, s), T(t, o, s), u && u.m(o, null), a = !0
        },
        p(t, e) {
            l && l.p && (!a || 4 & e) && m(l, s, t, t[2], a ? f(s, t[2], e, Ya) : g(t[2]), Ka), u && u.p && (!a || 4 & e) && m(u, c, t, t[2], a ? f(c, t[2], e, Xa) : g(t[2]), qa)
        },
        i(t) {
            a || (bt(l, t), bt(u, t), a = !0)
        },
        o(t) {
            wt(l, t), wt(u, t), a = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(o)), l && l.d(t), u && u.d(t)
        }
    }
}

function Za(t) {
    let e, n;
    const r = t[3].default,
        i = d(r, t, t[2], null);
    return {
        c() {
            e = L("div"), i && i.c(), N(e, "class", "configurator-side-section svelte-16t9dx5")
        },
        m(t, r) {
            T(t, e, r), i && i.m(e, null), n = !0
        },
        p(t, e) {
            i && i.p && (!n || 4 & e) && m(i, r, t, t[2], n ? f(r, t[2], e, null) : g(t[2]), null)
        },
        i(t) {
            n || (bt(i, t), n = !0)
        },
        o(t) {
            wt(i, t), n = !1
        },
        d(t) {
            t && B(e), i && i.d(t)
        }
    }
}

function ts(t) {
    let e, n, r, i;
    const o = [Za, Ja],
        a = [];

    function s(t, e) {
        return t[1] ? 0 : 1
    }
    return n = s(t), r = a[n] = o[n](t), {
        c() {
            e = L("div"), r.c(), N(e, "class", "configurator-side svelte-16t9dx5"), H(e, "configurator-side-right", t[0]), H(e, "configurator-side-full", t[1])
        },
        m(t, r) {
            T(t, e, r), a[n].m(e, null), i = !0
        },
        p(t, [l]) {
            let c = n;
            n = s(t), n === c ? a[n].p(t, l) : (Et(), wt(a[c], 1, 1, (() => {
                a[c] = null
            })), xt(), r = a[n], r ? r.p(t, l) : (r = a[n] = o[n](t), r.c()), bt(r, 1), r.m(e, null)), (!i || 1 & l) && H(e, "configurator-side-right", t[0]), (!i || 2 & l) && H(e, "configurator-side-full", t[1])
        },
        i(t) {
            i || (bt(r), i = !0)
        },
        o(t) {
            wt(r), i = !1
        },
        d(t) {
            t && B(e), a[n].d()
        }
    }
}

function es(t, e, n) {
    let {
        $$slots: r = {},
        $$scope: i
    } = e, {
        isRightSide: o = !1
    } = e, {
        isFullPage: a = !1
    } = e;
    return t.$$set = t => {
        "isRightSide" in t && n(0, o = t.isRightSide), "isFullPage" in t && n(1, a = t.isFullPage), "$$scope" in t && n(2, i = t.$$scope)
    }, [o, a, i, r]
}
class ns extends Dt {
    constructor(t) {
        super(), Lt(this, t, es, ts, a, {
            isRightSide: 0,
            isFullPage: 1
        })
    }
}
const {
    document: rs
} = C;

function is(t) {
    let e, n, r, i, o, a, s, l, c, u;
    return o = new va({}), {
        c() {
            e = L("link"), n = O(), r = L("div"), i = L("div"), Mt(o.$$.fragment), a = O(), s = L("div"), N(e, "rel", "stylesheet"), N(e, "href", "https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css"), N(i, "class", "configurator-map-loader svelte-piuxj0"), N(s, "class", "configurator-map-container svelte-piuxj0"), N(r, "class", "configurator-map svelte-piuxj0"), H(r, "configurator-map-loading", t[1])
        },
        m(h, d) {
            S(rs.head, e), T(h, n, d), T(h, r, d), S(r, i), Tt(o, i, null), S(r, a), S(r, s), t[8](s), l = !0, c || (u = U(e, "load", t[2]), c = !0)
        },
        p(t, [e]) {
            (!l || 2 & e) && H(r, "configurator-map-loading", t[1])
        },
        i(t) {
            l || (bt(o.$$.fragment, t), l = !0)
        },
        o(t) {
            wt(o.$$.fragment, t), l = !1
        },
        d(i) {
            i && (B(n), B(r)), B(e), Bt(o), t[8](null), c = !1, u()
        }
    }
}

function os(t, e, n) {
    let r, i, o, a, s, l;
    h(t, Ee, (t => n(7, i = t)));
    let c = !0;
    return t.$$.update = () => {
        128 & t.$$.dirty && n(6, r = i.data.latitude && i.data.longitude && [i.data.longitude, i.data.latitude]), 120 & t.$$.dirty && (() => {
            if (s && r) {
                if (!l) {
                    const t = document.createElement("div");
                    t.className = "configurator-map-marker", n(5, l = new a.Marker(t, {
                        offset: [-12, -30]
                    }))
                }
                l.setLngLat(r).addTo(s), s.flyTo({
                    center: r,
                    zoom: 17.25,
                    speed: 8,
                    curve: 1
                })
            } else l && l.remove()
        })()
    }, [o, c, async function () {
            n(3, a = await import("./mapbox-gl-C-aflYNn.js").then((function (t) {
                return t.m
            }))), n(4, s = new a.Map({
                container: o,
                center: r || [-115, 55],
                zoom: 1.5,
                accessToken: process.env.MAPBOX_ACCESS_TOKEN,
                style: "mapbox://styles/mapbox/outdoors-v11"
            })), s.scrollZoom.disable(), s.dragRotate.disable(), s.touchZoomRotate.disableRotation(), void 0 === r && s.fitBounds([-126.00014859723211, 30.66518526804218, -111.76246257054694, 43.59040152561951], {
                duration: 0
            }), s.once("idle", (() => {
                n(1, c = !1)
            }))
        }, a, s, l, r, i,
        function (t) {
            ot[t ? "unshift" : "push"]((() => {
                o = t, n(0, o)
            }))
        }]
}
class as extends Dt {
    constructor(t) {
        super(), Lt(this, t, os, is, a, {})
    }
}

function ss(t) {
    let e, n;
    return e = new as({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function ls(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C, I, M, R, D, P, k, F, Q, $, G, z, V, W, j, X, q, Y, K, J, Z, tt, et, nt, rt, it, ot, at, st, lt, ct, ut, ht, dt, pt, ft, mt;
    a = new Fr({
        props: {
            $$slots: {
                description: [hs],
                title: [us]
            },
            $$scope: {
                ctx: t
            }
        }
    }), v = new ma({
        props: {
            title: "First name",
            name: "firstName",
            store: Ee
        }
    }), E = new ma({
        props: {
            title: "Last name",
            name: "lastName",
            store: Ee
        }
    }), M = new ma({
        props: {
            title: "Email address",
            name: "email",
            type: "email",
            store: Ee
        }
    }), F = new ma({
        props: {
            title: "Phone number",
            name: "phone",
            type: "phone",
            store: Ee
        }
    });
    let gt = !0 !== t[1].data.isSubscribed && ds();
    Z = new Na({
        props: {
            fieldTitle: "Address",
            store: Ee,
            isError: !1 === t[0]
        }
    });
    let At = void 0 !== t[0] && ps(t),
        vt = t[3] && gs(t);
    const _t = [_s, vs],
        yt = [];

    function Ct(t, e) {
        return t[2] ? 0 : 1
    }
    return lt = Ct(t), ct = yt[lt] = _t[lt](t), {
        c() {
            e = L("div"), n = L("div"), r = L("div"), i = O(), o = L("div"), Mt(a.$$.fragment), s = O(), l = L("div"), c = L("div"), u = O(), h = L("div"), d = L("h2"), d.textContent = "Enter your contact details", p = O(), f = L("div"), m = O(), g = L("div"), A = L("div"), Mt(v.$$.fragment), _ = O(), y = L("div"), Mt(E.$$.fragment), x = O(), b = L("div"), w = L("div"), C = O(), I = L("div"), Mt(M.$$.fragment), R = O(), D = L("div"), P = O(), k = L("div"), Mt(F.$$.fragment), Q = O(), gt && gt.c(), $ = O(), G = L("div"), z = L("div"), V = O(), W = L("div"), j = L("h2"), j.textContent = "Where do you want Backyard installed?", X = O(), q = L("div"), Y = O(), K = L("div"), J = L("div"), Mt(Z.$$.fragment), tt = O(), At && At.c(), et = O(), nt = L("div"), rt = L("div"), it = L("div"), ot = O(), vt && vt.c(), at = O(), st = L("button"), ct.c(), ht = O(), dt = L("div"), N(r, "class", "spacer-150 m-spacer-80"), N(o, "class", "configurator-section-column svelte-m1arpc"), N(n, "class", "configurator-section"), N(c, "class", "spacer-80 m-spacer-50"), N(d, "class", "type-24-light m-type-18-light"), N(f, "class", "spacer-24 m-spacer-16"), N(A, "class", "modal-grid-column-3"), N(y, "class", "modal-grid-column-3"), N(g, "class", "modal-grid modal-grid-half-gap"), N(w, "class", "spacer-12 m-spacer-8"), N(I, "class", "modal-grid-column-6"), N(D, "class", "spacer-12 m-spacer-8"), N(k, "class", "modal-grid-column-6"), N(b, "class", "modal-grid modal-grid-half-gap"), N(h, "class", "configurator-section-column svelte-m1arpc"), N(l, "class", "configurator-section"), N(z, "class", "spacer-80 m-spacer-50"), N(j, "class", "type-24-light m-type-18-light"), N(q, "class", "spacer-8"), N(J, "class", "modal-grid-column-6"), N(K, "class", "modal-grid modal-grid-half-gap"), N(W, "class", "configurator-section-column svelte-m1arpc"), N(G, "class", "configurator-section"), N(it, "class", "spacer-80 m-spacer-50"), N(st, "class", "button-rounded button-rounded-blue button-submit type-18 m-type-15 svelte-m1arpc"), st.disabled = ut = !t[7], H(st, "button-loading", t[2]), N(rt, "class", "configurator-section-column svelte-m1arpc"), N(nt, "class", "configurator-section"), N(dt, "class", "spacer-150 m-spacer-72"), N(e, "class", "configurator-address-column svelte-m1arpc")
        },
        m(B, L) {
            T(B, e, L), S(e, n), S(n, r), S(n, i), S(n, o), Tt(a, o, null), S(e, s), S(e, l), S(l, c), S(l, u), S(l, h), S(h, d), S(h, p), S(h, f), S(h, m), S(h, g), S(g, A), Tt(v, A, null), S(g, _), S(g, y), Tt(E, y, null), S(h, x), S(h, b), S(b, w), S(b, C), S(b, I), Tt(M, I, null), S(b, R), S(b, D), S(b, P), S(b, k), Tt(F, k, null), S(h, Q), gt && gt.m(h, null), S(e, $), S(e, G), S(G, z), S(G, V), S(G, W), S(W, j), S(W, X), S(W, q), S(W, Y), S(W, K), S(K, J), Tt(Z, J, null), S(e, tt), At && At.m(e, null), S(e, et), S(e, nt), S(nt, rt), S(rt, it), S(rt, ot), vt && vt.m(rt, null), S(rt, at), S(rt, st), yt[lt].m(st, null), S(e, ht), S(e, dt), pt = !0, ft || (mt = U(st, "click", t[8]), ft = !0)
        },
        p(t, n) {
            const r = {};
            4096 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), a.$set(r), !0 !== t[1].data.isSubscribed ? gt ? 2 & n && bt(gt, 1) : (gt = ds(), gt.c(), bt(gt, 1), gt.m(h, null)) : gt && (Et(), wt(gt, 1, 1, (() => {
                gt = null
            })), xt());
            const i = {};
            1 & n && (i.isError = !1 === t[0]), Z.$set(i), void 0 !== t[0] ? At ? At.p(t, n) : (At = ps(t), At.c(), At.m(e, et)) : At && (At.d(1), At = null), t[3] ? vt ? (vt.p(t, n), 8 & n && bt(vt, 1)) : (vt = gs(t), vt.c(), bt(vt, 1), vt.m(rt, at)) : vt && (Et(), wt(vt, 1, 1, (() => {
                vt = null
            })), xt());
            let o = lt;
            lt = Ct(t), lt === o ? yt[lt].p(t, n) : (Et(), wt(yt[o], 1, 1, (() => {
                yt[o] = null
            })), xt(), ct = yt[lt], ct ? ct.p(t, n) : (ct = yt[lt] = _t[lt](t), ct.c()), bt(ct, 1), ct.m(st, null)), (!pt || 128 & n && ut !== (ut = !t[7])) && (st.disabled = ut), (!pt || 4 & n) && H(st, "button-loading", t[2])
        },
        i(t) {
            pt || (bt(a.$$.fragment, t), bt(v.$$.fragment, t), bt(E.$$.fragment, t), bt(M.$$.fragment, t), bt(F.$$.fragment, t), bt(gt), bt(Z.$$.fragment, t), bt(vt), bt(ct), pt = !0)
        },
        o(t) {
            wt(a.$$.fragment, t), wt(v.$$.fragment, t), wt(E.$$.fragment, t), wt(M.$$.fragment, t), wt(F.$$.fragment, t), wt(gt), wt(Z.$$.fragment, t), wt(vt), wt(ct), pt = !1
        },
        d(t) {
            t && B(e), Bt(a), Bt(v), Bt(E), Bt(M), Bt(F), gt && gt.d(), Bt(Z), At && At.d(), vt && vt.d(), yt[lt].d(), ft = !1, mt()
        }
    }
}

function cs(e) {
    let n, r, i, o, a, s, l, c, u, h, d, p, f, m = e[1].data.zip + "";
    return {
        c() {
            n = L("div"), r = L("div"), i = L("div"), o = L("h1"), o.textContent = "You’re on the list.", a = O(), s = L("div"), l = O(), c = L("p"), u = P("We’ll let you know when Backyard"), h = L("br"), d = P("\n\t\t\t\t\t\tis available in "), p = P(m), f = P("."), N(o, "class", "type-36 m-type-30-light"), N(s, "class", "spacer-12"), N(c, "class", "type-24-light m-type-18-light color-text-40"), N(i, "class", "configurator-section-column svelte-m1arpc"), N(r, "class", "configurator-section"), N(n, "class", "configurator-address-column configurator-address-subscribed type-center svelte-m1arpc")
        },
        m(t, e) {
            T(t, n, e), S(n, r), S(r, i), S(i, o), S(i, a), S(i, s), S(i, l), S(i, c), S(c, u), S(c, h), S(c, d), S(c, p), S(c, f)
        },
        p(t, e) {
            2 & e && m !== (m = t[1].data.zip + "") && F(p, m)
        },
        i: t,
        o: t,
        d(t) {
            t && B(n)
        }
    }
}

function us(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Confirm availability", N(n, "slot", "title")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function hs(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Share your address to verify availability and refine\n\t\t\t\t\t\t\tyour installation estimate.", N(n, "slot", "description")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function ds(t) {
    let e, n, r, i, o;
    return i = new $a({
        props: {
            title: "Send me general updates about Samara",
            name: "shouldSubscribe",
            store: Ee
        }
    }), {
        c() {
            e = L("div"), n = L("div"), r = O(), Mt(i.$$.fragment), N(n, "class", "spacer-24"), N(e, "class", "modal-grid-column-6")
        },
        m(t, a) {
            T(t, e, a), S(e, n), S(e, r), Tt(i, e, null), o = !0
        },
        i(t) {
            o || (bt(i.$$.fragment, t), o = !0)
        },
        o(t) {
            wt(i.$$.fragment, t), o = !1
        },
        d(t) {
            t && B(e), Bt(i)
        }
    }
}

function ps(t) {
    let e, n, r, i, o, a, s, l = !1 === t[0] && fs(),
        c = t[5] && ms(t);
    return {
        c() {
            e = L("div"), n = L("div"), r = O(), i = L("div"), o = L("div"), l && l.c(), a = O(), s = L("div"), c && c.c(), N(n, "class", "spacer-32"), N(o, "class", "configurator-address-status-text svelte-m1arpc"), N(s, "class", "configurator-address-status-map svelte-m1arpc"), N(i, "class", "configurator-section-column configurator-address-status type-center m-type-left svelte-m1arpc"), N(e, "class", "configurator-section")
        },
        m(t, u) {
            T(t, e, u), S(e, n), S(e, r), S(e, i), S(i, o), l && l.m(o, null), S(i, a), S(i, s), c && c.m(s, null)
        },
        p(t, e) {
            !1 === t[0] ? l || (l = fs(), l.c(), l.m(o, null)) : l && (l.d(1), l = null), t[5] ? c ? c.p(t, e) : (c = ms(t), c.c(), c.m(s, null)) : c && (c.d(1), c = null)
        },
        d(t) {
            t && B(e), l && l.d(), c && c.d()
        }
    }
}

function fs(t) {
    let e, n, r, i, o;
    return {
        c() {
            e = L("h2"), e.textContent = "Sorry, we're not available in your\n\t\t\t\t\t\t\t\t\tarea... yet.", n = O(), r = L("div"), i = O(), o = L("div"), o.textContent = "But we can notify you when Backyard comes\n\t\t\t\t\t\t\t\t\tto your area.", N(e, "class", "type-18 m-type-18-light color-red"), N(r, "class", "spacer-8 m-spacer-4"), N(o, "class", "type-16 m-type-14 type-light color-text-40")
        },
        m(t, a) {
            T(t, e, a), T(t, n, a), T(t, r, a), T(t, i, a), T(t, o, a)
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(o))
        }
    }
}

function ms(t) {
    let e, n, r, i, o;
    return {
        c() {
            e = L("img"), r = O(), i = L("img"), N(e, "class", "configurator-address-status-map-pin svelte-m1arpc"), l(e.src, n = "/assets/images/icons/pin.svg") || N(e, "src", "/assets/images/icons/pin.svg"), N(e, "width", "15"), N(e, "height", "18"), N(e, "alt", "Pin"), l(i.src, o = t[5]) || N(i, "src", o), N(i, "width", "100"), N(i, "height", "100"), N(i, "alt", "Map"), N(i, "class", "configurator-address-status-map-image")
        },
        m(t, n) {
            T(t, e, n), T(t, r, n), T(t, i, n)
        },
        p(t, e) {
            32 & e && !l(i.src, o = t[5]) && N(i, "src", o)
        },
        d(t) {
            t && (B(e), B(r), B(i))
        }
    }
}

function gs(t) {
    let e, n, r, i;
    return e = new ja({
        props: {
            $$slots: {
                default: [As]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment), n = O(), r = L("div"), N(r, "class", "spacer-24")
        },
        m(t, o) {
            Tt(e, t, o), T(t, n, o), T(t, r, o), i = !0
        },
        p(t, n) {
            const r = {};
            4160 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            i || (bt(e.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(n), B(r)), Bt(e, t)
        }
    }
}

function As(t) {
    let e, n, r;
    return {
        c() {
            e = L("a"), n = P("Click here"), r = P(" to get in touch\n\t\t\t\t\t\t\tvia email."), N(e, "href", t[6])
        },
        m(t, i) {
            T(t, e, i), S(e, n), T(t, r, i)
        },
        p(t, n) {
            64 & n && N(e, "href", t[6])
        },
        d(t) {
            t && (B(e), B(r))
        }
    }
}

function vs(e) {
    let n, r, i;

    function o(t, e) {
        return !1 === t[0] ? Es : ys
    }
    let a = o(e),
        s = a(e);
    return {
        c() {
            s.c(), n = O(), r = L("img"), l(r.src, i = e[7] ? "/assets/images/icons/arrow-right-white.svg" : "/assets/images/icons/arrow-right-black.svg") || N(r, "src", i), N(r, "width", "17"), N(r, "height", "12"), N(r, "alt", "→"), N(r, "class", "svelte-m1arpc")
        },
        m(t, e) {
            s.m(t, e), T(t, n, e), T(t, r, e)
        },
        p(t, e) {
            a !== (a = o(t)) && (s.d(1), s = a(t), s && (s.c(), s.m(n.parentNode, n))), 128 & e && !l(r.src, i = t[7] ? "/assets/images/icons/arrow-right-white.svg" : "/assets/images/icons/arrow-right-black.svg") && N(r, "src", i)
        },
        i: t,
        o: t,
        d(t) {
            t && (B(n), B(r)), s.d(t)
        }
    }
}

function _s(e) {
    let n, r;
    return n = new va({
        props: {
            variant: "light"
        }
    }), {
        c() {
            Mt(n.$$.fragment)
        },
        m(t, e) {
            Tt(n, t, e), r = !0
        },
        p: t,
        i(t) {
            r || (bt(n.$$.fragment, t), r = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), r = !1
        },
        d(t) {
            Bt(n, t)
        }
    }
}

function ys(t) {
    let e;
    return {
        c() {
            e = P("Continue")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Es(t) {
    let e;
    return {
        c() {
            e = P("Notify me")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function xs(t) {
    let e, n, r, i, o, a;
    n = new ns({
        props: {
            isFullPage: !0,
            $$slots: {
                default: [ss]
            },
            $$scope: {
                ctx: t
            }
        }
    });
    const s = [cs, ls],
        l = [];

    function c(t, e) {
        return t[4] ? 0 : 1
    }
    return i = c(t), o = l[i] = s[i](t), {
        c() {
            e = L("div"), Mt(n.$$.fragment), r = O(), o.c(), N(e, "class", "configurator-address svelte-m1arpc"), H(e, "configurator-address-loading", t[2])
        },
        m(t, o) {
            T(t, e, o), Tt(n, e, null), S(e, r), l[i].m(e, null), a = !0
        },
        p(t, [r]) {
            const u = {};
            4096 & r && (u.$$scope = {
                dirty: r,
                ctx: t
            }), n.$set(u);
            let h = i;
            i = c(t), i === h ? l[i].p(t, r) : (Et(), wt(l[h], 1, 1, (() => {
                l[h] = null
            })), xt(), o = l[i], o ? o.p(t, r) : (o = l[i] = s[i](t), o.c()), bt(o, 1), o.m(e, null)), (!a || 4 & r) && H(e, "configurator-address-loading", t[2])
        },
        i(t) {
            a || (bt(n.$$.fragment, t), bt(o), a = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), wt(o), a = !1
        },
        d(t) {
            t && B(e), Bt(n), l[i].d()
        }
    }
}

function bs(t, e, n) {
    let r, i, o, a, s, l, c;
    h(t, Ee, (t => n(1, l = t))), h(t, Te, (t => n(10, c = t)));
    let u = !1,
        d = !1,
        p = !1;
    return t.$$.update = () => {
        2 & t.$$.dirty && n(0, r = (() => {
            if (void 0 === l.data.zip || !0 !== Ae.test(l.data.zip)) return;
            const t = l.data.zip.split("-").at(0);
            return aa.network.includes(t)
        })()), 2 & t.$$.dirty && n(7, i = function ({
            data: t
        }) {
            const e = !!t.firstName,
                n = !!t.lastName,
                r = !!t.email && ge.test(t.email),
                i = !!t.phone && ve.test(t.phone),
                o = !!t.address,
                a = !!t.city,
                s = !!t.zip && Ae.test(t.zip);
            return e && n && r && i && o && a && s
        }(l)), 2 & t.$$.dirty && n(6, o = Ga("Site error", [
            ["Request type", "Market expansion"],
            ["ZIP code", l.data.zip]
        ])), 2 & t.$$.dirty && n(5, a = l.data.longitude && l.data.latitude && `https://api.mapbox.com/styles/v1/mapbox/outdoors-v11/static/${l.data.longitude},${l.data.latitude},18,0/200x200?access_token=${process.env.MAPBOX_ACCESS_TOKEN}&attribution=false&logo=false`), 3 & t.$$.dirty && n(9, s = void 0 === l.data.zip ? "socal" : aa.highInstallationCost.includes(l.data.zip) ? "nocal" : r ? "socal" : "rest"), 512 & t.$$.dirty && s && ne.select("region", s), 2 & t.$$.dirty && (async () => {
            if (l.data.address && void 0 === l.data.latitude) {
                const t = await API.completeAddress(l.data.address),
                    {
                        suggestions: e
                    } = await t.json();
                e.length > 0 && (Ee.updateData("latitude", e.at(0).coordinates.at(1)), Ee.updateData("longitude", e.at(0).coordinates.at(0)))
            }
        })()
    }, [r, l, u, d, p, a, o, i, function () {
        l.data.shouldSubscribe && (API.subscribe(l.data.email, ["configurator"]), Ee.updateData("isSubscribed", void 0)), r ? bi.next() : async function () {
            n(2, u = !0);
            try {
                if (!0 !== (await API.expand(l.data.zip, l.data.email, "configurator", c.id, l.data.address)).ok) throw new ja("failed to subscribe for availability notification");
                n(4, p = !0)
            } catch (t) {
                n(3, d = !0), console.error(t)
            }
            n(2, u = !1)
        }()
    }, s]
}
class ws extends Dt {
    constructor(t) {
        super(), Lt(this, t, bs, xs, a, {})
    }
}

function Cs(e) {
    let n, r, i;
    return {
        c() {
            n = L("button"), n.innerHTML = '<svg width="8" height="13" viewBox="0 0 8 13" fill="none" xmlns="http://www.w3.org/2000/svg" class="svelte-t01nv5"><path d="M0.271973 6.48193C0.271973 6.35498 0.293945 6.23779 0.337891 6.13037C0.386719 6.02295 0.459961 5.92041 0.557617 5.82275L6.26318 0.241699C6.4292 0.0805664 6.62939 0 6.86377 0C7.0249 0 7.16895 0.0390625 7.2959 0.117188C7.42773 0.19043 7.53271 0.290527 7.61084 0.41748C7.68896 0.544434 7.72803 0.688477 7.72803 0.849609C7.72803 1.0791 7.6377 1.28418 7.45703 1.46484L2.31543 6.48193L7.45703 11.499C7.6377 11.6797 7.72803 11.8872 7.72803 12.1216C7.72803 12.2778 7.68896 12.4194 7.61084 12.5464C7.53271 12.6782 7.42773 12.7808 7.2959 12.854C7.16895 12.9321 7.0249 12.9712 6.86377 12.9712C6.62939 12.9712 6.4292 12.8882 6.26318 12.7222L0.557617 7.14111C0.459961 7.04346 0.386719 6.94092 0.337891 6.8335C0.293945 6.72607 0.271973 6.60889 0.271973 6.48193Z" fill="black" fill-opacity="0.6"></path></svg>\n\tBack', N(n, "class", "button-rounded button-configurator type-15 m-type-12 svelte-t01nv5"), H(n, "configurator-back-button-hidden", e[0])
        },
        m(t, o) {
            T(t, n, o), r || (i = U(n, "click", e[1]), r = !0)
        },
        p(t, [e]) {
            1 & e && H(n, "configurator-back-button-hidden", t[0])
        },
        i: t,
        o: t,
        d(t) {
            t && B(n), r = !1, i()
        }
    }
}

function Ss(t, e, n) {
    let r, i;
    return h(t, bi, (t => n(2, i = t))), t.$$.update = () => {
        4 & t.$$.dirty && n(0, r = i.page === xi.options || i.page === xi.confirmation)
    }, [r, function () {
        bi.previous()
    }, i]
}
class Is extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ss, Cs, a, {})
    }
}

function Ms(t, e, n) {
    const r = t.slice();
    return r[15] = e[n], r
}

function Ts(t, e, n) {
    const r = t.slice();
    return r[15] = e[n], r
}

function Bs(t) {
    let e;
    return {
        c() {
            e = P("Backyard")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Rs(t) {
    let e;
    return {
        c() {
            e = P("Backyard")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Ls(e) {
    let n, r, i;
    return {
        c() {
            n = L("button"), n.textContent = "Edit", N(n, "class", "button-rounded button-configurator type-15 m-type-12 svelte-15d3j5i")
        },
        m(t, o) {
            T(t, n, o), r || (i = U(n, "click", e[9]), r = !0)
        },
        p: t,
        d(t) {
            t && B(n), r = !1, i()
        }
    }
}

function Ds(t) {
    let e, n;
    return {
        c() {
            e = L("div"), N(e, "class", "configurator-reservation-color-swatch svelte-15d3j5i"), N(e, "style", n = `background-color: #${t[8].hex.toString(16)}`)
        },
        m(t, n) {
            T(t, e, n)
        },
        p(t, r) {
            256 & r && n !== (n = `background-color: #${t[8].hex.toString(16)}`) && N(e, "style", n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Ps(t) {
    let e, n;

    function r(t, e) {
        return "floor-natural-oak" === t[2].floor ? ks : "floor-dark-oak" === t[2].floor ? Os : void 0
    }
    let i = r(t),
        o = i && i(t);
    return {
        c() {
            e = L("div"), o && o.c(), N(e, "class", "configurator-reservation-color-swatch svelte-15d3j5i"), N(e, "style", n = `background-color: #${t[6].hex.toString(16)}`)
        },
        m(t, n) {
            T(t, e, n), o && o.m(e, null)
        },
        p(t, a) {
            i !== (i = r(t)) && (o && o.d(1), o = i && i(t), o && (o.c(), o.m(e, null))), 64 & a && n !== (n = `background-color: #${t[6].hex.toString(16)}`) && N(e, "style", n)
        },
        d(t) {
            t && B(e), o && o.d()
        }
    }
}

function Os(t) {
    let e, n;
    return {
        c() {
            e = L("img"), l(e.src, n = "/assets/images/configure/floor-dark-stained-oak.jpg") || N(e, "src", "/assets/images/configure/floor-dark-stained-oak.jpg"), N(e, "alt", "Dark oak floor texture"), N(e, "width", "100%"), N(e, "height", "100%"), $(e, "object-fit", "cover"), $(e, "position", "absolute"), $(e, "top", "0"), $(e, "left", "0")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function ks(t) {
    let e, n;
    return {
        c() {
            e = L("img"), l(e.src, n = "/assets/images/configure/floor-natural-oak.jpg") || N(e, "src", "/assets/images/configure/floor-natural-oak.jpg"), N(e, "alt", "Natural oak floor texture"), N(e, "width", "100%"), N(e, "height", "100%"), $(e, "object-fit", "cover"), $(e, "position", "absolute"), $(e, "top", "0"), $(e, "left", "0")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Us(t) {
    let e, n;
    return {
        c() {
            e = L("img"), l(e.src, n = "/assets/images/configure/kitchen-cabinet-finish-natural-oak.jpg") || N(e, "src", "/assets/images/configure/kitchen-cabinet-finish-natural-oak.jpg"), N(e, "alt", "Natural oak kitchen cabinet finish texture"), N(e, "width", "100%"), N(e, "height", "100%"), $(e, "object-fit", "cover"), $(e, "position", "absolute"), $(e, "top", "0"), $(e, "left", "0")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Ns(t) {
    let e, n;
    return {
        c() {
            e = L("img"), l(e.src, n = "/assets/images/configure/kitchen-cabinet-finish-bone-white.jpg") || N(e, "src", "/assets/images/configure/kitchen-cabinet-finish-bone-white.jpg"), N(e, "alt", "Bone white kitchen cabinet finish texture"), N(e, "width", "100%"), N(e, "height", "100%"), $(e, "object-fit", "cover"), $(e, "position", "absolute"), $(e, "top", "0"), $(e, "left", "0")
        },
        m(t, n) {
            T(t, e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Fs(t) {
    let e, n, r, i = t[15] + "";
    return {
        c() {
            e = L("div"), n = O(), r = P(i), N(e, "class", "spacer-8")
        },
        m(t, i) {
            T(t, e, i), T(t, n, i), T(t, r, i)
        },
        p(t, e) {
            16 & e && i !== (i = t[15] + "") && F(r, i)
        },
        d(t) {
            t && (B(e), B(n), B(r))
        }
    }
}

function Qs(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p = St(t[3]),
        f = [];
    for (let e = 0; e < p.length; e += 1) f[e] = $s(Ms(t, p, e));
    return {
        c() {
            e = L("div"), n = O(), r = L("hr"), i = O(), o = L("div"), a = O(), s = L("div"), l = L("div"), c = L("div"), c.textContent = "Optional upgrades", u = O(), h = L("div"), d = O();
            for (let t = 0; t < f.length; t += 1) f[t].c();
            N(e, "class", "spacer-24 m-spacer-16"), N(r, "class", "divider"), N(o, "class", "spacer-24 m-spacer-16"), N(c, "class", "type-14 m-type-12 color-text-60"), N(h, "class", "spacer-4"), N(l, "class", "column-12 m-column-6"), N(s, "class", "modern-grid modern-grid-full configurator-reservation-color")
        },
        m(t, p) {
            T(t, e, p), T(t, n, p), T(t, r, p), T(t, i, p), T(t, o, p), T(t, a, p), T(t, s, p), S(s, l), S(l, c), S(l, u), S(l, h), S(l, d);
            for (let t = 0; t < f.length; t += 1) f[t] && f[t].m(l, null)
        },
        p(t, e) {
            if (8 & e) {
                let n;
                for (p = St(t[3]), n = 0; n < p.length; n += 1) {
                    const r = Ms(t, p, n);
                    f[n] ? f[n].p(r, e) : (f[n] = $s(r), f[n].c(), f[n].m(l, null))
                }
                for (; n < f.length; n += 1) f[n].d(1);
                f.length = p.length
            }
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(o), B(a), B(s)), R(f, t)
        }
    }
}

function $s(t) {
    let e, n, r, i = t[15] + "";
    return {
        c() {
            e = L("div"), n = P("+ "), r = P(i), N(e, "class", "type-18 m-type-15")
        },
        m(t, i) {
            T(t, e, i), S(e, n), S(e, r)
        },
        p(t, e) {
            8 & e && i !== (i = t[15] + "") && F(r, i)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Gs(t) {
    let e, n, r, i, o, a, s, l, c, u, h, p, A, v, _, y, E, x, b, w, C, I, M, D, U, Q, $, G, H, z, V, W, j, X, q, Y, K, J, Z, tt, et, nt, rt, it, ot, at, st, lt, ct, ut, ht, dt, pt, ft, mt, gt, At, vt, _t, yt, Et, xt, Ct, It, Mt, Tt, Bt, Rt, Lt, Dt, Pt, Ot, kt, Ut, Nt, Ft, Qt, $t, Gt, Ht, zt, Vt, Wt, jt, Xt, qt, Yt, Kt, Zt, te, ee, ne, re, ie, oe, ae, se, le, ce, ue, he, de = !0 === t[2].layout.startsWith("xl"),
        pe = Jt("layout", t[2].layout).display.title + "",
        fe = !1 === t[2].layout.startsWith("xl"),
        me = Jt("layout", t[2].layout).display.subtitle + "",
        ge = Jt("cladding", t[2].cladding).display.title + "",
        Ae = Jt("color", t[2].color).display.title + "",
        ve = Jt("roof", t[2].roof).display.title + "",
        _e = Jt("floor", t[2].floor).display.title + "",
        ye = Jt("kitchen-cabinet-finish", t[2]["kitchen-cabinet-finish"]).display.title + "",
        Ee = Jt("solar", t[2].solar).display.summaryLabel + "";
    const xe = t[14].default,
        be = d(xe, t, t[13], null);
    let we = de && Bs(),
        Ce = fe && Rs(),
        Se = t[0] && Ls(t),
        Ie = t[8] && Ds(t),
        Me = t[8] && Ps(t);

    function Te(t, e) {
        return "kitchen-cabinet-bone-white" === t[2]["kitchen-cabinet-finish"] ? Ns : "kitchen-cabinet-natural-oak" === t[2]["kitchen-cabinet-finish"] ? Us : void 0
    }
    let Be = Te(t),
        Re = Be && Be(t),
        Le = St(t[4]),
        De = [];
    for (let e = 0; e < Le.length; e += 1) De[e] = Fs(Ts(t, Le, e));
    let Pe = t[1].length > 0 && Qs(t);
    return {
        c() {
            e = L("h2"), e.textContent = "Your configuration", n = O(), be && be.c(), r = O(), i = L("div"), o = O(), a = L("hr"), s = O(), l = L("div"), c = O(), u = L("div"), h = L("div"), we && we.c(), p = O(), A = P(pe), v = O(), Ce && Ce.c(), _ = O(), y = L("div"), E = P(me), x = L("br"), b = O(), w = P(ge), C = P(" cladding"), I = O(), Se && Se.c(), M = O(), D = L("div"), U = O(), Q = L("hr"), $ = O(), G = L("div"), H = O(), z = L("div"), V = L("div"), W = L("div"), W.textContent = "Cladding color", j = O(), X = L("div"), q = O(), Y = L("div"), K = P(Ae), J = O(), Ie && Ie.c(), Z = O(), tt = L("div"), et = L("div"), et.textContent = "Roof color", nt = O(), rt = L("div"), it = O(), ot = L("div"), at = P(ve), st = O(), lt = L("div"), ut = O(), ht = L("div"), dt = O(), pt = L("hr"), ft = O(), mt = L("div"), gt = O(), At = L("div"), vt = L("div"), _t = L("div"), _t.textContent = "Floor color", yt = O(), Et = L("div"), xt = O(), Ct = L("div"), It = P(_e), Mt = O(), Me && Me.c(), Tt = O(), Bt = L("div"), Rt = L("div"), Rt.textContent = "Kitchen finish", Lt = O(), Dt = L("div"), Pt = O(), Ot = L("div"), kt = P(ye), Ut = O(), Nt = L("div"), Re && Re.c(), Qt = O(), $t = L("div"), Gt = O(), Ht = L("hr"), zt = O(), Vt = L("div"), Wt = O(), jt = L("div"), Xt = L("div"), qt = L("div"), qt.textContent = "Windows/doors", Yt = O(), Kt = L("div"), Zt = O(), te = L("div");
            for (let t = 0; t < De.length; t += 1) De[t].c();
            ee = O(), ne = L("div"), re = L("div"), re.textContent = "Solar roof", ie = O(), oe = L("div"), ae = O(), se = L("div"), le = P(Ee), ce = O(), Pe && Pe.c(), ue = k(), N(e, "class", "type-24-light m-type-18-light"), N(i, "class", "spacer-32 m-spacer-16"), N(a, "class", "divider"), N(l, "class", "spacer-32 m-spacer-16"), N(h, "class", "type-18 m-type-15"), N(y, "class", "type-18 m-type-15 color-text-60 type-light"), N(u, "class", "configurator-reservation-editable svelte-15d3j5i"), N(D, "class", "spacer-24 m-spacer-16"), N(Q, "class", "divider"), N(G, "class", "spacer-24 m-spacer-16"), N(W, "class", "type-14 m-type-12 color-text-60"), N(X, "class", "spacer-4"), N(Y, "class", "type-18 m-type-15"), N(V, "class", "column-6 m-column-3 svelte-15d3j5i"), N(et, "class", "type-14 m-type-12 color-text-60"), N(rt, "class", "spacer-4"), N(ot, "class", "type-18 m-type-15"), N(lt, "class", "configurator-reservation-color-swatch svelte-15d3j5i"), N(lt, "style", ct = `background-color: #${t[7].hex.toString(16)}`), N(tt, "class", "column-6 m-column-3 svelte-15d3j5i"), N(z, "class", "modern-grid modern-grid-full configurator-reservation-color svelte-15d3j5i"), N(ht, "class", "spacer-24 m-spacer-16"), N(pt, "class", "divider"), N(mt, "class", "spacer-24 m-spacer-16"), N(_t, "class", "type-14 m-type-12 color-text-60"), N(Et, "class", "spacer-4"), N(Ct, "class", "type-18 m-type-15"), N(vt, "class", "column-6 m-column-3 svelte-15d3j5i"), N(Rt, "class", "type-14 m-type-12 color-text-60"), N(Dt, "class", "spacer-4"), N(Ot, "class", "type-18 m-type-15"), N(Nt, "class", "configurator-reservation-color-swatch svelte-15d3j5i"), N(Nt, "style", Ft = `background-color: #${t[5].hex.toString(16)}`), N(Bt, "class", "column-6 m-column-3 svelte-15d3j5i"), N(At, "class", "modern-grid modern-grid-full configurator-reservation-color svelte-15d3j5i"), N($t, "class", "spacer-24 m-spacer-16"), N(Ht, "class", "divider"), N(Vt, "class", "spacer-24 m-spacer-16"), N(qt, "class", "type-14 m-type-12 color-text-60"), N(Kt, "class", "spacer-4"), N(te, "class", "type-18 m-type-15"), N(Xt, "class", "column-6 m-column-3 svelte-15d3j5i"), N(re, "class", "type-14 m-type-12 color-text-60"), N(oe, "class", "spacer-4"), N(se, "class", "type-18 m-type-15"), N(ne, "class", "column-6 m-column-3 svelte-15d3j5i"), N(jt, "class", "modern-grid modern-grid-full configurator-reservation-color svelte-15d3j5i")
        },
        m(t, d) {
            T(t, e, d), T(t, n, d), be && be.m(t, d), T(t, r, d), T(t, i, d), T(t, o, d), T(t, a, d), T(t, s, d), T(t, l, d), T(t, c, d), T(t, u, d), S(u, h), we && we.m(h, null), S(h, p), S(h, A), S(h, v), Ce && Ce.m(h, null), S(u, _), S(u, y), S(y, E), S(y, x), S(y, b), S(y, w), S(y, C), S(u, I), Se && Se.m(u, null), T(t, M, d), T(t, D, d), T(t, U, d), T(t, Q, d), T(t, $, d), T(t, G, d), T(t, H, d), T(t, z, d), S(z, V), S(V, W), S(V, j), S(V, X), S(V, q), S(V, Y), S(Y, K), S(V, J), Ie && Ie.m(V, null), S(z, Z), S(z, tt), S(tt, et), S(tt, nt), S(tt, rt), S(tt, it), S(tt, ot), S(ot, at), S(tt, st), S(tt, lt), T(t, ut, d), T(t, ht, d), T(t, dt, d), T(t, pt, d), T(t, ft, d), T(t, mt, d), T(t, gt, d), T(t, At, d), S(At, vt), S(vt, _t), S(vt, yt), S(vt, Et), S(vt, xt), S(vt, Ct), S(Ct, It), S(vt, Mt), Me && Me.m(vt, null), S(At, Tt), S(At, Bt), S(Bt, Rt), S(Bt, Lt), S(Bt, Dt), S(Bt, Pt), S(Bt, Ot), S(Ot, kt), S(Bt, Ut), S(Bt, Nt), Re && Re.m(Nt, null), T(t, Qt, d), T(t, $t, d), T(t, Gt, d), T(t, Ht, d), T(t, zt, d), T(t, Vt, d), T(t, Wt, d), T(t, jt, d), S(jt, Xt), S(Xt, qt), S(Xt, Yt), S(Xt, Kt), S(Xt, Zt), S(Xt, te);
            for (let t = 0; t < De.length; t += 1) De[t] && De[t].m(te, null);
            S(jt, ee), S(jt, ne), S(ne, re), S(ne, ie), S(ne, oe), S(ne, ae), S(ne, se), S(se, le), T(t, ce, d), Pe && Pe.m(t, d), T(t, ue, d), he = !0
        },
        p(t, [e]) {
            if (be && be.p && (!he || 8192 & e) && m(be, xe, t, t[13], he ? f(xe, t[13], e, null) : g(t[13]), null), 4 & e && (de = !0 === t[2].layout.startsWith("xl")), de ? we || (we = Bs(), we.c(), we.m(h, p)) : we && (we.d(1), we = null), (!he || 4 & e) && pe !== (pe = Jt("layout", t[2].layout).display.title + "") && F(A, pe), 4 & e && (fe = !1 === t[2].layout.startsWith("xl")), fe ? Ce || (Ce = Rs(), Ce.c(), Ce.m(h, null)) : Ce && (Ce.d(1), Ce = null), (!he || 4 & e) && me !== (me = Jt("layout", t[2].layout).display.subtitle + "") && F(E, me), (!he || 4 & e) && ge !== (ge = Jt("cladding", t[2].cladding).display.title + "") && F(w, ge), t[0] ? Se ? Se.p(t, e) : (Se = Ls(t), Se.c(), Se.m(u, null)) : Se && (Se.d(1), Se = null), (!he || 4 & e) && Ae !== (Ae = Jt("color", t[2].color).display.title + "") && F(K, Ae), t[8] ? Ie ? Ie.p(t, e) : (Ie = Ds(t), Ie.c(), Ie.m(V, null)) : Ie && (Ie.d(1), Ie = null), (!he || 4 & e) && ve !== (ve = Jt("roof", t[2].roof).display.title + "") && F(at, ve), (!he || 128 & e && ct !== (ct = `background-color: #${t[7].hex.toString(16)}`)) && N(lt, "style", ct), (!he || 4 & e) && _e !== (_e = Jt("floor", t[2].floor).display.title + "") && F(It, _e), t[8] ? Me ? Me.p(t, e) : (Me = Ps(t), Me.c(), Me.m(vt, null)) : Me && (Me.d(1), Me = null), (!he || 4 & e) && ye !== (ye = Jt("kitchen-cabinet-finish", t[2]["kitchen-cabinet-finish"]).display.title + "") && F(kt, ye), Be !== (Be = Te(t)) && (Re && Re.d(1), Re = Be && Be(t), Re && (Re.c(), Re.m(Nt, null))), (!he || 32 & e && Ft !== (Ft = `background-color: #${t[5].hex.toString(16)}`)) && N(Nt, "style", Ft), 16 & e) {
                let n;
                for (Le = St(t[4]), n = 0; n < Le.length; n += 1) {
                    const r = Ts(t, Le, n);
                    De[n] ? De[n].p(r, e) : (De[n] = Fs(r), De[n].c(), De[n].m(te, null))
                }
                for (; n < De.length; n += 1) De[n].d(1);
                De.length = Le.length
            }(!he || 4 & e) && Ee !== (Ee = Jt("solar", t[2].solar).display.summaryLabel + "") && F(le, Ee), t[1].length > 0 ? Pe ? Pe.p(t, e) : (Pe = Qs(t), Pe.c(), Pe.m(ue.parentNode, ue)) : Pe && (Pe.d(1), Pe = null)
        },
        i(t) {
            he || (bt(be, t), he = !0)
        },
        o(t) {
            wt(be, t), he = !1
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i), B(o), B(a), B(s), B(l), B(c), B(u), B(M), B(D), B(U), B(Q), B($), B(G), B(H), B(z), B(ut), B(ht), B(dt), B(pt), B(ft), B(mt), B(gt), B(At), B(Qt), B($t), B(Gt), B(Ht), B(zt), B(Vt), B(Wt), B(jt), B(ce), B(ue)), be && be.d(t), we && we.d(), Ce && Ce.d(), Se && Se.d(), Ie && Ie.d(), Me && Me.d(), Re && Re.d(), R(De, t), Pe && Pe.d(t)
        }
    }
}

function Hs(t, e, n) {
    let r, i, o, a, s, l, c, u, d, p, f;
    h(t, ne, (t => n(12, f = t)));
    let {
        $$slots: m = {},
        $$scope: g
    } = e, {
        isEditable: A = !0
    } = e;
    return t.$$set = t => {
        "isEditable" in t && n(0, A = t.isEditable), "$$scope" in t && n(13, g = t.$$scope)
    }, t.$$.update = () => {
        4096 & t.$$.dirty && n(11, r = Zt(f)), 4096 & t.$$.dirty && n(2, i = {
            ...jt,
            ...f
        }), 4 & t.$$.dirty && n(8, o = Xt[i.color]), 4 & t.$$.dirty && n(7, a = Xt[i.roof]), 4 & t.$$.dirty && n(6, s = Xt[i.floor]), 4 & t.$$.dirty && n(5, l = Xt[i["kitchen-cabinet-finish"]]), 2048 & t.$$.dirty && n(10, c = t => r.some((({
            key: e
        }) => e === t))), 1028 & t.$$.dirty && n(4, u = ["entry", "front", "left", "xl-living-room-side", "xl-primary-bedroom-side", "xl-secondary-bedroom-side"].map((t => c(t) && Jt(t, i[t]).display.summaryLabel)).filter((t => !!t))), 4100 & t.$$.dirty && n(1, d = ["kitchen-pantry", "kitchen-layout", "kitchen-cooler", "interior-blinds", "powerwall", "primary-bedroom-wardrobe", "secondary-bedroom-wardrobe"].map((t => {
            if (void 0 !== f[t] && "standard" !== f[t]) {
                const e = Jt(t, i[t]);
                return "primary-bedroom-wardrobe" !== t && "secondary-bedroom-wardrobe" !== t || "full" !== f[t] ? e.display.title : e.display.summaryLabel || e.display.title
            }
            return null
        })).filter((t => !!t))), 2 & t.$$.dirty && n(3, p = d.filter((t => !!t)))
    }, [A, d, i, p, u, l, s, a, o, function () {
        bi.open(xi.options)
    }, c, r, f, g, m]
}
class zs extends Dt {
    constructor(t) {
        super(), Lt(this, t, Hs, Gs, a, {
            isEditable: 0
        })
    }
}

function Vs(t) {
    let e, n;
    return e = new Bi({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Ws(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Get a detailed proposal", N(n, "slot", "title")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function js(e) {
    let n;
    return {
        c() {
            n = L("span"), n.textContent = "Every property is unique. We’ll need to review yours to create a complete\n\t\t\t\t\t\tand accurate proposal.", N(n, "slot", "description")
        },
        m(t, e) {
            T(t, n, e)
        },
        p: t,
        d(t) {
            t && B(n)
        }
    }
}

function Xs(e) {
    let n, r, i;
    return {
        c() {
            n = L("div"), r = O(), i = L("div"), i.textContent = "Review your Backyard below, but think of it as a starting point. You’ll have\n\t\t\t\t\t\tthe opportunity to revise it later.", N(n, "class", "spacer-12 m-spacer-8"), N(i, "class", "type-18 m-type-15 color-text-60 type-light")
        },
        m(t, e) {
            T(t, n, e), T(t, r, e), T(t, i, e)
        },
        p: t,
        d(t) {
            t && (B(n), B(r), B(i))
        }
    }
}

function qs(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C, I, M, R = t[0].data.firstName + "",
        D = t[0].data.lastName + "",
        k = t[0].data.phone + "",
        Q = t[0].data.email + "";
    return {
        c() {
            e = L("div"), n = L("div"), r = O(), i = L("div"), o = L("h2"), o.textContent = "Your contact details", a = O(), s = L("div"), l = O(), c = L("hr"), u = O(), h = L("div"), d = O(), p = L("div"), f = L("div"), m = P(R), g = O(), A = P(D), v = O(), _ = L("div"), y = P(k), E = O(), x = L("div"), b = P(Q), w = O(), C = L("button"), C.textContent = "Edit", N(n, "class", "spacer-80 m-spacer-0"), N(o, "class", "type-24-light m-type-18-light"), N(s, "class", "spacer-24 m-spacer-16"), N(c, "class", "divider"), N(h, "class", "spacer-24 m-spacer-16"), N(f, "class", "type-18 m-type-15"), N(_, "class", "type-18 m-type-15 type-light color-text-60"), N(x, "class", "type-18 m-type-15 type-light color-text-60"), N(C, "class", "button-rounded button-configurator type-15 m-type-12 svelte-ma6brr"), N(p, "class", "configurator-reservation-editable svelte-ma6brr"), N(i, "class", "configurator-section-column svelte-ma6brr"), N(e, "class", "configurator-section")
        },
        m(B, R) {
            T(B, e, R), S(e, n), S(e, r), S(e, i), S(i, o), S(i, a), S(i, s), S(i, l), S(i, c), S(i, u), S(i, h), S(i, d), S(i, p), S(p, f), S(f, m), S(f, g), S(f, A), S(p, v), S(p, _), S(_, y), S(p, E), S(p, x), S(x, b), S(p, w), S(p, C), I || (M = U(C, "click", t[6]), I = !0)
        },
        p(t, e) {
            1 & e && R !== (R = t[0].data.firstName + "") && F(m, R), 1 & e && D !== (D = t[0].data.lastName + "") && F(A, D), 1 & e && k !== (k = t[0].data.phone + "") && F(y, k), 1 & e && Q !== (Q = t[0].data.email + "") && F(b, Q)
        },
        d(t) {
            t && B(e), I = !1, M()
        }
    }
}

function Ys(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A, v;

    function _(t, e) {
        return t[4] ? Js : Ks
    }
    let y = _(t),
        E = y(t);
    return {
        c() {
            e = L("div"), n = L("div"), r = O(), i = L("div"), o = L("h2"), o.textContent = "Your address", a = O(), s = L("div"), l = O(), c = L("hr"), u = O(), h = L("div"), d = O(), p = L("div"), f = L("div"), E.c(), m = O(), g = L("button"), g.textContent = "Edit", N(n, "class", "spacer-80 m-spacer-64"), N(o, "class", "type-24-light m-type-18-light"), N(s, "class", "spacer-24 m-spacer-16"), N(c, "class", "divider"), N(h, "class", "spacer-24 m-spacer-16"), N(f, "class", "type-18 m-type-15"), N(g, "class", "button-rounded button-configurator type-15 m-type-12 svelte-ma6brr"), N(p, "class", "configurator-reservation-editable svelte-ma6brr"), N(i, "class", "configurator-section-column svelte-ma6brr"), N(e, "class", "configurator-section")
        },
        m(_, y) {
            T(_, e, y), S(e, n), S(e, r), S(e, i), S(i, o), S(i, a), S(i, s), S(i, l), S(i, c), S(i, u), S(i, h), S(i, d), S(i, p), S(p, f), E.m(f, null), S(p, m), S(p, g), A || (v = U(g, "click", t[6]), A = !0)
        },
        p(t, e) {
            y === (y = _(t)) && E ? E.p(t, e) : (E.d(1), E = y(t), E && (E.c(), E.m(f, null)))
        },
        d(t) {
            t && B(e), E.d(), A = !1, v()
        }
    }
}

function Ks(t) {
    let e, n = t[0].data.address + "";
    return {
        c() {
            e = P(n)
        },
        m(t, n) {
            T(t, e, n)
        },
        p(t, r) {
            1 & r && n !== (n = t[0].data.address + "") && F(e, n)
        },
        d(t) {
            t && B(e)
        }
    }
}

function Js(t) {
    let e, n, r, i, o = t[4].at(0) + "",
        a = `${t[0].data.city}, ${t[4].at(1)}`;
    return {
        c() {
            e = P(o), n = L("br"), r = O(), i = P(a)
        },
        m(t, o) {
            T(t, e, o), T(t, n, o), T(t, r, o), T(t, i, o)
        },
        p(t, n) {
            16 & n && o !== (o = t[4].at(0) + "") && F(e, o), 17 & n && a !== (a = `${t[0].data.city}, ${t[4].at(1)}`) && F(i, a)
        },
        d(t) {
            t && (B(e), B(n), B(r), B(i))
        }
    }
}

function Zs(e) {
    let n, r, i;
    return {
        c() {
            n = P("Request proposal\n\t\t\t\t\t\t\t"), r = L("img"), l(r.src, i = "/assets/images/icons/arrow-right-white.svg") || N(r, "src", "/assets/images/icons/arrow-right-white.svg"), N(r, "width", "17"), N(r, "height", "12"), N(r, "alt", "→")
        },
        m(t, e) {
            T(t, n, e), T(t, r, e)
        },
        i: t,
        o: t,
        d(t) {
            t && (B(n), B(r))
        }
    }
}

function tl(t) {
    let e, n;
    return e = new va({
        props: {
            variant: "light"
        }
    }), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function el(t) {
    let e, n, r, i;
    return e = new ja({
        props: {
            $$slots: {
                default: [nl]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment), n = O(), r = L("div"), N(r, "class", "spacer-8")
        },
        m(t, o) {
            Tt(e, t, o), T(t, n, o), T(t, r, o), i = !0
        },
        p(t, n) {
            const r = {};
            2056 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            i || (bt(e.$$.fragment, t), i = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), i = !1
        },
        d(t) {
            t && (B(n), B(r)), Bt(e, t)
        }
    }
}

function nl(t) {
    let e, n, r;
    return {
        c() {
            e = L("a"), n = P("Click here"), r = P(" to complete request via email."), N(e, "href", t[3])
        },
        m(t, i) {
            T(t, e, i), S(e, n), T(t, r, i)
        },
        p(t, n) {
            8 & n && N(e, "href", t[3])
        },
        d(t) {
            t && (B(e), B(r))
        }
    }
}

function rl(t) {
    let e, n, r, i, o, a, s, l;
    const c = [tl, Zs],
        u = [];

    function h(t, e) {
        return t[1] || !1 === t[5] ? 0 : 1
    }
    n = h(t), r = u[n] = c[n](t);
    let d = t[2] && el(t);
    return {
        c() {
            e = L("button"), r.c(), i = O(), d && d.c(), o = k(), N(e, "class", "button-rounded button-rounded-blue button-submit type-18 m-type-15"), H(e, "button-loading", t[1])
        },
        m(r, c) {
            T(r, e, c), u[n].m(e, null), T(r, i, c), d && d.m(r, c), T(r, o, c), a = !0, s || (l = U(e, "click", t[7]), s = !0)
        },
        p(t, i) {
            let s = n;
            n = h(t), n !== s && (Et(), wt(u[s], 1, 1, (() => {
                u[s] = null
            })), xt(), r = u[n], r || (r = u[n] = c[n](t), r.c()), bt(r, 1), r.m(e, null)), (!a || 2 & i) && H(e, "button-loading", t[1]), t[2] ? d ? (d.p(t, i), 4 & i && bt(d, 1)) : (d = el(t), d.c(), bt(d, 1), d.m(o.parentNode, o)) : d && (Et(), wt(d, 1, 1, (() => {
                d = null
            })), xt())
        },
        i(t) {
            a || (bt(r), bt(d), a = !0)
        },
        o(t) {
            wt(r), wt(d), a = !1
        },
        d(t) {
            t && (B(e), B(i), B(o)), u[n].d(), d && d.d(t), s = !1, l()
        }
    }
}

function il(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C, I, M, R, D, P, k, U, F;
    n = new ns({
        props: {
            isFullPage: !0,
            $$slots: {
                default: [Vs]
            },
            $$scope: {
                ctx: t
            }
        }
    }), c = new Fr({
        props: {
            $$slots: {
                description: [js],
                title: [Ws]
            },
            $$scope: {
                ctx: t
            }
        }
    }), m = new zs({
        props: {
            $$slots: {
                default: [Xs]
            },
            $$scope: {
                ctx: t
            }
        }
    }), y = new Bi({});
    let Q = t[0].data.firstName && qs(t),
        $ = t[0].data.address && Ys(t);
    return P = new ti({
        props: {
            $$slots: {
                default: [rl]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            e = L("div"), Mt(n.$$.fragment), r = O(), i = L("div"), o = L("div"), a = L("div"), s = O(), l = L("div"), Mt(c.$$.fragment), u = O(), h = L("div"), d = L("div"), p = O(), f = L("div"), Mt(m.$$.fragment), g = O(), A = L("div"), v = O(), _ = L("div"), Mt(y.$$.fragment), E = O(), x = L("div"), b = O(), Q && Q.c(), w = O(), $ && $.c(), C = O(), I = L("div"), M = L("div"), R = O(), D = L("div"), Mt(P.$$.fragment), k = O(), U = L("div"), N(a, "class", "spacer-150 m-spacer-80"), N(l, "class", "configurator-section-column svelte-ma6brr"), N(o, "class", "configurator-section"), N(d, "class", "spacer-80 m-spacer-64"), N(f, "class", "configurator-section-column svelte-ma6brr"), N(h, "class", "configurator-section"), N(A, "class", "spacer-0 m-spacer-64"), N(_, "class", "configurator-reservation-model-mobile desktop-hidden svelte-ma6brr"), N(x, "class", "spacer-0 m-spacer-64"), N(M, "class", "spacer-80 m-spacer-64"), N(D, "class", "configurator-section-column svelte-ma6brr"), N(I, "class", "configurator-section"), N(U, "class", "spacer-150 m-spacer-64"), N(i, "class", "configurator-reservation-column svelte-ma6brr"), N(e, "class", "configurator-reservation svelte-ma6brr"), H(e, "configurator-reservation-loading", t[1])
        },
        m(t, B) {
            T(t, e, B), Tt(n, e, null), S(e, r), S(e, i), S(i, o), S(o, a), S(o, s), S(o, l), Tt(c, l, null), S(i, u), S(i, h), S(h, d), S(h, p), S(h, f), Tt(m, f, null), S(i, g), S(i, A), S(i, v), S(i, _), Tt(y, _, null), S(i, E), S(i, x), S(i, b), Q && Q.m(i, null), S(i, w), $ && $.m(i, null), S(i, C), S(i, I), S(I, M), S(I, R), S(I, D), Tt(P, D, null), S(i, k), S(i, U), F = !0
        },
        p(t, [r]) {
            const o = {};
            2048 & r && (o.$$scope = {
                dirty: r,
                ctx: t
            }), n.$set(o);
            const a = {};
            2048 & r && (a.$$scope = {
                dirty: r,
                ctx: t
            }), c.$set(a);
            const s = {};
            2048 & r && (s.$$scope = {
                dirty: r,
                ctx: t
            }), m.$set(s), t[0].data.firstName ? Q ? Q.p(t, r) : (Q = qs(t), Q.c(), Q.m(i, w)) : Q && (Q.d(1), Q = null), t[0].data.address ? $ ? $.p(t, r) : ($ = Ys(t), $.c(), $.m(i, C)) : $ && ($.d(1), $ = null);
            const l = {};
            2094 & r && (l.$$scope = {
                dirty: r,
                ctx: t
            }), P.$set(l), (!F || 2 & r) && H(e, "configurator-reservation-loading", t[1])
        },
        i(t) {
            F || (bt(n.$$.fragment, t), bt(c.$$.fragment, t), bt(m.$$.fragment, t), bt(y.$$.fragment, t), bt(P.$$.fragment, t), F = !0)
        },
        o(t) {
            wt(n.$$.fragment, t), wt(c.$$.fragment, t), wt(m.$$.fragment, t), wt(y.$$.fragment, t), wt(P.$$.fragment, t), F = !1
        },
        d(t) {
            t && B(e), Bt(n), Bt(c), Bt(m), Bt(y), Q && Q.d(), $ && $.d(), Bt(P)
        }
    }
}

function ol(t, e, n) {
    let r, i, o, a, s, l, c;
    h(t, ne, (t => n(8, a = t))), h(t, Ee, (t => n(0, s = t))), h(t, Te, (t => n(10, l = t))), h(t, bi, (t => n(9, c = t)));
    let u = !1,
        d = !1;
    return t.$$.update = () => {
        512 & t.$$.dirty && n(5, r = c.page === xi.reservation), 1 & t.$$.dirty && n(4, i = s.data.city && s.data.address.split(`${s.data.city}, `)), 257 & t.$$.dirty && n(3, o = Ga("Site error: Requesting proposal ", [
            ["Request type", "Backyard proposal request"],
            ["Installation address", s.data.address],
            ["Name", `${s.data.firstName} ${s.data.lastName}`],
            ["Phone number", s.data.phone], ...Object.entries(ee(a))
        ]))
    }, [s, u, d, o, i, r, function () {
        bi.open(xi.address)
    }, async function () {
        n(1, u = !0);
        try {
            const t = await API.orderComplete(l.id, JSON.stringify({
                ...s.data,
                configuration: a
            }));
            if (!0 !== t.ok) throw new ja("failed to complete reservation");
            const {
                slug: e
            } = await t.json();
            Te.finalize(e), bi.next()
        } catch (t) {
            n(2, d = !0), console.error(t)
        }
        n(1, u = !1)
    }, a, c]
}
class al extends Dt {
    constructor(t) {
        super(), Lt(this, t, ol, il, a, {})
    }
}
var sl = '<svg fill="none" height="16" viewBox="0 0 17 16" width="17" xmlns="http://www.w3.org/2000/svg"><path d="m6.34961 15.5557c-.46875 0-.86719-.2022-1.19531-.6065l-4.552738-5.6074c-.128906-.15235-.222656-.30176-.28125-.44825-.052734-.14648-.079101-.29882-.079101-.45703 0-.35156.117187-.6416.351562-.87011.234375-.22852.530277-.34278.887697-.34278.4043 0 .74414.17285 1.01953.51856l3.81445 4.83401 7.44435-11.79495c.1523-.234375.3105-.398438.4746-.492188.1641-.099609.3691-.149414.6152-.149414.3575 0 .6504.111329.8789.333985.2286.222656.3428.506836.3428.852537 0 .14063-.0234.28125-.0703.42188-.0469.14062-.1201.28711-.2197.43945l-8.22659 12.7266c-.28125.4277-.68262.6416-1.2041.6416z" fill="#fff"/></svg>';

function ll(t, e, n) {
    const r = t.slice();
    return r[8] = e[n], r
}

function cl(t) {
    let e, n;
    return {
        c() {
            e = new V(!1), n = k(), e.a = n
        },
        m(t, r) {
            e.m(sl, t, r), T(t, n, r)
        },
        d(t) {
            t && (B(n), e.d())
        }
    }
}

function ul(t) {
    let e, n, r, i, o, a, s = t[8] + "",
        l = t[1](t[8]),
        c = l && cl();

    function u() {
        return t[7](t[8])
    }
    return {
        c() {
            e = L("button"), n = P(s), r = O(), c && c.c(), i = O(), N(e, "class", "type-15 m-type-14 svelte-5sncvi"), H(e, "selected", t[1](t[8]))
        },
        m(t, s) {
            T(t, e, s), S(e, n), S(e, r), c && c.m(e, null), S(e, i), o || (a = U(e, "click", u), o = !0)
        },
        p(r, o) {
            t = r, 1 & o && s !== (s = t[8] + "") && F(n, s), 3 & o && (l = t[1](t[8])), l ? c || (c = cl(), c.c(), c.m(e, i)) : c && (c.d(1), c = null), 7 & o && H(e, "selected", t[1](t[8]))
        },
        d(t) {
            t && B(e), c && c.d(), o = !1, a()
        }
    }
}

function hl(t) {
    let e, n;
    return e = new Bi({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function dl(t) {
    let e, n, r, i, o, a, s, l, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C, I, M, D, P, k, F, Q, $, G, H, z, V, W, j, X, q, Y, K, J, Z, tt, et, nt, rt, it, ot, at, st, lt, ct, ut, ht, dt, pt, ft, mt, gt;
    y = new zs({
        props: {
            isEditable: !1
        }
    }), k = new jr({}), H = new Bi({});
    let At = St([...t[2], ...t[0]]),
        vt = [];
    for (let e = 0; e < At.length; e += 1) vt[e] = ul(ll(t, At, e));
    return ot = new ma({
        props: {
            name: "usage",
            title: "I have another use in mind…"
        }
    }), ot.$on("input", t[4]), pt = new ns({
        props: {
            isRightSide: !0,
            isFullPage: !0,
            $$slots: {
                default: [hl]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            e = L("div"), n = L("div"), r = L("div"), r.innerHTML = '<div class="spacer-150 m-spacer-80"></div> <div class="configurator-section-column type-center svelte-5sncvi"><h1 class="type-36 m-type-30-light">What’s next?</h1> <h1 class="type-36 m-type-30-light color-text-40">We’ll be in touch.</h1></div>', i = O(), o = L("div"), a = L("div"), s = O(), l = L("div"), c = L("p"), c.textContent = "We'll review your property and will get in touch for next steps or if we need more\n\t\t\t\t\tdetails. In the meantime, we're here to answer your questions.", u = O(), h = L("div"), d = O(), p = L("div"), f = L("a"), f.textContent = "Ask a question", m = O(), g = L("div"), A = L("div"), v = O(), _ = L("div"), Mt(y.$$.fragment), E = O(), x = L("div"), b = L("div"), w = O(), C = L("div"), I = L("h2"), I.textContent = "Price breakdown for your Backyard", M = O(), D = L("div"), P = O(), Mt(k.$$.fragment), F = O(), Q = L("div"), $ = O(), G = L("div"), Mt(H.$$.fragment), z = O(), V = L("div"), W = O(), j = L("div"), X = L("div"), q = O(), Y = L("div"), K = L("h2"), K.textContent = "How will you use it?", J = O(), Z = L("div"), tt = O(), et = L("div");
            for (let t = 0; t < vt.length; t += 1) vt[t].c();
            nt = O(), rt = L("div"), it = O(), Mt(ot.$$.fragment), at = O(), st = L("div"), lt = O(), ct = L("div"), ct.innerHTML = '<a href="/" class="button-rounded button-rounded-blue type-14 svelte-5sncvi">Return to samara.com</a>', ut = O(), ht = L("div"), dt = O(), Mt(pt.$$.fragment), N(r, "class", "configurator-section"), N(a, "class", "spacer-80 m-spacer-36"), N(c, "class", "type-24-light m-type-18-light"), N(h, "class", "spacer-36 m-spacer-16"), N(f, "class", "button-rounded button-configurator type-15 m-type-12 type-regola-regular svelte-5sncvi"), N(p, "class", "configurator-confirmation-ask svelte-5sncvi"), N(l, "class", "configurator-section-column svelte-5sncvi"), N(o, "class", "configurator-section"), N(A, "class", "spacer-80 m-spacer-64"), N(_, "class", "configurator-section-column svelte-5sncvi"), N(g, "class", "configurator-section"), N(b, "class", "spacer-80 m-spacer-64"), N(I, "class", "type-24-light m-type-18-light"), N(D, "class", "spacer-24 m-spacer-16"), N(C, "class", "configurator-section-column svelte-5sncvi"), N(x, "class", "configurator-section"), N(Q, "class", "spacer-0 m-spacer-64"), N(G, "class", "configurator-confirmation-model-mobile desktop-hidden svelte-5sncvi"), N(V, "class", "spacer-0 m-spacer-64"), N(X, "class", "spacer-80 m-spacer-0"), N(K, "class", "type-24-light m-type-18-light"), N(Z, "class", "spacer-24"), N(et, "class", "configurator-confirmation-use svelte-5sncvi"), N(rt, "class", "spacer-50 m-spacer-36"), N(Y, "class", "configurator-section-column svelte-5sncvi"), N(j, "class", "configurator-section"), N(st, "class", "spacer-72 m-spacer-50"), N(ct, "class", "configurator-home-cta svelte-5sncvi"), N(ht, "class", "spacer-150 m-spacer-100"), N(n, "class", "configurator-confirmation-column svelte-5sncvi"), N(e, "class", "configurator-confirmation svelte-5sncvi")
        },
        m(t, B) {
            T(t, e, B), S(e, n), S(n, r), S(n, i), S(n, o), S(o, a), S(o, s), S(o, l), S(l, c), S(l, u), S(l, h), S(l, d), S(l, p), S(p, f), S(n, m), S(n, g), S(g, A), S(g, v), S(g, _), Tt(y, _, null), S(n, E), S(n, x), S(x, b), S(x, w), S(x, C), S(C, I), S(C, M), S(C, D), S(C, P), Tt(k, C, null), S(n, F), S(n, Q), S(n, $), S(n, G), Tt(H, G, null), S(n, z), S(n, V), S(n, W), S(n, j), S(j, X), S(j, q), S(j, Y), S(Y, K), S(Y, J), S(Y, Z), S(Y, tt), S(Y, et);
            for (let t = 0; t < vt.length; t += 1) vt[t] && vt[t].m(et, null);
            S(Y, nt), S(Y, rt), S(Y, it), Tt(ot, Y, null), S(n, at), S(n, st), S(n, lt), S(n, ct), S(n, ut), S(n, ht), S(e, dt), Tt(pt, e, null), ft = !0, mt || (gt = U(f, "click", pl), mt = !0)
        },
        p(t, [e]) {
            if (15 & e) {
                let n;
                for (At = St([...t[2], ...t[0]]), n = 0; n < At.length; n += 1) {
                    const r = ll(t, At, n);
                    vt[n] ? vt[n].p(r, e) : (vt[n] = ul(r), vt[n].c(), vt[n].m(et, null))
                }
                for (; n < vt.length; n += 1) vt[n].d(1);
                vt.length = At.length
            }
            const n = {};
            2048 & e && (n.$$scope = {
                dirty: e,
                ctx: t
            }), pt.$set(n)
        },
        i(t) {
            ft || (bt(y.$$.fragment, t), bt(k.$$.fragment, t), bt(H.$$.fragment, t), bt(ot.$$.fragment, t), bt(pt.$$.fragment, t), ft = !0)
        },
        o(t) {
            wt(y.$$.fragment, t), wt(k.$$.fragment, t), wt(H.$$.fragment, t), wt(ot.$$.fragment, t), wt(pt.$$.fragment, t), ft = !1
        },
        d(t) {
            t && B(e), Bt(y), Bt(k), Bt(H), R(vt, t), Bt(ot), Bt(pt), mt = !1, gt()
        }
    }
}

function pl() {
    Contact.show({
        variant: "confirmation",
        page: "message"
    })
}

function fl(t, e, n) {
    let r, i;
    h(t, Te, (t => n(6, i = t)));
    let o = [],
        a = [];

    function s(t) {
        r(t) ? n(5, o = o.filter((e => e !== t))) : n(5, o = o.concat(t))
    }
    return t.$$.update = () => {
        32 & t.$$.dirty && n(1, r = t => o.includes(t)), 96 & t.$$.dirty && o && API.orderUpdateUsage(i.slug, o)
    }, [a, r, ["House family", "Rent it out", "Home office", "Creative studio", "Home gym", "Secret hideout"], s, function (t) {
        const e = t.detail.inputEvent;
        "Enter" === e.key && (n(5, o = o.concat(e.target.value)), n(0, a = a.concat(e.target.value)), t.detail.reset(), e.target.blur())
    }, o, i, t => s(t)]
}
class ml extends Dt {
    constructor(t) {
        super(), Lt(this, t, fl, dl, a, {})
    }
}

function gl(t) {
    let e, n;
    return e = new rn({
        props: {
            variant: "financing",
            $$slots: {
                default: [Al]
            },
            $$scope: {
                ctx: t
            }
        }
    }), e.$on("dismiss", t[1]), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        p(t, n) {
            const r = {};
            8 & n && (r.$$scope = {
                dirty: n,
                ctx: t
            }), e.$set(r)
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Al(e) {
    let n, r, i, o, a, s, c, u, h, d, p, f, m, g, A, v, _, y, E, x, b, w, C;
    return {
        c() {
            n = L("div"), r = L("img"), o = O(), a = L("h1"), a.innerHTML = "Financing an ADU is hard.<br/> With Backyard it’s easy.", s = O(), c = L("div"), u = O(), h = L("ul"), h.innerHTML = '<li class="svelte-yvwghp">APRs as low as 6.5%</li> <li class="svelte-yvwghp">No payments or interest for 6 months</li> <li class="svelte-yvwghp">As little as no money down</li> <li class="svelte-yvwghp">No need to touch your existing mortgage</li>', d = O(), p = L("div"), f = O(), m = L("p"), m.innerHTML = 'Designed for Backyard.<br class="desktop-hidden"/> Only at Samara.', g = O(), A = L("div"), v = O(), _ = L("a"), _.innerHTML = 'Learn more <svg width="15" height="13" viewBox="0 0 15 13" fill="none" xmlns="http://www.w3.org/2000/svg" class="svelte-yvwghp"><path d="M14.3491 6.50098C14.3491 6.68652 14.2759 6.8501 14.1294 6.9917L9.25879 11.8477C9.11719 11.9844 8.9585 12.0527 8.78271 12.0527C8.60205 12.0527 8.45068 11.9917 8.32861 11.8696C8.20654 11.7524 8.14551 11.6035 8.14551 11.4229C8.14551 11.335 8.16016 11.252 8.18945 11.1738C8.21875 11.0908 8.2627 11.02 8.32129 10.9614L9.96191 9.2915L12.8696 6.64746L13.0161 7.00635L10.6577 7.15283H1.39258C1.20215 7.15283 1.0459 7.0918 0.923828 6.96973C0.806641 6.84766 0.748047 6.69141 0.748047 6.50098C0.748047 6.31055 0.806641 6.1543 0.923828 6.03223C1.0459 5.91016 1.20215 5.84912 1.39258 5.84912H10.6577L13.0161 5.99561L12.8696 6.36182L9.96191 3.71045L8.32129 2.04053C8.2627 1.98193 8.21875 1.91357 8.18945 1.83545C8.16016 1.75244 8.14551 1.66699 8.14551 1.5791C8.14551 1.39844 8.20654 1.24951 8.32861 1.13232C8.45068 1.01025 8.60205 0.949219 8.78271 0.949219C8.87061 0.949219 8.95361 0.966309 9.03174 1.00049C9.11475 1.03467 9.19531 1.09082 9.27344 1.16895L14.1294 6.01025C14.2759 6.15186 14.3491 6.31543 14.3491 6.50098Z" fill="white" style="fill:white;fill-opacity:1;"></path></svg>', y = O(), E = L("div"), x = O(), b = L("div"), b.innerHTML = '<p>Samara Finance, LLC is licensed by the Department of\n                    Financial Protection and Innovation.</p> <p>Samara does not make loans. All loans are made by Samara’s\n                    third party lender partners. Loans made or arranged pursuant\n                    to a California Financing Law, license number 60DBO-188555,\n                    <a href="https://www.nmlsconsumeraccess.org/" class="svelte-yvwghp">NMLS Consumer Access</a> number 2549049.</p>', N(r, "width", "1000"), N(r, "height", "1016"), l(r.src, i = "/assets/images/financing/financing-main/financing-main-1000.webp") || N(r, "src", "/assets/images/financing/financing-main/financing-main-1000.webp"), N(r, "alt", "Financing an ADU is hard. With Backyard it’s easy."), N(r, "class", "svelte-yvwghp"), N(a, "class", "type-48 m-type-36"), N(c, "class", "spacer-50"), N(h, "class", "type-18-light svelte-yvwghp"), N(p, "class", "spacer-24"), N(m, "class", "type-18-light"), N(A, "class", "spacer-36"), N(_, "class", "configurator-financing-modal-button type-18-light svelte-yvwghp"), N(_, "href", "/backyard/financing"), N(E, "class", "spacer-32 m-spacer-24"), N(b, "class", "configurator-financing-modal-footnote type-12 color-text-40 svelte-yvwghp"), N(n, "class", "configurator-modal-content svelte-yvwghp")
        },
        m(t, e) {
            T(t, n, e), S(n, r), S(n, o), S(n, a), S(n, s), S(n, c), S(n, u), S(n, h), S(n, d), S(n, p), S(n, f), S(n, m), S(n, g), S(n, A), S(n, v), S(n, _), S(n, y), S(n, E), S(n, x), S(n, b), w || (C = U(_, "click", _l), w = !0)
        },
        p: t,
        d(t) {
            t && B(n), w = !1, C()
        }
    }
}

function vl(t) {
    let e, n, r = t[0].isVisible && gl(t);
    return {
        c() {
            r && r.c(), e = k()
        },
        m(t, i) {
            r && r.m(t, i), T(t, e, i), n = !0
        },
        p(t, [n]) {
            t[0].isVisible ? r ? (r.p(t, n), 1 & n && bt(r, 1)) : (r = gl(t), r.c(), bt(r, 1), r.m(e.parentNode, e)) : r && (Et(), wt(r, 1, 1, (() => {
                r = null
            })), xt())
        },
        i(t) {
            n || (bt(r), n = !0)
        },
        o(t) {
            wt(r), n = !1
        },
        d(t) {
            t && B(e), r && r.d(t)
        }
    }
}

function _l(t) {
    t.preventDefault(), openRoute("/backyard/financing")
}

function yl(t, e, n) {
    let r;
    h(t, li, (t => n(0, r = t)));
    const i = nt();
    return [r, function () {
        i("dismiss"), li.hide()
    }]
}
class El extends Dt {
    constructor(t) {
        super(), Lt(this, t, yl, vl, a, {})
    }
}

function xl(t) {
    let e, n;
    return e = new ml({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function bl(t) {
    let e, n;
    return e = new al({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function wl(t) {
    let e, n;
    return e = new ws({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Cl(t) {
    let e, n;
    return e = new oa({}), {
        c() {
            Mt(e.$$.fragment)
        },
        m(t, r) {
            Tt(e, t, r), n = !0
        },
        i(t) {
            n || (bt(e.$$.fragment, t), n = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), n = !1
        },
        d(t) {
            Bt(e, t)
        }
    }
}

function Sl(t) {
    let e, n, r, i;
    const o = [Cl, wl, bl, xl],
        a = [];

    function s(t, e) {
        return t[0].page === xi.options ? 0 : t[0].page === xi.address ? 1 : t[0].page === xi.reservation ? 2 : t[0].page === xi.confirmation ? 3 : -1
    }
    return ~(e = s(t)) && (n = a[e] = o[e](t)), {
        c() {
            n && n.c(), r = k()
        },
        m(t, n) {
            ~e && a[e].m(t, n), T(t, r, n), i = !0
        },
        p(t, i) {
            let l = e;
            e = s(t), e !== l && (n && (Et(), wt(a[l], 1, 1, (() => {
                a[l] = null
            })), xt()), ~e ? (n = a[e], n || (n = a[e] = o[e](t), n.c()), bt(n, 1), n.m(r.parentNode, r)) : n = null)
        },
        i(t) {
            i || (bt(n), i = !0)
        },
        o(t) {
            wt(n), i = !1
        },
        d(t) {
            t && B(r), ~e && a[e].d(t)
        }
    }
}

function Il(t) {
    let e, n, r, i, o, a;
    return e = new Is({}), r = new El({}), o = new $t({
        props: {
            index: t[0].page,
            shouldControlGlobalScroll: !0,
            $$slots: {
                default: [Sl]
            },
            $$scope: {
                ctx: t
            }
        }
    }), {
        c() {
            Mt(e.$$.fragment), n = O(), Mt(r.$$.fragment), i = O(), Mt(o.$$.fragment)
        },
        m(t, s) {
            Tt(e, t, s), T(t, n, s), Tt(r, t, s), T(t, i, s), Tt(o, t, s), a = !0
        },
        p(t, [e]) {
            const n = {};
            1 & e && (n.index = t[0].page), 3 & e && (n.$$scope = {
                dirty: e,
                ctx: t
            }), o.$set(n)
        },
        i(t) {
            a || (bt(e.$$.fragment, t), bt(r.$$.fragment, t), bt(o.$$.fragment, t), a = !0)
        },
        o(t) {
            wt(e.$$.fragment, t), wt(r.$$.fragment, t), wt(o.$$.fragment, t), a = !1
        },
        d(t) {
            t && (B(n), B(i)), Bt(e, t), Bt(r, t), Bt(o, t)
        }
    }
}

function Ml(t, e, n) {
    let r;
    return h(t, bi, (t => n(0, r = t))), Te.start(), [r]
}
class Tl extends Dt {
    constructor(t) {
        super(), Lt(this, t, Ml, Il, a, {})
    }
}

function Bl() {
    const t = new Tl({
        target: document.querySelector("main > .page")
    });
    return function () {
        ne.reset(), bi.reset(), Te.reset(), si.resetCamera(), t.$destroy()
    }
}
export {
    Bl as a, se as c, le as g
};
//# sourceMappingURL=index-Cqi25RFM.js.map;